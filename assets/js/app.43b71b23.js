(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,l,a=e[0],s=e[1],c=e[2],u=0,p=[];u<a.length;u++)l=a[u],Object.prototype.hasOwnProperty.call(i,l)&&i[l]&&p.push(i[l][0]),i[l]=0;for(r in s)Object.prototype.hasOwnProperty.call(s,r)&&(n[r]=s[r]);for(d&&d(e);p.length;)p.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,a=1;a<t.length;a++){var s=t[a];0!==i[s]&&(r=!1)}r&&(o.splice(e--,1),n=l(l.s=t[0]))}return n}var r={},i={1:0},o=[];function l(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,l),t.l=!0,t.exports}l.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var o,a=document.createElement("script");a.charset="utf-8",a.timeout=120,l.nc&&a.setAttribute("nonce",l.nc),a.src=function(n){return l.p+"assets/js/"+({}[n]||n)+"."+{2:"4d5ff6b8",3:"abdca415",4:"ed0d6299",5:"073c5f59",6:"f91b4c78",7:"e9b2363f",8:"f2aaae7e",9:"4a52db44",10:"2ccba745",11:"910cd2c8",12:"d2d0a09a",13:"e17c010c",14:"f7a24595",15:"67fe62bc",16:"a21f9cdc",17:"c873a6ae",18:"52005188",19:"36f139b9",20:"4a7a4af3",21:"0054d54e",22:"0cdf174d",23:"2ef3af62",24:"c1d5bb94",25:"230d0bca",26:"c6ac4025",27:"9e10a751",28:"4ff8625c",29:"5eeededc",30:"f122e073",31:"f278db07",32:"f8ff2acf",33:"c56fb946",34:"cd793481",35:"a37593b8",36:"36006f14",37:"e8e4ed46",38:"103f47f4",39:"629426ab",40:"86ee3edb",41:"9da5c570",42:"93c2f6f5",43:"761bc316",44:"e72d15ef",45:"12347ae1",46:"a0b87e58",47:"413fe9cb",48:"80b750be",49:"2344cdf8",50:"130bcafc",51:"c8c789a2",52:"50b1c9ee",53:"7a5b2716",54:"7dcd65d1",55:"a91f76d6",56:"e24e0adc",57:"a9cbb581",58:"3528efc2",59:"5efc9fff",60:"18dc722c",61:"5eb86dd5",62:"83bd7651",63:"f09c41ad",64:"d58ac066",65:"48dbcfe9",66:"f56bd067",67:"c6aeb55c",68:"1b030780",69:"f5bd126c",70:"e733cf44",71:"10f1b630",72:"a6c5e0be",73:"3c39e441",74:"3df294ed",75:"ab05f79d",76:"edc26d24",77:"964180bb",78:"856b9f87",79:"ba0eae96",80:"2f55aa18",81:"3786e301",82:"2da55b99",83:"5b71c5e8",84:"eed34a60",85:"976c2a77",86:"9e0dd28c",87:"62e95469",88:"e066047d",89:"3660c7e7",90:"0f31a02c",91:"a99fea5e",92:"8a991c13",93:"ad7c7fa0",94:"1b4e36e0",95:"6b2ae37d",96:"5bcfd363",97:"7bbc8c7d",98:"c901ae5b",99:"e4ac6e9f",100:"3ef7ac81",101:"714e784a",102:"84793f85",103:"21fe3423",104:"d41c72c1",105:"5dc33f98",106:"f7be4b29",107:"36f5034f",108:"f186490e",109:"b85665a6",110:"83793a92",111:"3eccddfd",112:"da39adb6",113:"a2eb39cf",114:"f11972b5",115:"ef16ed23",116:"f30c432c",117:"37889296",118:"8dde5316",119:"eeb38f74",120:"c918536e",121:"69b8431e",122:"abb60b23",123:"78213f25",124:"45720736",125:"2d7daf39",126:"c002b22b",127:"d9f678ae",128:"52b34eb5",129:"73ac36ee",130:"7fa387ec",131:"1ee3e55f",132:"065815d8",133:"fc202bf1",134:"127e20d7",135:"df77be6f",136:"b54883e3",137:"681d9145",138:"847d523d",139:"c14aa105",140:"3039bc9d",141:"6ac91033",142:"53786750",143:"2b602d2d",144:"a4635412",145:"f8fc713f",146:"503f87ac",147:"26c046fa",148:"a89cf8ab",149:"25dfc137",150:"7b95b937",151:"ed0af269",152:"fe221c67",153:"e1223f50",154:"dcff6a95",155:"2fd767e7",156:"12715b22",157:"1a0f357e",158:"ad60a591",159:"ba9a99bb",160:"aa6fddbf",161:"0e29875c",162:"0639399c",163:"71e9d189",164:"82abf0aa",165:"51ba7f8c",166:"e543339a",167:"536208b8",168:"8bed8d63",169:"4a8a7906",170:"dc1665a7",171:"8703b022",172:"cd266176",173:"8dd202ae",174:"d1b99e8c",175:"bf1b06d9",176:"885fe5d8",177:"6bd73a21",178:"77b3c3c2",179:"175d0039",180:"ab968826",181:"8b2f8627",182:"0f01623a",183:"6ca85e81",184:"1e3c2d09",185:"61f144d4",186:"b1d9e04b",187:"7d527435",188:"98f161b3",189:"32bf89e6",190:"409271e9",191:"b0e4a71c",192:"0e223bf4",193:"481e1de3",194:"4a2b7c98",195:"cd1b9ba6",196:"e8e116cd",197:"3703c733",198:"f11a2b59",199:"acef1f36",200:"150c70a2",201:"acb52567",202:"38f09e85",203:"416db570",204:"3bde6bbf",205:"fc219aad",206:"30e4e230",207:"0abaf49c",208:"5f6d7678",209:"d88fc314",210:"a2320a01",211:"f958df67",212:"e55a4446",213:"d41c7e7d",214:"6f94d6a4",215:"14a184af",216:"29239b67",217:"b9f6a563",218:"786131ed",219:"0b3aba02",220:"15c9e3ef",221:"a178fa2b",222:"b1a5804c",223:"d92a70e3",224:"e191637d",225:"bc0168b9",226:"e6a55b23",227:"01651eb9",228:"dac14675",229:"5364857c",230:"8a4f5cc6",231:"c7a5d02a",232:"3513cf73",233:"941c4b01",234:"e031e0ad",235:"018ac223",236:"4f5017f1",237:"737241cb",238:"a035d1c2",239:"f11231ae",240:"debbf045",241:"7e2f04db",242:"a5ffb76d",243:"d9af76fd",244:"ab7f46c1",245:"422323a3",246:"2ad1d193",247:"3349665c",248:"242f1c33",249:"c0808cf1",250:"d0c16783",251:"7f463c17",252:"5140d42d",253:"e16f9dd3",254:"ff0d38a6",255:"620356ac",256:"4ffb2795",257:"eb2b961d",258:"179e7c30",259:"cad08a59",260:"e7e6f2ea",261:"2acd9b28",262:"0461ced9",263:"d994c9ad",264:"1f7f2c66",265:"fdc08081",266:"003bfecb",267:"8265dfc8",268:"eb9b6b7a",269:"e7be1fb1",270:"08a47cc5",271:"24c69bfa",272:"0d41b65d",273:"dd79684a",274:"cbf37104",275:"45c7f812",276:"758edd71",277:"d689b196",278:"e2ccf461",279:"31f7eed4",280:"68e4c555",281:"5b910292",282:"61037ae0",283:"bc6e3262",284:"8a702c68",285:"e4e69423",286:"766d7b4e",287:"e2112f2f",288:"048ed7d2",289:"6399cef6",290:"cd391788",291:"a8634ce1",292:"e1b84bfa",293:"fce144c3",294:"c9607173",295:"abbd27b0",296:"767451a8",297:"9b825e7d",298:"93f1903b",299:"546668d4",300:"5e3eb955",301:"4103b81c",302:"4a2a17f7",303:"eebb8283",304:"e4800aee",305:"42ead618",306:"98ca0458",307:"2e8d48ff",308:"eb32e3eb",309:"ce4717e5",310:"44cc0350",311:"45770b65",312:"d28e7eed",313:"443bf4b2",314:"450f98a0"}[n]+".js"}(n);var s=new Error;o=function(e){a.onerror=a.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;s.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",s.name="ChunkLoadError",s.type=r,s.request=o,t[1](s)}i[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:a})}),12e4);a.onerror=a.onload=o,document.head.appendChild(a)}return Promise.all(e)},l.m=n,l.c=r,l.d=function(n,e,t){l.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},l.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},l.t=function(n,e){if(1&e&&(n=l(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(l.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)l.d(t,r,function(e){return n[e]}.bind(null,r));return t},l.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return l.d(e,"a",e),e},l.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},l.p="/",l.oe=function(n){throw console.error(n),n};var a=window.webpackJsonp=window.webpackJsonp||[],s=a.push.bind(a);a.push=e,a=a.slice();for(var c=0;c<a.length;c++)e(a[c]);var d=s;o.push([200,0]),t()}([function(n,e,t){var r=t(2),i=t(27).f,o=t(15),l=t(13),a=t(86),s=t(133),c=t(84);n.exports=function(n,e){var t,d,u,p,m,h=n.target,g=n.global,f=n.stat;if(t=g?r:f?r[h]||a(h,{}):(r[h]||{}).prototype)for(d in e){if(p=e[d],u=n.noTargetGet?(m=i(t,d))&&m.value:t[d],!c(g?d:h+(f?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;s(p,u)}(n.sham||u&&u.sham)&&o(p,"sham",!0),l(t,d,p,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(2),i=t(62),o=t(9),l=t(63),a=t(88),s=t(127),c=i("wks"),d=r.Symbol,u=s?d:d&&d.withoutSetter||l;n.exports=function(n){return o(c,n)&&(a||"string"==typeof c[n])||(a&&o(d,n)?c[n]=d[n]:c[n]=u("Symbol."+n)),c[n]}},function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},function(n,e,t){var r=t(4);n.exports=function(n){if(!r(n))throw TypeError(String(n)+" is not an object");return n}},function(n,e,t){var r=t(1);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(96),i=t(13),o=t(216);r||i(Object.prototype,"toString",o,{unsafe:!0})},function(n,e,t){var r=t(6),i=t(125),o=t(5),l=t(48),a=Object.defineProperty;e.f=r?a:function(n,e,t){if(o(n),e=l(e,!0),o(t),i)try{return a(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(11),i={}.hasOwnProperty;n.exports=Object.hasOwn||function(n,e){return i.call(r(n),e)}},function(n,e,t){var r=t(50),i=Math.min;n.exports=function(n){return n>0?i(r(n),9007199254740991):0}},function(n,e,t){var r=t(12);n.exports=function(n){return Object(r(n))}},function(n,e){n.exports=function(n){if(null==n)throw TypeError("Can't call method on "+n);return n}},function(n,e,t){var r=t(2),i=t(15),o=t(9),l=t(86),a=t(91),s=t(36),c=s.get,d=s.enforce,u=String(String).split("String");(n.exports=function(n,e,t,a){var s,c=!!a&&!!a.unsafe,p=!!a&&!!a.enumerable,m=!!a&&!!a.noTargetGet;"function"==typeof t&&("string"!=typeof e||o(t,"name")||i(t,"name",e),(s=d(t)).source||(s.source=u.join("string"==typeof e?e:""))),n!==r?(c?!m&&n[e]&&(p=!0):delete n[e],p?n[e]=t:i(n,e,t)):p?n[e]=t:l(e,t)})(Function.prototype,"toString",(function(){return"function"==typeof this&&c(this).source||a(this)}))},function(n,e,t){"use strict";var r=t(147).charAt,i=t(36),o=t(132),l=i.set,a=i.getterFor("String Iterator");o(String,"String",(function(n){l(this,{type:"String Iterator",string:String(n),index:0})}),(function(){var n,e=a(this),t=e.string,i=e.index;return i>=t.length?{value:void 0,done:!0}:(n=r(t,i),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(6),i=t(8),o=t(49);n.exports=r?function(n,e,t){return i.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(47),i=t(12);n.exports=function(n){return r(i(n))}},function(n,e,t){var r=t(2),i=t(148),o=t(124),l=t(15),a=t(3),s=a("iterator"),c=a("toStringTag"),d=o.values;for(var u in i){var p=r[u],m=p&&p.prototype;if(m){if(m[s]!==d)try{l(m,s,d)}catch(n){m[s]=d}if(m[c]||l(m,c,u),i[u])for(var h in o)if(m[h]!==o[h])try{l(m,h,o[h])}catch(n){m[h]=o[h]}}}},function(n,e,t){"use strict";var r=t(0),i=t(73);r({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(162),i="object"==typeof self&&self&&self.Object===Object&&self,o=r||i||Function("return this")();n.exports=o},function(n,e,t){"use strict";function r(n,e,t,r,i,o,l,a){var s,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),l?(s=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(l)},c._ssrRegister=s):i&&(s=a?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),s)if(c.functional){c._injectStyles=s;var d=c.render;c.render=function(n,e){return s.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,s):[s]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(0),i=t(45).filter;r({target:"Array",proto:!0,forced:!t(71)("filter")},{filter:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(0),i=t(155);r({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},function(n,e,t){var r=t(2),i=t(148),o=t(155),l=t(15);for(var a in i){var s=r[a],c=s&&s.prototype;if(c&&c.forEach!==o)try{l(c,"forEach",o)}catch(n){c.forEach=o}}},function(n,e,t){var r=t(26);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(126),i=t(2),o=function(n){return"function"==typeof n?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n])||o(i[n]):r[n]&&r[n][e]||i[n]&&i[n][e]}},function(n,e,t){var r=t(6),i=t(92),o=t(49),l=t(16),a=t(48),s=t(9),c=t(125),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=l(n),e=a(e,!0),c)try{return d(n,e)}catch(n){}if(s(n,e))return o(!i.f.call(n,e),n[e])}},function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(String(n)+" is not a function");return n}},function(n,e,t){"use strict";var r=t(98),i=t(1),o=t(5),l=t(10),a=t(50),s=t(12),c=t(99),d=t(224),u=t(100),p=t(3)("replace"),m=Math.max,h=Math.min,g="$0"==="a".replace(/./,"$0"),f=!!/./[p]&&""===/./[p]("a","$0");r("replace",(function(n,e,t){var r=f?"$":"$0";return[function(n,t){var r=s(this),i=null==n?void 0:n[p];return void 0!==i?i.call(n,r,t):e.call(String(r),n,t)},function(n,i){if("string"==typeof i&&-1===i.indexOf(r)&&-1===i.indexOf("$<")){var s=t(e,this,n,i);if(s.done)return s.value}var p=o(this),g=String(n),f="function"==typeof i;f||(i=String(i));var v=p.global;if(v){var y=p.unicode;p.lastIndex=0}for(var b=[];;){var x=u(p,g);if(null===x)break;if(b.push(x),!v)break;""===String(x[0])&&(p.lastIndex=c(g,l(p.lastIndex),y))}for(var w,E="",j=0,z=0;z<b.length;z++){x=b[z];for(var T=String(x[0]),S=m(h(a(x.index),g.length),0),k=[],I=1;I<x.length;I++)k.push(void 0===(w=x[I])?w:String(w));var A=x.groups;if(f){var _=[T].concat(k,S,g);void 0!==A&&_.push(A);var V=String(i.apply(void 0,_))}else V=d(T,g,S,k,A,i);S>=j&&(E+=g.slice(j,S)+V,j=S+T.length)}return E+g.slice(j)}]}),!!i((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!g||f)},function(n,e){var t={}.toString;n.exports=function(n){return t.call(n).slice(8,-1)}},function(n,e){n.exports=!1},function(n,e,t){var r,i=t(5),o=t(128),l=t(90),a=t(51),s=t(131),c=t(87),d=t(65),u=d("IE_PROTO"),p=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(){try{r=document.domain&&new ActiveXObject("htmlfile")}catch(n){}var n,e;h=r?function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e}(r):((e=c("iframe")).style.display="none",s.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F);for(var t=l.length;t--;)delete h.prototype[l[t]];return h()};a[u]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=i(n),t=new p,p.prototype=null,t[u]=n):t=h(),void 0===e?t:o(t,e)}},function(n,e,t){var r=t(243),i=t(246);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";var r=t(0),i=t(4),o=t(53),l=t(130),a=t(10),s=t(16),c=t(70),d=t(3),u=t(71)("slice"),p=d("species"),m=[].slice,h=Math.max;r({target:"Array",proto:!0,forced:!u},{slice:function(n,e){var t,r,d,u=s(this),g=a(u.length),f=l(n,g),v=l(void 0===e?g:e,g);if(o(u)&&("function"!=typeof(t=u.constructor)||t!==Array&&!o(t.prototype)?i(t)&&null===(t=t[p])&&(t=void 0):t=void 0,t===Array||void 0===t))return m.call(u,f,v);for(r=new(void 0===t?Array:t)(h(v-f,0)),d=0;f<v;f++,d++)f in u&&c(r,d,u[f]);return r.length=d,r}})},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return l})),t.d(e,"g",(function(){return s})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return f})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return b}));t(18),t(29),t(113),t(82),t(101),t(44),t(23),t(24),t(22),t(60),t(83),t(7),t(123),t(43),t(182),t(115);var r=/#.*$/,i=/\.(md|html)$/,o=/\/$/,l=/^[a-z]+:/i;function a(n){return decodeURI(n).replace(r,"").replace(i,"")}function s(n){return l.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(s(n))return n;var e=n.match(r),t=e?e[0]:"",i=a(n);return o.test(i)?n:i+".html"+t}function p(n,e){var t=n.hash,i=function(n){var e=n.match(r);if(e)return e[0]}(e);return(!i||t===i)&&a(n.path)===a(e)}function m(n,e,t){if(s(e))return{type:"external",path:e};t&&(e=function(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var o=n.replace(/^\//,"").split("/"),l=0;l<o.length;l++){var a=o[l];".."===a?i.pop():"."!==a&&i.push(a)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));for(var r=a(e),i=0;i<n.length;i++)if(a(n[i].regularPath)===r)return Object.assign({},n[i],{type:"page",path:u(n[i].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function h(n,e,t,r){var i=t.pages,o=t.themeConfig,l=r&&o.locales&&o.locales[r]||o;if("auto"===(n.frontmatter.sidebar||l.sidebar||o.sidebar))return function(n){var e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}(n);var a=l.sidebar||o.sidebar;if(a){var s=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var r;return{}}(e,a),c=s.base,d=s.config;return d?d.map((function(n){return function n(e,t,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var o=e.children||[];return 0===o.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,children:o.map((function(e){return n(e,t,r,i+1)})),collapsable:!1!==e.collapsable}}(n,i,c)})):[]}return[]}function g(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function f(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){var e=n.frontmatter.date||n.lastUpdated,t=new Date(e);return"Invalid Date"==t&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function b(n,e){return y(e)-y(n)}},function(n,e,t){var r,i,o,l=t(201),a=t(2),s=t(4),c=t(15),d=t(9),u=t(85),p=t(65),m=t(51),h=a.WeakMap;if(l||u.state){var g=u.state||(u.state=new h),f=g.get,v=g.has,y=g.set;r=function(n,e){if(v.call(g,n))throw new TypeError("Object already initialized");return e.facade=n,y.call(g,n,e),e},i=function(n){return f.call(g,n)||{}},o=function(n){return v.call(g,n)}}else{var b=p("state");m[b]=!0,r=function(n,e){if(d(n,b))throw new TypeError("Object already initialized");return e.facade=n,c(n,b,e),e},i=function(n){return d(n,b)?n[b]:{}},o=function(n){return d(n,b)}}n.exports={set:r,get:i,has:o,enforce:function(n){return o(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!s(e)||(t=i(e)).type!==n)throw TypeError("Incompatible receiver, "+n+" required");return t}}}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r,i,o=t(2),l=t(25),a=o.process,s=a&&a.versions,c=s&&s.v8;c?i=(r=c.split("."))[0]<4?1:r[0]+r[1]:l&&(!(r=l.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=l.match(/Chrome\/(\d+)/))&&(i=r[1]),n.exports=i&&+i},function(n,e,t){"use strict";var r=t(1);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){throw 1},1)}))}},function(n,e,t){"use strict";var r=t(0),i=t(2),o=t(26),l=t(31),a=t(6),s=t(88),c=t(127),d=t(1),u=t(9),p=t(53),m=t(4),h=t(5),g=t(11),f=t(16),v=t(48),y=t(49),b=t(32),x=t(64),w=t(59),E=t(221),j=t(94),z=t(27),T=t(8),S=t(92),k=t(15),I=t(13),A=t(62),_=t(65),V=t(51),N=t(63),L=t(3),B=t(157),P=t(158),C=t(66),D=t(36),q=t(45).forEach,M=_("hidden"),R=L("toPrimitive"),J=D.set,O=D.getterFor("Symbol"),U=Object.prototype,G=i.Symbol,F=o("JSON","stringify"),Z=z.f,$=T.f,W=E.f,H=S.f,Y=A("symbols"),X=A("op-symbols"),Q=A("string-to-symbol-registry"),K=A("symbol-to-string-registry"),nn=A("wks"),en=i.QObject,tn=!en||!en.prototype||!en.prototype.findChild,rn=a&&d((function(){return 7!=b($({},"a",{get:function(){return $(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=Z(U,e);r&&delete U[e],$(n,e,t),r&&n!==U&&$(U,e,r)}:$,on=function(n,e){var t=Y[n]=b(G.prototype);return J(t,{type:"Symbol",tag:n,description:e}),a||(t.description=e),t},ln=c?function(n){return"symbol"==typeof n}:function(n){return Object(n)instanceof G},an=function(n,e,t){n===U&&an(X,e,t),h(n);var r=v(e,!0);return h(t),u(Y,r)?(t.enumerable?(u(n,M)&&n[M][r]&&(n[M][r]=!1),t=b(t,{enumerable:y(0,!1)})):(u(n,M)||$(n,M,y(1,{})),n[M][r]=!0),rn(n,r,t)):$(n,r,t)},sn=function(n,e){h(n);var t=f(e),r=x(t).concat(pn(t));return q(r,(function(e){a&&!cn.call(t,e)||an(n,e,t[e])})),n},cn=function(n){var e=v(n,!0),t=H.call(this,e);return!(this===U&&u(Y,e)&&!u(X,e))&&(!(t||!u(this,e)||!u(Y,e)||u(this,M)&&this[M][e])||t)},dn=function(n,e){var t=f(n),r=v(e,!0);if(t!==U||!u(Y,r)||u(X,r)){var i=Z(t,r);return!i||!u(Y,r)||u(t,M)&&t[M][r]||(i.enumerable=!0),i}},un=function(n){var e=W(f(n)),t=[];return q(e,(function(n){u(Y,n)||u(V,n)||t.push(n)})),t},pn=function(n){var e=n===U,t=W(e?X:f(n)),r=[];return q(t,(function(n){!u(Y,n)||e&&!u(U,n)||r.push(Y[n])})),r};(s||(I((G=function(){if(this instanceof G)throw TypeError("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=N(n),t=function(n){this===U&&t.call(X,n),u(this,M)&&u(this[M],e)&&(this[M][e]=!1),rn(this,e,y(1,n))};return a&&tn&&rn(U,e,{configurable:!0,set:t}),on(e,n)}).prototype,"toString",(function(){return O(this).tag})),I(G,"withoutSetter",(function(n){return on(N(n),n)})),S.f=cn,T.f=an,z.f=dn,w.f=E.f=un,j.f=pn,B.f=function(n){return on(L(n),n)},a&&($(G.prototype,"description",{configurable:!0,get:function(){return O(this).description}}),l||I(U,"propertyIsEnumerable",cn,{unsafe:!0}))),r({global:!0,wrap:!0,forced:!s,sham:!s},{Symbol:G}),q(x(nn),(function(n){P(n)})),r({target:"Symbol",stat:!0,forced:!s},{for:function(n){var e=String(n);if(u(Q,e))return Q[e];var t=G(e);return Q[e]=t,K[t]=e,t},keyFor:function(n){if(!ln(n))throw TypeError(n+" is not a symbol");if(u(K,n))return K[n]},useSetter:function(){tn=!0},useSimple:function(){tn=!1}}),r({target:"Object",stat:!0,forced:!s,sham:!a},{create:function(n,e){return void 0===e?b(n):sn(b(n),e)},defineProperty:an,defineProperties:sn,getOwnPropertyDescriptor:dn}),r({target:"Object",stat:!0,forced:!s},{getOwnPropertyNames:un,getOwnPropertySymbols:pn}),r({target:"Object",stat:!0,forced:d((function(){j.f(1)}))},{getOwnPropertySymbols:function(n){return j.f(g(n))}}),F)&&r({target:"JSON",stat:!0,forced:!s||d((function(){var n=G();return"[null]"!=F([n])||"{}"!=F({a:n})||"{}"!=F(Object(n))}))},{stringify:function(n,e,t){for(var r,i=[n],o=1;arguments.length>o;)i.push(arguments[o++]);if(r=e,(m(e)||void 0!==n)&&!ln(n))return p(e)||(e=function(n,e){if("function"==typeof r&&(e=r.call(this,n,e)),!ln(e))return e}),i[1]=e,F.apply(null,i)}});G.prototype[R]||k(G.prototype,R,G.prototype.valueOf),C(G,"Symbol"),V[M]=!0},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(58),t(40),t(22),t(332),t(23),t(24),t(150),t(333),t(111);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}},function(n,e,t){var r=t(0),i=t(2),o=t(25),l=[].slice,a=function(n){return function(e,t){var r=arguments.length>2,i=r?l.call(arguments,2):void 0;return n(r?function(){("function"==typeof e?e:Function(e)).apply(this,i)}:e,t)}};r({global:!0,bind:!0,forced:/MSIE .\./.test(o)},{setTimeout:a(i.setTimeout),setInterval:a(i.setInterval)})},function(n,e,t){"use strict";var r=t(0),i=t(1),o=t(53),l=t(4),a=t(11),s=t(10),c=t(70),d=t(149),u=t(71),p=t(3),m=t(38),h=p("isConcatSpreadable"),g=m>=51||!i((function(){var n=[];return n[h]=!1,n.concat()[0]!==n})),f=u("concat"),v=function(n){if(!l(n))return!1;var e=n[h];return void 0!==e?!!e:o(n)};r({target:"Array",proto:!0,forced:!g||!f},{concat:function(n){var e,t,r,i,o,l=a(this),u=d(l,0),p=0;for(e=-1,r=arguments.length;e<r;e++)if(v(o=-1===e?l:arguments[e])){if(p+(i=s(o.length))>9007199254740991)throw TypeError("Maximum allowed index exceeded");for(t=0;t<i;t++,p++)t in o&&c(u,p,o[t])}else{if(p>=9007199254740991)throw TypeError("Maximum allowed index exceeded");c(u,p++,o)}return u.length=p,u}})},function(n,e,t){"use strict";var r=t(0),i=t(45).map;r({target:"Array",proto:!0,forced:!t(71)("map")},{map:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(68),i=t(47),o=t(11),l=t(10),a=t(149),s=[].push,c=function(n){var e=1==n,t=2==n,c=3==n,d=4==n,u=6==n,p=7==n,m=5==n||u;return function(h,g,f,v){for(var y,b,x=o(h),w=i(x),E=r(g,f,3),j=l(w.length),z=0,T=v||a,S=e?T(h,j):t||p?T(h,0):void 0;j>z;z++)if((m||z in w)&&(b=E(y=w[z],z,x),n))if(e)S[z]=b;else if(b)switch(n){case 3:return!0;case 5:return y;case 6:return z;case 2:s.call(S,y)}else switch(n){case 4:return!1;case 7:s.call(S,y)}return u?-1:c||d?d:S}};n.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6),filterOut:c(7)}},function(n,e,t){var r=t(55),i=t(228),o=t(229),l=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":l&&l in Object(n)?i(n):o(n)}},function(n,e,t){var r=t(1),i=t(30),o="".split;n.exports=r((function(){return!Object("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?o.call(n,""):Object(n)}:Object},function(n,e,t){var r=t(4);n.exports=function(n,e){if(!r(n))return n;var t,i;if(e&&"function"==typeof(t=n.toString)&&!r(i=t.call(n)))return i;if("function"==typeof(t=n.valueOf)&&!r(i=t.call(n)))return i;if(!e&&"function"==typeof(t=n.toString)&&!r(i=t.call(n)))return i;throw TypeError("Can't convert object to primitive value")}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?r:t)(n)}},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var r=t(30);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){"use strict";var r=t(0),i=t(6),o=t(2),l=t(9),a=t(4),s=t(8).f,c=t(133),d=o.Symbol;if(i&&"function"==typeof d&&(!("description"in d.prototype)||void 0!==d().description)){var u={},p=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),e=this instanceof p?new d(n):void 0===n?d():d(n);return""===n&&(u[e]=!0),e};c(p,d);var m=p.prototype=d.prototype;m.constructor=p;var h=m.toString,g="Symbol(test)"==String(d("test")),f=/^Symbol\((.*)\)[^)]+$/;s(m,"description",{configurable:!0,get:function(){var n=a(this)?this.valueOf():this,e=h.call(n);if(l(u,n))return"";var t=g?e.slice(7,-1):e.replace(f,"$1");return""===t?void 0:t}}),r({global:!0,forced:!0},{Symbol:p})}},function(n,e,t){var r=t(20).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(60);var r=t(57);t(40),t(54),t(7),t(72),t(14),t(17),t(159);var i=t(79);function o(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(i.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(0),i=t(11),o=t(64);r({target:"Object",stat:!0,forced:t(1)((function(){o(1)}))},{keys:function(n){return o(i(n))}})},function(n,e,t){var r=t(129),i=t(90).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){t(0)({target:"Array",stat:!0},{isArray:t(53)})},function(n,e,t){var r=t(6),i=t(8).f,o=Function.prototype,l=o.toString,a=/^\s*function ([^ (]*)/;r&&!("name"in o)&&i(o,"name",{configurable:!0,get:function(){try{return l.call(this).match(a)[1]}catch(n){return""}}})},function(n,e,t){var r=t(31),i=t(85);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.15.2",mode:r?"pure":"global",copyright:"© 2021 Denis Pushkarev (zloirock.ru)"})},function(n,e){var t=0,r=Math.random();n.exports=function(n){return"Symbol("+String(void 0===n?"":n)+")_"+(++t+r).toString(36)}},function(n,e,t){var r=t(129),i=t(90);n.exports=Object.keys||function(n){return r(n,i)}},function(n,e,t){var r=t(62),i=t(63),o=r("keys");n.exports=function(n){return o[n]||(o[n]=i(n))}},function(n,e,t){var r=t(8).f,i=t(9),o=t(3)("toStringTag");n.exports=function(n,e,t){n&&!i(n=t?n:n.prototype,o)&&r(n,o,{configurable:!0,value:e})}},function(n,e,t){var r=t(5),i=t(203);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return r(t),i(o),e?n.call(t,o):t.__proto__=o,t}}():void 0)},function(n,e,t){var r=t(28);n.exports=function(n,e,t){if(r(n),void 0===e)return n;switch(t){case 0:return function(){return n.call(e)};case 1:return function(t){return n.call(e,t)};case 2:return function(t,r){return n.call(e,t,r)};case 3:return function(t,r,i){return n.call(e,t,r,i)}}return function(){return n.apply(e,arguments)}}},function(n,e,t){var r=t(30),i=t(2);n.exports="process"==r(i.process)},function(n,e,t){"use strict";var r=t(48),i=t(8),o=t(49);n.exports=function(n,e,t){var l=r(e);l in n?i.f(n,l,o(0,t)):n[l]=t}},function(n,e,t){var r=t(1),i=t(3),o=t(38),l=i("species");n.exports=function(n){return o>=51||!r((function(){var e=[];return(e.constructor={})[l]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){t(158)("iterator")},function(n,e,t){"use strict";var r,i,o=t(118),l=t(119),a=t(62),s=t(32),c=t(36).get,d=t(192),u=t(193),p=RegExp.prototype.exec,m=a("native-string-replace",String.prototype.replace),h=p,g=(r=/a/,i=/b*/g,p.call(r,"a"),p.call(i,"a"),0!==r.lastIndex||0!==i.lastIndex),f=l.UNSUPPORTED_Y||l.BROKEN_CARET,v=void 0!==/()??/.exec("")[1];(g||v||f||d||u)&&(h=function(n){var e,t,r,i,l,a,d,u=this,y=c(u),b=y.raw;if(b)return b.lastIndex=u.lastIndex,e=h.call(b,n),u.lastIndex=b.lastIndex,e;var x=y.groups,w=f&&u.sticky,E=o.call(u),j=u.source,z=0,T=n;if(w&&(-1===(E=E.replace("y","")).indexOf("g")&&(E+="g"),T=String(n).slice(u.lastIndex),u.lastIndex>0&&(!u.multiline||u.multiline&&"\n"!==n[u.lastIndex-1])&&(j="(?: "+j+")",T=" "+T,z++),t=new RegExp("^(?:"+j+")",E)),v&&(t=new RegExp("^"+j+"$(?!\\s)",E)),g&&(r=u.lastIndex),i=p.call(w?t:u,T),w?i?(i.input=i.input.slice(z),i[0]=i[0].slice(z),i.index=u.lastIndex,u.lastIndex+=i[0].length):u.lastIndex=0:g&&i&&(u.lastIndex=u.global?i.index+i[0].length:r),v&&i&&i.length>1&&m.call(i[0],t,(function(){for(l=1;l<arguments.length-2;l++)void 0===arguments[l]&&(i[l]=void 0)})),i&&x)for(i.groups=a=s(null),l=0;l<x.length;l++)a[(d=x[l])[0]]=i[d[1]];return i}),n.exports=h},function(n,e,t){var r=t(233),i=t(234),o=t(235),l=t(236),a=t(237);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=i,s.prototype.get=o,s.prototype.has=l,s.prototype.set=a,n.exports=s},function(n,e,t){var r=t(164);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(33)(Object,"create");n.exports=r},function(n,e,t){var r=t(255);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(109);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(34),t(7),t(61),t(159),t(14);var r=t(57);function i(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var s=t.render(!e),c=s.querySelector(r.barSelector),d=r.speed,u=r.easing;return s.offsetWidth,l((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),a(c,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,i}(n,d,u)),1===n?(a(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){a(s,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,l=e.querySelector(r.barSelector),s=n?"-100":o(t.status||0),d=document.querySelector(r.parent);return a(l,{transition:"all 0 linear",transform:"translate3d("+s+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&p(i),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var l=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),a=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,o=arguments;if(2==o.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,o[1],o[2])}}();function s(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;s(t,e)||(n.className=r.substring(1))}function d(n,e){var t,r=u(n);s(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){"use strict";var r=t(98),i=t(117),o=t(5),l=t(12),a=t(97),s=t(99),c=t(10),d=t(100),u=t(73),p=t(119),m=t(1),h=p.UNSUPPORTED_Y,g=[].push,f=Math.min;r("split",(function(n,e,t){var r;return r="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var r=String(l(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[r];if(!i(n))return e.call(r,n,o);for(var a,s,c,d=[],p=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),m=0,h=new RegExp(n.source,p+"g");(a=u.call(h,r))&&!((s=h.lastIndex)>m&&(d.push(r.slice(m,a.index)),a.length>1&&a.index<r.length&&g.apply(d,a.slice(1)),c=a[0].length,m=s,d.length>=o));)h.lastIndex===a.index&&h.lastIndex++;return m===r.length?!c&&h.test("")||d.push(""):d.push(r.slice(m)),d.length>o?d.slice(0,o):d}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:e.call(this,n,t)}:e,[function(e,t){var i=l(this),o=null==e?void 0:e[n];return void 0!==o?o.call(e,i,t):r.call(String(i),e,t)},function(n,i){var l=t(r,this,n,i,r!==e);if(l.done)return l.value;var u=o(this),p=String(n),m=a(u,RegExp),g=u.unicode,v=(u.ignoreCase?"i":"")+(u.multiline?"m":"")+(u.unicode?"u":"")+(h?"g":"y"),y=new m(h?"^(?:"+u.source+")":u,v),b=void 0===i?4294967295:i>>>0;if(0===b)return[];if(0===p.length)return null===d(y,p)?[p]:[];for(var x=0,w=0,E=[];w<p.length;){y.lastIndex=h?0:w;var j,z=d(y,h?p.slice(w):p);if(null===z||(j=f(c(y.lastIndex+(h?w:0)),p.length))===x)w=s(p,w,g);else{if(E.push(p.slice(x,w)),E.length===b)return E;for(var T=1;T<=z.length-1;T++)if(E.push(z[T]),E.length===b)return E;w=x=j}}return E.push(p.slice(x)),E}]}),!!m((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),h)},function(n,e,t){"use strict";var r=t(0),i=t(89).indexOf,o=t(39),l=[].indexOf,a=!!l&&1/[1].indexOf(1,-0)<0,s=o("indexOf");r({target:"Array",proto:!0,forced:a||!s},{indexOf:function(n){return a?l.apply(this,arguments)||0:i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(1),i=/#|\.prototype\./,o=function(n,e){var t=a[l(n)];return t==c||t!=s&&("function"==typeof e?r(e):!!e)},l=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},a=o.data={},s=o.NATIVE="N",c=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(2),i=t(86),o=r["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=o},function(n,e,t){var r=t(2),i=t(15);n.exports=function(n,e){try{i(r,n,e)}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(2),i=t(4),o=r.document,l=i(o)&&i(o.createElement);n.exports=function(n){return l?o.createElement(n):{}}},function(n,e,t){var r=t(38),i=t(1);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r=t(16),i=t(10),o=t(130),l=function(n){return function(e,t,l){var a,s=r(e),c=i(s.length),d=o(l,c);if(n&&t!=t){for(;c>d;)if((a=s[d++])!=a)return!0}else for(;c>d;d++)if((n||d in s)&&s[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:l(!0),indexOf:l(!1)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(85),i=Function.toString;"function"!=typeof r.inspectSource&&(r.inspectSource=function(n){return i.call(n)}),n.exports=r.inspectSource},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,o=i&&!r.call({1:2},1);e.f=o?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(26),i=t(59),o=t(94),l=t(5);n.exports=r("Reflect","ownKeys")||function(n){var e=i.f(l(n)),t=o.f;return t?e.concat(t(n)):e}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(9),i=t(11),o=t(65),l=t(135),a=o("IE_PROTO"),s=Object.prototype;n.exports=l?Object.getPrototypeOf:function(n){return n=i(n),r(n,a)?n[a]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?s:null}},function(n,e,t){var r={};r[t(3)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(5),i=t(28),o=t(3)("species");n.exports=function(n,e){var t,l=r(n).constructor;return void 0===l||null==(t=r(l)[o])?e:i(t)}},function(n,e,t){"use strict";t(18);var r=t(13),i=t(73),o=t(1),l=t(3),a=t(15),s=l("species"),c=RegExp.prototype;n.exports=function(n,e,t,d){var u=l(n),p=!o((function(){var e={};return e[u]=function(){return 7},7!=""[n](e)})),m=p&&!o((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[s]=function(){return t},t.flags="",t[u]=/./[u]),t.exec=function(){return e=!0,null},t[u](""),!e}));if(!p||!m||t){var h=/./[u],g=e(u,""[n],(function(n,e,t,r,o){var l=e.exec;return l===i||l===c.exec?p&&!o?{done:!0,value:h.call(e,t,r)}:{done:!0,value:n.call(t,e,r)}:{done:!1}}));r(String.prototype,n,g[0]),r(c,u,g[1])}d&&a(c[u],"sham",!0)}},function(n,e,t){"use strict";var r=t(147).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){var r=t(30),i=t(73);n.exports=function(n,e){var t=n.exec;if("function"==typeof t){var o=t.call(n,e);if("object"!=typeof o)throw TypeError("RegExp exec method returned something other than an Object or null");return o}if("RegExp"!==r(n))throw TypeError("RegExp#exec called on incompatible receiver");return i.call(n,e)}},function(n,e,t){"use strict";var r=t(0),i=t(47),o=t(16),l=t(39),a=[].join,s=i!=Object,c=l("join",",");r({target:"Array",proto:!0,forced:s||!c},{join:function(n){return a.call(o(this),void 0===n?",":n)}})},function(n,e,t){var r=t(227),i=t(37),o=Object.prototype,l=o.hasOwnProperty,a=o.propertyIsEnumerable,s=r(function(){return arguments}())?r:function(n){return i(n)&&l.call(n,"callee")&&!a.call(n,"callee")};n.exports=s},function(n,e,t){var r=t(33)(t(20),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(247),i=t(254),o=t(256),l=t(257),a=t(258);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=i,s.prototype.get=o,s.prototype.has=l,s.prototype.set=a,n.exports=s},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(19),i=t(109),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,l=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(l.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(46),i=t(37);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(0),i=t(6);r({target:"Object",stat:!0,forced:!i,sham:!i},{defineProperty:t(8).f})},function(n,e,t){"use strict";var r=t(0),i=t(45).some;r({target:"Array",proto:!0,forced:!t(39)("some")},{some:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(98),i=t(5),o=t(10),l=t(12),a=t(99),s=t(100);r("match",(function(n,e,t){return[function(e){var t=l(this),r=null==e?void 0:e[n];return void 0!==r?r.call(e,t):new RegExp(e)[n](String(t))},function(n){var r=t(e,this,n);if(r.done)return r.value;var l=i(this),c=String(n);if(!l.global)return s(l,c);var d=l.unicode;l.lastIndex=0;for(var u,p=[],m=0;null!==(u=s(l,c));){var h=String(u[0]);p[m]=h,""===h&&(l.lastIndex=a(c,o(l.lastIndex),d)),m++}return 0===m?null:p}]}))},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){"use strict";var r=t(13),i=t(5),o=t(1),l=t(118),a=RegExp.prototype,s=a.toString,c=o((function(){return"/a/b"!=s.call({source:"a",flags:"b"})})),d="toString"!=s.name;(c||d)&&r(RegExp.prototype,"toString",(function(){var n=i(this),e=String(n.source),t=n.flags;return"/"+e+"/"+String(void 0===t&&n instanceof RegExp&&!("flags"in a)?l.call(n):t)}),{unsafe:!0})},function(n,e,t){var r=t(3),i=t(32),o=t(8),l=r("unscopables"),a=Array.prototype;null==a[l]&&o.f(a,l,{configurable:!0,value:i(null)}),n.exports=function(n){a[l][n]=!0}},function(n,e,t){var r=t(4),i=t(30),o=t(3)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[o])?!!e:"RegExp"==i(n))}},function(n,e,t){"use strict";var r=t(5);n.exports=function(){var n=r(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(1),i=function(n,e){return RegExp(n,e)};e.UNSUPPORTED_Y=r((function(){var n=i("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),e.BROKEN_CARET=r((function(){var n=i("^r","gy");return n.lastIndex=2,null!=n.exec("str")}))},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,o=/^0o[0-7]+$/i,l=parseInt,a="object"==typeof global&&global&&global.Object===Object&&global,s="object"==typeof self&&self&&self.Object===Object&&self,c=a||s||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var a=i.test(n);return a||o.test(n)?l(n.slice(2),a?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,o,l,a,s,c=0,d=!1,f=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=r,o=i;return r=i=void 0,c=e,l=n.apply(o,t)}function b(n){return c=n,a=setTimeout(w,e),d?y(n):l}function x(n){var t=n-s;return void 0===s||t>=e||t<0||f&&n-c>=o}function w(){var n=m();if(x(n))return E(n);a=setTimeout(w,function(n){var t=e-(n-s);return f?p(t,o-(n-c)):t}(n))}function E(n){return a=void 0,v&&r?y(n):(r=i=void 0,l)}function j(){var n=m(),t=x(n);if(r=arguments,i=this,s=n,t){if(void 0===a)return b(s);if(f)return a=setTimeout(w,e),y(s)}return void 0===a&&(a=setTimeout(w,e)),l}return e=g(e)||0,h(t)&&(d=!!t.leading,o=(f="maxWait"in t)?u(g(t.maxWait)||0,e):o,v="trailing"in t?!!t.trailing:v),j.cancel=function(){void 0!==a&&clearTimeout(a),c=0,r=s=i=a=void 0},j.flush=function(){return void 0===a?l:E(m())},j}},function(n,e,t){var r=t(12),i="["+t(122)+"]",o=RegExp("^"+i+i+"*"),l=RegExp(i+i+"*$"),a=function(n){return function(e){var t=String(r(e));return 1&n&&(t=t.replace(o,"")),2&n&&(t=t.replace(l,"")),t}};n.exports={start:a(1),end:a(2),trim:a(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){var r=t(13),i=Date.prototype,o=i.toString,l=i.getTime;new Date(NaN)+""!="Invalid Date"&&r(i,"toString",(function(){var n=l.call(this);return n==n?o.call(this):"Invalid Date"}))},function(n,e,t){"use strict";var r=t(16),i=t(116),o=t(52),l=t(36),a=t(132),s=l.set,c=l.getterFor("Array Iterator");n.exports=a(Array,"Array",(function(n,e){s(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=c(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values"),o.Arguments=o.Array,i("keys"),i("values"),i("entries")},function(n,e,t){var r=t(6),i=t(1),o=t(87);n.exports=!r&&!i((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(2);n.exports=r},function(n,e,t){var r=t(88);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(6),i=t(8),o=t(5),l=t(64);n.exports=r?Object.defineProperties:function(n,e){o(n);for(var t,r=l(e),a=r.length,s=0;a>s;)i.f(n,t=r[s++],e[t]);return n}},function(n,e,t){var r=t(9),i=t(16),o=t(89).indexOf,l=t(51);n.exports=function(n,e){var t,a=i(n),s=0,c=[];for(t in a)!r(l,t)&&r(a,t)&&c.push(t);for(;e.length>s;)r(a,t=e[s++])&&(~o(c,t)||c.push(t));return c}},function(n,e,t){var r=t(50),i=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):o(t,e)}},function(n,e,t){var r=t(26);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(0),i=t(202),o=t(95),l=t(67),a=t(66),s=t(15),c=t(13),d=t(3),u=t(31),p=t(52),m=t(134),h=m.IteratorPrototype,g=m.BUGGY_SAFARI_ITERATORS,f=d("iterator"),v=function(){return this};n.exports=function(n,e,t,d,m,y,b){i(t,e,d);var x,w,E,j=function(n){if(n===m&&I)return I;if(!g&&n in S)return S[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},z=e+" Iterator",T=!1,S=n.prototype,k=S[f]||S["@@iterator"]||m&&S[m],I=!g&&k||j(m),A="Array"==e&&S.entries||k;if(A&&(x=o(A.call(new n)),h!==Object.prototype&&x.next&&(u||o(x)===h||(l?l(x,h):"function"!=typeof x[f]&&s(x,f,v)),a(x,z,!0,!0),u&&(p[z]=v))),"values"==m&&k&&"values"!==k.name&&(T=!0,I=function(){return k.call(this)}),u&&!b||S[f]===I||s(S,f,I),p[e]=I,m)if(w={values:j("values"),keys:y?I:j("keys"),entries:j("entries")},b)for(E in w)(g||T||!(E in S))&&c(S,E,w[E]);else r({target:e,proto:!0,forced:g||T},w);return w}},function(n,e,t){var r=t(9),i=t(93),o=t(27),l=t(8);n.exports=function(n,e){for(var t=i(e),a=l.f,s=o.f,c=0;c<t.length;c++){var d=t[c];r(n,d)||a(n,d,s(e,d))}}},function(n,e,t){"use strict";var r,i,o,l=t(1),a=t(95),s=t(15),c=t(9),d=t(3),u=t(31),p=d("iterator"),m=!1;[].keys&&("next"in(o=[].keys())?(i=a(a(o)))!==Object.prototype&&(r=i):m=!0);var h=null==r||l((function(){var n={};return r[p].call(n)!==n}));h&&(r={}),u&&!h||c(r,p)||s(r,p,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:m}},function(n,e,t){var r=t(1);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(2);n.exports=r.Promise},function(n,e,t){var r=t(3),i=t(52),o=r("iterator"),l=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||l[o]===n)}},function(n,e,t){var r=t(139),i=t(52),o=t(3)("iterator");n.exports=function(n){if(null!=n)return n[o]||n["@@iterator"]||i[r(n)]}},function(n,e,t){var r=t(96),i=t(30),o=t(3)("toStringTag"),l="Arguments"==i(function(){return arguments}());n.exports=r?i:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=Object(n),o))?t:l?i(e):"Object"==(r=i(e))&&"function"==typeof e.callee?"Arguments":r}},function(n,e,t){var r=t(5);n.exports=function(n){var e=n.return;if(void 0!==e)return r(e.call(n)).value}},function(n,e,t){var r=t(3)("iterator"),i=!1;try{var o=0,l={next:function(){return{done:!!o++}},return:function(){i=!0}};l[r]=function(){return this},Array.from(l,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!i)return!1;var t=!1;try{var o={};o[r]=function(){return{next:function(){return{done:t=!0}}}},n(o)}catch(n){}return t}},function(n,e,t){var r,i,o,l=t(2),a=t(1),s=t(68),c=t(131),d=t(87),u=t(143),p=t(69),m=l.location,h=l.setImmediate,g=l.clearImmediate,f=l.process,v=l.MessageChannel,y=l.Dispatch,b=0,x={},w=function(n){if(x.hasOwnProperty(n)){var e=x[n];delete x[n],e()}},E=function(n){return function(){w(n)}},j=function(n){w(n.data)},z=function(n){l.postMessage(n+"",m.protocol+"//"+m.host)};h&&g||(h=function(n){for(var e=[],t=1;arguments.length>t;)e.push(arguments[t++]);return x[++b]=function(){("function"==typeof n?n:Function(n)).apply(void 0,e)},r(b),b},g=function(n){delete x[n]},p?r=function(n){f.nextTick(E(n))}:y&&y.now?r=function(n){y.now(E(n))}:v&&!u?(o=(i=new v).port2,i.port1.onmessage=j,r=s(o.postMessage,o,1)):l.addEventListener&&"function"==typeof postMessage&&!l.importScripts&&m&&"file:"!==m.protocol&&!a(z)?(r=z,l.addEventListener("message",j,!1)):r="onreadystatechange"in d("script")?function(n){c.appendChild(d("script")).onreadystatechange=function(){c.removeChild(this),w(n)}}:function(n){setTimeout(E(n),0)}),n.exports={set:h,clear:g}},function(n,e,t){var r=t(25);n.exports=/(?:iphone|ipod|ipad).*applewebkit/i.test(r)},function(n,e,t){var r=t(5),i=t(4),o=t(145);n.exports=function(n,e){if(r(n),i(e)&&e.constructor===n)return e;var t=o.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){"use strict";var r=t(28),i=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new i(n)}},function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},i=r.iterator||"@@iterator",o=r.asyncIterator||"@@asyncIterator",l=r.toStringTag||"@@toStringTag";function a(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{a({},"")}catch(n){a=function(n,e,t){return n[e]=t}}function s(n,e,t,r){var i=e&&e.prototype instanceof u?e:u,o=Object.create(i.prototype),l=new j(r||[]);return o._invoke=function(n,e,t){var r="suspendedStart";return function(i,o){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===i)throw o;return T()}for(t.method=i,t.arg=o;;){var l=t.delegate;if(l){var a=x(l,t);if(a){if(a===d)continue;return a}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var s=c(n,e,t);if("normal"===s.type){if(r=t.done?"completed":"suspendedYield",s.arg===d)continue;return{value:s.arg,done:t.done}}"throw"===s.type&&(r="completed",t.method="throw",t.arg=s.arg)}}}(n,t,l),o}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=s;var d={};function u(){}function p(){}function m(){}var h={};h[i]=function(){return this};var g=Object.getPrototypeOf,f=g&&g(g(z([])));f&&f!==e&&t.call(f,i)&&(h=f);var v=m.prototype=u.prototype=Object.create(h);function y(n){["next","throw","return"].forEach((function(e){a(n,e,(function(n){return this._invoke(e,n)}))}))}function b(n,e){var r;this._invoke=function(i,o){function l(){return new e((function(r,l){!function r(i,o,l,a){var s=c(n[i],n,o);if("throw"!==s.type){var d=s.arg,u=d.value;return u&&"object"==typeof u&&t.call(u,"__await")?e.resolve(u.__await).then((function(n){r("next",n,l,a)}),(function(n){r("throw",n,l,a)})):e.resolve(u).then((function(n){d.value=n,l(d)}),(function(n){return r("throw",n,l,a)}))}a(s.arg)}(i,o,r,l)}))}return r=r?r.then(l,l):l()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return d;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var r=c(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,d;var i=r.arg;return i?i.done?(e[n.resultName]=i.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,d):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,d)}function w(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function E(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function j(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(w,this),this.reset(!0)}function z(n){if(n){var e=n[i];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,o=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return o.next=o}}return{next:T}}function T(){return{value:void 0,done:!0}}return p.prototype=v.constructor=m,m.constructor=p,p.displayName=a(m,l,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,a(n,l,"GeneratorFunction")),n.prototype=Object.create(v),n},n.awrap=function(n){return{__await:n}},y(b.prototype),b.prototype[o]=function(){return this},n.AsyncIterator=b,n.async=function(e,t,r,i,o){void 0===o&&(o=Promise);var l=new b(s(e,t,r,i),o);return n.isGeneratorFunction(t)?l:l.next().then((function(n){return n.done?n.value:l.next()}))},y(v),a(v,l,"Generator"),v[i]=function(){return this},v.toString=function(){return"[object Generator]"},n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=z,j.prototype={constructor:j,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(E),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return l.type="throw",l.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i],l=o.completion;if("root"===o.tryLoc)return r("end");if(o.tryLoc<=this.prev){var a=t.call(o,"catchLoc"),s=t.call(o,"finallyLoc");if(a&&s){if(this.prev<o.catchLoc)return r(o.catchLoc,!0);if(this.prev<o.finallyLoc)return r(o.finallyLoc)}else if(a){if(this.prev<o.catchLoc)return r(o.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return r(o.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&t.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===n||"continue"===n)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var l=o?o.completion:{};return l.type=n,l.arg=e,o?(this.method="next",this.next=o.finallyLoc,d):this.complete(l)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),d},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),E(t),d}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var i=r.arg;E(t)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:z(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),d}},n}(n.exports);try{regeneratorRuntime=r}catch(n){Function("r","regeneratorRuntime = r")(r)}},function(n,e,t){var r=t(50),i=t(12),o=function(n){return function(e,t){var o,l,a=String(i(e)),s=r(t),c=a.length;return s<0||s>=c?n?"":void 0:(o=a.charCodeAt(s))<55296||o>56319||s+1===c||(l=a.charCodeAt(s+1))<56320||l>57343?n?a.charAt(s):o:n?a.slice(s,s+2):l-56320+(o-55296<<10)+65536}};n.exports={codeAt:o(!1),charAt:o(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var r=t(4),i=t(53),o=t(3)("species");n.exports=function(n,e){var t;return i(n)&&("function"!=typeof(t=n.constructor)||t!==Array&&!i(t.prototype)?r(t)&&null===(t=t[o])&&(t=void 0):t=void 0),new(void 0===t?Array:t)(0===e?0:e)}},function(n,e,t){var r=t(0),i=t(6),o=t(93),l=t(16),a=t(27),s=t(70);r({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(n){for(var e,t,r=l(n),i=a.f,c=o(r),d={},u=0;c.length>u;)void 0!==(t=i(r,e=c[u++]))&&s(d,e,t);return d}})},function(n,e,t){var r=t(0),i=t(1),o=t(11),l=t(95),a=t(135);r({target:"Object",stat:!0,forced:i((function(){l(1)})),sham:!a},{getPrototypeOf:function(n){return l(o(n))}})},function(n,e,t){"use strict";var r,i=t(0),o=t(27).f,l=t(10),a=t(153),s=t(12),c=t(154),d=t(31),u="".startsWith,p=Math.min,m=c("startsWith");i({target:"String",proto:!0,forced:!!(d||m||(r=o(String.prototype,"startsWith"),!r||r.writable))&&!m},{startsWith:function(n){var e=String(s(this));a(n);var t=l(p(arguments.length>1?arguments[1]:void 0,e.length)),r=String(n);return u?u.call(e,r,t):e.slice(t,t+r.length)===r}})},function(n,e,t){var r=t(117);n.exports=function(n){if(r(n))throw TypeError("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(3)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var r=t(45).forEach,i=t(39)("forEach");n.exports=i?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(1);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(3);e.f=r},function(n,e,t){var r=t(126),i=t(9),o=t(157),l=t(8).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});i(e,n)||l(e,n,{value:o.f(n)})}},function(n,e,t){var r=t(0),i=t(222);r({target:"Array",stat:!0,forced:!t(141)((function(n){Array.from(n)}))},{from:i})},function(n,e,t){t(0)({target:"Object",stat:!0,sham:!t(6)},{create:t(32)})},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(74),i=t(238),o=t(239),l=t(240),a=t(241),s=t(242);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=o,c.prototype.get=l,c.prototype.has=a,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(46),i=t(104);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(259),i=t(37);n.exports=function n(e,t,o,l,a){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,o,l,n,a))}},function(n,e,t){var r=t(169),i=t(262),o=t(170);n.exports=function(n,e,t,l,a,s){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=s.get(n),m=s.get(e);if(p&&m)return p==e&&m==n;var h=-1,g=!0,f=2&t?new r:void 0;for(s.set(n,e),s.set(e,n);++h<d;){var v=n[h],y=e[h];if(l)var b=c?l(y,v,h,e,n,s):l(v,y,h,n,e,s);if(void 0!==b){if(b)continue;g=!1;break}if(f){if(!i(e,(function(n,e){if(!o(f,e)&&(v===n||a(v,n,t,l,s)))return f.push(e)}))){g=!1;break}}else if(v!==y&&!a(v,y,t,l,s)){g=!1;break}}return s.delete(n),s.delete(e),g}},function(n,e,t){var r=t(105),i=t(260),o=t(261);function l(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}l.prototype.add=l.prototype.push=i,l.prototype.has=o,n.exports=l},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(272),i=t(278),o=t(175);n.exports=function(n){return o(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(20),i=t(274),o=e&&!e.nodeType&&e,l=o&&"object"==typeof n&&n&&!n.nodeType&&n,a=l&&l.exports===o?r.Buffer:void 0,s=(a?a.isBuffer:void 0)||i;n.exports=s}).call(this,t(114)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(275),i=t(276),o=t(277),l=o&&o.isTypedArray,a=l?i(l):r;n.exports=a},function(n,e,t){var r=t(165),i=t(107);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(33)(t(20),"Set");n.exports=r},function(n,e,t){var r=t(104);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(180),i=t(78);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[i(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(19),i=t(108),o=t(289),l=t(292);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:o(l(n))}},function(n,e,t){"use strict";var r=t(28),i=t(4),o=[].slice,l={},a=function(n,e,t){if(!(e in l)){for(var r=[],i=0;i<e;i++)r[i]="a["+i+"]";l[e]=Function("C,a","return new C("+r.join(",")+")")}return l[e](n,t)};n.exports=Function.bind||function(n){var e=r(this),t=o.call(arguments,1),l=function(){var r=t.concat(o.call(arguments));return this instanceof l?a(e,r.length,r):e.apply(n,r)};return i(e.prototype)&&(l.prototype=e.prototype),l}},function(n,e,t){"use strict";var r=t(0),i=t(199).start;r({target:"String",proto:!0,forced:t(324)},{padStart:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){t(0)({target:"Object",stat:!0},{setPrototypeOf:t(67)})},function(n,e,t){var r=t(0),i=t(26),o=t(28),l=t(5),a=t(4),s=t(32),c=t(181),d=t(1),u=i("Reflect","construct"),p=d((function(){function n(){}return!(u((function(){}),[],n)instanceof n)})),m=!d((function(){u((function(){}))})),h=p||m;r({target:"Reflect",stat:!0,forced:h,sham:h},{construct:function(n,e){o(n),l(e);var t=arguments.length<3?n:o(arguments[2]);if(m&&!p)return u(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return r.push.apply(r,e),new(c.apply(n,r))}var i=t.prototype,d=s(a(i)?i:Object.prototype),h=Function.apply.call(n,d,e);return a(h)?h:d}})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(225),i=t(230),o=t(301),l=t(309),a=t(318),s=t(196),c=o((function(n){var e=s(n);return a(e)&&(e=void 0),l(r(n,1,a,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(335),i=t(336),o=t(337),l=!1,a=t(338).version,s=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=s.concat("cache"),d=/^\uFEFF/;function u(n,t){var i,o,l=t.views,a=/^[A-Za-z]+:\\|^\//.exec(n);if(a&&a.length)i=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(o=e.resolveInclude(n,t.filename),r.existsSync(o)&&(i=o)),i||Array.isArray(l)&&l.some((function(t){return o=e.resolveInclude(n,t,!0),r.existsSync(o)}))&&(i=o),!i)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return i}function p(n,t){var r,i=n.filename,o=arguments.length>1;if(n.cache){if(!i)throw new Error("cache option requires a filename");if(r=e.cache.get(i))return r;o||(t=h(i).toString().replace(d,""))}else if(!o){if(!i)throw new Error("Internal EJS error: no file name or template provided");t=h(i).toString().replace(d,"")}return r=e.compile(t,n),n.cache&&e.cache.set(i,r),r}function m(n,t,r){var i;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(i=p(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{i=p(n)(t)}catch(n){return r(n)}r(null,i)}function h(n){return e.fileLoader(n)}function g(n,e,t,r,i){var o=e.split("\n"),l=Math.max(r-3,0),a=Math.min(o.length,r+3),s=i(t),c=o.slice(l,a).map((function(n,e){var t=e+l+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=s,n.message=(s||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function f(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||o.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=o.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=i.dirname,o=i.extname,l=(0,i.resolve)(t?e:r(e),n);return o(n)||(l+=".ejs"),l},e.compile=function(n,e){return e&&e.scope&&(l||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),l=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var r=e||{},i=t||{};return 2==arguments.length&&o.shallowCopyFromList(i,r,s),p(i,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),i=r.shift(),l={filename:i};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?o.shallowCopy(l,r.pop()):(e.settings&&(e.settings.views&&(l.views=e.settings.views),e.settings["view cache"]&&(l.cache=!0),(t=e.settings["view options"])&&o.shallowCopy(l,t)),o.shallowCopyFromList(l,e,c)),l.filename=i):e={},m(l,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=o.escapeRegExpChars(this.opts.delimiter),t=o.escapeRegExpChars(this.opts.openDelimiter),r=o.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,l="",a="",s=r.escapeFunction;if(!this.source){if(this.generateSource(),l+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(l+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",d=0;d<r.destructuredLocals.length;d++){var m=r.destructuredLocals[d];d>0&&(c+=",\n  "),c+=m+" = __locals."+m}l+=c+";\n"}!1!==r._with&&(l+="  with ("+r.localsName+" || {}) {\n",a+="  }\n"),a+="  return __output;\n",this.source=l+this.source+a}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+s.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+g.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=r.client?e:function(n){return e.apply(r.context,[n||{},s,function(e,t){var i=o.shallowCopy({},n);return t&&(i=o.shallowCopy(i,t)),function(n,e){var t=o.shallowCopy({},e);return t.filename=u(n,t),p(t)}(e,r)(i)},g])};if(h.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var f=r.filename,v=i.basename(f,i.extname(f));try{Object.defineProperty(h,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),i=this.opts.delimiter,l=this.opts.openDelimiter,a=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(s,c){var p,m,g,f,y,b;if(0===s.indexOf(l+i)&&0!==s.indexOf(l+i+i)&&(m=r[c+2])!=i+a&&m!="-"+i+a&&m!="_"+i+a)throw new Error('Could not find matching close tag for "'+s+'".');if(n.legacyInclude&&(g=s.match(/^\s*include\s+(\S+)/))&&(p=r[c-1])&&(p==l+i||p==l+i+"-"||p==l+i+"_"))return f=o.shallowCopy({},t.opts),y=function(n,e){var t,r,i=o.shallowCopy({},e);r=h(t=u(n,i)).toString().replace(d,""),i.filename=t;var l=new v(r,i);return l.generateSource(),{source:l.source,filename:t,template:r}}(g[1],f),b=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(y.template)+"\n      , __filename = "+JSON.stringify(y.filename)+";\n      try {\n"+y.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+y.source+"    ; }).call(this)\n",t.source+=b,void t.dependencies.push(e.resolveInclude(g[1],f.filename));t.scanLine(s)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),i=[];r;)0!==(n=r.index)&&(i.push(e.substring(0,n)),e=e.slice(n)),i.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&i.push(e),i},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,i=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=v.modes.EVAL;break;case r+t+"=":this.mode=v.modes.ESCAPED;break;case r+t+"-":this.mode=v.modes.RAW;break;case r+t+"#":this.mode=v.modes.COMMENT;break;case r+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+i:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+i,t+i)+'")\n';break;case t+i:case"-"+t+i:case"_"+t+i:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+f(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+f(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=o.escapeXML,e.__express=e.renderFile,e.VERSION=a,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){function r(e){return"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?(n.exports=r=function(n){return typeof n},n.exports.default=n.exports,n.exports.__esModule=!0):(n.exports=r=function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n.exports.default=n.exports,n.exports.__esModule=!0),r(e)}t(40),t(54),t(7),t(72),t(14),t(17),n.exports=r,n.exports.default=n.exports,n.exports.__esModule=!0},function(n,e,t){"use strict";var r=t(6),i=t(2),o=t(84),l=t(13),a=t(9),s=t(30),c=t(198),d=t(48),u=t(1),p=t(32),m=t(59).f,h=t(27).f,g=t(8).f,f=t(121).trim,v=i.Number,y=v.prototype,b="Number"==s(p(y)),x=function(n){var e,t,r,i,o,l,a,s,c=d(n,!1);if("string"==typeof c&&c.length>2)if(43===(e=(c=f(c)).charCodeAt(0))||45===e){if(88===(t=c.charCodeAt(2))||120===t)return NaN}else if(48===e){switch(c.charCodeAt(1)){case 66:case 98:r=2,i=49;break;case 79:case 111:r=8,i=55;break;default:return+c}for(l=(o=c.slice(2)).length,a=0;a<l;a++)if((s=o.charCodeAt(a))<48||s>i)return NaN;return parseInt(o,r)}return+c};if(o("Number",!v(" 0o1")||!v("0b1")||v("+0x1"))){for(var w,E=function(n){var e=arguments.length<1?0:n,t=this;return t instanceof E&&(b?u((function(){y.valueOf.call(t)})):"Number"!=s(t))?c(new v(x(e)),t,E):x(e)},j=r?m(v):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(","),z=0;j.length>z;z++)a(v,w=j[z])&&!a(E,w)&&g(E,w,h(v,w));E.prototype=y,y.constructor=E,l(i,"Number",E)}},function(n,e,t){"use strict";var r=t(26),i=t(8),o=t(3),l=t(6),a=o("species");n.exports=function(n){var e=r(n),t=i.f;l&&e&&!e[a]&&t(e,a,{configurable:!0,get:function(){return this}})}},function(n,e,t){var r=t(1);n.exports=r((function(){var n=RegExp(".","string".charAt(0));return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){var r=t(1);n.exports=r((function(){var n=RegExp("(?<a>b)","string".charAt(5));return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){"use strict";var r=t(0),i=t(89).includes,o=t(116);r({target:"Array",proto:!0},{includes:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,e,t){"use strict";var r=t(0),i=t(153),o=t(12);r({target:"String",proto:!0,forced:!t(154)("includes")},{includes:function(n){return!!~String(o(this)).indexOf(i(n),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var r=t(0),i=t(121).trim;r({target:"String",proto:!0,forced:t(321)("trim")},{trim:function(){return i(this)}})},function(n,e,t){var r=t(4),i=t(67);n.exports=function(n,e,t){var o,l;return i&&"function"==typeof(o=e.constructor)&&o!==t&&r(l=o.prototype)&&l!==t.prototype&&i(n,l),n}},function(n,e,t){var r=t(10),i=t(323),o=t(12),l=Math.ceil,a=function(n){return function(e,t,a){var s,c,d=String(o(e)),u=d.length,p=void 0===a?" ":String(a),m=r(t);return m<=u||""==p?d:(s=m-u,(c=i.call(p,l(s/p.length))).length>s&&(c=c.slice(0,s)),n?d+c:c+d)}};n.exports={start:a(!1),end:a(!0)}},function(n,e,t){n.exports=t(341)},function(n,e,t){var r=t(2),i=t(91),o=r.WeakMap;n.exports="function"==typeof o&&/native code/.test(i(o))},function(n,e,t){"use strict";var r=t(134).IteratorPrototype,i=t(32),o=t(49),l=t(66),a=t(52),s=function(){return this};n.exports=function(n,e,t){var c=e+" Iterator";return n.prototype=i(r,{next:o(1,t)}),l(n,c,!1,!0),a[c]=s,n}},function(n,e,t){var r=t(4);n.exports=function(n){if(!r(n)&&null!==n)throw TypeError("Can't set "+String(n)+" as a prototype");return n}},function(n,e,t){"use strict";var r,i,o,l,a=t(0),s=t(31),c=t(2),d=t(26),u=t(136),p=t(13),m=t(205),h=t(67),g=t(66),f=t(191),v=t(4),y=t(28),b=t(206),x=t(91),w=t(207),E=t(141),j=t(97),z=t(142).set,T=t(208),S=t(144),k=t(210),I=t(145),A=t(211),_=t(36),V=t(84),N=t(3),L=t(212),B=t(69),P=t(38),C=N("species"),D="Promise",q=_.get,M=_.set,R=_.getterFor(D),J=u&&u.prototype,O=u,U=J,G=c.TypeError,F=c.document,Z=c.process,$=I.f,W=$,H=!!(F&&F.createEvent&&c.dispatchEvent),Y="function"==typeof PromiseRejectionEvent,X=!1,Q=V(D,(function(){var n=x(O),e=n!==String(O);if(!e&&66===P)return!0;if(s&&!U.finally)return!0;if(P>=51&&/native code/.test(n))return!1;var t=new O((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(t.constructor={})[C]=r,!(X=t.then((function(){}))instanceof r)||!e&&L&&!Y})),K=Q||!E((function(n){O.all(n).catch((function(){}))})),nn=function(n){var e;return!(!v(n)||"function"!=typeof(e=n.then))&&e},en=function(n,e){if(!n.notified){n.notified=!0;var t=n.reactions;T((function(){for(var r=n.value,i=1==n.state,o=0;t.length>o;){var l,a,s,c=t[o++],d=i?c.ok:c.fail,u=c.resolve,p=c.reject,m=c.domain;try{d?(i||(2===n.rejection&&ln(n),n.rejection=1),!0===d?l=r:(m&&m.enter(),l=d(r),m&&(m.exit(),s=!0)),l===c.promise?p(G("Promise-chain cycle")):(a=nn(l))?a.call(l,u,p):u(l)):p(r)}catch(n){m&&!s&&m.exit(),p(n)}}n.reactions=[],n.notified=!1,e&&!n.rejection&&rn(n)}))}},tn=function(n,e,t){var r,i;H?((r=F.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!Y&&(i=c["on"+n])?i(r):"unhandledrejection"===n&&k("Unhandled promise rejection",t)},rn=function(n){z.call(c,(function(){var e,t=n.facade,r=n.value;if(on(n)&&(e=A((function(){B?Z.emit("unhandledRejection",r,t):tn("unhandledrejection",t,r)})),n.rejection=B||on(n)?2:1,e.error))throw e.value}))},on=function(n){return 1!==n.rejection&&!n.parent},ln=function(n){z.call(c,(function(){var e=n.facade;B?Z.emit("rejectionHandled",e):tn("rejectionhandled",e,n.value)}))},an=function(n,e,t){return function(r){n(e,r,t)}},sn=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,en(n,!0))},cn=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw G("Promise can't be resolved itself");var r=nn(e);r?T((function(){var t={done:!1};try{r.call(e,an(cn,t,n),an(sn,t,n))}catch(e){sn(t,e,n)}})):(n.value=e,n.state=1,en(n,!1))}catch(e){sn({done:!1},e,n)}}};if(Q&&(U=(O=function(n){b(this,O,D),y(n),r.call(this);var e=q(this);try{n(an(cn,e),an(sn,e))}catch(n){sn(e,n)}}).prototype,(r=function(n){M(this,{type:D,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=m(U,{then:function(n,e){var t=R(this),r=$(j(this,O));return r.ok="function"!=typeof n||n,r.fail="function"==typeof e&&e,r.domain=B?Z.domain:void 0,t.parent=!0,t.reactions.push(r),0!=t.state&&en(t,!1),r.promise},catch:function(n){return this.then(void 0,n)}}),i=function(){var n=new r,e=q(n);this.promise=n,this.resolve=an(cn,e),this.reject=an(sn,e)},I.f=$=function(n){return n===O||n===o?new i(n):W(n)},!s&&"function"==typeof u&&J!==Object.prototype)){l=J.then,X||(p(J,"then",(function(n,e){var t=this;return new O((function(n,e){l.call(t,n,e)})).then(n,e)}),{unsafe:!0}),p(J,"catch",U.catch,{unsafe:!0}));try{delete J.constructor}catch(n){}h&&h(J,U)}a({global:!0,wrap:!0,forced:Q},{Promise:O}),g(O,D,!1,!0),f(D),o=d(D),a({target:D,stat:!0,forced:Q},{reject:function(n){var e=$(this);return e.reject.call(void 0,n),e.promise}}),a({target:D,stat:!0,forced:s||Q},{resolve:function(n){return S(s&&this===o?O:this,n)}}),a({target:D,stat:!0,forced:K},{all:function(n){var e=this,t=$(e),r=t.resolve,i=t.reject,o=A((function(){var t=y(e.resolve),o=[],l=0,a=1;w(n,(function(n){var s=l++,c=!1;o.push(void 0),a++,t.call(e,n).then((function(n){c||(c=!0,o[s]=n,--a||r(o))}),i)})),--a||r(o)}));return o.error&&i(o.value),t.promise},race:function(n){var e=this,t=$(e),r=t.reject,i=A((function(){var i=y(e.resolve);w(n,(function(n){i.call(e,n).then(t.resolve,r)}))}));return i.error&&r(i.value),t.promise}})},function(n,e,t){var r=t(13);n.exports=function(n,e,t){for(var i in e)r(n,i,e[i],t);return n}},function(n,e){n.exports=function(n,e,t){if(!(n instanceof e))throw TypeError("Incorrect "+(t?t+" ":"")+"invocation");return n}},function(n,e,t){var r=t(5),i=t(137),o=t(10),l=t(68),a=t(138),s=t(140),c=function(n,e){this.stopped=n,this.result=e};n.exports=function(n,e,t){var d,u,p,m,h,g,f,v=t&&t.that,y=!(!t||!t.AS_ENTRIES),b=!(!t||!t.IS_ITERATOR),x=!(!t||!t.INTERRUPTED),w=l(e,v,1+y+x),E=function(n){return d&&s(d),new c(!0,n)},j=function(n){return y?(r(n),x?w(n[0],n[1],E):w(n[0],n[1])):x?w(n,E):w(n)};if(b)d=n;else{if("function"!=typeof(u=a(n)))throw TypeError("Target is not iterable");if(i(u)){for(p=0,m=o(n.length);m>p;p++)if((h=j(n[p]))&&h instanceof c)return h;return new c(!1)}d=u.call(n)}for(g=d.next;!(f=g.call(d)).done;){try{h=j(f.value)}catch(n){throw s(d),n}if("object"==typeof h&&h&&h instanceof c)return h}return new c(!1)}},function(n,e,t){var r,i,o,l,a,s,c,d,u=t(2),p=t(27).f,m=t(142).set,h=t(143),g=t(209),f=t(69),v=u.MutationObserver||u.WebKitMutationObserver,y=u.document,b=u.process,x=u.Promise,w=p(u,"queueMicrotask"),E=w&&w.value;E||(r=function(){var n,e;for(f&&(n=b.domain)&&n.exit();i;){e=i.fn,i=i.next;try{e()}catch(n){throw i?l():o=void 0,n}}o=void 0,n&&n.enter()},h||f||g||!v||!y?x&&x.resolve?((c=x.resolve(void 0)).constructor=x,d=c.then,l=function(){d.call(c,r)}):l=f?function(){b.nextTick(r)}:function(){m.call(u,r)}:(a=!0,s=y.createTextNode(""),new v(r).observe(s,{characterData:!0}),l=function(){s.data=a=!a})),n.exports=E||function(n){var e={fn:n,next:void 0};o&&(o.next=e),i||(i=e,l()),o=e}},function(n,e,t){var r=t(25);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(2);n.exports=function(n,e){var t=r.console;t&&t.error&&(1===arguments.length?t.error(n):t.error(n,e))}},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e){n.exports="object"==typeof window},function(n,e,t){var r=t(0),i=t(214);r({target:"Object",stat:!0,forced:Object.assign!==i},{assign:i})},function(n,e,t){"use strict";var r=t(6),i=t(1),o=t(64),l=t(94),a=t(92),s=t(11),c=t(47),d=Object.assign,u=Object.defineProperty;n.exports=!d||i((function(){if(r&&1!==d({b:1},d(u({},"a",{enumerable:!0,get:function(){u(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=d({},n)[t]||"abcdefghijklmnopqrst"!=o(d({},e)).join("")}))?function(n,e){for(var t=s(n),i=arguments.length,d=1,u=l.f,p=a.f;i>d;)for(var m,h=c(arguments[d++]),g=u?o(h).concat(u(h)):o(h),f=g.length,v=0;f>v;)m=g[v++],r&&!p.call(h,m)||(t[m]=h[m]);return t}:d},function(n,e,t){"use strict";var r=t(0),i=t(31),o=t(136),l=t(1),a=t(26),s=t(97),c=t(144),d=t(13);if(r({target:"Promise",proto:!0,real:!0,forced:!!o&&l((function(){o.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=s(this,a("Promise")),t="function"==typeof n;return this.then(t?function(t){return c(e,n()).then((function(){return t}))}:n,t?function(t){return c(e,n()).then((function(){throw t}))}:n)}}),!i&&"function"==typeof o){var u=a("Promise").prototype.finally;o.prototype.finally!==u&&d(o.prototype,"finally",u,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(96),i=t(139);n.exports=r?{}.toString:function(){return"[object "+i(this)+"]"}},function(n,e,t){"use strict";var r=t(0),i=t(218).left,o=t(39),l=t(38),a=t(69);r({target:"Array",proto:!0,forced:!o("reduce")||!a&&l>79&&l<83},{reduce:function(n){return i(this,n,arguments.length,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(28),i=t(11),o=t(47),l=t(10),a=function(n){return function(e,t,a,s){r(t);var c=i(e),d=o(c),u=l(c.length),p=n?u-1:0,m=n?-1:1;if(a<2)for(;;){if(p in d){s=d[p],p+=m;break}if(p+=m,n?p<0:u<=p)throw TypeError("Reduce of empty array with no initial value")}for(;n?p>=0:u>p;p+=m)p in d&&(s=t(s,d[p],p,c));return s}};n.exports={left:a(!1),right:a(!0)}},function(n,e,t){var r=t(0),i=t(156),o=t(1),l=t(4),a=t(220).onFreeze,s=Object.freeze;r({target:"Object",stat:!0,forced:o((function(){s(1)})),sham:!i},{freeze:function(n){return s&&l(n)?s(a(n)):n}})},function(n,e,t){var r=t(51),i=t(4),o=t(9),l=t(8).f,a=t(63),s=t(156),c=a("meta"),d=0,u=Object.isExtensible||function(){return!0},p=function(n){l(n,c,{value:{objectID:"O"+d++,weakData:{}}})},m=n.exports={REQUIRED:!1,fastKey:function(n,e){if(!i(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!o(n,c)){if(!u(n))return"F";if(!e)return"E";p(n)}return n[c].objectID},getWeakData:function(n,e){if(!o(n,c)){if(!u(n))return!0;if(!e)return!1;p(n)}return n[c].weakData},onFreeze:function(n){return s&&m.REQUIRED&&u(n)&&!o(n,c)&&p(n),n}};r[c]=!0},function(n,e,t){var r=t(16),i=t(59).f,o={}.toString,l="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return l&&"[object Window]"==o.call(n)?function(n){try{return i(n)}catch(n){return l.slice()}}(n):i(r(n))}},function(n,e,t){"use strict";var r=t(68),i=t(11),o=t(223),l=t(137),a=t(10),s=t(70),c=t(138);n.exports=function(n){var e,t,d,u,p,m,h=i(n),g="function"==typeof this?this:Array,f=arguments.length,v=f>1?arguments[1]:void 0,y=void 0!==v,b=c(h),x=0;if(y&&(v=r(v,f>2?arguments[2]:void 0,2)),null==b||g==Array&&l(b))for(t=new g(e=a(h.length));e>x;x++)m=y?v(h[x],x):h[x],s(t,x,m);else for(p=(u=b.call(h)).next,t=new g;!(d=p.call(u)).done;x++)m=y?o(u,v,[d.value,x],!0):d.value,s(t,x,m);return t.length=x,t}},function(n,e,t){var r=t(5),i=t(140);n.exports=function(n,e,t,o){try{return o?e(r(t)[0],t[1]):e(t)}catch(e){throw i(n),e}}},function(n,e,t){var r=t(11),i=Math.floor,o="".replace,l=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,a=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,s,c,d){var u=t+n.length,p=s.length,m=a;return void 0!==c&&(c=r(c),m=l),o.call(d,m,(function(r,o){var l;switch(o.charAt(0)){case"$":return"$";case"&":return n;case"`":return e.slice(0,t);case"'":return e.slice(u);case"<":l=c[o.slice(1,-1)];break;default:var a=+o;if(0===a)return r;if(a>p){var d=i(a/10);return 0===d?r:d<=p?void 0===s[d-1]?o.charAt(1):s[d-1]+o.charAt(1):r}l=s[a-1]}return void 0===l?"":l}))}},function(n,e,t){var r=t(161),i=t(226);n.exports=function n(e,t,o,l,a){var s=-1,c=e.length;for(o||(o=i),a||(a=[]);++s<c;){var d=e[s];t>0&&o(d)?t>1?n(d,t-1,o,l,a):r(a,d):l||(a[a.length]=d)}return a}},function(n,e,t){var r=t(55),i=t(102),o=t(19),l=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||i(n)||!!(l&&n&&n[l])}},function(n,e,t){var r=t(46),i=t(37);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(55),i=Object.prototype,o=i.hasOwnProperty,l=i.toString,a=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,a),t=n[a];try{n[a]=void 0;var r=!0}catch(n){}var i=l.call(n);return r&&(e?n[a]=t:delete n[a]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(231),i=t(287),o=t(110),l=t(19),a=t(298);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?l(n)?i(n[0],n[1]):r(n):a(n)}},function(n,e,t){var r=t(232),i=t(286),o=t(178);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(163),i=t(167);n.exports=function(n,e,t,o){var l=t.length,a=l,s=!o;if(null==n)return!a;for(n=Object(n);l--;){var c=t[l];if(s&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++l<a;){var d=(c=t[l])[0],u=n[d],p=c[1];if(s&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new r;if(o)var h=o(u,p,d,n,e,m);if(!(void 0===h?i(p,u,3,o,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(75),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(75);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(75);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(75);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(74);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(74),i=t(103),o=t(105);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var l=t.__data__;if(!i||l.length<199)return l.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(l)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(165),i=t(244),o=t(104),l=t(166),a=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,d=s.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||i(n))&&(r(n)?p:a).test(l(n))}},function(n,e,t){var r,i=t(245),o=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(20)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(248),i=t(74),o=t(103);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||i),string:new r}}},function(n,e,t){var r=t(249),i=t(250),o=t(251),l=t(252),a=t(253);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=i,s.prototype.get=o,s.prototype.has=l,s.prototype.set=a,n.exports=s},function(n,e,t){var r=t(76);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(76),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(76),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(76);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(77);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(77);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(77);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(77);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(163),i=t(168),o=t(263),l=t(266),a=t(282),s=t(19),c=t(172),d=t(174),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var f=s(n),v=s(e),y=f?"[object Array]":a(n),b=v?"[object Array]":a(e),x=(y="[object Arguments]"==y?u:y)==u,w=(b="[object Arguments]"==b?u:b)==u,E=y==b;if(E&&c(n)){if(!c(e))return!1;f=!0,x=!1}if(E&&!x)return g||(g=new r),f||d(n)?i(n,e,t,m,h,g):o(n,e,y,t,m,h,g);if(!(1&t)){var j=x&&p.call(n,"__wrapped__"),z=w&&p.call(e,"__wrapped__");if(j||z){var T=j?n.value():n,S=z?e.value():e;return g||(g=new r),h(T,S,t,m,g)}}return!!E&&(g||(g=new r),l(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(55),i=t(264),o=t(164),l=t(168),a=t(265),s=t(106),c=r?r.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=a;case"[object Set]":var h=1&r;if(m||(m=s),n.size!=e.size&&!h)return!1;var g=p.get(n);if(g)return g==e;r|=2,p.set(n,e);var f=l(m(n),m(e),r,c,u,p);return p.delete(n),f;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var r=t(20).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(267),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,l,a){var s=1&t,c=r(n),d=c.length;if(d!=r(e).length&&!s)return!1;for(var u=d;u--;){var p=c[u];if(!(s?p in e:i.call(e,p)))return!1}var m=a.get(n),h=a.get(e);if(m&&h)return m==e&&h==n;var g=!0;a.set(n,e),a.set(e,n);for(var f=s;++u<d;){var v=n[p=c[u]],y=e[p];if(o)var b=s?o(y,v,p,e,n,a):o(v,y,p,n,e,a);if(!(void 0===b?v===y||l(v,y,t,o,a):b)){g=!1;break}f||(f="constructor"==p)}if(g&&!f){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(g=!1)}return a.delete(n),a.delete(e),g}},function(n,e,t){var r=t(268),i=t(269),o=t(171);n.exports=function(n){return r(n,o,i)}},function(n,e,t){var r=t(161),i=t(19);n.exports=function(n,e,t){var o=e(n);return i(n)?o:r(o,t(n))}},function(n,e,t){var r=t(270),i=t(271),o=Object.prototype.propertyIsEnumerable,l=Object.getOwnPropertySymbols,a=l?function(n){return null==n?[]:(n=Object(n),r(l(n),(function(e){return o.call(n,e)})))}:i;n.exports=a},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,o=[];++t<r;){var l=n[t];e(l,t,n)&&(o[i++]=l)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(273),i=t(102),o=t(19),l=t(172),a=t(173),s=t(174),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),d=!t&&i(n),u=!t&&!d&&l(n),p=!t&&!d&&!u&&s(n),m=t||d||u||p,h=m?r(n.length,String):[],g=h.length;for(var f in n)!e&&!c.call(n,f)||m&&("length"==f||u&&("offset"==f||"parent"==f)||p&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||a(f,g))||h.push(f);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(46),i=t(107),o=t(37),l={};l["[object Float32Array]"]=l["[object Float64Array]"]=l["[object Int8Array]"]=l["[object Int16Array]"]=l["[object Int32Array]"]=l["[object Uint8Array]"]=l["[object Uint8ClampedArray]"]=l["[object Uint16Array]"]=l["[object Uint32Array]"]=!0,l["[object Arguments]"]=l["[object Array]"]=l["[object ArrayBuffer]"]=l["[object Boolean]"]=l["[object DataView]"]=l["[object Date]"]=l["[object Error]"]=l["[object Function]"]=l["[object Map]"]=l["[object Number]"]=l["[object Object]"]=l["[object RegExp]"]=l["[object Set]"]=l["[object String]"]=l["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&i(n.length)&&!!l[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(162),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,l=o&&o.exports===i&&r.process,a=function(){try{var n=o&&o.require&&o.require("util").types;return n||l&&l.binding&&l.binding("util")}catch(n){}}();n.exports=a}).call(this,t(114)(n))},function(n,e,t){var r=t(279),i=t(280),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(281)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(283),i=t(103),o=t(284),l=t(176),a=t(285),s=t(46),c=t(166),d=c(r),u=c(i),p=c(o),m=c(l),h=c(a),g=s;(r&&"[object DataView]"!=g(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=g(new i)||o&&"[object Promise]"!=g(o.resolve())||l&&"[object Set]"!=g(new l)||a&&"[object WeakMap]"!=g(new a))&&(g=function(n){var e=s(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var r=t(33)(t(20),"DataView");n.exports=r},function(n,e,t){var r=t(33)(t(20),"Promise");n.exports=r},function(n,e,t){var r=t(33)(t(20),"WeakMap");n.exports=r},function(n,e,t){var r=t(177),i=t(171);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var o=e[t],l=n[o];e[t]=[o,l,r(l)]}return e}},function(n,e,t){var r=t(167),i=t(288),o=t(295),l=t(108),a=t(177),s=t(178),c=t(78);n.exports=function(n,e){return l(n)&&a(e)?s(c(n),e):function(t){var l=i(t,n);return void 0===l&&l===e?o(t,n):r(e,l,3)}}},function(n,e,t){var r=t(179);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(290),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,l=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(o,"$1"):t||n)})),e}));n.exports=l},function(n,e,t){var r=t(291);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(105);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],o=t.cache;if(o.has(i))return o.get(i);var l=n.apply(this,r);return t.cache=o.set(i,l)||o,l};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(293);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(55),i=t(294),o=t(19),l=t(109),a=r?r.prototype:void 0,s=a?a.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return i(e,n)+"";if(l(e))return s?s.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(296),i=t(297);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(180),i=t(102),o=t(19),l=t(173),a=t(107),s=t(78);n.exports=function(n,e,t){for(var c=-1,d=(e=r(e,n)).length,u=!1;++c<d;){var p=s(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&a(d)&&l(p,d)&&(o(n)||i(n))}},function(n,e,t){var r=t(299),i=t(300),o=t(108),l=t(78);n.exports=function(n){return o(n)?r(l(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(179);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(110),i=t(302),o=t(304);n.exports=function(n,e){return o(i(n,e,r),n+"")}},function(n,e,t){var r=t(303),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var o=arguments,l=-1,a=i(o.length-e,0),s=Array(a);++l<a;)s[l]=o[e+l];l=-1;for(var c=Array(e+1);++l<e;)c[l]=o[l];return c[e]=t(s),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(305),i=t(308)(r);n.exports=i},function(n,e,t){var r=t(306),i=t(307),o=t(110),l=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=l},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(33),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),o=16-(i-r);if(r=i,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(169),i=t(310),o=t(315),l=t(170),a=t(316),s=t(106);n.exports=function(n,e,t){var c=-1,d=i,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=o;else if(u>=200){var g=e?null:a(n);if(g)return s(g);p=!1,d=l,h=new r}else h=e?[]:m;n:for(;++c<u;){var f=n[c],v=e?e(f):f;if(f=t||0!==f?f:0,p&&v==v){for(var y=h.length;y--;)if(h[y]===v)continue n;e&&h.push(v),m.push(f)}else d(h,v,t)||(h!==m&&h.push(v),m.push(f))}return m}},function(n,e,t){var r=t(311);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(312),i=t(313),o=t(314);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,o=t+(r?1:-1);r?o--:++o<i;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(176),i=t(317),o=t(106),l=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=l},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(175),i=t(37);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(1),i=t(122);n.exports=function(n){return r((function(){return!!i[n]()||"​᠎"!="​᠎"[n]()||i[n].name!==n}))}},function(n,e,t){t(0)({target:"Function",proto:!0},{bind:t(181)})},function(n,e,t){"use strict";var r=t(50),i=t(12);n.exports=function(n){var e=String(i(this)),t="",o=r(n);if(o<0||o==1/0)throw RangeError("Wrong number of repetitions");for(;o>0;(o>>>=1)&&(e+=e))1&o&&(t+=e);return t}},function(n,e,t){var r=t(25);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(r)},function(n,e,t){"use strict";var r=t(0),i=t(28),o=t(11),l=t(10),a=t(1),s=t(326),c=t(39),d=t(327),u=t(328),p=t(38),m=t(329),h=[],g=h.sort,f=a((function(){h.sort(void 0)})),v=a((function(){h.sort(null)})),y=c("sort"),b=!a((function(){if(p)return p<70;if(!(d&&d>3)){if(u)return!0;if(m)return m<603;var n,e,t,r,i="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(r=0;r<47;r++)h.push({k:e+r,v:t})}for(h.sort((function(n,e){return e.v-n.v})),r=0;r<h.length;r++)e=h[r].k.charAt(0),i.charAt(i.length-1)!==e&&(i+=e);return"DGBEFHACIJK"!==i}}));r({target:"Array",proto:!0,forced:f||!v||!y||!b},{sort:function(n){void 0!==n&&i(n);var e=o(this);if(b)return void 0===n?g.call(e):g.call(e,n);var t,r,a=[],c=l(e.length);for(r=0;r<c;r++)r in e&&a.push(e[r]);for(t=(a=s(a,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:String(e)>String(t)?1:-1}}(n))).length,r=0;r<t;)e[r]=a[r++];for(;r<c;)delete e[r++];return e}})},function(n,e){var t=Math.floor,r=function(n,e){var l=n.length,a=t(l/2);return l<8?i(n,e):o(r(n.slice(0,a),e),r(n.slice(a),e),e)},i=function(n,e){for(var t,r,i=n.length,o=1;o<i;){for(r=o,t=n[o];r&&e(n[r-1],t)>0;)n[r]=n[--r];r!==o++&&(n[r]=t)}return n},o=function(n,e,t){for(var r=n.length,i=e.length,o=0,l=0,a=[];o<r||l<i;)o<r&&l<i?a.push(t(n[o],e[l])<=0?n[o++]:e[l++]):a.push(o<r?n[o++]:e[l++]);return a};n.exports=r},function(n,e,t){var r=t(25).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,e,t){var r=t(25);n.exports=/MSIE|Trident/.test(r)},function(n,e,t){var r=t(25).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(0),i=t(1),o=t(16),l=t(27).f,a=t(6),s=i((function(){l(1)}));r({target:"Object",stat:!0,forced:!a||s,sham:!a},{getOwnPropertyDescriptor:function(n,e){return l(o(n),e)}})},function(n,e,t){var r=t(0),i=t(6);r({target:"Object",stat:!0,forced:!i,sham:!i},{defineProperties:t(128)})},function(n,e,t){t(0)({target:"Reflect",stat:!0},{ownKeys:t(93)})},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var i=n[r];"."===i?n.splice(r,1):".."===i?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,i=arguments.length-1;i>=-1&&!e;i--){var o=i>=0?arguments[i]:process.cwd();if("string"!=typeof o)throw new TypeError("Arguments to path.resolve must be strings");o&&(n=o+"/"+n,e="/"===o.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var o=e.isAbsolute(n),l="/"===i(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!o).join("/"))||o||(n="."),n&&l&&(n+="/"),(o?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var i=r(n.split("/")),o=r(t.split("/")),l=Math.min(i.length,o.length),a=l,s=0;s<l;s++)if(i[s]!==o[s]){a=s;break}var c=[];for(s=a;s<i.length;s++)c.push("..");return(c=c.concat(o.slice(a))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,i=!0,o=n.length-1;o>=1;--o)if(47===(e=n.charCodeAt(o))){if(!i){r=o;break}}else i=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,i=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!i){t=e+1;break}}else-1===r&&(i=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,i=!0,o=0,l=n.length-1;l>=0;--l){var a=n.charCodeAt(l);if(47!==a)-1===r&&(i=!1,r=l+1),46===a?-1===e?e=l:1!==o&&(o=1):-1!==e&&(o=-1);else if(!i){t=l+1;break}}return-1===e||-1===r||0===o||1===o&&e===r-1&&e===t+1?"":n.slice(e,r)};var i="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},o=/[&<>'"]/g;function l(n){return i[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(o,l)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var i=t[r];void 0!==e[i]&&(n[i]=e[i])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(185)},function(n,e,t){"use strict";t(186)},function(n,e,t){"use strict";t.r(e);t(124),t(204),t(213),t(215),t(7);function r(n,e,t,r,i,o,l){try{var a=n[o](l),s=a.value}catch(n){return void t(n)}a.done?e(s):Promise.resolve(s).then(r,i)}function i(n){return function(){var e=this,t=arguments;return new Promise((function(i,o){var l=n.apply(e,t);function a(n){r(l,i,o,a,s,"next",n)}function s(n){r(l,i,o,a,s,"throw",n)}a(void 0)}))}}t(146),t(34),t(14),t(17),t(44),t(22);var o=Object.freeze({});function l(n){return null==n}function a(n){return null!=n}function s(n){return!0===n}function c(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return a(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function y(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}y("slot,component",!0);var b=y("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var w=Object.prototype.hasOwnProperty;function E(n,e){return w.call(n,e)}function j(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var z=/-(\w)/g,T=j((function(n){return n.replace(z,(function(n,e){return e?e.toUpperCase():""}))})),S=j((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),k=/\B([A-Z])/g,I=j((function(n){return n.replace(k,"-$1").toLowerCase()}));var A=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function _(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function V(n,e){for(var t in e)n[t]=e[t];return n}function N(n){for(var e={},t=0;t<n.length;t++)n[t]&&V(e,n[t]);return e}function L(n,e,t){}var B=function(n,e,t){return!1},P=function(n){return n};function C(n,e){if(n===e)return!0;var t=d(n),r=d(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),o=Array.isArray(e);if(i&&o)return n.length===e.length&&n.every((function(n,t){return C(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||o)return!1;var l=Object.keys(n),a=Object.keys(e);return l.length===a.length&&l.every((function(t){return C(n[t],e[t])}))}catch(n){return!1}}function D(n,e){for(var t=0;t<n.length;t++)if(C(n[t],e))return t;return-1}function q(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var M=["component","directive","filter"],R=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],J={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:B,isReservedAttr:B,isUnknownElement:B,getTagNamespace:L,parsePlatformTagName:P,mustUseProp:B,async:!0,_lifecycleHooks:R},O=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function U(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var G=new RegExp("[^"+O.source+".$_\\d]");var F,Z="__proto__"in{},$="undefined"!=typeof window,W="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,H=W&&WXEnvironment.platform.toLowerCase(),Y=$&&window.navigator.userAgent.toLowerCase(),X=Y&&/msie|trident/.test(Y),Q=Y&&Y.indexOf("msie 9.0")>0,K=Y&&Y.indexOf("edge/")>0,nn=(Y&&Y.indexOf("android"),Y&&/iphone|ipad|ipod|ios/.test(Y)||"ios"===H),en=(Y&&/chrome\/\d+/.test(Y),Y&&/phantomjs/.test(Y),Y&&Y.match(/firefox\/(\d+)/)),tn={}.watch,rn=!1;if($)try{var on={};Object.defineProperty(on,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var ln=function(){return void 0===F&&(F=!$&&!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),F},an=$&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function sn(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&sn(Symbol)&&"undefined"!=typeof Reflect&&sn(Reflect.ownKeys);cn="undefined"!=typeof Set&&sn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=L,pn=0,mn=function(){this.id=pn++,this.subs=[]};mn.prototype.addSub=function(n){this.subs.push(n)},mn.prototype.removeSub=function(n){x(this.subs,n)},mn.prototype.depend=function(){mn.target&&mn.target.addDep(this)},mn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},mn.target=null;var hn=[];function gn(n){hn.push(n),mn.target=n}function fn(){hn.pop(),mn.target=hn[hn.length-1]}var vn=function(n,e,t,r,i,o,l,a){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=l,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=a,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},yn={child:{configurable:!0}};yn.child.get=function(){return this.componentInstance},Object.defineProperties(vn.prototype,yn);var bn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function xn(n){return new vn(void 0,void 0,void 0,String(n))}function wn(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var En=Array.prototype,jn=Object.create(En);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=En[n];U(jn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var i,o=e.apply(this,t),l=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&l.observeArray(i),l.dep.notify(),o}))}));var zn=Object.getOwnPropertyNames(jn),Tn=!0;function Sn(n){Tn=n}var kn=function(n){this.value=n,this.dep=new mn,this.vmCount=0,U(n,"__ob__",this),Array.isArray(n)?(Z?function(n,e){n.__proto__=e}(n,jn):function(n,e,t){for(var r=0,i=t.length;r<i;r++){var o=t[r];U(n,o,e[o])}}(n,jn,zn),this.observeArray(n)):this.walk(n)};function In(n,e){var t;if(d(n)&&!(n instanceof vn))return E(n,"__ob__")&&n.__ob__ instanceof kn?t=n.__ob__:Tn&&!ln()&&(Array.isArray(n)||p(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new kn(n)),e&&t&&t.vmCount++,t}function An(n,e,t,r,i){var o=new mn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var a=l&&l.get,s=l&&l.set;a&&!s||2!==arguments.length||(t=n[e]);var c=!i&&In(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=a?a.call(n):t;return mn.target&&(o.depend(),c&&(c.dep.depend(),Array.isArray(e)&&Nn(e))),e},set:function(e){var r=a?a.call(n):t;e===r||e!=e&&r!=r||a&&!s||(s?s.call(n,e):t=e,c=!i&&In(e),o.notify())}})}}function _n(n,e,t){if(Array.isArray(n)&&h(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(An(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function Vn(n,e){if(Array.isArray(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||E(n,e)&&(delete n[e],t&&t.dep.notify())}}function Nn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&Nn(e)}kn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)An(n,e[t])},kn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)In(n[e])};var Ln=J.optionMergeStrategies;function Bn(n,e){if(!e)return n;for(var t,r,i,o=dn?Reflect.ownKeys(e):Object.keys(e),l=0;l<o.length;l++)"__ob__"!==(t=o[l])&&(r=n[t],i=e[t],E(n,t)?r!==i&&p(r)&&p(i)&&Bn(r,i):_n(n,t,i));return n}function Pn(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,i="function"==typeof n?n.call(t,t):n;return r?Bn(r,i):i}:e?n?function(){return Bn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Cn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Dn(n,e,t,r){var i=Object.create(n||null);return e?V(i,e):i}Ln.data=function(n,e,t){return t?Pn(n,e,t):e&&"function"!=typeof e?n:Pn(n,e)},R.forEach((function(n){Ln[n]=Cn})),M.forEach((function(n){Ln[n+"s"]=Dn})),Ln.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in V(i,n),e){var l=i[o],a=e[o];l&&!Array.isArray(l)&&(l=[l]),i[o]=l?l.concat(a):Array.isArray(a)?a:[a]}return i},Ln.props=Ln.methods=Ln.inject=Ln.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return V(i,n),e&&V(i,e),i},Ln.provide=Pn;var qn=function(n,e){return void 0===e?n:e};function Mn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,i,o={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(i=t[r])&&(o[T(i)]={type:null});else if(p(t))for(var l in t)i=t[l],o[T(l)]=p(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var i=0;i<t.length;i++)r[t[i]]={from:t[i]};else if(p(t))for(var o in t){var l=t[o];r[o]=p(l)?V({from:o},l):{from:l}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Mn(n,e.extends,t)),e.mixins))for(var r=0,i=e.mixins.length;r<i;r++)n=Mn(n,e.mixins[r],t);var o,l={};for(o in n)a(o);for(o in e)E(n,o)||a(o);function a(r){var i=Ln[r]||qn;l[r]=i(n[r],e[r],t,r)}return l}function Rn(n,e,t,r){if("string"==typeof t){var i=n[e];if(E(i,t))return i[t];var o=T(t);if(E(i,o))return i[o];var l=S(o);return E(i,l)?i[l]:i[t]||i[o]||i[l]}}function Jn(n,e,t,r){var i=e[n],o=!E(t,n),l=t[n],a=Fn(Boolean,i.type);if(a>-1)if(o&&!E(i,"default"))l=!1;else if(""===l||l===I(n)){var s=Fn(String,i.type);(s<0||a<s)&&(l=!0)}if(void 0===l){l=function(n,e,t){if(!E(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Un(e.type)?r.call(n):r}(r,i,n);var c=Tn;Sn(!0),In(l),Sn(c)}return l}var On=/^\s*function (\w+)/;function Un(n){var e=n&&n.toString().match(On);return e?e[1]:""}function Gn(n,e){return Un(n)===Un(e)}function Fn(n,e){if(!Array.isArray(e))return Gn(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Gn(e[t],n))return t;return-1}function Zn(n,e,t){gn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var o=0;o<i.length;o++)try{if(!1===i[o].call(r,n,e,t))return}catch(n){Wn(n,r,"errorCaptured hook")}}Wn(n,e,t)}finally{fn()}}function $n(n,e,t,r,i){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&g(o)&&!o._handled&&(o.catch((function(n){return Zn(n,r,i+" (Promise/async)")})),o._handled=!0)}catch(n){Zn(n,r,i)}return o}function Wn(n,e,t){if(J.errorHandler)try{return J.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Hn(e,null,"config.errorHandler")}Hn(n,e,t)}function Hn(n,e,t){if(!$&&!W||"undefined"==typeof console)throw n;console.error(n)}var Yn,Xn=!1,Qn=[],Kn=!1;function ne(){Kn=!1;var n=Qn.slice(0);Qn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&sn(Promise)){var ee=Promise.resolve();Yn=function(){ee.then(ne),nn&&setTimeout(L)},Xn=!0}else if(X||"undefined"==typeof MutationObserver||!sn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Yn="undefined"!=typeof setImmediate&&sn(setImmediate)?function(){setImmediate(ne)}:function(){setTimeout(ne,0)};else{var te=1,re=new MutationObserver(ne),ie=document.createTextNode(String(te));re.observe(ie,{characterData:!0}),Yn=function(){te=(te+1)%2,ie.data=String(te)},Xn=!0}function oe(n,e){var t;if(Qn.push((function(){if(n)try{n.call(e)}catch(n){Zn(n,e,"nextTick")}else t&&t(e)})),Kn||(Kn=!0,Yn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var le=new cn;function ae(n){!function n(e,t){var r,i,o=Array.isArray(e);if(!o&&!d(e)||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var l=e.__ob__.dep.id;if(t.has(l))return;t.add(l)}if(o)for(r=e.length;r--;)n(e[r],t);else for(i=Object.keys(e),r=i.length;r--;)n(e[i[r]],t)}(n,le),le.clear()}var se=j((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function ce(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return $n(r,null,arguments,e,"v-on handler");for(var i=r.slice(),o=0;o<i.length;o++)$n(i[o],null,n,e,"v-on handler")}return t.fns=n,t}function de(n,e,t,r,i,o){var a,c,d,u;for(a in n)c=n[a],d=e[a],u=se(a),l(c)||(l(d)?(l(c.fns)&&(c=n[a]=ce(c,o)),s(u.once)&&(c=n[a]=i(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[a]=d));for(a in e)l(n[a])&&r((u=se(a)).name,e[a],u.capture)}function ue(n,e,t){var r;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function o(){t.apply(this,arguments),x(r.fns,o)}l(i)?r=ce([o]):a(i.fns)&&s(i.merged)?(r=i).fns.push(o):r=ce([i,o]),r.merged=!0,n[e]=r}function pe(n,e,t,r,i){if(a(e)){if(E(e,t))return n[t]=e[t],i||delete e[t],!0;if(E(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function me(n){return c(n)?[xn(n)]:Array.isArray(n)?function n(e,t){var r,i,o,d,u=[];for(r=0;r<e.length;r++)l(i=e[r])||"boolean"==typeof i||(o=u.length-1,d=u[o],Array.isArray(i)?i.length>0&&(he((i=n(i,(t||"")+"_"+r))[0])&&he(d)&&(u[o]=xn(d.text+i[0].text),i.shift()),u.push.apply(u,i)):c(i)?he(d)?u[o]=xn(d.text+i):""!==i&&u.push(xn(i)):he(i)&&he(d)?u[o]=xn(d.text+i.text):(s(e._isVList)&&a(i.tag)&&l(i.key)&&a(t)&&(i.key="__vlist"+t+"_"+r+"__"),u.push(i)));return u}(n):void 0}function he(n){return a(n)&&a(n.text)&&!1===n.isComment}function ge(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var o=r[i];if("__ob__"!==o){for(var l=n[o].from,a=e;a;){if(a._provided&&E(a._provided,l)){t[o]=a._provided[l];break}a=a.$parent}if(!a)if("default"in n[o]){var s=n[o].default;t[o]="function"==typeof s?s.call(e):s}else 0}}return t}}function fe(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var o=n[r],l=o.data;if(l&&l.attrs&&l.attrs.slot&&delete l.attrs.slot,o.context!==e&&o.fnContext!==e||!l||null==l.slot)(t.default||(t.default=[])).push(o);else{var a=l.slot,s=t[a]||(t[a]=[]);"template"===o.tag?s.push.apply(s,o.children||[]):s.push(o)}}for(var c in t)t[c].every(ve)&&delete t[c];return t}function ve(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ye(n){return n.isComment&&n.asyncFactory}function be(n,e,t){var r,i=Object.keys(e).length>0,l=n?!!n.$stable:!i,a=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(l&&t&&t!==o&&a===t.$key&&!i&&!t.$hasNormal)return t;for(var s in r={},n)n[s]&&"$"!==s[0]&&(r[s]=xe(e,s,n[s]))}else r={};for(var c in e)c in r||(r[c]=we(e,c));return n&&Object.isExtensible(n)&&(n._normalized=r),U(r,"$stable",l),U(r,"$key",a),U(r,"$hasNormal",i),r}function xe(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:me(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ye(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function we(n,e){return function(){return n[e]}}function Ee(n,e){var t,r,i,o,l;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,i=n.length;r<i;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(d(n))if(dn&&n[Symbol.iterator]){t=[];for(var s=n[Symbol.iterator](),c=s.next();!c.done;)t.push(e(c.value,t.length)),c=s.next()}else for(o=Object.keys(n),t=new Array(o.length),r=0,i=o.length;r<i;r++)l=o[r],t[r]=e(n[l],l,r);return a(t)||(t=[]),t._isVList=!0,t}function je(n,e,t,r){var i,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=V(V({},r),t)),i=o(t)||("function"==typeof e?e():e)):i=this.$slots[n]||("function"==typeof e?e():e);var l=t&&t.slot;return l?this.$createElement("template",{slot:l},i):i}function ze(n){return Rn(this.$options,"filters",n)||P}function Te(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Se(n,e,t,r,i){var o=J.keyCodes[e]||t;return i&&r&&!J.keyCodes[e]?Te(i,r):o?Te(o,n):r?I(r)!==e:void 0===n}function ke(n,e,t,r,i){if(t)if(d(t)){var o;Array.isArray(t)&&(t=N(t));var l=function(l){if("class"===l||"style"===l||b(l))o=n;else{var a=n.attrs&&n.attrs.type;o=r||J.mustUseProp(e,a,l)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var s=T(l),c=I(l);s in o||c in o||(o[l]=t[l],i&&((n.on||(n.on={}))["update:"+l]=function(n){t[l]=n}))};for(var a in t)l(a)}else;return n}function Ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||_e(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Ae(n,e,t){return _e(n,"__once__"+e+(t?"_"+t:""),!0),n}function _e(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Ve(n[r],e+"_"+r,t);else Ve(n,e,t)}function Ve(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ne(n,e){if(e)if(p(e)){var t=n.on=n.on?V({},n.on):{};for(var r in e){var i=t[r],o=e[r];t[r]=i?[].concat(i,o):o}}else;return n}function Le(n,e,t,r){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];Array.isArray(o)?Le(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function Be(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Pe(n,e){return"string"==typeof n?e+n:n}function Ce(n){n._o=Ae,n._n=v,n._s=f,n._l=Ee,n._t=je,n._q=C,n._i=D,n._m=Ie,n._f=ze,n._k=Se,n._b=ke,n._v=xn,n._e=bn,n._u=Le,n._g=Ne,n._d=Be,n._p=Pe}function De(n,e,t,r,i){var l,a=this,c=i.options;E(r,"_uid")?(l=Object.create(r))._original=r:(l=r,r=r._original);var d=s(c._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||o,this.injections=ge(c.inject,r),this.slots=function(){return a.$slots||be(n.scopedSlots,a.$slots=fe(t,r)),a.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(n.scopedSlots,this.slots())}}),d&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=be(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,i){var o=Ge(l,n,e,t,i,u);return o&&!Array.isArray(o)&&(o.fnScopeId=c._scopeId,o.fnContext=r),o}:this._c=function(n,e,t,r){return Ge(l,n,e,t,r,u)}}function qe(n,e,t,r,i){var o=wn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function Me(n,e){for(var t in e)n[T(t)]=e[t]}Ce(De.prototype);var Re={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Re.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;a(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){0;var l=r.data.scopedSlots,a=n.$scopedSlots,s=!!(l&&!l.$stable||a!==o&&!a.$stable||l&&n.$scopedSlots.$key!==l.$key||!l&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||s);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=i,n.$attrs=r.data.attrs||o,n.$listeners=t||o,e&&n.$options.props){Sn(!1);for(var d=n._props,u=n.$options._propKeys||[],p=0;p<u.length;p++){var m=u[p],h=n.$options.props;d[m]=Jn(m,h,e,n)}Sn(!0),n.$options.propsData=e}t=t||o;var g=n.$options._parentListeners;n.$options._parentListeners=t,Qe(n,t,g),c&&(n.$slots=fe(i,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,rt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,ot.push(e)):tt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,et(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);rt(e,"deactivated")}}(e,!0):e.$destroy())}},Je=Object.keys(Re);function Oe(n,e,t,r,i){if(!l(n)){var c=t.$options._base;if(d(n)&&(n=c.extend(n)),"function"==typeof n){var u;if(l(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&a(n.errorComp))return n.errorComp;if(a(n.resolved))return n.resolved;var t=Ze;t&&a(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(s(n.loading)&&a(n.loadingComp))return n.loadingComp;if(t&&!a(n.owners)){var r=n.owners=[t],i=!0,o=null,c=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==o&&(clearTimeout(o),o=null),null!==c&&(clearTimeout(c),c=null))},p=q((function(t){n.resolved=$e(t,e),i?r.length=0:u(!0)})),m=q((function(e){a(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return d(h)&&(g(h)?l(n.resolved)&&h.then(p,m):g(h.component)&&(h.component.then(p,m),a(h.error)&&(n.errorComp=$e(h.error,e)),a(h.loading)&&(n.loadingComp=$e(h.loading,e),0===h.delay?n.loading=!0:o=setTimeout((function(){o=null,l(n.resolved)&&l(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),a(h.timeout)&&(c=setTimeout((function(){c=null,l(n.resolved)&&m(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(u=n,c)))return function(n,e,t,r,i){var o=bn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:i},o}(u,e,t,r,i);e=e||{},Tt(n),a(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),o=i[r],l=e.model.callback;a(o)?(Array.isArray(o)?-1===o.indexOf(l):o!==l)&&(i[r]=[l].concat(o)):i[r]=l}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!l(r)){var i={},o=n.attrs,s=n.props;if(a(o)||a(s))for(var c in r){var d=I(c);pe(i,s,c,d,!0)||pe(i,o,c,d,!1)}return i}}(e,n);if(s(n.options.functional))return function(n,e,t,r,i){var l=n.options,s={},c=l.props;if(a(c))for(var d in c)s[d]=Jn(d,c,e||o);else a(t.attrs)&&Me(s,t.attrs),a(t.props)&&Me(s,t.props);var u=new De(t,s,i,r,n),p=l.render.call(null,u._c,u);if(p instanceof vn)return qe(p,t,u.parent,l,u);if(Array.isArray(p)){for(var m=me(p)||[],h=new Array(m.length),g=0;g<m.length;g++)h[g]=qe(m[g],t,u.parent,l,u);return h}}(n,p,e,t,r);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var h=e.slot;e={},h&&(e.slot=h)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Je.length;t++){var r=Je[t],i=e[r],o=Re[r];i===o||i&&i._merged||(e[r]=i?Ue(o,i):o)}}(e);var f=n.options.name||i;return new vn("vue-component-"+n.cid+(f?"-"+f:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:m,tag:i,children:r},u)}}}function Ue(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Ge(n,e,t,r,i,o){return(Array.isArray(t)||c(t))&&(i=r,r=t,t=void 0),s(o)&&(i=2),function(n,e,t,r,i){if(a(t)&&a(t.__ob__))return bn();a(t)&&a(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===i?r=me(r):1===i&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var o,c;if("string"==typeof e){var u;c=n.$vnode&&n.$vnode.ns||J.getTagNamespace(e),o=J.isReservedTag(e)?new vn(J.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!a(u=Rn(n.$options,"components",e))?new vn(e,t,r,void 0,void 0,n):Oe(u,t,n,r,e)}else o=Oe(e,t,n,r);return Array.isArray(o)?o:a(o)?(a(c)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(a(e.children))for(var i=0,o=e.children.length;i<o;i++){var c=e.children[i];a(c.tag)&&(l(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(o,c),a(t)&&function(n){d(n.style)&&ae(n.style);d(n.class)&&ae(n.class)}(t),o):bn()}(n,e,t,r,i)}var Fe,Ze=null;function $e(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function We(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(a(t)&&(a(t.componentOptions)||ye(t)))return t}}function He(n,e){Fe.$on(n,e)}function Ye(n,e){Fe.$off(n,e)}function Xe(n,e){var t=Fe;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function Qe(n,e,t){Fe=n,de(e,t||{},He,Ye,Xe,n),Fe=void 0}var Ke=null;function nt(n){var e=Ke;return Ke=n,function(){Ke=e}}function et(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function tt(n,e){if(e){if(n._directInactive=!1,et(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)tt(n.$children[t]);rt(n,"activated")}}function rt(n,e){gn();var t=n.$options[e],r=e+" hook";if(t)for(var i=0,o=t.length;i<o;i++)$n(t[i],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),fn()}var it=[],ot=[],lt={},at=!1,st=!1,ct=0;var dt=0,ut=Date.now;if($&&!X){var pt=window.performance;pt&&"function"==typeof pt.now&&ut()>document.createEvent("Event").timeStamp&&(ut=function(){return pt.now()})}function mt(){var n,e;for(dt=ut(),st=!0,it.sort((function(n,e){return n.id-e.id})),ct=0;ct<it.length;ct++)(n=it[ct]).before&&n.before(),e=n.id,lt[e]=null,n.run();var t=ot.slice(),r=it.slice();ct=it.length=ot.length=0,lt={},at=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,tt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&rt(r,"updated")}}(r),an&&J.devtools&&an.emit("flush")}var ht=0,gt=function(n,e,t,r,i){this.vm=n,i&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++ht,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=L)),this.value=this.lazy?void 0:this.get()};gt.prototype.get=function(){var n;gn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Zn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ae(n),fn(),this.cleanupDeps()}return n},gt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},gt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},gt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==lt[e]){if(lt[e]=!0,st){for(var t=it.length-1;t>ct&&it[t].id>n.id;)t--;it.splice(t+1,0,n)}else it.push(n);at||(at=!0,oe(mt))}}(this)},gt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';$n(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},gt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},gt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},gt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||x(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ft={enumerable:!0,configurable:!0,get:L,set:L};function vt(n,e,t){ft.get=function(){return this[e][t]},ft.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ft)}function yt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},i=n.$options._propKeys=[];n.$parent&&Sn(!1);var o=function(o){i.push(o);var l=Jn(o,e,t,n);An(r,o,l),o in n||vt(n,"_props",o)};for(var l in e)o(l);Sn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?L:A(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;p(e=n._data="function"==typeof e?function(n,e){gn();try{return n.call(e,e)}catch(n){return Zn(n,e,"data()"),{}}finally{fn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var o=t[i];0,r&&E(r,o)||(l=void 0,36!==(l=(o+"").charCodeAt(0))&&95!==l&&vt(n,"_data",o))}var l;In(e,!0)}(n):In(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=ln();for(var i in e){var o=e[i],l="function"==typeof o?o:o.get;0,r||(t[i]=new gt(n,l||L,L,bt)),i in n||xt(n,i,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var i=0;i<r.length;i++)jt(n,t,r[i]);else jt(n,t,r)}}(n,e.watch)}var bt={lazy:!0};function xt(n,e,t){var r=!ln();"function"==typeof t?(ft.get=r?wt(e):Et(t),ft.set=L):(ft.get=t.get?r&&!1!==t.cache?wt(e):Et(t.get):L,ft.set=t.set||L),Object.defineProperty(n,e,ft)}function wt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),mn.target&&e.depend(),e.value}}function Et(n){return function(){return n.call(this,this)}}function jt(n,e,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var zt=0;function Tt(n){var e=n.options;if(n.super){var t=Tt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&V(n.extendOptions,r),(e=n.options=Mn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function St(n){this._init(n)}function kt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var o=n.name||t.options.name;var l=function(n){this._init(n)};return(l.prototype=Object.create(t.prototype)).constructor=l,l.cid=e++,l.options=Mn(t.options,n),l.super=t,l.options.props&&function(n){var e=n.options.props;for(var t in e)vt(n.prototype,"_props",t)}(l),l.options.computed&&function(n){var e=n.options.computed;for(var t in e)xt(n.prototype,t,e[t])}(l),l.extend=t.extend,l.mixin=t.mixin,l.use=t.use,M.forEach((function(n){l[n]=t[n]})),o&&(l.options.components[o]=l),l.superOptions=t.options,l.extendOptions=n,l.sealedOptions=V({},l.options),i[r]=l,l}}function It(n){return n&&(n.Ctor.options.name||n.tag)}function At(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function _t(n,e){var t=n.cache,r=n.keys,i=n._vnode;for(var o in t){var l=t[o];if(l){var a=l.name;a&&!e(a)&&Vt(t,o,r,i)}}}function Vt(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=zt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Mn(Tt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=fe(e._renderChildren,r),n.$scopedSlots=o,n._c=function(e,t,r,i){return Ge(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return Ge(n,e,t,r,i,!0)};var i=t&&t.data;An(n,"$attrs",i&&i.attrs||o,null,!0),An(n,"$listeners",e._parentListeners||o,null,!0)}(e),rt(e,"beforeCreate"),function(n){var e=ge(n.$options.inject,n);e&&(Sn(!1),Object.keys(e).forEach((function(t){An(n,t,e[t])})),Sn(!0))}(e),yt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),rt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(St),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=_n,n.prototype.$delete=Vn,n.prototype.$watch=function(n,e,t){if(p(e))return jt(this,n,e,t);(t=t||{}).user=!0;var r=new gt(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'+r.expression+'"';gn(),$n(e,this,[r.value],this,i),fn()}return function(){r.teardown()}}}(St),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var i=0,o=n.length;i<o;i++)r.$on(n[i],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,i=n.length;r<i;r++)t.$off(n[r],e);return t}var o,l=t._events[n];if(!l)return t;if(!e)return t._events[n]=null,t;for(var a=l.length;a--;)if((o=l[a])===e||o.fn===e){l.splice(a,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?_(t):t;for(var r=_(arguments,1),i='event handler for "'+n+'"',o=0,l=t.length;o<l;o++)$n(t[o],e,r,e,i)}return e}}(St),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,o=nt(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){rt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),rt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(St),function(n){Ce(n.prototype),n.prototype.$nextTick=function(n){return oe(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,i=t._parentVnode;i&&(e.$scopedSlots=be(i.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=i;try{Ze=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Zn(t,e,"render"),n=e._vnode}finally{Ze=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=bn()),n.parent=i,n}}(St);var Nt=[String,RegExp,Array],Lt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Nt,exclude:Nt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,o=t.componentInstance,l=t.componentOptions;n[r]={name:It(l),tag:i,componentInstance:o},e.push(r),this.max&&e.length>parseInt(this.max)&&Vt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Vt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){_t(n,(function(n){return At(e,n)}))})),this.$watch("exclude",(function(e){_t(n,(function(n){return!At(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=We(n),t=e&&e.componentOptions;if(t){var r=It(t),i=this.include,o=this.exclude;if(i&&(!r||!At(i,r))||o&&r&&At(o,r))return e;var l=this.cache,a=this.keys,s=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;l[s]?(e.componentInstance=l[s].componentInstance,x(a,s),a.push(s)):(this.vnodeToCache=e,this.keyToCache=s),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return J}};Object.defineProperty(n,"config",e),n.util={warn:un,extend:V,mergeOptions:Mn,defineReactive:An},n.set=_n,n.delete=Vn,n.nextTick=oe,n.observable=function(n){return In(n),n},n.options=Object.create(null),M.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,V(n.options.components,Lt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=_(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Mn(this.options,n),this}}(n),kt(n),function(n){M.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(St),Object.defineProperty(St.prototype,"$isServer",{get:ln}),Object.defineProperty(St.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(St,"FunctionalRenderContext",{value:De}),St.version="2.6.14";var Bt=y("style,class"),Pt=y("input,textarea,option,select,progress"),Ct=y("contenteditable,draggable,spellcheck"),Dt=y("events,caret,typing,plaintext-only"),qt=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Mt="http://www.w3.org/1999/xlink",Rt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Jt=function(n){return Rt(n)?n.slice(6,n.length):""},Ot=function(n){return null==n||!1===n};function Ut(n){for(var e=n.data,t=n,r=n;a(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Gt(r.data,e));for(;a(t=t.parent);)t&&t.data&&(e=Gt(e,t.data));return function(n,e){if(a(n)||a(e))return Ft(n,Zt(e));return""}(e.staticClass,e.class)}function Gt(n,e){return{staticClass:Ft(n.staticClass,e.staticClass),class:a(n.class)?[n.class,e.class]:e.class}}function Ft(n,e){return n?e?n+" "+e:n:e||""}function Zt(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)a(e=Zt(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var $t={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Wt=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Ht=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Yt=function(n){return Wt(n)||Ht(n)};var Xt=Object.create(null);var Qt=y("text,number,password,search,email,tel,url");var Kt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS($t[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),nr={create:function(n,e){er(e)},update:function(n,e){n.data.ref!==e.data.ref&&(er(n,!0),er(e))},destroy:function(n){er(n,!0)}};function er(n,e){var t=n.data.ref;if(a(t)){var r=n.context,i=n.componentInstance||n.elm,o=r.$refs;e?Array.isArray(o[t])?x(o[t],i):o[t]===i&&(o[t]=void 0):n.data.refInFor?Array.isArray(o[t])?o[t].indexOf(i)<0&&o[t].push(i):o[t]=[i]:o[t]=i}}var tr=new vn("",{},[]),rr=["create","activate","update","remove","destroy"];function ir(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&a(n.data)===a(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=a(t=n.data)&&a(t=t.attrs)&&t.type,i=a(t=e.data)&&a(t=t.attrs)&&t.type;return r===i||Qt(r)&&Qt(i)}(n,e)||s(n.isAsyncPlaceholder)&&l(e.asyncFactory.error))}function or(n,e,t){var r,i,o={};for(r=e;r<=t;++r)a(i=n[r].key)&&(o[i]=r);return o}var lr={create:ar,update:ar,destroy:function(n){ar(n,tr)}};function ar(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,o=n===tr,l=e===tr,a=cr(n.data.directives,n.context),s=cr(e.data.directives,e.context),c=[],d=[];for(t in s)r=a[t],i=s[t],r?(i.oldValue=r.value,i.oldArg=r.arg,ur(i,"update",e,n),i.def&&i.def.componentUpdated&&d.push(i)):(ur(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var u=function(){for(var t=0;t<c.length;t++)ur(c[t],"inserted",e,n)};o?ue(e,"insert",u):u()}d.length&&ue(e,"postpatch",(function(){for(var t=0;t<d.length;t++)ur(d[t],"componentUpdated",e,n)}));if(!o)for(t in a)s[t]||ur(a[t],"unbind",n,n,l)}(n,e)}var sr=Object.create(null);function cr(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=sr),i[dr(r)]=r,r.def=Rn(e.$options,"directives",r.name);return i}function dr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function ur(n,e,t,r,i){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,i)}catch(r){Zn(r,t.context,"directive "+n.name+" "+e+" hook")}}var pr=[nr,lr];function mr(n,e){var t=e.componentOptions;if(!(a(t)&&!1===t.Ctor.options.inheritAttrs||l(n.data.attrs)&&l(e.data.attrs))){var r,i,o=e.elm,s=n.data.attrs||{},c=e.data.attrs||{};for(r in a(c.__ob__)&&(c=e.data.attrs=V({},c)),c)i=c[r],s[r]!==i&&hr(o,r,i,e.data.pre);for(r in(X||K)&&c.value!==s.value&&hr(o,"value",c.value),s)l(c[r])&&(Rt(r)?o.removeAttributeNS(Mt,Jt(r)):Ct(r)||o.removeAttribute(r))}}function hr(n,e,t,r){r||n.tagName.indexOf("-")>-1?gr(n,e,t):qt(e)?Ot(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Ct(e)?n.setAttribute(e,function(n,e){return Ot(e)||"false"===e?"false":"contenteditable"===n&&Dt(e)?e:"true"}(e,t)):Rt(e)?Ot(t)?n.removeAttributeNS(Mt,Jt(e)):n.setAttributeNS(Mt,e,t):gr(n,e,t)}function gr(n,e,t){if(Ot(t))n.removeAttribute(e);else{if(X&&!Q&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var fr={create:mr,update:mr};function vr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(l(r.staticClass)&&l(r.class)&&(l(i)||l(i.staticClass)&&l(i.class)))){var o=Ut(e),s=t._transitionClasses;a(s)&&(o=Ft(o,Zt(s))),o!==t._prevClass&&(t.setAttribute("class",o),t._prevClass=o)}}var yr,br={create:vr,update:vr};function xr(n,e,t){var r=yr;return function i(){var o=e.apply(null,arguments);null!==o&&jr(n,i,t,r)}}var wr=Xn&&!(en&&Number(en[1])<=53);function Er(n,e,t,r){if(wr){var i=dt,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}yr.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function jr(n,e,t,r){(r||yr).removeEventListener(n,e._wrapper||e,t)}function zr(n,e){if(!l(n.data.on)||!l(e.data.on)){var t=e.data.on||{},r=n.data.on||{};yr=e.elm,function(n){if(a(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}a(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),de(t,r,Er,jr,xr,e.context),yr=void 0}}var Tr,Sr={create:zr,update:zr};function kr(n,e){if(!l(n.data.domProps)||!l(e.data.domProps)){var t,r,i=e.elm,o=n.data.domProps||{},s=e.data.domProps||{};for(t in a(s.__ob__)&&(s=e.data.domProps=V({},s)),o)t in s||(i[t]="");for(t in s){if(r=s[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===o[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var c=l(r)?"":String(r);Ir(i,c)&&(i.value=c)}else if("innerHTML"===t&&Ht(i.tagName)&&l(i.innerHTML)){(Tr=Tr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var d=Tr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;d.firstChild;)i.appendChild(d.firstChild)}else if(r!==o[t])try{i[t]=r}catch(n){}}}}function Ir(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(a(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ar={create:kr,update:kr},_r=j((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Vr(n){var e=Nr(n.style);return n.staticStyle?V(n.staticStyle,e):e}function Nr(n){return Array.isArray(n)?N(n):"string"==typeof n?_r(n):n}var Lr,Br=/^--/,Pr=/\s*!important$/,Cr=function(n,e,t){if(Br.test(e))n.style.setProperty(e,t);else if(Pr.test(t))n.style.setProperty(I(e),t.replace(Pr,""),"important");else{var r=qr(e);if(Array.isArray(t))for(var i=0,o=t.length;i<o;i++)n.style[r]=t[i];else n.style[r]=t}},Dr=["Webkit","Moz","ms"],qr=j((function(n){if(Lr=Lr||document.createElement("div").style,"filter"!==(n=T(n))&&n in Lr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Dr.length;t++){var r=Dr[t]+e;if(r in Lr)return r}}));function Mr(n,e){var t=e.data,r=n.data;if(!(l(t.staticStyle)&&l(t.style)&&l(r.staticStyle)&&l(r.style))){var i,o,s=e.elm,c=r.staticStyle,d=r.normalizedStyle||r.style||{},u=c||d,p=Nr(e.data.style)||{};e.data.normalizedStyle=a(p.__ob__)?V({},p):p;var m=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Vr(i.data))&&V(r,t);(t=Vr(n.data))&&V(r,t);for(var o=n;o=o.parent;)o.data&&(t=Vr(o.data))&&V(r,t);return r}(e,!0);for(o in u)l(m[o])&&Cr(s,o,"");for(o in m)(i=m[o])!==u[o]&&Cr(s,o,null==i?"":i)}}var Rr={create:Mr,update:Mr},Jr=/\s+/;function Or(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Jr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Ur(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Jr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Gr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&V(e,Fr(n.name||"v")),V(e,n),e}return"string"==typeof n?Fr(n):void 0}}var Fr=j((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Zr=$&&!Q,$r="transition",Wr="transitionend",Hr="animation",Yr="animationend";Zr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&($r="WebkitTransition",Wr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Hr="WebkitAnimation",Yr="webkitAnimationEnd"));var Xr=$?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Qr(n){Xr((function(){Xr(n)}))}function Kr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Or(n,e))}function ni(n,e){n._transitionClasses&&x(n._transitionClasses,e),Ur(n,e)}function ei(n,e,t){var r=ri(n,e),i=r.type,o=r.timeout,l=r.propCount;if(!i)return t();var a="transition"===i?Wr:Yr,s=0,c=function(){n.removeEventListener(a,d),t()},d=function(e){e.target===n&&++s>=l&&c()};setTimeout((function(){s<l&&c()}),o+1),n.addEventListener(a,d)}var ti=/\b(transform|all)(,|$)/;function ri(n,e){var t,r=window.getComputedStyle(n),i=(r[$r+"Delay"]||"").split(", "),o=(r[$r+"Duration"]||"").split(", "),l=ii(i,o),a=(r[Hr+"Delay"]||"").split(", "),s=(r[Hr+"Duration"]||"").split(", "),c=ii(a,s),d=0,u=0;return"transition"===e?l>0&&(t="transition",d=l,u=o.length):"animation"===e?c>0&&(t="animation",d=c,u=s.length):u=(t=(d=Math.max(l,c))>0?l>c?"transition":"animation":null)?"transition"===t?o.length:s.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&ti.test(r[$r+"Property"])}}function ii(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return oi(e)+oi(n[t])})))}function oi(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function li(n,e){var t=n.elm;a(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Gr(n.data.transition);if(!l(r)&&!a(t._enterCb)&&1===t.nodeType){for(var i=r.css,o=r.type,s=r.enterClass,c=r.enterToClass,u=r.enterActiveClass,p=r.appearClass,m=r.appearToClass,h=r.appearActiveClass,g=r.beforeEnter,f=r.enter,y=r.afterEnter,b=r.enterCancelled,x=r.beforeAppear,w=r.appear,E=r.afterAppear,j=r.appearCancelled,z=r.duration,T=Ke,S=Ke.$vnode;S&&S.parent;)T=S.context,S=S.parent;var k=!T._isMounted||!n.isRootInsert;if(!k||w||""===w){var I=k&&p?p:s,A=k&&h?h:u,_=k&&m?m:c,V=k&&x||g,N=k&&"function"==typeof w?w:f,L=k&&E||y,B=k&&j||b,P=v(d(z)?z.enter:z);0;var C=!1!==i&&!Q,D=ci(N),M=t._enterCb=q((function(){C&&(ni(t,_),ni(t,A)),M.cancelled?(C&&ni(t,I),B&&B(t)):L&&L(t),t._enterCb=null}));n.data.show||ue(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),N&&N(t,M)})),V&&V(t),C&&(Kr(t,I),Kr(t,A),Qr((function(){ni(t,I),M.cancelled||(Kr(t,_),D||(si(P)?setTimeout(M,P):ei(t,o,M)))}))),n.data.show&&(e&&e(),N&&N(t,M)),C||D||M()}}}function ai(n,e){var t=n.elm;a(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Gr(n.data.transition);if(l(r)||1!==t.nodeType)return e();if(!a(t._leaveCb)){var i=r.css,o=r.type,s=r.leaveClass,c=r.leaveToClass,u=r.leaveActiveClass,p=r.beforeLeave,m=r.leave,h=r.afterLeave,g=r.leaveCancelled,f=r.delayLeave,y=r.duration,b=!1!==i&&!Q,x=ci(m),w=v(d(y)?y.leave:y);0;var E=t._leaveCb=q((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(ni(t,c),ni(t,u)),E.cancelled?(b&&ni(t,s),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));f?f(j):j()}function j(){E.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),b&&(Kr(t,s),Kr(t,u),Qr((function(){ni(t,s),E.cancelled||(Kr(t,c),x||(si(w)?setTimeout(E,w):ei(t,o,E)))}))),m&&m(t,E),b||x||E())}}function si(n){return"number"==typeof n&&!isNaN(n)}function ci(n){if(l(n))return!1;var e=n.fns;return a(e)?ci(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function di(n,e){!0!==e.data.show&&li(e)}var ui=function(n){var e,t,r={},i=n.modules,o=n.nodeOps;for(e=0;e<rr.length;++e)for(r[rr[e]]=[],t=0;t<i.length;++t)a(i[t][rr[e]])&&r[rr[e]].push(i[t][rr[e]]);function d(n){var e=o.parentNode(n);a(e)&&o.removeChild(e,n)}function u(n,e,t,i,l,c,d){if(a(n.elm)&&a(c)&&(n=c[d]=wn(n)),n.isRootInsert=!l,!function(n,e,t,i){var o=n.data;if(a(o)){var l=a(n.componentInstance)&&o.keepAlive;if(a(o=o.hook)&&a(o=o.init)&&o(n,!1),a(n.componentInstance))return p(n,e),m(t,n.elm,i),s(l)&&function(n,e,t,i){var o,l=n;for(;l.componentInstance;)if(l=l.componentInstance._vnode,a(o=l.data)&&a(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](tr,l);e.push(l);break}m(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var u=n.data,g=n.children,y=n.tag;a(y)?(n.elm=n.ns?o.createElementNS(n.ns,y):o.createElement(y,n),v(n),h(n,g,e),a(u)&&f(n,e),m(t,n.elm,i)):s(n.isComment)?(n.elm=o.createComment(n.text),m(t,n.elm,i)):(n.elm=o.createTextNode(n.text),m(t,n.elm,i))}}function p(n,e){a(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(f(n,e),v(n)):(er(n),e.push(n))}function m(n,e,t){a(n)&&(a(t)?o.parentNode(t)===n&&o.insertBefore(n,e,t):o.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)u(e[r],t,n.elm,null,!0,e,r)}else c(n.text)&&o.appendChild(n.elm,o.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return a(n.tag)}function f(n,t){for(var i=0;i<r.create.length;++i)r.create[i](tr,n);a(e=n.data.hook)&&(a(e.create)&&e.create(tr,n),a(e.insert)&&t.push(n))}function v(n){var e;if(a(e=n.fnScopeId))o.setStyleScope(n.elm,e);else for(var t=n;t;)a(e=t.context)&&a(e=e.$options._scopeId)&&o.setStyleScope(n.elm,e),t=t.parent;a(e=Ke)&&e!==n.context&&e!==n.fnContext&&a(e=e.$options._scopeId)&&o.setStyleScope(n.elm,e)}function b(n,e,t,r,i,o){for(;r<=i;++r)u(t[r],o,n,e,!1,t,r)}function x(n){var e,t,i=n.data;if(a(i))for(a(e=i.hook)&&a(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(a(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var r=n[e];a(r)&&(a(r.tag)?(E(r),x(r)):d(r.elm))}}function E(n,e){if(a(e)||a(n.data)){var t,i=r.remove.length+1;for(a(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,i),a(t=n.componentInstance)&&a(t=t._vnode)&&a(t.data)&&E(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);a(t=n.data.hook)&&a(t=t.remove)?t(n,e):e()}else d(n.elm)}function j(n,e,t,r){for(var i=t;i<r;i++){var o=e[i];if(a(o)&&ir(n,o))return i}}function z(n,e,t,i,c,d){if(n!==e){a(e.elm)&&a(i)&&(e=i[c]=wn(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))a(e.asyncFactory.resolved)?k(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;a(h)&&a(m=h.hook)&&a(m=m.prepatch)&&m(n,e);var f=n.children,v=e.children;if(a(h)&&g(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);a(m=h.hook)&&a(m=m.update)&&m(n,e)}l(e.text)?a(f)&&a(v)?f!==v&&function(n,e,t,r,i){var s,c,d,p=0,m=0,h=e.length-1,g=e[0],f=e[h],v=t.length-1,y=t[0],x=t[v],E=!i;for(0;p<=h&&m<=v;)l(g)?g=e[++p]:l(f)?f=e[--h]:ir(g,y)?(z(g,y,r,t,m),g=e[++p],y=t[++m]):ir(f,x)?(z(f,x,r,t,v),f=e[--h],x=t[--v]):ir(g,x)?(z(g,x,r,t,v),E&&o.insertBefore(n,g.elm,o.nextSibling(f.elm)),g=e[++p],x=t[--v]):ir(f,y)?(z(f,y,r,t,m),E&&o.insertBefore(n,f.elm,g.elm),f=e[--h],y=t[++m]):(l(s)&&(s=or(e,p,h)),l(c=a(y.key)?s[y.key]:j(y,e,p,h))?u(y,r,n,g.elm,!1,t,m):ir(d=e[c],y)?(z(d,y,r,t,m),e[c]=void 0,E&&o.insertBefore(n,d.elm,g.elm)):u(y,r,n,g.elm,!1,t,m),y=t[++m]);p>h?b(n,l(t[v+1])?null:t[v+1].elm,t,m,v,r):m>v&&w(e,p,h)}(p,f,v,t,d):a(v)?(a(n.text)&&o.setTextContent(p,""),b(p,null,v,0,v.length-1,t)):a(f)?w(f,0,f.length-1):a(n.text)&&o.setTextContent(p,""):n.text!==e.text&&o.setTextContent(p,e.text),a(h)&&a(m=h.hook)&&a(m=m.postpatch)&&m(n,e)}}}function T(n,e,t){if(s(t)&&a(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var S=y("attrs,class,staticClass,staticStyle,key");function k(n,e,t,r){var i,o=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&a(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(a(l)&&(a(i=l.hook)&&a(i=i.init)&&i(e,!0),a(i=e.componentInstance)))return p(e,t),!0;if(a(o)){if(a(c))if(n.hasChildNodes())if(a(i=l)&&a(i=i.domProps)&&a(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,m=0;m<c.length;m++){if(!u||!k(u,c[m],t,r)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else h(e,c,t);if(a(l)){var g=!1;for(var v in l)if(!S(v)){g=!0,f(e,t);break}!g&&l.class&&ae(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!l(e)){var c,d=!1,p=[];if(l(n))d=!0,u(e,p);else{var m=a(n.nodeType);if(!m&&ir(n,e))z(n,e,p,null,null,i);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&k(n,e,p))return T(e,p,!0),n;c=n,n=new vn(o.tagName(c).toLowerCase(),{},[],void 0,c)}var h=n.elm,f=o.parentNode(h);if(u(e,p,h._leaveCb?null:f,o.nextSibling(h)),a(e.parent))for(var v=e.parent,y=g(e);v;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](v);if(v.elm=e.elm,y){for(var E=0;E<r.create.length;++E)r.create[E](tr,v);var j=v.data.hook.insert;if(j.merged)for(var S=1;S<j.fns.length;S++)j.fns[S]()}else er(v);v=v.parent}a(f)?w([n],0,0):a(n.tag)&&x(n)}}return T(e,p,d),e.elm}a(n)&&x(n)}}({nodeOps:Kt,modules:[fr,br,Sr,Ar,Rr,$?{create:di,activate:di,remove:function(n,e){!0!==n.data.show?ai(n,e):e()}}:{}].concat(pr)});Q&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&bi(n,"input")}));var pi={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?ue(t,"postpatch",(function(){pi.componentUpdated(n,e,t)})):mi(n,e,t.context),n._vOptions=[].map.call(n.options,fi)):("textarea"===t.tag||Qt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",vi),n.addEventListener("compositionend",yi),n.addEventListener("change",yi),Q&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){mi(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,fi);if(i.some((function(n,e){return!C(n,r[e])})))(n.multiple?e.value.some((function(n){return gi(n,i)})):e.value!==e.oldValue&&gi(e.value,i))&&bi(n,"change")}}};function mi(n,e,t){hi(n,e,t),(X||K)&&setTimeout((function(){hi(n,e,t)}),0)}function hi(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var o,l,a=0,s=n.options.length;a<s;a++)if(l=n.options[a],i)o=D(r,fi(l))>-1,l.selected!==o&&(l.selected=o);else if(C(fi(l),r))return void(n.selectedIndex!==a&&(n.selectedIndex=a));i||(n.selectedIndex=-1)}}function gi(n,e){return e.every((function(e){return!C(e,n)}))}function fi(n){return"_value"in n?n._value:n.value}function vi(n){n.target.composing=!0}function yi(n){n.target.composing&&(n.target.composing=!1,bi(n.target,"input"))}function bi(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function xi(n){return!n.componentInstance||n.data&&n.data.transition?n:xi(n.componentInstance._vnode)}var wi={model:pi,show:{bind:function(n,e,t){var r=e.value,i=(t=xi(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,li(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=xi(t)).data&&t.data.transition?(t.data.show=!0,r?li(t,(function(){n.style.display=n.__vOriginalDisplay})):ai(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},Ei={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ji(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?ji(We(e.children)):n}function zi(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var o in i)e[T(o)]=i[o];return e}function Ti(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Si=function(n){return n.tag||ye(n)},ki=function(n){return"show"===n.name},Ii={name:"transition",props:Ei,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Si)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var o=ji(i);if(!o)return i;if(this._leaving)return Ti(n,i);var l="__transition-"+this._uid+"-";o.key=null==o.key?o.isComment?l+"comment":l+o.tag:c(o.key)?0===String(o.key).indexOf(l)?o.key:l+o.key:o.key;var a=(o.data||(o.data={})).transition=zi(this),s=this._vnode,d=ji(s);if(o.data.directives&&o.data.directives.some(ki)&&(o.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,d)&&!ye(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=V({},a);if("out-in"===r)return this._leaving=!0,ue(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ti(n,i);if("in-out"===r){if(ye(o))return s;var p,m=function(){p()};ue(a,"afterEnter",m),ue(a,"enterCancelled",m),ue(u,"delayLeave",(function(n){p=n}))}}return i}}},Ai=V({tag:String,moveClass:String},Ei);function _i(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Vi(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ni(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+i+"px)",o.transitionDuration="0s"}}delete Ai.mode;var Li={Transition:Ii,TransitionGroup:{props:Ai,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=nt(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],l=zi(this),a=0;a<i.length;a++){var s=i[a];if(s.tag)if(null!=s.key&&0!==String(s.key).indexOf("__vlist"))o.push(s),t[s.key]=s,(s.data||(s.data={})).transition=l;else;}if(r){for(var c=[],d=[],u=0;u<r.length;u++){var p=r[u];p.data.transition=l,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):d.push(p)}this.kept=n(e,null,c),this.removed=d}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(_i),n.forEach(Vi),n.forEach(Ni),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Kr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Wr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Wr,n),t._moveCb=null,ni(t,e))})}})))},methods:{hasMove:function(n,e){if(!Zr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Ur(t,n)})),Or(t,e),t.style.display="none",this.$el.appendChild(t);var r=ri(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};St.config.mustUseProp=function(n,e,t){return"value"===t&&Pt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},St.config.isReservedTag=Yt,St.config.isReservedAttr=Bt,St.config.getTagNamespace=function(n){return Ht(n)?"svg":"math"===n?"math":void 0},St.config.isUnknownElement=function(n){if(!$)return!0;if(Yt(n))return!1;if(n=n.toLowerCase(),null!=Xt[n])return Xt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Xt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Xt[n]=/HTMLUnknownElement/.test(e.toString())},V(St.options.directives,wi),V(St.options.components,Li),St.prototype.__patch__=$?ui:L,St.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=bn),rt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new gt(n,r,L,{before:function(){n._isMounted&&!n._isDestroyed&&rt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,rt(n,"mounted")),n}(this,n=n&&$?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},$&&setTimeout((function(){J.devtools&&an&&an.emit("init",St)}),0);var Bi=St;
/*!
  * vue-router v3.5.2
  * (c) 2021 Evan You
  * @license MIT
  */function Pi(n,e){for(var t in e)n[t]=e[t];return n}var Ci=/[!'()*]/g,Di=function(n){return"%"+n.charCodeAt(0).toString(16)},qi=/%2C/g,Mi=function(n){return encodeURIComponent(n).replace(Ci,Di).replace(qi,",")};function Ri(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Ji=function(n){return null==n||"object"==typeof n?n:String(n)};function Oi(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=Ri(t.shift()),i=t.length>0?Ri(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function Ui(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Mi(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(Mi(e)):r.push(Mi(e)+"="+Mi(n)))})),r.join("&")}return Mi(e)+"="+Mi(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Gi=/\/?$/;function Fi(n,e,t,r){var i=r&&r.options.stringifyQuery,o=e.query||{};try{o=Zi(o)}catch(n){}var l={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:Hi(e,i),matched:n?Wi(n):[]};return t&&(l.redirectedFrom=Hi(t,i)),Object.freeze(l)}function Zi(n){if(Array.isArray(n))return n.map(Zi);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Zi(n[t]);return e}return n}var $i=Fi(null,{path:"/"});function Wi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Hi(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||Ui)(r)+i}function Yi(n,e,t){return e===$i?n===e:!!e&&(n.path&&e.path?n.path.replace(Gi,"")===e.path.replace(Gi,"")&&(t||n.hash===e.hash&&Xi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Xi(n.query,e.query)&&Xi(n.params,e.params))))}function Xi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var o=n[t];if(r[i]!==t)return!1;var l=e[t];return null==o||null==l?o===l:"object"==typeof o&&"object"==typeof l?Xi(o,l):String(o)===String(l)}))}function Qi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],o=t.enteredCbs[r];if(i&&o){delete t.enteredCbs[r];for(var l=0;l<o.length;l++)i._isBeingDestroyed||o[l](i)}}}}var Ki={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,o=e.data;o.routerView=!0;for(var l=i.$createElement,a=t.name,s=i.$route,c=i._routerViewCache||(i._routerViewCache={}),d=0,u=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&d++,p.keepAlive&&i._directInactive&&i._inactive&&(u=!0),i=i.$parent}if(o.routerViewDepth=d,u){var m=c[a],h=m&&m.component;return h?(m.configProps&&no(h,o,m.route,m.configProps),l(h,o,r)):l()}var g=s.matched[d],f=g&&g.components[a];if(!g||!f)return c[a]=null,l();c[a]={component:f},o.registerRouteInstance=function(n,e){var t=g.instances[a];(e&&t!==n||!e&&t===n)&&(g.instances[a]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){g.instances[a]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[a]&&(g.instances[a]=n.componentInstance),Qi(s)};var v=g.props&&g.props[a];return v&&(Pi(c[a],{route:s,configProps:v}),no(f,o,s,v)),l(f,o,r)}};function no(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=Pi({},i);var o=e.attrs=e.attrs||{};for(var l in i)n.props&&l in n.props||(o[l]=i[l],delete i[l])}}function eo(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var o=n.replace(/^\//,"").split("/"),l=0;l<o.length;l++){var a=o[l];".."===a?i.pop():"."!==a&&i.push(a)}return""!==i[0]&&i.unshift(""),i.join("/")}function to(n){return n.replace(/\/\//g,"/")}var ro=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},io=bo,oo=uo,lo=function(n,e){return mo(uo(n,e),e)},ao=mo,so=yo,co=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function uo(n,e){for(var t,r=[],i=0,o=0,l="",a=e&&e.delimiter||"/";null!=(t=co.exec(n));){var s=t[0],c=t[1],d=t.index;if(l+=n.slice(o,d),o=d+s.length,c)l+=c[1];else{var u=n[o],p=t[2],m=t[3],h=t[4],g=t[5],f=t[6],v=t[7];l&&(r.push(l),l="");var y=null!=p&&null!=u&&u!==p,b="+"===f||"*"===f,x="?"===f||"*"===f,w=t[2]||a,E=h||g;r.push({name:m||i++,prefix:p||"",delimiter:w,optional:x,repeat:b,partial:y,asterisk:!!v,pattern:E?go(E):v?".*":"[^"+ho(w)+"]+?"})}}return o<n.length&&(l+=n.substr(o)),l&&r.push(l),r}function po(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function mo(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",vo(e)));return function(e,r){for(var i="",o=e||{},l=(r||{}).pretty?po:encodeURIComponent,a=0;a<n.length;a++){var s=n[a];if("string"!=typeof s){var c,d=o[s.name];if(null==d){if(s.optional){s.partial&&(i+=s.prefix);continue}throw new TypeError('Expected "'+s.name+'" to be defined')}if(ro(d)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=l(d[u]),!t[a].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===u?s.prefix:s.delimiter)+c}}else{if(c=s.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):l(d),!t[a].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but received "'+c+'"');i+=s.prefix+c}}else i+=s}return i}}function ho(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function go(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function fo(n,e){return n.keys=e,n}function vo(n){return n&&n.sensitive?"":"i"}function yo(n,e,t){ro(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,o="",l=0;l<n.length;l++){var a=n[l];if("string"==typeof a)o+=ho(a);else{var s=ho(a.prefix),c="(?:"+a.pattern+")";e.push(a),a.repeat&&(c+="(?:"+s+c+")*"),o+=c=a.optional?a.partial?s+"("+c+")?":"(?:"+s+"("+c+"))?":s+"("+c+")"}}var d=ho(t.delimiter||"/"),u=o.slice(-d.length)===d;return r||(o=(u?o.slice(0,-d.length):o)+"(?:"+d+"(?=$))?"),o+=i?"$":r&&u?"":"(?="+d+"|$)",fo(new RegExp("^"+o,vo(t)),e)}function bo(n,e,t){return ro(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return fo(n,e)}(n,e):ro(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(bo(n[i],e,t).source);return fo(new RegExp("(?:"+r.join("|")+")",vo(t)),e)}(n,e,t):function(n,e,t){return yo(uo(n,t),e,t)}(n,e,t)}io.parse=oo,io.compile=lo,io.tokensToFunction=ao,io.tokensToRegExp=so;var xo=Object.create(null);function wo(n,e,t){e=e||{};try{var r=xo[n]||(xo[n]=io.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Eo(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var o=(i=Pi({},n)).params;return o&&"object"==typeof o&&(i.params=Pi({},o)),i}if(!i.path&&i.params&&e){(i=Pi({},i))._normalized=!0;var l=Pi(Pi({},e.params),i.params);if(e.name)i.name=e.name,i.params=l;else if(e.matched.length){var a=e.matched[e.matched.length-1].path;i.path=wo(a,l,e.path)}else 0;return i}var s=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",d=s.path?eo(s.path,c,t||i.append):c,u=function(n,e,t){void 0===e&&(e={});var r,i=t||Oi;try{r=i(n||"")}catch(n){r={}}for(var o in e){var l=e[o];r[o]=Array.isArray(l)?l.map(Ji):Ji(l)}return r}(s.query,i.query,r&&r.options.parseQuery),p=i.hash||s.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var jo,zo=function(){},To={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),o=i.location,l=i.route,a=i.href,s={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,g=l.redirectedFrom?Fi(null,Eo(l.redirectedFrom),null,t):l;s[h]=Yi(r,g,this.exactPath),s[m]=this.exact||this.exactPath?s[h]:function(n,e){return 0===n.path.replace(Gi,"/").indexOf(e.path.replace(Gi,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,g);var f=s[h]?this.ariaCurrentValue:null,v=function(n){So(n)&&(e.replace?t.replace(o,zo):t.push(o,zo))},y={click:So};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=v})):y[this.event]=v;var b={class:s},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:a,route:l,navigate:v,isActive:s[m],isExactActive:s[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)b.on=y,b.attrs={href:a,"aria-current":f};else{var w=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var E=w.data=Pi({},w.data);for(var j in E.on=E.on||{},E.on){var z=E.on[j];j in y&&(E.on[j]=Array.isArray(z)?z:[z])}for(var T in y)T in E.on?E.on[T].push(y[T]):E.on[T]=v;var S=w.data.attrs=Pi({},w.data.attrs);S.href=a,S["aria-current"]=f}else b.on=y}return n(this.tag,b,this.$slots.default)}};function So(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var ko="undefined"!=typeof window;function Io(n,e,t,r,i){var o=e||[],l=t||Object.create(null),a=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,o,l){var a=i.path,s=i.name;0;var c=i.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return to(e.path+"/"+n)}(a,o,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var u={path:d,regex:Ao(d,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:s,parent:o,matchAs:l,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var o=l?to(l+"/"+i.path):void 0;n(e,t,r,i,u,o)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==i.alias)for(var p=Array.isArray(i.alias)?i.alias:[i.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:i.children};n(e,t,r,h,o,u.path||"/")}s&&(r[s]||(r[s]=u))}(o,l,a,n,i)}));for(var s=0,c=o.length;s<c;s++)"*"===o[s]&&(o.push(o.splice(s,1)[0]),c--,s--);return{pathList:o,pathMap:l,nameMap:a}}function Ao(n,e){return io(n,[],e)}function _o(n,e){var t=Io(n),r=t.pathList,i=t.pathMap,o=t.nameMap;function l(n,t,l){var a=Eo(n,t,!1,e),c=a.name;if(c){var d=o[c];if(!d)return s(null,a);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof a.params&&(a.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in a.params)&&u.indexOf(p)>-1&&(a.params[p]=t.params[p]);return a.path=wo(d.path,a.params),s(d,a,l)}if(a.path){a.params={};for(var m=0;m<r.length;m++){var h=r[m],g=i[h];if(Vo(g.regex,a.path,a.params))return s(g,a,l)}}return s(null,a)}function a(n,t){var r=n.redirect,i="function"==typeof r?r(Fi(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return s(null,t);var a=i,c=a.name,d=a.path,u=t.query,p=t.hash,m=t.params;if(u=a.hasOwnProperty("query")?a.query:u,p=a.hasOwnProperty("hash")?a.hash:p,m=a.hasOwnProperty("params")?a.params:m,c){o[c];return l({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return eo(n,e.parent?e.parent.path:"/",!0)}(d,n);return l({_normalized:!0,path:wo(h,m),query:u,hash:p},void 0,t)}return s(null,t)}function s(n,t,r){return n&&n.redirect?a(n,r||t):n&&n.matchAs?function(n,e,t){var r=l({_normalized:!0,path:wo(t,e.params)});if(r){var i=r.matched,o=i[i.length-1];return e.params=r.params,s(o,e)}return s(null,e)}(0,t,n.matchAs):Fi(n,t,r,e)}return{match:l,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Io([e||n],r,i,o,t),t&&t.alias.length&&Io(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,o,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Io(n,r,i,o)}}}function Vo(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,o=r.length;i<o;++i){var l=n.keys[i-1];l&&(t[l.name||"pathMatch"]="string"==typeof r[i]?Ri(r[i]):r[i])}return!0}var No=ko&&window.performance&&window.performance.now?window.performance:Date;function Lo(){return No.now().toFixed(3)}var Bo=Lo();function Po(){return Bo}function Co(n){return Bo=n}var Do=Object.create(null);function qo(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Pi({},window.history.state);return t.key=Po(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Jo),function(){window.removeEventListener("popstate",Jo)}}function Mo(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var o=function(){var n=Po();if(n)return Do[n]}(),l=i.call(n,e,t,r?o:null);l&&("function"==typeof l.then?l.then((function(n){Zo(n,o)})).catch((function(n){0})):Zo(l,o))}))}}function Ro(){var n=Po();n&&(Do[n]={x:window.pageXOffset,y:window.pageYOffset})}function Jo(n){Ro(),n.state&&n.state.key&&Co(n.state.key)}function Oo(n){return Go(n.x)||Go(n.y)}function Uo(n){return{x:Go(n.x)?n.x:window.pageXOffset,y:Go(n.y)?n.y:window.pageYOffset}}function Go(n){return"number"==typeof n}var Fo=/^#\d/;function Zo(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=Fo.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,o={x:Go((t=o).x)?t.x:0,y:Go(t.y)?t.y:0})}else Oo(n)&&(e=Uo(n))}else r&&Oo(n)&&(e=Uo(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var $o,Wo=ko&&((-1===($o=window.navigator.userAgent).indexOf("Android 2.")&&-1===$o.indexOf("Android 4.0")||-1===$o.indexOf("Mobile Safari")||-1!==$o.indexOf("Chrome")||-1!==$o.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Ho(n,e){Ro();var t=window.history;try{if(e){var r=Pi({},t.state);r.key=Po(),t.replaceState(r,"",n)}else t.pushState({key:Co(Lo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Yo(n){Ho(n,!0)}function Xo(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}var Qo={redirected:2,aborted:4,cancelled:8,duplicated:16};function Ko(n,e){return el(n,e,Qo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return tl.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function nl(n,e){return el(n,e,Qo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function el(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var tl=["params","query","hash"];function rl(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function il(n,e){return rl(n)&&n._isRouter&&(null==e||n.type===e)}function ol(n){return function(e,t,r){var i=!1,o=0,l=null;ll(n,(function(n,e,t,a){if("function"==typeof n&&void 0===n.cid){i=!0,o++;var s,c=cl((function(e){var i;((i=e).__esModule||sl&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:jo.extend(e),t.components[a]=e,--o<=0&&r()})),d=cl((function(n){var e="Failed to resolve async component "+a+": "+n;l||(l=rl(n)?n:new Error(e),r(l))}));try{s=n(c,d)}catch(n){d(n)}if(s)if("function"==typeof s.then)s.then(c,d);else{var u=s.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),i||r()}}function ll(n,e){return al(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function al(n){return Array.prototype.concat.apply([],n)}var sl="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function cl(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var dl=function(n,e){this.router=n,this.base=function(n){if(!n)if(ko){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=$i,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ul(n,e,t,r){var i=ll(n,(function(n,r,i,o){var l=function(n,e){"function"!=typeof n&&(n=jo.extend(n));return n.options[e]}(n,e);if(l)return Array.isArray(l)?l.map((function(n){return t(n,r,i,o)})):t(l,r,i,o)}));return al(r?i.reverse():i)}function pl(n,e){if(e)return function(){return n.apply(e,arguments)}}dl.prototype.listen=function(n){this.cb=n},dl.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},dl.prototype.onError=function(n){this.errorCbs.push(n)},dl.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,o)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(il(n,Qo.redirected)&&o===$i||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},dl.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var o,l,a=function(n){!il(n)&&rl(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},s=n.matched.length-1,c=i.matched.length-1;if(Yi(n,i)&&s===c&&n.matched[s]===i.matched[c])return this.ensureURL(),a(((l=el(o=i,n,Qo.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",l));var d=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return ul(n,"beforeRouteLeave",pl,!0)}(p),this.router.beforeHooks,function(n){return ul(n,"beforeRouteUpdate",pl)}(u),m.map((function(n){return n.beforeEnter})),ol(m)),g=function(e,t){if(r.pending!==n)return a(nl(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),a(function(n,e){return el(n,e,Qo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):rl(e)?(r.ensureURL(!0),a(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(a(Ko(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){a(n)}};Xo(h,g,(function(){Xo(function(n){return ul(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,o){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),g,(function(){if(r.pending!==n)return a(nl(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Qi(n)}))}))}))},dl.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},dl.prototype.setupListeners=function(){},dl.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=$i,this.pending=null};var ml=function(n){function e(e,t){n.call(this,e,t),this._startLocation=hl(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Wo&&t;r&&this.listeners.push(qo());var i=function(){var t=n.current,i=hl(n.base);n.current===$i&&i===n._startLocation||n.transitionTo(i,(function(n){r&&Mo(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Ho(to(r.base+n.fullPath)),Mo(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Yo(to(r.base+n.fullPath)),Mo(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(hl(this.base)!==this.current.fullPath){var e=to(this.base+this.current.fullPath);n?Ho(e):Yo(e)}},e.prototype.getCurrentLocation=function(){return hl(this.base)},e}(dl);function hl(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(to(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var gl=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=hl(n);if(!/^\/#/.test(e))return window.location.replace(to(n+"/#"+e)),!0}(this.base)||fl()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Wo&&e;t&&this.listeners.push(qo());var r=function(){var e=n.current;fl()&&n.transitionTo(vl(),(function(r){t&&Mo(n.router,r,e,!0),Wo||xl(r.fullPath)}))},i=Wo?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){bl(n.fullPath),Mo(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){xl(n.fullPath),Mo(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;vl()!==e&&(n?bl(e):xl(e))},e.prototype.getCurrentLocation=function(){return vl()},e}(dl);function fl(){var n=vl();return"/"===n.charAt(0)||(xl("/"+n),!1)}function vl(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function yl(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function bl(n){Wo?Ho(yl(n)):window.location.hash=n}function xl(n){Wo?Yo(yl(n)):window.location.replace(yl(n))}var wl=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){il(n,Qo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(dl),El=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=_o(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Wo&&!1!==n.fallback,this.fallback&&(e="hash"),ko||(e="abstract"),this.mode=e,e){case"history":this.history=new ml(this,n.base);break;case"hash":this.history=new gl(this,n.base,this.fallback);break;case"abstract":this.history=new wl(this,n.base);break;default:0}},jl={currentRoute:{configurable:!0}};function zl(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}El.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},jl.currentRoute.get=function(){return this.history&&this.history.current},El.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof ml||t instanceof gl){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;Wo&&i&&"fullPath"in n&&Mo(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},El.prototype.beforeEach=function(n){return zl(this.beforeHooks,n)},El.prototype.beforeResolve=function(n){return zl(this.resolveHooks,n)},El.prototype.afterEach=function(n){return zl(this.afterHooks,n)},El.prototype.onReady=function(n,e){this.history.onReady(n,e)},El.prototype.onError=function(n){this.history.onError(n)},El.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},El.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},El.prototype.go=function(n){this.history.go(n)},El.prototype.back=function(){this.go(-1)},El.prototype.forward=function(){this.go(1)},El.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},El.prototype.resolve=function(n,e,t){var r=Eo(n,e=e||this.history.current,t,this),i=this.match(r,e),o=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?to(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:i}},El.prototype.getRoutes=function(){return this.matcher.getRoutes()},El.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==$i&&this.history.transitionTo(this.history.getCurrentLocation())},El.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==$i&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(El.prototype,jl),El.install=function n(e){if(!n.installed||jo!==e){n.installed=!0,jo=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Ki),e.component("RouterLink",To);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},El.version="3.5.2",El.isNavigationFailure=il,El.NavigationFailureType=Qo,El.START_LOCATION=$i,ko&&window.Vue&&window.Vue.use(El);var Tl=El;t(150),t(151),t(217),t(58),t(152),t(23),t(24),t(219);function Sl(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(40),t(54),t(72);var kl=t(56),Il=(t(160),t(18),t(29),t(194),t(195),{NotFound:function(){return Promise.all([t.e(0),t.e(5)]).then(t.bind(null,568))},Layout:function(){return Promise.all([t.e(0),t.e(2),t.e(3)]).then(t.bind(null,567))}}),Al={"v-3dfeac0a":function(){return t.e(7).then(t.bind(null,570))},"v-64dafe41":function(){return t.e(9).then(t.bind(null,571))},"v-5e3aa7ac":function(){return t.e(8).then(t.bind(null,572))},"v-73c0e481":function(){return t.e(10).then(t.bind(null,573))},"v-14d384af":function(){return t.e(11).then(t.bind(null,574))},"v-254c0b14":function(){return t.e(12).then(t.bind(null,575))},"v-39f537e0":function(){return t.e(13).then(t.bind(null,576))},"v-11eba928":function(){return t.e(14).then(t.bind(null,577))},"v-2dfb486b":function(){return t.e(15).then(t.bind(null,578))},"v-4abfd090":function(){return t.e(16).then(t.bind(null,579))},"v-4a700847":function(){return t.e(17).then(t.bind(null,580))},"v-176ecc6d":function(){return t.e(18).then(t.bind(null,581))},"v-29b3469e":function(){return t.e(19).then(t.bind(null,582))},"v-6b8abe87":function(){return t.e(20).then(t.bind(null,583))},"v-4e764050":function(){return t.e(21).then(t.bind(null,584))},"v-f5686124":function(){return t.e(22).then(t.bind(null,585))},"v-3ef721a4":function(){return t.e(23).then(t.bind(null,586))},"v-56ad6238":function(){return t.e(24).then(t.bind(null,587))},"v-057873f0":function(){return t.e(25).then(t.bind(null,588))},"v-365c4844":function(){return t.e(26).then(t.bind(null,589))},"v-75251f27":function(){return t.e(27).then(t.bind(null,590))},"v-5873af27":function(){return t.e(28).then(t.bind(null,591))},"v-406283e4":function(){return t.e(29).then(t.bind(null,592))},"v-ff6467ec":function(){return t.e(30).then(t.bind(null,593))},"v-28ca9b09":function(){return t.e(31).then(t.bind(null,594))},"v-6e501801":function(){return t.e(32).then(t.bind(null,595))},"v-40daeab2":function(){return t.e(33).then(t.bind(null,596))},"v-076af421":function(){return t.e(34).then(t.bind(null,597))},"v-69d0e2bb":function(){return t.e(35).then(t.bind(null,598))},"v-445308e1":function(){return t.e(36).then(t.bind(null,599))},"v-9638d2dc":function(){return t.e(37).then(t.bind(null,600))},"v-eed23472":function(){return t.e(38).then(t.bind(null,601))},"v-3ada3421":function(){return t.e(39).then(t.bind(null,602))},"v-d4112a68":function(){return t.e(40).then(t.bind(null,603))},"v-8bdc6966":function(){return t.e(41).then(t.bind(null,604))},"v-28f18332":function(){return t.e(42).then(t.bind(null,605))},"v-197875f8":function(){return t.e(43).then(t.bind(null,606))},"v-6a2136f8":function(){return t.e(44).then(t.bind(null,607))},"v-fc4d86a6":function(){return t.e(45).then(t.bind(null,608))},"v-0f2635e4":function(){return t.e(46).then(t.bind(null,609))},"v-0152edd7":function(){return t.e(47).then(t.bind(null,610))},"v-6f0ca157":function(){return t.e(48).then(t.bind(null,611))},"v-e038dfdc":function(){return t.e(49).then(t.bind(null,612))},"v-f821d6fe":function(){return t.e(50).then(t.bind(null,613))},"v-47723afe":function(){return t.e(51).then(t.bind(null,614))},"v-0acd08c8":function(){return t.e(52).then(t.bind(null,615))},"v-1eb400c4":function(){return t.e(53).then(t.bind(null,616))},"v-3b8af4e5":function(){return t.e(54).then(t.bind(null,617))},"v-69cddf07":function(){return t.e(55).then(t.bind(null,618))},"v-23a69c14":function(){return t.e(56).then(t.bind(null,619))},"v-34822816":function(){return t.e(57).then(t.bind(null,620))},"v-14075572":function(){return t.e(58).then(t.bind(null,621))},"v-3f1c5b45":function(){return t.e(59).then(t.bind(null,622))},"v-3d9e1e51":function(){return t.e(60).then(t.bind(null,623))},"v-63be4647":function(){return t.e(61).then(t.bind(null,624))},"v-d6e0aee8":function(){return t.e(62).then(t.bind(null,625))},"v-42571427":function(){return t.e(63).then(t.bind(null,626))},"v-c57e491e":function(){return t.e(64).then(t.bind(null,627))},"v-42d939e7":function(){return t.e(65).then(t.bind(null,628))},"v-7bfc9367":function(){return t.e(66).then(t.bind(null,629))},"v-53742b01":function(){return t.e(67).then(t.bind(null,630))},"v-18e98ab2":function(){return t.e(68).then(t.bind(null,631))},"v-a7ccf908":function(){return t.e(70).then(t.bind(null,632))},"v-6ae185b2":function(){return t.e(69).then(t.bind(null,633))},"v-1e7a2316":function(){return t.e(71).then(t.bind(null,634))},"v-bfdfb6f2":function(){return t.e(72).then(t.bind(null,635))},"v-cec914d2":function(){return t.e(73).then(t.bind(null,636))},"v-65770dca":function(){return t.e(74).then(t.bind(null,637))},"v-d33c36c0":function(){return t.e(75).then(t.bind(null,638))},"v-3b7ceb99":function(){return t.e(76).then(t.bind(null,639))},"v-09f55659":function(){return t.e(77).then(t.bind(null,640))},"v-76d0f302":function(){return t.e(78).then(t.bind(null,641))},"v-734fa6d2":function(){return t.e(79).then(t.bind(null,642))},"v-19a97cc4":function(){return t.e(80).then(t.bind(null,643))},"v-273a5ff2":function(){return t.e(81).then(t.bind(null,644))},"v-7c3b4127":function(){return t.e(82).then(t.bind(null,645))},"v-5b069c87":function(){return t.e(83).then(t.bind(null,646))},"v-bdfb2438":function(){return t.e(84).then(t.bind(null,647))},"v-a2bdfe2e":function(){return t.e(85).then(t.bind(null,648))},"v-624d6567":function(){return t.e(86).then(t.bind(null,649))},"v-2a6aeffc":function(){return t.e(87).then(t.bind(null,650))},"v-4ed47a78":function(){return t.e(88).then(t.bind(null,651))},"v-350b55c4":function(){return t.e(89).then(t.bind(null,652))},"v-859a1432":function(){return t.e(90).then(t.bind(null,653))},"v-f862e242":function(){return t.e(91).then(t.bind(null,654))},"v-911a4cb2":function(){return t.e(92).then(t.bind(null,655))},"v-949ed272":function(){return t.e(93).then(t.bind(null,656))},"v-2687274a":function(){return t.e(94).then(t.bind(null,657))},"v-eb81604a":function(){return t.e(95).then(t.bind(null,658))},"v-3b2ed841":function(){return t.e(96).then(t.bind(null,659))},"v-1b79f9b2":function(){return t.e(97).then(t.bind(null,660))},"v-91a43932":function(){return t.e(98).then(t.bind(null,661))},"v-5b7e22d8":function(){return t.e(99).then(t.bind(null,662))},"v-5c9209e7":function(){return t.e(100).then(t.bind(null,663))},"v-069718c6":function(){return t.e(101).then(t.bind(null,664))},"v-5a548ea7":function(){return t.e(102).then(t.bind(null,665))},"v-275d0591":function(){return t.e(103).then(t.bind(null,666))},"v-6b8e495c":function(){return t.e(104).then(t.bind(null,667))},"v-9aa612be":function(){return t.e(105).then(t.bind(null,668))},"v-7907a92c":function(){return t.e(106).then(t.bind(null,669))},"v-24153e5a":function(){return t.e(107).then(t.bind(null,670))},"v-d9351e72":function(){return t.e(108).then(t.bind(null,671))},"v-12d6d9a7":function(){return t.e(109).then(t.bind(null,672))},"v-67b93205":function(){return t.e(110).then(t.bind(null,673))},"v-6b98a4ad":function(){return t.e(112).then(t.bind(null,674))},"v-1c0a88ad":function(){return t.e(111).then(t.bind(null,675))},"v-6b5017b6":function(){return t.e(113).then(t.bind(null,676))},"v-722c7ae1":function(){return t.e(117).then(t.bind(null,677))},"v-c7d4dc5a":function(){return t.e(118).then(t.bind(null,678))},"v-edee666c":function(){return t.e(119).then(t.bind(null,679))},"v-72dbfc5e":function(){return t.e(120).then(t.bind(null,680))},"v-07325a6c":function(){return t.e(121).then(t.bind(null,681))},"v-6e49a090":function(){return t.e(122).then(t.bind(null,682))},"v-71470c67":function(){return t.e(123).then(t.bind(null,683))},"v-5b68280b":function(){return t.e(116).then(t.bind(null,684))},"v-278cb130":function(){return t.e(124).then(t.bind(null,685))},"v-2413460e":function(){return t.e(126).then(t.bind(null,686))},"v-447f30ed":function(){return t.e(125).then(t.bind(null,687))},"v-3ab1949e":function(){return t.e(127).then(t.bind(null,688))},"v-e3636626":function(){return t.e(128).then(t.bind(null,689))},"v-7e51c139":function(){return t.e(129).then(t.bind(null,690))},"v-6fd6c2ca":function(){return t.e(131).then(t.bind(null,691))},"v-9b7fbf2c":function(){return t.e(130).then(t.bind(null,692))},"v-05f7c36e":function(){return t.e(132).then(t.bind(null,693))},"v-a24a8ab2":function(){return t.e(133).then(t.bind(null,694))},"v-1d3a2736":function(){return t.e(134).then(t.bind(null,695))},"v-0196fb6a":function(){return t.e(135).then(t.bind(null,696))},"v-35ab16a6":function(){return t.e(136).then(t.bind(null,697))},"v-7cc459ac":function(){return t.e(137).then(t.bind(null,698))},"v-a9ae197e":function(){return t.e(138).then(t.bind(null,699))},"v-d66a91a0":function(){return t.e(139).then(t.bind(null,700))},"v-32c4dbca":function(){return t.e(140).then(t.bind(null,701))},"v-116b07e7":function(){return t.e(141).then(t.bind(null,702))},"v-35faa073":function(){return t.e(142).then(t.bind(null,703))},"v-0c342a0a":function(){return t.e(143).then(t.bind(null,704))},"v-1b1ca026":function(){return t.e(144).then(t.bind(null,705))},"v-8626ba16":function(){return t.e(145).then(t.bind(null,706))},"v-d7da2f68":function(){return t.e(146).then(t.bind(null,707))},"v-4b97ba8b":function(){return t.e(147).then(t.bind(null,708))},"v-6b219a6c":function(){return t.e(148).then(t.bind(null,709))},"v-df35d6d8":function(){return t.e(149).then(t.bind(null,710))},"v-10d6ed72":function(){return t.e(150).then(t.bind(null,711))},"v-5879d1de":function(){return t.e(151).then(t.bind(null,712))},"v-7a154764":function(){return t.e(152).then(t.bind(null,713))},"v-8754a666":function(){return t.e(153).then(t.bind(null,714))},"v-0f188b26":function(){return t.e(154).then(t.bind(null,715))},"v-0246fc47":function(){return t.e(155).then(t.bind(null,716))},"v-de88eb66":function(){return t.e(156).then(t.bind(null,717))},"v-51c9fe7e":function(){return t.e(157).then(t.bind(null,718))},"v-6e287744":function(){return t.e(158).then(t.bind(null,719))},"v-be1a0b66":function(){return t.e(159).then(t.bind(null,720))},"v-06605e90":function(){return t.e(160).then(t.bind(null,721))},"v-1e673d87":function(){return t.e(161).then(t.bind(null,722))},"v-244162d4":function(){return t.e(162).then(t.bind(null,723))},"v-40451dd0":function(){return t.e(163).then(t.bind(null,724))},"v-06229c47":function(){return t.e(164).then(t.bind(null,725))},"v-8d798c44":function(){return t.e(165).then(t.bind(null,726))},"v-8d89c36a":function(){return t.e(166).then(t.bind(null,727))},"v-f1ed640a":function(){return t.e(167).then(t.bind(null,728))},"v-ad145af8":function(){return t.e(168).then(t.bind(null,729))},"v-604efc27":function(){return t.e(169).then(t.bind(null,730))},"v-2e8ac566":function(){return t.e(170).then(t.bind(null,731))},"v-03f0b06c":function(){return t.e(171).then(t.bind(null,732))},"v-cb385bb0":function(){return t.e(172).then(t.bind(null,733))},"v-74182564":function(){return t.e(173).then(t.bind(null,734))},"v-0ede2966":function(){return t.e(174).then(t.bind(null,735))},"v-2fc7dd8a":function(){return t.e(175).then(t.bind(null,736))},"v-e3b62984":function(){return t.e(176).then(t.bind(null,737))},"v-3c44de45":function(){return t.e(177).then(t.bind(null,738))},"v-0741be07":function(){return t.e(178).then(t.bind(null,739))},"v-41ff946d":function(){return t.e(179).then(t.bind(null,740))},"v-76f8e447":function(){return t.e(180).then(t.bind(null,741))},"v-81264718":function(){return t.e(181).then(t.bind(null,742))},"v-2db38f71":function(){return t.e(182).then(t.bind(null,743))},"v-22a05178":function(){return t.e(183).then(t.bind(null,744))},"v-6f5582e6":function(){return Promise.all([t.e(0),t.e(6)]).then(t.bind(null,745))},"v-0328ed0a":function(){return t.e(184).then(t.bind(null,746))},"v-3186c650":function(){return t.e(185).then(t.bind(null,747))},"v-68c34360":function(){return t.e(186).then(t.bind(null,748))},"v-6f27372b":function(){return t.e(188).then(t.bind(null,749))},"v-14b3b590":function(){return t.e(187).then(t.bind(null,750))},"v-22cacea6":function(){return t.e(189).then(t.bind(null,751))},"v-31cf86c2":function(){return t.e(190).then(t.bind(null,752))},"v-24505513":function(){return t.e(191).then(t.bind(null,753))},"v-2f38b2cd":function(){return t.e(192).then(t.bind(null,754))},"v-2d1f7017":function(){return t.e(193).then(t.bind(null,755))},"v-66feb918":function(){return t.e(194).then(t.bind(null,756))},"v-4484de06":function(){return t.e(195).then(t.bind(null,757))},"v-12c5050d":function(){return t.e(196).then(t.bind(null,758))},"v-7c3f7872":function(){return t.e(198).then(t.bind(null,759))},"v-6fccf164":function(){return t.e(197).then(t.bind(null,760))},"v-6fe55fb2":function(){return t.e(199).then(t.bind(null,761))},"v-087510e6":function(){return t.e(200).then(t.bind(null,762))},"v-76f71d4d":function(){return t.e(201).then(t.bind(null,763))},"v-47133da7":function(){return t.e(202).then(t.bind(null,764))},"v-56e01078":function(){return t.e(203).then(t.bind(null,765))},"v-2638102d":function(){return t.e(204).then(t.bind(null,766))},"v-6fd2026d":function(){return t.e(205).then(t.bind(null,767))},"v-1eea3c94":function(){return t.e(206).then(t.bind(null,768))},"v-053dc7a7":function(){return t.e(207).then(t.bind(null,769))},"v-6d4c0ee6":function(){return t.e(208).then(t.bind(null,770))},"v-2aeda3f0":function(){return t.e(209).then(t.bind(null,771))},"v-cb64dc94":function(){return t.e(210).then(t.bind(null,772))},"v-67e15bec":function(){return t.e(211).then(t.bind(null,773))},"v-1c60702d":function(){return t.e(212).then(t.bind(null,774))},"v-5de0b9c9":function(){return t.e(213).then(t.bind(null,775))},"v-64a8ceed":function(){return t.e(214).then(t.bind(null,776))},"v-ec1f55f2":function(){return t.e(215).then(t.bind(null,777))},"v-43829904":function(){return t.e(216).then(t.bind(null,778))},"v-2f8a2e55":function(){return t.e(217).then(t.bind(null,779))},"v-711f4807":function(){return t.e(218).then(t.bind(null,780))},"v-1709b7ac":function(){return t.e(220).then(t.bind(null,781))},"v-7f96c701":function(){return t.e(219).then(t.bind(null,782))},"v-5c6e50c4":function(){return t.e(221).then(t.bind(null,783))},"v-67ce5dea":function(){return t.e(222).then(t.bind(null,784))},"v-b92268dc":function(){return t.e(223).then(t.bind(null,785))},"v-30cdd8aa":function(){return t.e(224).then(t.bind(null,786))},"v-77be7816":function(){return t.e(225).then(t.bind(null,787))},"v-86c3715c":function(){return t.e(226).then(t.bind(null,788))},"v-03e14d32":function(){return t.e(227).then(t.bind(null,789))},"v-460671de":function(){return t.e(228).then(t.bind(null,790))},"v-c10acd60":function(){return t.e(229).then(t.bind(null,791))},"v-5f117cb8":function(){return t.e(230).then(t.bind(null,792))},"v-95ad93e6":function(){return t.e(231).then(t.bind(null,793))},"v-0a51c005":function(){return t.e(232).then(t.bind(null,794))},"v-2d3e01cd":function(){return t.e(233).then(t.bind(null,795))},"v-4d0cd04d":function(){return t.e(234).then(t.bind(null,796))},"v-7d5a9373":function(){return t.e(235).then(t.bind(null,797))},"v-2ec7306c":function(){return t.e(236).then(t.bind(null,798))},"v-3427b4ec":function(){return t.e(237).then(t.bind(null,799))},"v-47845ccd":function(){return t.e(238).then(t.bind(null,800))},"v-6971653e":function(){return t.e(239).then(t.bind(null,801))},"v-d21c602e":function(){return t.e(240).then(t.bind(null,802))},"v-713df3aa":function(){return t.e(241).then(t.bind(null,803))},"v-614e421a":function(){return t.e(242).then(t.bind(null,804))},"v-5cebfd60":function(){return t.e(115).then(t.bind(null,805))},"v-4a789dac":function(){return t.e(244).then(t.bind(null,806))},"v-42a65f8d":function(){return t.e(245).then(t.bind(null,807))},"v-3c52b6c0":function(){return t.e(246).then(t.bind(null,808))},"v-d7a396b2":function(){return t.e(247).then(t.bind(null,809))},"v-2cae356c":function(){return t.e(248).then(t.bind(null,810))},"v-2ceda1ea":function(){return t.e(249).then(t.bind(null,811))},"v-4b5829a4":function(){return t.e(250).then(t.bind(null,812))},"v-3665f0bc":function(){return t.e(251).then(t.bind(null,813))},"v-1e5f7a6c":function(){return t.e(253).then(t.bind(null,814))},"v-b7d5d7be":function(){return t.e(252).then(t.bind(null,815))},"v-34b8b412":function(){return t.e(254).then(t.bind(null,816))},"v-15f36787":function(){return t.e(255).then(t.bind(null,817))},"v-0a109a26":function(){return t.e(256).then(t.bind(null,818))},"v-5d80cac8":function(){return t.e(257).then(t.bind(null,819))},"v-105f262a":function(){return t.e(258).then(t.bind(null,820))},"v-19d98050":function(){return t.e(259).then(t.bind(null,821))},"v-2ee1b1e0":function(){return t.e(260).then(t.bind(null,822))},"v-7c38df78":function(){return t.e(261).then(t.bind(null,823))},"v-4f15c9b5":function(){return t.e(262).then(t.bind(null,824))},"v-6b004bb0":function(){return t.e(263).then(t.bind(null,825))},"v-0e5f7767":function(){return t.e(264).then(t.bind(null,826))},"v-7a95866c":function(){return t.e(265).then(t.bind(null,827))},"v-472abdca":function(){return t.e(266).then(t.bind(null,828))},"v-869db188":function(){return t.e(267).then(t.bind(null,829))},"v-2fc8e5ed":function(){return t.e(268).then(t.bind(null,830))},"v-64923fa7":function(){return t.e(269).then(t.bind(null,831))},"v-4ed6ea9a":function(){return t.e(270).then(t.bind(null,832))},"v-12282736":function(){return t.e(271).then(t.bind(null,833))},"v-7def93d5":function(){return t.e(272).then(t.bind(null,834))},"v-45d1bfd4":function(){return t.e(273).then(t.bind(null,835))},"v-66fb014a":function(){return t.e(274).then(t.bind(null,836))},"v-8e4edc24":function(){return t.e(275).then(t.bind(null,837))},"v-4798fbce":function(){return t.e(276).then(t.bind(null,838))},"v-14dd923c":function(){return t.e(277).then(t.bind(null,839))},"v-38983e24":function(){return t.e(278).then(t.bind(null,840))},"v-34c996ae":function(){return t.e(279).then(t.bind(null,841))},"v-30404e92":function(){return t.e(280).then(t.bind(null,842))},"v-1165f877":function(){return t.e(281).then(t.bind(null,843))},"v-a4e897ee":function(){return t.e(282).then(t.bind(null,844))},"v-c67a5246":function(){return t.e(283).then(t.bind(null,569))},"v-18cd99be":function(){return t.e(284).then(t.bind(null,845))},"v-94956944":function(){return t.e(285).then(t.bind(null,846))},"v-4b1784ae":function(){return t.e(286).then(t.bind(null,847))},"v-2c01a8f7":function(){return t.e(287).then(t.bind(null,848))},"v-4cc41921":function(){return t.e(288).then(t.bind(null,849))},"v-fa4af0ea":function(){return t.e(289).then(t.bind(null,850))},"v-159f52b8":function(){return t.e(290).then(t.bind(null,851))},"v-3c880437":function(){return t.e(291).then(t.bind(null,852))},"v-4648f725":function(){return t.e(292).then(t.bind(null,853))},"v-3d488047":function(){return t.e(293).then(t.bind(null,854))},"v-b8aed80e":function(){return t.e(294).then(t.bind(null,855))},"v-d294c11a":function(){return t.e(295).then(t.bind(null,856))},"v-7e7f13b0":function(){return t.e(296).then(t.bind(null,857))},"v-50c4c17c":function(){return t.e(297).then(t.bind(null,858))},"v-21e06e58":function(){return t.e(298).then(t.bind(null,859))},"v-7bb61519":function(){return t.e(299).then(t.bind(null,860))},"v-46832679":function(){return t.e(300).then(t.bind(null,861))},"v-3a384e99":function(){return t.e(301).then(t.bind(null,862))},"v-0f18a2ab":function(){return t.e(302).then(t.bind(null,863))},"v-5d5e3e2b":function(){return t.e(303).then(t.bind(null,864))},"v-55259a32":function(){return t.e(304).then(t.bind(null,865))},"v-283cafc0":function(){return t.e(305).then(t.bind(null,866))},"v-11f80eb1":function(){return t.e(306).then(t.bind(null,867))},"v-cda926b0":function(){return t.e(307).then(t.bind(null,868))},"v-b5a93fd2":function(){return t.e(308).then(t.bind(null,869))},"v-44ea6316":function(){return t.e(309).then(t.bind(null,870))},"v-78c8d138":function(){return t.e(310).then(t.bind(null,871))},"v-46620dca":function(){return t.e(311).then(t.bind(null,872))},"v-d45a52be":function(){return t.e(114).then(t.bind(null,873))},"v-7ee238fd":function(){return t.e(243).then(t.bind(null,874))}};function _l(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Vl=/-(\w)/g,Nl=_l((function(n){return n.replace(Vl,(function(n,e){return e?e.toUpperCase():""}))})),Ll=/\B([A-Z])/g,Bl=_l((function(n){return n.replace(Ll,"-$1").toLowerCase()})),Pl=_l((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Cl(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Pl(Nl(e))):n(Pl(e))||n(Bl(e))}var Dl=Object.assign({},Il,Al),ql=function(n){return Dl[n]},Ml=function(n){return Al[n]},Rl=function(n){return Il[n]},Jl=function(n){return Bi.component(n)};function Ol(n){return Cl(Ml,n)}function Ul(n){return Cl(Rl,n)}function Gl(n){return Cl(ql,n)}function Fl(n){return Cl(Jl,n)}function Zl(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=i(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Fl(e)||!Gl(e)){n.next=5;break}return n.next=3,Gl(e)();case 3:t=n.sent,Bi.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function $l(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}t(60);var Wl=t(79);function Hl(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,i,o=[],l=!0,a=!1;try{for(t=t.call(n);!(l=(r=t.next()).done)&&(o.push(r.value),!e||o.length!==e);l=!0);}catch(n){a=!0,i=n}finally{try{l||null==t.return||t.return()}finally{if(a)throw i}}return o}}(n,e)||Object(Wl.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}t(101),t(43);var Yl=t(187),Xl=t.n(Yl),Ql={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Hl(n,1)[0]})).map((function(n){var e=Hl(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(n[t],'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=na(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(kl.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=ea(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Xl()([{name:"description",content:this.$description}],n,this.siteMeta,ta)},updateCanonicalLink:function(){Kl(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",na(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){ea(null,this.currentMetaTags),Kl()}};function Kl(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function na(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function ea(n,e){if(e&&Object(kl.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function ta(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(112);var ra=t(120),ia={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ra)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+r,l=0;l<t.length;l++){var a=t[l],s=t[l+1],c=0===l&&0===r||r>=a.parentElement.offsetTop+10&&(!s||r<s.parentElement.offsetTop-10),d=decodeURIComponent(this.$route.hash);if(c&&d!==decodeURIComponent(a.hash)){var u=a;if(o===i)for(var p=l+1;p<t.length;p++)if(d===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(u.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},oa=(t(61),t(80)),la=t.n(oa),aa={mounted:function(){var n=this;la.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Bi.component(n.name)||la.a.start(),t()})),this.$router.afterEach((function(){la.a.done(),n.isSidebarOpen=!1}))}};t(42),t(319);function sa(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(111);function ca(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function da(n,e,t){return e&&ca(n.prototype,e),t&&ca(n,t),n}t(320);var ua=function(){function n(){sa(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return da(n,[{key:"show",value:function(n){var e=this,t=n.text,r=void 0===t?"":t,i=n.duration,o=void 0===i?3e3:i,l=document.createElement("div");l.className="message move-in",l.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(l),o>0&&setTimeout((function(){e.close(l)}),o)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),pa={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Click to Copy to Clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new ua).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};t(197),t(83),t(82),t(113),t(322);!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var ma={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},ha={},ga=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},fa=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:ma[n]},va=function n(e,t,r){var i=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))i[n]=t[n];else{var e=n.replace("data","");i.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,o=e.children;i.appendChild(n(t,r,o))})),i},ya=function(n,e,t){var r,i=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==i.length||t?i:i[0]},ba=function(n,e){var t,r,i=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),l=n.match(/<script>([\s\S]+)<\/script>/),a={css:i&&i[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:l&&l[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};a.htmlTpl=ga(a.html),a.jsTpl=(t=a.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),a.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,o=[eval][0](i);return o.template=e,o}(a.js,a.html);var s=fa("vue");return a.jsLib.unshift(s),a},xa=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),l={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return l.htmlTpl=l.html,l.jsTpl=l.js,l.script=(t=l.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),l},wa=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ea(){var n=ya(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=ya(n,"vuepress-plugin-demo-block__code"),t=ya(n,"vuepress-plugin-demo-block__display"),r=ya(n,"vuepress-plugin-demo-block__footer"),i=ya(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),l=decodeURIComponent(n.dataset.config),a=decodeURIComponent(n.dataset.type);l=l?JSON.parse(l):{};var s=e.querySelector("div").clientHeight,c="react"===a?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),o={js:i,css:i.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:wa(n),htmlTpl:ga("")},l=fa("react"),a=fa("reactDOM");return o.jsLib.unshift(l,a),o}(o,l):"vanilla"===a?xa(o,l):ba(o,l),d=va("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(d),d.addEventListener("click",ja.bind(null,d,s,e,r)),fa("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,o=n.cssLib,l=i.concat(o).concat(fa("cssLib")).concat(fa("jsLib")).join(",");return va("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:l}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),fa("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,o=n.cssLib,l=JSON.stringify({css:e,html:t,js:r,js_external:i.concat(fa("jsLib")).join(";"),css_external:o.concat(fa("cssLib")).join(";"),layout:fa("codepenLayout"),js_pre_processor:fa("codepenJsProcessor"),editors:fa("codepenEditors")});return va("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:l}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==l.horizontal?l.horizontal:fa("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!ha[n]){var e=va("style",{innerHTML:n});document.body.appendChild(e),ha[n]=!0}}(c.css),"react"===a)ReactDOM.render(React.createElement(c.js),i);else if("vue"===a){var p=(new(Vue.extend(c.script))).$mount();i.appendChild(p.$el)}else"vanilla"===a&&(i.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ea()}),300)}function ja(n,e,t,r){var i="1"!==n.dataset.isExpand;t.style.height=i?"".concat(e,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var za={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ea()},updated:function(){Ea()}},Ta=(t(190),"auto"),Sa="zoom-in",ka="zoom-out",Ia="grab",Aa="move";function _a(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Va(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Na(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function La(n,e,t){!function(n){var e=Ba,t=Pa;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var r=n.style,i={};for(var o in e)t&&(i[o]=r[o]||""),r[o]=e[o];return i}var Ba="transition",Pa="transform",Ca="transform",Da="transitionend";var qa=function(){},Ma={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:qa,onClose:qa,onGrab:qa,onMove:qa,onRelease:qa,onBeforeOpen:qa,onBeforeClose:qa,onBeforeGrab:qa,onBeforeRelease:qa,onImageLoading:qa,onImageLoaded:qa},Ra={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Oa(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(i)>=o||Math.abs(r)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Ja(n)&&!Oa(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Ja(n)&&!Oa(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Ja(n){return 0===n.button}function Oa(n){return n.metaKey||n.ctrlKey}var Ua={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,La(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),_a(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){La(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Ga="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Fa=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Za=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},$a={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Na(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ia:ka,transition:Ca+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=La(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,La(this.el,{transform:"none"})},grab:function(n,e,t){var r=Wa(),i=r.x-n,o=r.y-e;La(this.el,{cursor:Aa,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Wa(),i=r.x-n,o=r.y-e;La(this.el,{transition:Ca,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){La(this.el,this.styleClose)},restoreOpenStyle:function(){La(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Wa(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,i=r.customSize,o=r.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Ga(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var l=this.rect.width/2,a=this.rect.height/2,s=Wa(),c={x:s.x-l,y:s.y-a},d=c.x/l,u=c.y/a,p=o+Math.min(d,u);if(i&&"string"==typeof i){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,g=parseFloat(i)*m/(100*this.rect.width),f=parseFloat(i)*h/(100*this.rect.height);if(p>g||p>f)return{x:g,y:f}}return{x:p,y:p}}};function Wa(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Ha(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){_a(n,r,e[r],t)}))}var Ya=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create($a),this.overlay=Object.create(Ua),this.handler=Object.create(Ra),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Za({},Ma,e),this.overlay.init(this),this.handler.init(this)}return Fa(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Sa,_a(n,"click",this.handler.click),this.options.preloadImage&&Va(Na(n)));return this}},{key:"config",value:function(n){return n?(Za(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),Va(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),_a(document,"scroll",this.handler.scroll),_a(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&_a(window,"resize",this.handler.resizeWindow);var o=function n(){_a(r,Da,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Ha(document,e.handler,!0),t(r)};return _a(r,Da,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Ta,this.overlay.fadeOut(),this.target.zoomOut(),_a(document,"scroll",this.handler.scroll,!1),_a(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&_a(window,"resize",this.handler.resizeWindow,!1);var r=function r(){_a(t,Da,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Ha(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return _a(t,Da,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var o=function n(){_a(i,Da,n,!1),r(i)};return _a(i,Da,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Aa,this.target.move(n,e,t);var i=this.target.el,o=function n(){_a(i,Da,n,!1),r(i)};return _a(i,Da,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Ta,this.target.restoreOpenStyle();var r=function r(){_a(t,Da,r,!1),n.lock=!1,n.released=!0,e(t)};return _a(t,Da,r),this}}}]),n}(),Xa=".theme-vdoing-content img:not(.no-zoom)",Qa=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),Ka=Number("500"),ns=function(){function n(){sa(this,n),this.instance=new Ya(Qa)}return da(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Xa;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Xa,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ka;setTimeout((function(){return n.update(e)}),t)}}]),n}(),es=[Ql,ia,aa,pa,za,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new ns,this.$vuepress.zooming.updateDelay()}}],ts={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return $l("layout",n),Bi.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},rs=t(21),is=Object(rs.a)(ts,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(kl.a)(t));break;default:throw new Error("Unknown option name.")}}(is,"mixins",es);var os=[{name:"v-3dfeac0a",path:"/algo/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3dfeac0a").then(t)}},{path:"/algo/index.html",redirect:"/algo/"},{path:"/00.目录页/01.算法.html",redirect:"/algo/"},{name:"v-64dafe41",path:"/technology/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-64dafe41").then(t)}},{path:"/technology/index.html",redirect:"/technology/"},{path:"/00.目录页/03.技术.html",redirect:"/technology/"},{name:"v-5e3aa7ac",path:"/ui/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5e3aa7ac").then(t)}},{path:"/ui/index.html",redirect:"/ui/"},{path:"/00.目录页/02.页面.html",redirect:"/ui/"},{name:"v-73c0e481",path:"/web/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-73c0e481").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/00.目录页/04.前端.html",redirect:"/web/"},{name:"v-14d384af",path:"/more/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-14d384af").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/05.更多.html",redirect:"/more/"},{name:"v-254c0b14",path:"/leetcode1/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-254c0b14").then(t)}},{path:"/leetcode1/index.html",redirect:"/leetcode1/"},{path:"/01.算法/24.leetcode/10001.leetcode1 两数之和[简单难度].html",redirect:"/leetcode1/"},{name:"v-39f537e0",path:"/p/244378/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-39f537e0").then(t)}},{path:"/p/244378/index.html",redirect:"/p/244378/"},{path:"/01.算法/24.leetcode/10002.leetcode2 Add Two Numbers.html",redirect:"/p/244378/"},{name:"v-11eba928",path:"/p/a2420b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-11eba928").then(t)}},{path:"/p/a2420b/index.html",redirect:"/p/a2420b/"},{path:"/01.算法/24.leetcode/10003.leetcode3 Longest Substring Without Repeating Characters.html",redirect:"/p/a2420b/"},{name:"v-2dfb486b",path:"/leetcode4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2dfb486b").then(t)}},{path:"/leetcode4/index.html",redirect:"/leetcode4/"},{path:"/01.算法/24.leetcode/10004.leetcode4 寻找两个正序数组的中位数[困难难度].html",redirect:"/leetcode4/"},{name:"v-4abfd090",path:"/p/804ab4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4abfd090").then(t)}},{path:"/p/804ab4/index.html",redirect:"/p/804ab4/"},{path:"/01.算法/24.leetcode/10005.leetcode5 Longest Palindromic Substring.html",redirect:"/p/804ab4/"},{name:"v-4a700847",path:"/p/a57b35/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4a700847").then(t)}},{path:"/p/a57b35/index.html",redirect:"/p/a57b35/"},{path:"/01.算法/24.leetcode/10006.leetcode6 ZigZag Conversion.html",redirect:"/p/a57b35/"},{name:"v-176ecc6d",path:"/p/786ee4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-176ecc6d").then(t)}},{path:"/p/786ee4/index.html",redirect:"/p/786ee4/"},{path:"/01.算法/24.leetcode/10007.leetcode7 Reverse Integer.html",redirect:"/p/786ee4/"},{name:"v-29b3469e",path:"/p/d5e058/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-29b3469e").then(t)}},{path:"/p/d5e058/index.html",redirect:"/p/d5e058/"},{path:"/01.算法/24.leetcode/10008.leetcode8 String to Integer (atoi).html",redirect:"/p/d5e058/"},{name:"v-6b8abe87",path:"/p/d52cd1/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6b8abe87").then(t)}},{path:"/p/d52cd1/index.html",redirect:"/p/d52cd1/"},{path:"/01.算法/24.leetcode/10009.leetcode9 Palindrome Number.html",redirect:"/p/d52cd1/"},{name:"v-4e764050",path:"/p/10dbda/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4e764050").then(t)}},{path:"/p/10dbda/index.html",redirect:"/p/10dbda/"},{path:"/01.算法/24.leetcode/10010.leetcode10 Regular Expression Matching.html",redirect:"/p/10dbda/"},{name:"v-f5686124",path:"/leetcode11/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-f5686124").then(t)}},{path:"/leetcode11/index.html",redirect:"/leetcode11/"},{path:"/01.算法/24.leetcode/10011.leetcode11-盛最多水的容器[中等难度].html",redirect:"/leetcode11/"},{name:"v-3ef721a4",path:"/p/a5942d/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3ef721a4").then(t)}},{path:"/p/a5942d/index.html",redirect:"/p/a5942d/"},{path:"/01.算法/24.leetcode/10012.leetcode12 Integer to Roman.html",redirect:"/p/a5942d/"},{name:"v-56ad6238",path:"/p/07f2a8/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-56ad6238").then(t)}},{path:"/p/07f2a8/index.html",redirect:"/p/07f2a8/"},{path:"/01.算法/24.leetcode/10013.leetcode13 Roman to Integer.html",redirect:"/p/07f2a8/"},{name:"v-057873f0",path:"/p/bbae3d/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-057873f0").then(t)}},{path:"/p/bbae3d/index.html",redirect:"/p/bbae3d/"},{path:"/01.算法/24.leetcode/10014.leetcode14 Longest Common Prefix.html",redirect:"/p/bbae3d/"},{name:"v-365c4844",path:"/p/42c6e3/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-365c4844").then(t)}},{path:"/p/42c6e3/index.html",redirect:"/p/42c6e3/"},{path:"/01.算法/24.leetcode/10015.leetcode15 3Sum.html",redirect:"/p/42c6e3/"},{name:"v-75251f27",path:"/p/5fe737/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-75251f27").then(t)}},{path:"/p/5fe737/index.html",redirect:"/p/5fe737/"},{path:"/01.算法/24.leetcode/10016.leetcode16 3Sum Closest.html",redirect:"/p/5fe737/"},{name:"v-5873af27",path:"/p/942fa8/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5873af27").then(t)}},{path:"/p/942fa8/index.html",redirect:"/p/942fa8/"},{path:"/01.算法/24.leetcode/10017.leetcode17 Letter Combinations of a Phone Number.html",redirect:"/p/942fa8/"},{name:"v-406283e4",path:"/p/1935e9/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-406283e4").then(t)}},{path:"/p/1935e9/index.html",redirect:"/p/1935e9/"},{path:"/01.算法/24.leetcode/10018.leetcode18 4Sum.html",redirect:"/p/1935e9/"},{name:"v-ff6467ec",path:"/p/e99d7b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-ff6467ec").then(t)}},{path:"/p/e99d7b/index.html",redirect:"/p/e99d7b/"},{path:"/01.算法/24.leetcode/10019.leetcode19 Remove Nth Node From End of List.html",redirect:"/p/e99d7b/"},{name:"v-28ca9b09",path:"/p/0afb6c/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-28ca9b09").then(t)}},{path:"/p/0afb6c/index.html",redirect:"/p/0afb6c/"},{path:"/01.算法/24.leetcode/10020.leetcode20 Valid Parentheses.html",redirect:"/p/0afb6c/"},{name:"v-6e501801",path:"/p/163bb4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6e501801").then(t)}},{path:"/p/163bb4/index.html",redirect:"/p/163bb4/"},{path:"/01.算法/24.leetcode/10021.leetcode21 Merge Two Sorted Lists.html",redirect:"/p/163bb4/"},{name:"v-40daeab2",path:"/p/cc1223/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-40daeab2").then(t)}},{path:"/p/cc1223/index.html",redirect:"/p/cc1223/"},{path:"/01.算法/24.leetcode/10022.leetcode22 Generate Parentheses.html",redirect:"/p/cc1223/"},{name:"v-076af421",path:"/p/e16635/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-076af421").then(t)}},{path:"/p/e16635/index.html",redirect:"/p/e16635/"},{path:"/01.算法/24.leetcode/10023.leetcode23 Merge k Sorted Lists.html",redirect:"/p/e16635/"},{name:"v-69d0e2bb",path:"/p/5421f4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-69d0e2bb").then(t)}},{path:"/p/5421f4/index.html",redirect:"/p/5421f4/"},{path:"/01.算法/24.leetcode/10024.leetcode24 Swap Nodes in Pairs.html",redirect:"/p/5421f4/"},{name:"v-445308e1",path:"/p/222c60/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-445308e1").then(t)}},{path:"/p/222c60/index.html",redirect:"/p/222c60/"},{path:"/01.算法/24.leetcode/10025.leetcode25 Reverse Nodes in k-Group.html",redirect:"/p/222c60/"},{name:"v-9638d2dc",path:"/p/dbd8bb/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-9638d2dc").then(t)}},{path:"/p/dbd8bb/index.html",redirect:"/p/dbd8bb/"},{path:"/01.算法/24.leetcode/10026.leetcode26 Remove Duplicates from Sorted Array.html",redirect:"/p/dbd8bb/"},{name:"v-eed23472",path:"/p/ac2720/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-eed23472").then(t)}},{path:"/p/ac2720/index.html",redirect:"/p/ac2720/"},{path:"/01.算法/24.leetcode/10027.leetcode27 Remove Element.html",redirect:"/p/ac2720/"},{name:"v-3ada3421",path:"/p/612dd5/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3ada3421").then(t)}},{path:"/p/612dd5/index.html",redirect:"/p/612dd5/"},{path:"/01.算法/24.leetcode/10028.leetcode28 Implement strStr().html",redirect:"/p/612dd5/"},{name:"v-d4112a68",path:"/p/35bd07/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-d4112a68").then(t)}},{path:"/p/35bd07/index.html",redirect:"/p/35bd07/"},{path:"/01.算法/24.leetcode/10029.leetcode29 Divide Two Integers.html",redirect:"/p/35bd07/"},{name:"v-8bdc6966",path:"/p/62136e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-8bdc6966").then(t)}},{path:"/p/62136e/index.html",redirect:"/p/62136e/"},{path:"/01.算法/24.leetcode/10030.leetcode30 Substring with Concatenation of All Words.html",redirect:"/p/62136e/"},{name:"v-28f18332",path:"/p/d4a741/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-28f18332").then(t)}},{path:"/p/d4a741/index.html",redirect:"/p/d4a741/"},{path:"/01.算法/24.leetcode/10031.leetcode31 Next Permutation.html",redirect:"/p/d4a741/"},{name:"v-197875f8",path:"/p/d12644/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-197875f8").then(t)}},{path:"/p/d12644/index.html",redirect:"/p/d12644/"},{path:"/01.算法/24.leetcode/10032.leetcode32 Longest Valid Parentheses.html",redirect:"/p/d12644/"},{name:"v-6a2136f8",path:"/p/584160/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6a2136f8").then(t)}},{path:"/p/584160/index.html",redirect:"/p/584160/"},{path:"/01.算法/24.leetcode/10033.leetcode33 Search in Rotated Sorted Array.html",redirect:"/p/584160/"},{name:"v-fc4d86a6",path:"/p/f47e3f/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-fc4d86a6").then(t)}},{path:"/p/f47e3f/index.html",redirect:"/p/f47e3f/"},{path:"/01.算法/24.leetcode/10034.leetcode34 Find First and Last Position of Element in Sorted Array.html",redirect:"/p/f47e3f/"},{name:"v-0f2635e4",path:"/p/b5f6ea/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0f2635e4").then(t)}},{path:"/p/b5f6ea/index.html",redirect:"/p/b5f6ea/"},{path:"/01.算法/24.leetcode/10035.leetcode35 Search Insert Position.html",redirect:"/p/b5f6ea/"},{name:"v-0152edd7",path:"/leetcode36/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0152edd7").then(t)}},{path:"/leetcode36/index.html",redirect:"/leetcode36/"},{path:"/01.算法/24.leetcode/10036.leetcode36 有效的数独[中等难度].html",redirect:"/leetcode36/"},{name:"v-6f0ca157",path:"/p/1a4005/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6f0ca157").then(t)}},{path:"/p/1a4005/index.html",redirect:"/p/1a4005/"},{path:"/01.算法/24.leetcode/10037.leetcode37 Sudoku Solver.html",redirect:"/p/1a4005/"},{name:"v-e038dfdc",path:"/leetcode38/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-e038dfdc").then(t)}},{path:"/leetcode38/index.html",redirect:"/leetcode38/"},{path:"/01.算法/24.leetcode/10038.leetcode38 外观数列(报数)【中等难度】.html",redirect:"/leetcode38/"},{name:"v-f821d6fe",path:"/p/ca29a3/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-f821d6fe").then(t)}},{path:"/p/ca29a3/index.html",redirect:"/p/ca29a3/"},{path:"/01.算法/24.leetcode/10039.leetcode39 Combination Sum.html",redirect:"/p/ca29a3/"},{name:"v-47723afe",path:"/p/3104b4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-47723afe").then(t)}},{path:"/p/3104b4/index.html",redirect:"/p/3104b4/"},{path:"/01.算法/24.leetcode/10040.leetcode40 Combination Sum II.html",redirect:"/p/3104b4/"},{name:"v-0acd08c8",path:"/p/56c9c9/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0acd08c8").then(t)}},{path:"/p/56c9c9/index.html",redirect:"/p/56c9c9/"},{path:"/01.算法/24.leetcode/10041.leetcode41 First Missing Positive-zh.html",redirect:"/p/56c9c9/"},{name:"v-1eb400c4",path:"/p/41be27/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1eb400c4").then(t)}},{path:"/p/41be27/index.html",redirect:"/p/41be27/"},{path:"/01.算法/24.leetcode/10042.leetcode42 Trapping Rain Water-zh.html",redirect:"/p/41be27/"},{name:"v-3b8af4e5",path:"/p/b5dd5b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3b8af4e5").then(t)}},{path:"/p/b5dd5b/index.html",redirect:"/p/b5dd5b/"},{path:"/01.算法/24.leetcode/10043.leetcode43 Multiply Strings-zh.html",redirect:"/p/b5dd5b/"},{name:"v-69cddf07",path:"/p/6a9e78/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-69cddf07").then(t)}},{path:"/p/6a9e78/index.html",redirect:"/p/6a9e78/"},{path:"/01.算法/24.leetcode/10044.leetcode44 Wildcard Matching-zh.html",redirect:"/p/6a9e78/"},{name:"v-23a69c14",path:"/p/fce74b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-23a69c14").then(t)}},{path:"/p/fce74b/index.html",redirect:"/p/fce74b/"},{path:"/01.算法/24.leetcode/10045.leetcode45 Jump Game II-zh.html",redirect:"/p/fce74b/"},{name:"v-34822816",path:"/p/64e1ed/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-34822816").then(t)}},{path:"/p/64e1ed/index.html",redirect:"/p/64e1ed/"},{path:"/01.算法/24.leetcode/10046.leetcode46 Permutations-zh.html",redirect:"/p/64e1ed/"},{name:"v-14075572",path:"/p/8e858c/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-14075572").then(t)}},{path:"/p/8e858c/index.html",redirect:"/p/8e858c/"},{path:"/01.算法/24.leetcode/10047.leetcode47 Permutations II-zh.html",redirect:"/p/8e858c/"},{name:"v-3f1c5b45",path:"/p/deb8c7/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3f1c5b45").then(t)}},{path:"/p/deb8c7/index.html",redirect:"/p/deb8c7/"},{path:"/01.算法/24.leetcode/10048.leetcode48 Rotate Image-zh.html",redirect:"/p/deb8c7/"},{name:"v-3d9e1e51",path:"/p/15206f/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3d9e1e51").then(t)}},{path:"/p/15206f/index.html",redirect:"/p/15206f/"},{path:"/01.算法/24.leetcode/10049.leetcode49 Group Anagrams-zh.html",redirect:"/p/15206f/"},{name:"v-63be4647",path:"/p/f37caf/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-63be4647").then(t)}},{path:"/p/f37caf/index.html",redirect:"/p/f37caf/"},{path:"/01.算法/24.leetcode/10050.leetcode50 Pow(x, n)-zh.html",redirect:"/p/f37caf/"},{name:"v-d6e0aee8",path:"/p/890db5/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-d6e0aee8").then(t)}},{path:"/p/890db5/index.html",redirect:"/p/890db5/"},{path:"/01.算法/24.leetcode/10051.leetcode51 N-Queens-zh.html",redirect:"/p/890db5/"},{name:"v-42571427",path:"/p/06718e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-42571427").then(t)}},{path:"/p/06718e/index.html",redirect:"/p/06718e/"},{path:"/01.算法/24.leetcode/10052.leetcode52 N-Queens II-zh.html",redirect:"/p/06718e/"},{name:"v-c57e491e",path:"/p/827961/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-c57e491e").then(t)}},{path:"/p/827961/index.html",redirect:"/p/827961/"},{path:"/01.算法/24.leetcode/10053.leetcode53 Maximum Subarray-zh.html",redirect:"/p/827961/"},{name:"v-42d939e7",path:"/p/b4f91b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-42d939e7").then(t)}},{path:"/p/b4f91b/index.html",redirect:"/p/b4f91b/"},{path:"/01.算法/24.leetcode/10054.leetcode54 Spiral Matrix-zh.html",redirect:"/p/b4f91b/"},{name:"v-7bfc9367",path:"/p/30906e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7bfc9367").then(t)}},{path:"/p/30906e/index.html",redirect:"/p/30906e/"},{path:"/01.算法/24.leetcode/10055.leetcode55 Jump Game-zh.html",redirect:"/p/30906e/"},{name:"v-53742b01",path:"/p/f65cda/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-53742b01").then(t)}},{path:"/p/f65cda/index.html",redirect:"/p/f65cda/"},{path:"/01.算法/24.leetcode/10056.leetcode56 Merge Intervals-zh.html",redirect:"/p/f65cda/"},{name:"v-18e98ab2",path:"/p/93b3a2/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-18e98ab2").then(t)}},{path:"/p/93b3a2/index.html",redirect:"/p/93b3a2/"},{path:"/01.算法/24.leetcode/10057.leetcode57 Insert Interval-zh.html",redirect:"/p/93b3a2/"},{name:"v-a7ccf908",path:"/p/1f8940/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-a7ccf908").then(t)}},{path:"/p/1f8940/index.html",redirect:"/p/1f8940/"},{path:"/01.算法/24.leetcode/10059.leetcode59 Spiral Matrix II-zh.html",redirect:"/p/1f8940/"},{name:"v-6ae185b2",path:"/p/3d955e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6ae185b2").then(t)}},{path:"/p/3d955e/index.html",redirect:"/p/3d955e/"},{path:"/01.算法/24.leetcode/10058.leetcode58 Length of Last Word-zh.html",redirect:"/p/3d955e/"},{name:"v-1e7a2316",path:"/p/a46975/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1e7a2316").then(t)}},{path:"/p/a46975/index.html",redirect:"/p/a46975/"},{path:"/01.算法/24.leetcode/10060.leetcode60 Permutation Sequence-zh.html",redirect:"/p/a46975/"},{name:"v-bfdfb6f2",path:"/p/fe1724/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-bfdfb6f2").then(t)}},{path:"/p/fe1724/index.html",redirect:"/p/fe1724/"},{path:"/01.算法/24.leetcode/10061.leetcode61 Rotate List-zh.html",redirect:"/p/fe1724/"},{name:"v-cec914d2",path:"/p/665af6/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-cec914d2").then(t)}},{path:"/p/665af6/index.html",redirect:"/p/665af6/"},{path:"/01.算法/24.leetcode/10062.leetcode62 Unique Paths-zh.html",redirect:"/p/665af6/"},{name:"v-65770dca",path:"/p/641106/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-65770dca").then(t)}},{path:"/p/641106/index.html",redirect:"/p/641106/"},{path:"/01.算法/24.leetcode/10063.leetcode63 Unique Paths II-zh.html",redirect:"/p/641106/"},{name:"v-d33c36c0",path:"/p/3cbab8/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-d33c36c0").then(t)}},{path:"/p/3cbab8/index.html",redirect:"/p/3cbab8/"},{path:"/01.算法/24.leetcode/10064.leetcode64 Minimum Path Sum-zh.html",redirect:"/p/3cbab8/"},{name:"v-3b7ceb99",path:"/p/d84d4d/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3b7ceb99").then(t)}},{path:"/p/d84d4d/index.html",redirect:"/p/d84d4d/"},{path:"/01.算法/24.leetcode/10065.leetcode65 Valid Number-zh.html",redirect:"/p/d84d4d/"},{name:"v-09f55659",path:"/p/a9a5e7/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-09f55659").then(t)}},{path:"/p/a9a5e7/index.html",redirect:"/p/a9a5e7/"},{path:"/01.算法/24.leetcode/10066.leetcode66 Plus One-zh.html",redirect:"/p/a9a5e7/"},{name:"v-76d0f302",path:"/p/7ca8bd/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-76d0f302").then(t)}},{path:"/p/7ca8bd/index.html",redirect:"/p/7ca8bd/"},{path:"/01.算法/24.leetcode/10067.leetcode67 Add Binary-zh.html",redirect:"/p/7ca8bd/"},{name:"v-734fa6d2",path:"/p/d7cf8a/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-734fa6d2").then(t)}},{path:"/p/d7cf8a/index.html",redirect:"/p/d7cf8a/"},{path:"/01.算法/24.leetcode/10068.leetcode68 Text Justification-zh.html",redirect:"/p/d7cf8a/"},{name:"v-19a97cc4",path:"/p/565a77/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-19a97cc4").then(t)}},{path:"/p/565a77/index.html",redirect:"/p/565a77/"},{path:"/01.算法/24.leetcode/10069.leetcode69 Sqrt(x)-zh.html",redirect:"/p/565a77/"},{name:"v-273a5ff2",path:"/p/fa8040/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-273a5ff2").then(t)}},{path:"/p/fa8040/index.html",redirect:"/p/fa8040/"},{path:"/01.算法/24.leetcode/10070.leetcode70 Climbing Stairs-zh.html",redirect:"/p/fa8040/"},{name:"v-7c3b4127",path:"/p/ba0add/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7c3b4127").then(t)}},{path:"/p/ba0add/index.html",redirect:"/p/ba0add/"},{path:"/01.算法/24.leetcode/10071.leetcode71 Simplify Path-zh.html",redirect:"/p/ba0add/"},{name:"v-5b069c87",path:"/p/143034/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5b069c87").then(t)}},{path:"/p/143034/index.html",redirect:"/p/143034/"},{path:"/01.算法/24.leetcode/10072.leetcode72 Edit Distance-zh.html",redirect:"/p/143034/"},{name:"v-bdfb2438",path:"/p/1a45c9/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-bdfb2438").then(t)}},{path:"/p/1a45c9/index.html",redirect:"/p/1a45c9/"},{path:"/01.算法/24.leetcode/10073.leetcode73 Set Matrix Zeroes-zh.html",redirect:"/p/1a45c9/"},{name:"v-a2bdfe2e",path:"/p/8b2390/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-a2bdfe2e").then(t)}},{path:"/p/8b2390/index.html",redirect:"/p/8b2390/"},{path:"/01.算法/24.leetcode/10074.leetcode74 Search a 2D Matrix-zh.html",redirect:"/p/8b2390/"},{name:"v-624d6567",path:"/p/d1d03e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-624d6567").then(t)}},{path:"/p/d1d03e/index.html",redirect:"/p/d1d03e/"},{path:"/01.算法/24.leetcode/10075.leetcode75 Sort Colors-zh.html",redirect:"/p/d1d03e/"},{name:"v-2a6aeffc",path:"/p/8151b3/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2a6aeffc").then(t)}},{path:"/p/8151b3/index.html",redirect:"/p/8151b3/"},{path:"/01.算法/24.leetcode/10076.leetcode76 Minimum Window Substring-zh.html",redirect:"/p/8151b3/"},{name:"v-4ed47a78",path:"/p/c30f65/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4ed47a78").then(t)}},{path:"/p/c30f65/index.html",redirect:"/p/c30f65/"},{path:"/01.算法/24.leetcode/10077.leetcode77 Combinations-zh.html",redirect:"/p/c30f65/"},{name:"v-350b55c4",path:"/p/be20e0/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-350b55c4").then(t)}},{path:"/p/be20e0/index.html",redirect:"/p/be20e0/"},{path:"/01.算法/24.leetcode/10078.leetcode78 Subsets-zh.html",redirect:"/p/be20e0/"},{name:"v-859a1432",path:"/p/832da5/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-859a1432").then(t)}},{path:"/p/832da5/index.html",redirect:"/p/832da5/"},{path:"/01.算法/24.leetcode/10079.leetcode79 Word Search-zh.html",redirect:"/p/832da5/"},{name:"v-f862e242",path:"/p/2f5116/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-f862e242").then(t)}},{path:"/p/2f5116/index.html",redirect:"/p/2f5116/"},{path:"/01.算法/24.leetcode/10080.leetcode80 Remove Duplicates from Sorted Array II-zh.html",redirect:"/p/2f5116/"},{name:"v-911a4cb2",path:"/p/d72c14/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-911a4cb2").then(t)}},{path:"/p/d72c14/index.html",redirect:"/p/d72c14/"},{path:"/01.算法/24.leetcode/10081.leetcode81 Search in Rotated Sorted Array II-zh.html",redirect:"/p/d72c14/"},{name:"v-949ed272",path:"/p/3f819f/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-949ed272").then(t)}},{path:"/p/3f819f/index.html",redirect:"/p/3f819f/"},{path:"/01.算法/24.leetcode/10082.leetcode82 Remove Duplicates from Sorted List II-zh.html",redirect:"/p/3f819f/"},{name:"v-2687274a",path:"/p/54a9ff/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2687274a").then(t)}},{path:"/p/54a9ff/index.html",redirect:"/p/54a9ff/"},{path:"/01.算法/24.leetcode/10083.leetcode83 Remove Duplicates from Sorted List-zh.html",redirect:"/p/54a9ff/"},{name:"v-eb81604a",path:"/p/61c799/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-eb81604a").then(t)}},{path:"/p/61c799/index.html",redirect:"/p/61c799/"},{path:"/01.算法/24.leetcode/10084.leetcode84 Largest Rectangle in Histogram-zh.html",redirect:"/p/61c799/"},{name:"v-3b2ed841",path:"/p/54fa5d/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3b2ed841").then(t)}},{path:"/p/54fa5d/index.html",redirect:"/p/54fa5d/"},{path:"/01.算法/24.leetcode/10085.leetcode85 Maximal Rectangle-zh.html",redirect:"/p/54fa5d/"},{name:"v-1b79f9b2",path:"/p/4b39e8/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1b79f9b2").then(t)}},{path:"/p/4b39e8/index.html",redirect:"/p/4b39e8/"},{path:"/01.算法/24.leetcode/10086.leetcode86 Partition List-zh.html",redirect:"/p/4b39e8/"},{name:"v-91a43932",path:"/p/9b9658/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-91a43932").then(t)}},{path:"/p/9b9658/index.html",redirect:"/p/9b9658/"},{path:"/01.算法/24.leetcode/10087.leetcode87 Scramble String-zh.html",redirect:"/p/9b9658/"},{name:"v-5b7e22d8",path:"/p/9ab86e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5b7e22d8").then(t)}},{path:"/p/9ab86e/index.html",redirect:"/p/9ab86e/"},{path:"/01.算法/24.leetcode/10088.leetcode88 Merge Sorted Array-zh.html",redirect:"/p/9ab86e/"},{name:"v-5c9209e7",path:"/p/dc9180/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5c9209e7").then(t)}},{path:"/p/dc9180/index.html",redirect:"/p/dc9180/"},{path:"/01.算法/24.leetcode/10089.leetcode89 Gray Code-zh.html",redirect:"/p/dc9180/"},{name:"v-069718c6",path:"/p/8df0f5/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-069718c6").then(t)}},{path:"/p/8df0f5/index.html",redirect:"/p/8df0f5/"},{path:"/01.算法/24.leetcode/10090.leetcode90 Subsets II-zh.html",redirect:"/p/8df0f5/"},{name:"v-5a548ea7",path:"/p/04a12e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5a548ea7").then(t)}},{path:"/p/04a12e/index.html",redirect:"/p/04a12e/"},{path:"/01.算法/24.leetcode/10091.leetcode91 Decode Ways-zh.html",redirect:"/p/04a12e/"},{name:"v-275d0591",path:"/p/4999f0/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-275d0591").then(t)}},{path:"/p/4999f0/index.html",redirect:"/p/4999f0/"},{path:"/01.算法/24.leetcode/10092.leetcode92 Reverse Linked List II-zh.html",redirect:"/p/4999f0/"},{name:"v-6b8e495c",path:"/p/81aad5/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6b8e495c").then(t)}},{path:"/p/81aad5/index.html",redirect:"/p/81aad5/"},{path:"/01.算法/24.leetcode/10093.leetcode93 Restore IP Addresses-zh.html",redirect:"/p/81aad5/"},{name:"v-9aa612be",path:"/p/6844b9/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-9aa612be").then(t)}},{path:"/p/6844b9/index.html",redirect:"/p/6844b9/"},{path:"/01.算法/24.leetcode/10094.leetcode94 Binary Tree Inorder Traversal-zh.html",redirect:"/p/6844b9/"},{name:"v-7907a92c",path:"/p/65b61c/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7907a92c").then(t)}},{path:"/p/65b61c/index.html",redirect:"/p/65b61c/"},{path:"/01.算法/24.leetcode/10095.leetcode95 Unique Binary Search Trees II-zh.html",redirect:"/p/65b61c/"},{name:"v-24153e5a",path:"/p/b6afec/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-24153e5a").then(t)}},{path:"/p/b6afec/index.html",redirect:"/p/b6afec/"},{path:"/01.算法/24.leetcode/10096.leetcode96 Unique Binary Search Trees-zh.html",redirect:"/p/b6afec/"},{name:"v-d9351e72",path:"/p/53d753/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-d9351e72").then(t)}},{path:"/p/53d753/index.html",redirect:"/p/53d753/"},{path:"/01.算法/24.leetcode/10097.leetcode97 Interleaving String-zh.html",redirect:"/p/53d753/"},{name:"v-12d6d9a7",path:"/p/64d24d/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-12d6d9a7").then(t)}},{path:"/p/64d24d/index.html",redirect:"/p/64d24d/"},{path:"/01.算法/24.leetcode/10098.leetcode98 Validate Binary Search Tree-zh.html",redirect:"/p/64d24d/"},{name:"v-67b93205",path:"/p/4c13f1/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-67b93205").then(t)}},{path:"/p/4c13f1/index.html",redirect:"/p/4c13f1/"},{path:"/01.算法/24.leetcode/10099.leetcode99 Recover Binary Search Tree-zh.html",redirect:"/p/4c13f1/"},{name:"v-6b98a4ad",path:"/p/f654ba/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6b98a4ad").then(t)}},{path:"/p/f654ba/index.html",redirect:"/p/f654ba/"},{path:"/01.算法/24.leetcode/10101.leetcode101 Symmetric Tree-zh.html",redirect:"/p/f654ba/"},{name:"v-1c0a88ad",path:"/p/7662fd/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1c0a88ad").then(t)}},{path:"/p/7662fd/index.html",redirect:"/p/7662fd/"},{path:"/01.算法/24.leetcode/10100.leetcode100 Same Tree-zh.html",redirect:"/p/7662fd/"},{name:"v-6b5017b6",path:"/p/74e9b3/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6b5017b6").then(t)}},{path:"/p/74e9b3/index.html",redirect:"/p/74e9b3/"},{path:"/01.算法/24.leetcode/10102.leetcode102 Binary Tree Level Order Traversal-zh.html",redirect:"/p/74e9b3/"},{name:"v-722c7ae1",path:"/p/bb567d/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-722c7ae1").then(t)}},{path:"/p/bb567d/index.html",redirect:"/p/bb567d/"},{path:"/01.算法/24.leetcode/10106.leetcode106 Construct Binary Tree from Inorder and Postorder Traversal-zh.html",redirect:"/p/bb567d/"},{name:"v-c7d4dc5a",path:"/p/cdb832/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-c7d4dc5a").then(t)}},{path:"/p/cdb832/index.html",redirect:"/p/cdb832/"},{path:"/01.算法/24.leetcode/10107.leetcode107 Binary Tree Level Order Traversal II-zh.html",redirect:"/p/cdb832/"},{name:"v-edee666c",path:"/p/ea87fb/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-edee666c").then(t)}},{path:"/p/ea87fb/index.html",redirect:"/p/ea87fb/"},{path:"/01.算法/24.leetcode/10108.leetcode108 Convert Sorted Array to Binary Search Tree-zh.html",redirect:"/p/ea87fb/"},{name:"v-72dbfc5e",path:"/p/bc54a6/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-72dbfc5e").then(t)}},{path:"/p/bc54a6/index.html",redirect:"/p/bc54a6/"},{path:"/01.算法/24.leetcode/10109.leetcode109 Convert Sorted List to Binary Search Tree-zh.html",redirect:"/p/bc54a6/"},{name:"v-07325a6c",path:"/p/00d991/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-07325a6c").then(t)}},{path:"/p/00d991/index.html",redirect:"/p/00d991/"},{path:"/01.算法/24.leetcode/10110.leetcode110 Balanced Binary Tree-zh.html",redirect:"/p/00d991/"},{name:"v-6e49a090",path:"/p/14281b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6e49a090").then(t)}},{path:"/p/14281b/index.html",redirect:"/p/14281b/"},{path:"/01.算法/24.leetcode/10111.leetcode111 Minimum Depth of Binary Tree-zh.html",redirect:"/p/14281b/"},{name:"v-71470c67",path:"/p/a45972/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-71470c67").then(t)}},{path:"/p/a45972/index.html",redirect:"/p/a45972/"},{path:"/01.算法/24.leetcode/10112.leetcode112 Path Sum-zh.html",redirect:"/p/a45972/"},{name:"v-5b68280b",path:"/p/5990ea/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5b68280b").then(t)}},{path:"/p/5990ea/index.html",redirect:"/p/5990ea/"},{path:"/01.算法/24.leetcode/10105.leetcode105 Construct Binary Tree from Preorder and Inorder Traversal-zh.html",redirect:"/p/5990ea/"},{name:"v-278cb130",path:"/p/056cf0/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-278cb130").then(t)}},{path:"/p/056cf0/index.html",redirect:"/p/056cf0/"},{path:"/01.算法/24.leetcode/10113.leetcode113 Path Sum II-zh.html",redirect:"/p/056cf0/"},{name:"v-2413460e",path:"/p/32c581/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2413460e").then(t)}},{path:"/p/32c581/index.html",redirect:"/p/32c581/"},{path:"/01.算法/24.leetcode/10115.leetcode115 Distinct Subsequences-zh.html",redirect:"/p/32c581/"},{name:"v-447f30ed",path:"/p/22ae1f/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-447f30ed").then(t)}},{path:"/p/22ae1f/index.html",redirect:"/p/22ae1f/"},{path:"/01.算法/24.leetcode/10114.leetcode114 Flatten Binary Tree to Linked List-zh.html",redirect:"/p/22ae1f/"},{name:"v-3ab1949e",path:"/p/f0fba3/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3ab1949e").then(t)}},{path:"/p/f0fba3/index.html",redirect:"/p/f0fba3/"},{path:"/01.算法/24.leetcode/10116.leetcode116 Populating Next Right Pointers in Each Node-zh.html",redirect:"/p/f0fba3/"},{name:"v-e3636626",path:"/p/cd0756/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-e3636626").then(t)}},{path:"/p/cd0756/index.html",redirect:"/p/cd0756/"},{path:"/01.算法/24.leetcode/10117.leetcode117 Populating Next Right Pointers in Each Node II-zh.html",redirect:"/p/cd0756/"},{name:"v-7e51c139",path:"/p/d24f32/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7e51c139").then(t)}},{path:"/p/d24f32/index.html",redirect:"/p/d24f32/"},{path:"/01.算法/24.leetcode/10118.leetcode118 Pascal's Triangle-zh.html",redirect:"/p/d24f32/"},{name:"v-6fd6c2ca",path:"/p/c386b4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6fd6c2ca").then(t)}},{path:"/p/c386b4/index.html",redirect:"/p/c386b4/"},{path:"/01.算法/24.leetcode/10120.leetcode120 Triangle-zh.html",redirect:"/p/c386b4/"},{name:"v-9b7fbf2c",path:"/p/5953ec/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-9b7fbf2c").then(t)}},{path:"/p/5953ec/index.html",redirect:"/p/5953ec/"},{path:"/01.算法/24.leetcode/10119.leetcode119 Pascal's Triangle II-zh.html",redirect:"/p/5953ec/"},{name:"v-05f7c36e",path:"/p/3e318e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-05f7c36e").then(t)}},{path:"/p/3e318e/index.html",redirect:"/p/3e318e/"},{path:"/01.算法/24.leetcode/10121.leetcode121 Best Time to Buy and Sell Stock-zh.html",redirect:"/p/3e318e/"},{name:"v-a24a8ab2",path:"/p/1c022a/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-a24a8ab2").then(t)}},{path:"/p/1c022a/index.html",redirect:"/p/1c022a/"},{path:"/01.算法/24.leetcode/10122.leetcode122 Best Time to Buy and Sell Stock II-zh.html",redirect:"/p/1c022a/"},{name:"v-1d3a2736",path:"/p/b6d063/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1d3a2736").then(t)}},{path:"/p/b6d063/index.html",redirect:"/p/b6d063/"},{path:"/01.算法/24.leetcode/10123.leetcode123 Best Time to Buy and Sell Stock III-zh.html",redirect:"/p/b6d063/"},{name:"v-0196fb6a",path:"/p/067c87/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0196fb6a").then(t)}},{path:"/p/067c87/index.html",redirect:"/p/067c87/"},{path:"/01.算法/24.leetcode/10124.leetcode124 Binary Tree Maximum Path Sum-zh.html",redirect:"/p/067c87/"},{name:"v-35ab16a6",path:"/p/6d33d7/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-35ab16a6").then(t)}},{path:"/p/6d33d7/index.html",redirect:"/p/6d33d7/"},{path:"/01.算法/24.leetcode/10125.leetcode125 Valid Palindrome-zh.html",redirect:"/p/6d33d7/"},{name:"v-7cc459ac",path:"/p/b0951d/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7cc459ac").then(t)}},{path:"/p/b0951d/index.html",redirect:"/p/b0951d/"},{path:"/01.算法/24.leetcode/10126.leetcode126 Word Ladder II-zh.html",redirect:"/p/b0951d/"},{name:"v-a9ae197e",path:"/p/3ec509/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-a9ae197e").then(t)}},{path:"/p/3ec509/index.html",redirect:"/p/3ec509/"},{path:"/01.算法/24.leetcode/10127.leetcode127 Word Ladder-zh.html",redirect:"/p/3ec509/"},{name:"v-d66a91a0",path:"/p/68f243/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-d66a91a0").then(t)}},{path:"/p/68f243/index.html",redirect:"/p/68f243/"},{path:"/01.算法/24.leetcode/10128.leetcode128 Longest Consecutive Sequence-zh.html",redirect:"/p/68f243/"},{name:"v-32c4dbca",path:"/p/2dfa58/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-32c4dbca").then(t)}},{path:"/p/2dfa58/index.html",redirect:"/p/2dfa58/"},{path:"/01.算法/24.leetcode/10129.leetcode129 Sum Root to Leaf Numbers-zh.html",redirect:"/p/2dfa58/"},{name:"v-116b07e7",path:"/p/e68122/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-116b07e7").then(t)}},{path:"/p/e68122/index.html",redirect:"/p/e68122/"},{path:"/01.算法/24.leetcode/10130.leetcode130 Surrounded Regions-zh.html",redirect:"/p/e68122/"},{name:"v-35faa073",path:"/p/fbe3f4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-35faa073").then(t)}},{path:"/p/fbe3f4/index.html",redirect:"/p/fbe3f4/"},{path:"/01.算法/24.leetcode/10131.leetcode131 Palindrome Partitioning-zh.html",redirect:"/p/fbe3f4/"},{name:"v-0c342a0a",path:"/p/cba4c5/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0c342a0a").then(t)}},{path:"/p/cba4c5/index.html",redirect:"/p/cba4c5/"},{path:"/01.算法/24.leetcode/10132.leetcode132 Palindrome Partitioning II-zh.html",redirect:"/p/cba4c5/"},{name:"v-1b1ca026",path:"/p/7ede97/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1b1ca026").then(t)}},{path:"/p/7ede97/index.html",redirect:"/p/7ede97/"},{path:"/01.算法/24.leetcode/10133.leetcode133 Clone Graph-zh.html",redirect:"/p/7ede97/"},{name:"v-8626ba16",path:"/p/cc0ab7/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-8626ba16").then(t)}},{path:"/p/cc0ab7/index.html",redirect:"/p/cc0ab7/"},{path:"/01.算法/24.leetcode/10134.leetcode134 Gas Station-zh.html",redirect:"/p/cc0ab7/"},{name:"v-d7da2f68",path:"/p/3f7a76/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-d7da2f68").then(t)}},{path:"/p/3f7a76/index.html",redirect:"/p/3f7a76/"},{path:"/01.算法/24.leetcode/10135.leetcode135 Candy-zh.html",redirect:"/p/3f7a76/"},{name:"v-4b97ba8b",path:"/p/e857cf/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4b97ba8b").then(t)}},{path:"/p/e857cf/index.html",redirect:"/p/e857cf/"},{path:"/01.算法/24.leetcode/10136.leetcode136 Single Number-zh.html",redirect:"/p/e857cf/"},{name:"v-6b219a6c",path:"/p/0e631d/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6b219a6c").then(t)}},{path:"/p/0e631d/index.html",redirect:"/p/0e631d/"},{path:"/01.算法/24.leetcode/10137.leetcode137 Single Number II-zh.html",redirect:"/p/0e631d/"},{name:"v-df35d6d8",path:"/p/529fc9/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-df35d6d8").then(t)}},{path:"/p/529fc9/index.html",redirect:"/p/529fc9/"},{path:"/01.算法/24.leetcode/10138.leetcode138 Copy List with Random Pointer-zh.html",redirect:"/p/529fc9/"},{name:"v-10d6ed72",path:"/p/d40856/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-10d6ed72").then(t)}},{path:"/p/d40856/index.html",redirect:"/p/d40856/"},{path:"/01.算法/24.leetcode/10139.leetcode139 Word Break-zh.html",redirect:"/p/d40856/"},{name:"v-5879d1de",path:"/p/ccca7c/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5879d1de").then(t)}},{path:"/p/ccca7c/index.html",redirect:"/p/ccca7c/"},{path:"/01.算法/24.leetcode/10140.leetcode140 Word Break II-zh.html",redirect:"/p/ccca7c/"},{name:"v-7a154764",path:"/p/f2a66f/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7a154764").then(t)}},{path:"/p/f2a66f/index.html",redirect:"/p/f2a66f/"},{path:"/01.算法/24.leetcode/10141.leetcode141 Linked List Cycle-zh.html",redirect:"/p/f2a66f/"},{name:"v-8754a666",path:"/p/1394c2/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-8754a666").then(t)}},{path:"/p/1394c2/index.html",redirect:"/p/1394c2/"},{path:"/01.算法/24.leetcode/10142.leetcode142 Linked List Cycle II-zh.html",redirect:"/p/1394c2/"},{name:"v-0f188b26",path:"/p/820427/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0f188b26").then(t)}},{path:"/p/820427/index.html",redirect:"/p/820427/"},{path:"/01.算法/24.leetcode/10143.leetcode143 Reorder List-zh.html",redirect:"/p/820427/"},{name:"v-0246fc47",path:"/p/89277c/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0246fc47").then(t)}},{path:"/p/89277c/index.html",redirect:"/p/89277c/"},{path:"/01.算法/24.leetcode/10144.leetcode144 Binary Tree Preorder Traversal-zh.html",redirect:"/p/89277c/"},{name:"v-de88eb66",path:"/p/31fafb/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-de88eb66").then(t)}},{path:"/p/31fafb/index.html",redirect:"/p/31fafb/"},{path:"/01.算法/24.leetcode/10145.leetcode145 Binary Tree Postorder Traversal-zh.html",redirect:"/p/31fafb/"},{name:"v-51c9fe7e",path:"/p/2b0d9a/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-51c9fe7e").then(t)}},{path:"/p/2b0d9a/index.html",redirect:"/p/2b0d9a/"},{path:"/01.算法/24.leetcode/10146.leetcode146 Lru Cache-zh.html",redirect:"/p/2b0d9a/"},{name:"v-6e287744",path:"/p/085977/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6e287744").then(t)}},{path:"/p/085977/index.html",redirect:"/p/085977/"},{path:"/01.算法/24.leetcode/10147.leetcode147 Insertion Sort List-zh.html",redirect:"/p/085977/"},{name:"v-be1a0b66",path:"/p/fa1546/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-be1a0b66").then(t)}},{path:"/p/fa1546/index.html",redirect:"/p/fa1546/"},{path:"/01.算法/24.leetcode/10148.leetcode148 Sort List-zh.html",redirect:"/p/fa1546/"},{name:"v-06605e90",path:"/p/949028/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-06605e90").then(t)}},{path:"/p/949028/index.html",redirect:"/p/949028/"},{path:"/01.算法/24.leetcode/10149.leetcode149 Max Points on a Line-zh.html",redirect:"/p/949028/"},{name:"v-1e673d87",path:"/p/76312a/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1e673d87").then(t)}},{path:"/p/76312a/index.html",redirect:"/p/76312a/"},{path:"/01.算法/24.leetcode/10150.leetcode150 Evaluate Reverse Polish Notation-zh.html",redirect:"/p/76312a/"},{name:"v-244162d4",path:"/p/780e72/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-244162d4").then(t)}},{path:"/p/780e72/index.html",redirect:"/p/780e72/"},{path:"/01.算法/24.leetcode/10151.leetcode151 Reverse Words in a String-zh.html",redirect:"/p/780e72/"},{name:"v-40451dd0",path:"/p/769c10/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-40451dd0").then(t)}},{path:"/p/769c10/index.html",redirect:"/p/769c10/"},{path:"/01.算法/24.leetcode/10152.leetcode152 Maximum Product Subarray-zh.html",redirect:"/p/769c10/"},{name:"v-06229c47",path:"/p/67e5b5/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-06229c47").then(t)}},{path:"/p/67e5b5/index.html",redirect:"/p/67e5b5/"},{path:"/01.算法/24.leetcode/10153.leetcode153 Find Minimum in Rotated Sorted Array-zh.html",redirect:"/p/67e5b5/"},{name:"v-8d798c44",path:"/p/9d0183/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-8d798c44").then(t)}},{path:"/p/9d0183/index.html",redirect:"/p/9d0183/"},{path:"/01.算法/24.leetcode/10154.leetcode154 Find Minimum in Rotated Sorted Array II-zh.html",redirect:"/p/9d0183/"},{name:"v-8d89c36a",path:"/p/a7d71e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-8d89c36a").then(t)}},{path:"/p/a7d71e/index.html",redirect:"/p/a7d71e/"},{path:"/01.算法/24.leetcode/10155.leetcode155 Min Stack-zh.html",redirect:"/p/a7d71e/"},{name:"v-f1ed640a",path:"/p/357d2e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-f1ed640a").then(t)}},{path:"/p/357d2e/index.html",redirect:"/p/357d2e/"},{path:"/01.算法/24.leetcode/10156.leetcode156 Binary Tree Upside Down-zh.html",redirect:"/p/357d2e/"},{name:"v-ad145af8",path:"/p/11e2e0/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-ad145af8").then(t)}},{path:"/p/11e2e0/index.html",redirect:"/p/11e2e0/"},{path:"/01.算法/24.leetcode/10157.leetcode157 Read N Characters Given Read4-zh.html",redirect:"/p/11e2e0/"},{name:"v-604efc27",path:"/p/638bc7/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-604efc27").then(t)}},{path:"/p/638bc7/index.html",redirect:"/p/638bc7/"},{path:"/01.算法/24.leetcode/10158.leetcode158 Read N Characters Given Read4 II - Call multiple times-zh.html",redirect:"/p/638bc7/"},{name:"v-2e8ac566",path:"/p/13bb7d/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2e8ac566").then(t)}},{path:"/p/13bb7d/index.html",redirect:"/p/13bb7d/"},{path:"/01.算法/24.leetcode/10159.leetcode159 Longest Substring with At Most Two Distinct Characters-zh.html",redirect:"/p/13bb7d/"},{name:"v-03f0b06c",path:"/p/8e04cc/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-03f0b06c").then(t)}},{path:"/p/8e04cc/index.html",redirect:"/p/8e04cc/"},{path:"/01.算法/24.leetcode/10160.leetcode160 Intersection of Two Linked Lists-zh.html",redirect:"/p/8e04cc/"},{name:"v-cb385bb0",path:"/p/3ba9d1/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-cb385bb0").then(t)}},{path:"/p/3ba9d1/index.html",redirect:"/p/3ba9d1/"},{path:"/01.算法/24.leetcode/10161.leetcode161 One Edit Distance-zh.html",redirect:"/p/3ba9d1/"},{name:"v-74182564",path:"/p/7b7235/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-74182564").then(t)}},{path:"/p/7b7235/index.html",redirect:"/p/7b7235/"},{path:"/01.算法/24.leetcode/10162.leetcode162 Find Peak Element-zh.html",redirect:"/p/7b7235/"},{name:"v-0ede2966",path:"/p/073c7e/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0ede2966").then(t)}},{path:"/p/073c7e/index.html",redirect:"/p/073c7e/"},{path:"/01.算法/24.leetcode/10163.leetcode163 Missing Ranges-zh.html",redirect:"/p/073c7e/"},{name:"v-2fc7dd8a",path:"/p/881ab1/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2fc7dd8a").then(t)}},{path:"/p/881ab1/index.html",redirect:"/p/881ab1/"},{path:"/01.算法/24.leetcode/10164.leetcode164 Maximum Gap-zh.html",redirect:"/p/881ab1/"},{name:"v-e3b62984",path:"/p/1808db/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-e3b62984").then(t)}},{path:"/p/1808db/index.html",redirect:"/p/1808db/"},{path:"/01.算法/24.leetcode/10165.leetcode165 Compare Version Numbers-zh.html",redirect:"/p/1808db/"},{name:"v-3c44de45",path:"/p/c52337/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3c44de45").then(t)}},{path:"/p/c52337/index.html",redirect:"/p/c52337/"},{path:"/01.算法/24.leetcode/10166.leetcode166 Fraction to Recurring Decimal-zh.html",redirect:"/p/c52337/"},{name:"v-0741be07",path:"/p/a20291/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0741be07").then(t)}},{path:"/p/a20291/index.html",redirect:"/p/a20291/"},{path:"/01.算法/24.leetcode/10167.leetcode167 Two Sum II - Input array is sorted-zh.html",redirect:"/p/a20291/"},{name:"v-41ff946d",path:"/p/57b4e1/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-41ff946d").then(t)}},{path:"/p/57b4e1/index.html",redirect:"/p/57b4e1/"},{path:"/01.算法/24.leetcode/10168.leetcode168 Excel Sheet Column Title-zh.html",redirect:"/p/57b4e1/"},{name:"v-76f8e447",path:"/p/a36e82/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-76f8e447").then(t)}},{path:"/p/a36e82/index.html",redirect:"/p/a36e82/"},{path:"/01.算法/24.leetcode/10169.leetcode169 Majority Element-zh.html",redirect:"/p/a36e82/"},{name:"v-81264718",path:"/p/6d9984/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-81264718").then(t)}},{path:"/p/6d9984/index.html",redirect:"/p/6d9984/"},{path:"/01.算法/24.leetcode/10170.leetcode170 Two Sum III - Data structure design-zh.html",redirect:"/p/6d9984/"},{name:"v-2db38f71",path:"/p/7d969b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2db38f71").then(t)}},{path:"/p/7d969b/index.html",redirect:"/p/7d969b/"},{path:"/01.算法/24.leetcode/10171.leetcode171 Excel Sheet Column Number-zh.html",redirect:"/p/7d969b/"},{name:"v-22a05178",path:"/p/4f95d4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-22a05178").then(t)}},{path:"/p/4f95d4/index.html",redirect:"/p/4f95d4/"},{path:"/01.算法/24.leetcode/10172.leetcode172 Factorial Trailing Zeroes-zh.html",redirect:"/p/4f95d4/"},{name:"v-6f5582e6",path:"/p/43f342/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6f5582e6").then(t)}},{path:"/p/43f342/index.html",redirect:"/p/43f342/"},{path:"/01.算法/24.leetcode/10174.leetcode174 Dungeon Game-zh.html",redirect:"/p/43f342/"},{name:"v-0328ed0a",path:"/p/64c315/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0328ed0a").then(t)}},{path:"/p/64c315/index.html",redirect:"/p/64c315/"},{path:"/01.算法/24.leetcode/10173.leetcode173 Binary Search Tree Iterator-zh.html",redirect:"/p/64c315/"},{name:"v-3186c650",path:"/p/2a7c04/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3186c650").then(t)}},{path:"/p/2a7c04/index.html",redirect:"/p/2a7c04/"},{path:"/01.算法/24.leetcode/10175.leetcode175 Combine Two Tables-zh.html",redirect:"/p/2a7c04/"},{name:"v-68c34360",path:"/p/076d61/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-68c34360").then(t)}},{path:"/p/076d61/index.html",redirect:"/p/076d61/"},{path:"/01.算法/24.leetcode/10176.leetcode176 Second Highest Salary-zh.html",redirect:"/p/076d61/"},{name:"v-6f27372b",path:"/p/a2620f/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6f27372b").then(t)}},{path:"/p/a2620f/index.html",redirect:"/p/a2620f/"},{path:"/01.算法/24.leetcode/10178.leetcode178 Rank Scores-zh.html",redirect:"/p/a2620f/"},{name:"v-14b3b590",path:"/p/1b72ec/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-14b3b590").then(t)}},{path:"/p/1b72ec/index.html",redirect:"/p/1b72ec/"},{path:"/01.算法/24.leetcode/10177.leetcode177 Nth Highest Salary-zh.html",redirect:"/p/1b72ec/"},{name:"v-22cacea6",path:"/p/2aa7a2/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-22cacea6").then(t)}},{path:"/p/2aa7a2/index.html",redirect:"/p/2aa7a2/"},{path:"/01.算法/24.leetcode/10179.leetcode179 Largest Number-zh.html",redirect:"/p/2aa7a2/"},{name:"v-31cf86c2",path:"/p/647279/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-31cf86c2").then(t)}},{path:"/p/647279/index.html",redirect:"/p/647279/"},{path:"/01.算法/24.leetcode/10180.leetcode180 Consecutive Numbers-zh.html",redirect:"/p/647279/"},{name:"v-24505513",path:"/p/a2cad5/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-24505513").then(t)}},{path:"/p/a2cad5/index.html",redirect:"/p/a2cad5/"},{path:"/01.算法/24.leetcode/10181.leetcode181 Employees Earning More Than Their Managers-zh.html",redirect:"/p/a2cad5/"},{name:"v-2f38b2cd",path:"/p/ea4745/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2f38b2cd").then(t)}},{path:"/p/ea4745/index.html",redirect:"/p/ea4745/"},{path:"/01.算法/24.leetcode/10182.leetcode182 Duplicate Emails-zh.html",redirect:"/p/ea4745/"},{name:"v-2d1f7017",path:"/p/2e1a79/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2d1f7017").then(t)}},{path:"/p/2e1a79/index.html",redirect:"/p/2e1a79/"},{path:"/01.算法/24.leetcode/10183.leetcode183 Customers Who Never Order-zh.html",redirect:"/p/2e1a79/"},{name:"v-66feb918",path:"/p/df5343/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-66feb918").then(t)}},{path:"/p/df5343/index.html",redirect:"/p/df5343/"},{path:"/01.算法/24.leetcode/10184.leetcode184 Department Highest Salary-zh.html",redirect:"/p/df5343/"},{name:"v-4484de06",path:"/p/d64ea2/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4484de06").then(t)}},{path:"/p/d64ea2/index.html",redirect:"/p/d64ea2/"},{path:"/01.算法/24.leetcode/10185.leetcode185 Department Top Three Salaries-zh.html",redirect:"/p/d64ea2/"},{name:"v-12c5050d",path:"/p/036d01/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-12c5050d").then(t)}},{path:"/p/036d01/index.html",redirect:"/p/036d01/"},{path:"/01.算法/24.leetcode/10186.leetcode186 Reverse Words in a String II-zh.html",redirect:"/p/036d01/"},{name:"v-7c3f7872",path:"/p/8e4d7f/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7c3f7872").then(t)}},{path:"/p/8e4d7f/index.html",redirect:"/p/8e4d7f/"},{path:"/01.算法/24.leetcode/10188.leetcode188 Best Time to Buy and Sell Stock IV-zh.html",redirect:"/p/8e4d7f/"},{name:"v-6fccf164",path:"/p/99a96f/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6fccf164").then(t)}},{path:"/p/99a96f/index.html",redirect:"/p/99a96f/"},{path:"/01.算法/24.leetcode/10187.leetcode187 Repeated DNA Sequences-zh.html",redirect:"/p/99a96f/"},{name:"v-6fe55fb2",path:"/p/035bd4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6fe55fb2").then(t)}},{path:"/p/035bd4/index.html",redirect:"/p/035bd4/"},{path:"/01.算法/24.leetcode/10189.leetcode189 Rotate Array-zh.html",redirect:"/p/035bd4/"},{name:"v-087510e6",path:"/p/2f9de5/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-087510e6").then(t)}},{path:"/p/2f9de5/index.html",redirect:"/p/2f9de5/"},{path:"/01.算法/24.leetcode/10190.leetcode190 Reverse Bits-zh.html",redirect:"/p/2f9de5/"},{name:"v-76f71d4d",path:"/p/ca7d94/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-76f71d4d").then(t)}},{path:"/p/ca7d94/index.html",redirect:"/p/ca7d94/"},{path:"/01.算法/24.leetcode/10191.leetcode191 Number of 1 Bits-zh.html",redirect:"/p/ca7d94/"},{name:"v-47133da7",path:"/p/610d36/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-47133da7").then(t)}},{path:"/p/610d36/index.html",redirect:"/p/610d36/"},{path:"/01.算法/24.leetcode/10192.leetcode192 Word Frequency-zh.html",redirect:"/p/610d36/"},{name:"v-56e01078",path:"/p/bc41dd/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-56e01078").then(t)}},{path:"/p/bc41dd/index.html",redirect:"/p/bc41dd/"},{path:"/01.算法/24.leetcode/10193.leetcode193 Valid Phone Numbers-zh.html",redirect:"/p/bc41dd/"},{name:"v-2638102d",path:"/p/abe998/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2638102d").then(t)}},{path:"/p/abe998/index.html",redirect:"/p/abe998/"},{path:"/01.算法/24.leetcode/10194.leetcode194 Transpose File-zh.html",redirect:"/p/abe998/"},{name:"v-6fd2026d",path:"/p/fb58c4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6fd2026d").then(t)}},{path:"/p/fb58c4/index.html",redirect:"/p/fb58c4/"},{path:"/01.算法/24.leetcode/10195.leetcode195 Tenth Line-zh.html",redirect:"/p/fb58c4/"},{name:"v-1eea3c94",path:"/p/b142e0/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1eea3c94").then(t)}},{path:"/p/b142e0/index.html",redirect:"/p/b142e0/"},{path:"/01.算法/24.leetcode/10196.leetcode196 Delete Duplicate Emails-zh.html",redirect:"/p/b142e0/"},{name:"v-053dc7a7",path:"/p/81acc9/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-053dc7a7").then(t)}},{path:"/p/81acc9/index.html",redirect:"/p/81acc9/"},{path:"/01.算法/24.leetcode/10197.leetcode197 Rising Temperature-zh.html",redirect:"/p/81acc9/"},{name:"v-6d4c0ee6",path:"/p/6f8e73/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6d4c0ee6").then(t)}},{path:"/p/6f8e73/index.html",redirect:"/p/6f8e73/"},{path:"/01.算法/24.leetcode/10198.leetcode198 House Robber-zh.html",redirect:"/p/6f8e73/"},{name:"v-2aeda3f0",path:"/p/098207/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2aeda3f0").then(t)}},{path:"/p/098207/index.html",redirect:"/p/098207/"},{path:"/01.算法/24.leetcode/10199.leetcode199 Binary Tree Right Side View-zh.html",redirect:"/p/098207/"},{name:"v-cb64dc94",path:"/p/394356/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-cb64dc94").then(t)}},{path:"/p/394356/index.html",redirect:"/p/394356/"},{path:"/01.算法/24.leetcode/10200.leetcode200 Number of Islands-zh.html",redirect:"/p/394356/"},{name:"v-67e15bec",path:"/p/d93f2b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-67e15bec").then(t)}},{path:"/p/d93f2b/index.html",redirect:"/p/d93f2b/"},{path:"/01.算法/24.leetcode/10201.leetcode201 Bitwise AND of Numbers Range-zh.html",redirect:"/p/d93f2b/"},{name:"v-1c60702d",path:"/p/c9273c/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1c60702d").then(t)}},{path:"/p/c9273c/index.html",redirect:"/p/c9273c/"},{path:"/01.算法/24.leetcode/10202.leetcode202 Happy Number-zh.html",redirect:"/p/c9273c/"},{name:"v-5de0b9c9",path:"/p/fbd6a2/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5de0b9c9").then(t)}},{path:"/p/fbd6a2/index.html",redirect:"/p/fbd6a2/"},{path:"/01.算法/24.leetcode/10203.leetcode203 Remove Linked List Elements-zh.html",redirect:"/p/fbd6a2/"},{name:"v-64a8ceed",path:"/p/73017b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-64a8ceed").then(t)}},{path:"/p/73017b/index.html",redirect:"/p/73017b/"},{path:"/01.算法/24.leetcode/10204.leetcode204 Count Primes-zh.html",redirect:"/p/73017b/"},{name:"v-ec1f55f2",path:"/p/18ca2f/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-ec1f55f2").then(t)}},{path:"/p/18ca2f/index.html",redirect:"/p/18ca2f/"},{path:"/01.算法/24.leetcode/10205.leetcode205 Isomorphic Strings-zh.html",redirect:"/p/18ca2f/"},{name:"v-43829904",path:"/p/c4fbe9/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-43829904").then(t)}},{path:"/p/c4fbe9/index.html",redirect:"/p/c4fbe9/"},{path:"/01.算法/24.leetcode/10206.leetcode206 Reverse Linked List-zh.html",redirect:"/p/c4fbe9/"},{name:"v-2f8a2e55",path:"/p/96e670/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2f8a2e55").then(t)}},{path:"/p/96e670/index.html",redirect:"/p/96e670/"},{path:"/01.算法/24.leetcode/10207.leetcode207 Course Schedule-zh.html",redirect:"/p/96e670/"},{name:"v-711f4807",path:"/p/a86416/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-711f4807").then(t)}},{path:"/p/a86416/index.html",redirect:"/p/a86416/"},{path:"/01.算法/24.leetcode/10208.leetcode208 Implement Trie (Prefix Tree)-zh.html",redirect:"/p/a86416/"},{name:"v-1709b7ac",path:"/p/198892/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1709b7ac").then(t)}},{path:"/p/198892/index.html",redirect:"/p/198892/"},{path:"/01.算法/24.leetcode/10210.leetcode210 Course Schedule II-zh.html",redirect:"/p/198892/"},{name:"v-7f96c701",path:"/p/2de570/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7f96c701").then(t)}},{path:"/p/2de570/index.html",redirect:"/p/2de570/"},{path:"/01.算法/24.leetcode/10209.leetcode209 Minimum Size Subarray Sum-zh.html",redirect:"/p/2de570/"},{name:"v-5c6e50c4",path:"/p/43f608/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5c6e50c4").then(t)}},{path:"/p/43f608/index.html",redirect:"/p/43f608/"},{path:"/01.算法/24.leetcode/10211.leetcode211 Design Add and Search Words Data Structure-zh.html",redirect:"/p/43f608/"},{name:"v-67ce5dea",path:"/p/fd6811/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-67ce5dea").then(t)}},{path:"/p/fd6811/index.html",redirect:"/p/fd6811/"},{path:"/01.算法/24.leetcode/10212.leetcode212 Word Search II-zh.html",redirect:"/p/fd6811/"},{name:"v-b92268dc",path:"/p/b3cf16/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-b92268dc").then(t)}},{path:"/p/b3cf16/index.html",redirect:"/p/b3cf16/"},{path:"/01.算法/24.leetcode/10213.leetcode213 House Robber II-zh.html",redirect:"/p/b3cf16/"},{name:"v-30cdd8aa",path:"/p/d6bf9a/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-30cdd8aa").then(t)}},{path:"/p/d6bf9a/index.html",redirect:"/p/d6bf9a/"},{path:"/01.算法/24.leetcode/10214.leetcode214 Shortest Palindrome-zh.html",redirect:"/p/d6bf9a/"},{name:"v-77be7816",path:"/p/fd7454/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-77be7816").then(t)}},{path:"/p/fd7454/index.html",redirect:"/p/fd7454/"},{path:"/01.算法/24.leetcode/10215.leetcode215 Kth Largest Element in an Array-zh.html",redirect:"/p/fd7454/"},{name:"v-86c3715c",path:"/p/bc08e4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-86c3715c").then(t)}},{path:"/p/bc08e4/index.html",redirect:"/p/bc08e4/"},{path:"/01.算法/24.leetcode/10216.leetcode216 Combination Sum III-zh.html",redirect:"/p/bc08e4/"},{name:"v-03e14d32",path:"/p/0b5a60/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-03e14d32").then(t)}},{path:"/p/0b5a60/index.html",redirect:"/p/0b5a60/"},{path:"/01.算法/24.leetcode/10217.leetcode217 Contains Duplicate-zh.html",redirect:"/p/0b5a60/"},{name:"v-460671de",path:"/p/8f61bf/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-460671de").then(t)}},{path:"/p/8f61bf/index.html",redirect:"/p/8f61bf/"},{path:"/01.算法/24.leetcode/10218.leetcode218 The Skyline Problem-zh.html",redirect:"/p/8f61bf/"},{name:"v-c10acd60",path:"/p/1c26f8/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-c10acd60").then(t)}},{path:"/p/1c26f8/index.html",redirect:"/p/1c26f8/"},{path:"/01.算法/24.leetcode/10219.leetcode219 Contains Duplicate II-zh.html",redirect:"/p/1c26f8/"},{name:"v-5f117cb8",path:"/p/7fc47c/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5f117cb8").then(t)}},{path:"/p/7fc47c/index.html",redirect:"/p/7fc47c/"},{path:"/01.算法/24.leetcode/10220.leetcode220 Contains Duplicate III-zh.html",redirect:"/p/7fc47c/"},{name:"v-95ad93e6",path:"/p/838c9a/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-95ad93e6").then(t)}},{path:"/p/838c9a/index.html",redirect:"/p/838c9a/"},{path:"/01.算法/24.leetcode/10221.leetcode221 Maximal Square-zh.html",redirect:"/p/838c9a/"},{name:"v-0a51c005",path:"/p/f1ccb7/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0a51c005").then(t)}},{path:"/p/f1ccb7/index.html",redirect:"/p/f1ccb7/"},{path:"/01.算法/24.leetcode/10222.leetcode222 Count Complete Tree Nodes-zh.html",redirect:"/p/f1ccb7/"},{name:"v-2d3e01cd",path:"/p/e71170/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2d3e01cd").then(t)}},{path:"/p/e71170/index.html",redirect:"/p/e71170/"},{path:"/01.算法/24.leetcode/10223.leetcode223 Rectangle Area-zh.html",redirect:"/p/e71170/"},{name:"v-4d0cd04d",path:"/p/5590ee/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4d0cd04d").then(t)}},{path:"/p/5590ee/index.html",redirect:"/p/5590ee/"},{path:"/01.算法/24.leetcode/10224.leetcode224 Basic Calculator-zh.html",redirect:"/p/5590ee/"},{name:"v-7d5a9373",path:"/p/2cde3f/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7d5a9373").then(t)}},{path:"/p/2cde3f/index.html",redirect:"/p/2cde3f/"},{path:"/01.算法/24.leetcode/10225.leetcode225 Implement Stack using Queues-zh.html",redirect:"/p/2cde3f/"},{name:"v-2ec7306c",path:"/p/b0dddc/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2ec7306c").then(t)}},{path:"/p/b0dddc/index.html",redirect:"/p/b0dddc/"},{path:"/01.算法/24.leetcode/10226.leetcode226 Invert Binary Tree-zh.html",redirect:"/p/b0dddc/"},{name:"v-3427b4ec",path:"/p/f546b9/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3427b4ec").then(t)}},{path:"/p/f546b9/index.html",redirect:"/p/f546b9/"},{path:"/01.算法/24.leetcode/10227.leetcode227 Basic Calculator II-zh.html",redirect:"/p/f546b9/"},{name:"v-47845ccd",path:"/p/a3f9ac/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-47845ccd").then(t)}},{path:"/p/a3f9ac/index.html",redirect:"/p/a3f9ac/"},{path:"/01.算法/24.leetcode/10228.leetcode228 Summary Ranges-zh.html",redirect:"/p/a3f9ac/"},{name:"v-6971653e",path:"/p/ff53b7/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6971653e").then(t)}},{path:"/p/ff53b7/index.html",redirect:"/p/ff53b7/"},{path:"/01.算法/24.leetcode/10229.leetcode229 Majority Element II-zh.html",redirect:"/p/ff53b7/"},{name:"v-d21c602e",path:"/p/2a0744/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-d21c602e").then(t)}},{path:"/p/2a0744/index.html",redirect:"/p/2a0744/"},{path:"/01.算法/24.leetcode/10230.leetcode230 Kth Smallest Element in a BST-zh.html",redirect:"/p/2a0744/"},{name:"v-713df3aa",path:"/p/1952f3/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-713df3aa").then(t)}},{path:"/p/1952f3/index.html",redirect:"/p/1952f3/"},{path:"/01.算法/24.leetcode/10231.leetcode231 Power of Two-zh.html",redirect:"/p/1952f3/"},{name:"v-614e421a",path:"/p/9f96da/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-614e421a").then(t)}},{path:"/p/9f96da/index.html",redirect:"/p/9f96da/"},{path:"/01.算法/24.leetcode/10232.leetcode232 Implement Queue using Stacks-zh.html",redirect:"/p/9f96da/"},{name:"v-5cebfd60",path:"/p/df42dd/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5cebfd60").then(t)}},{path:"/p/df42dd/index.html",redirect:"/p/df42dd/"},{path:"/01.算法/24.leetcode/10104.leetcode104 Maximum Depth of Binary Tree-zh.html",redirect:"/p/df42dd/"},{name:"v-4a789dac",path:"/p/fe43a3/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4a789dac").then(t)}},{path:"/p/fe43a3/index.html",redirect:"/p/fe43a3/"},{path:"/01.算法/24.leetcode/10234.leetcode234 Palindrome Linked List-zh.html",redirect:"/p/fe43a3/"},{name:"v-42a65f8d",path:"/p/82740a/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-42a65f8d").then(t)}},{path:"/p/82740a/index.html",redirect:"/p/82740a/"},{path:"/01.算法/24.leetcode/10235.leetcode235 Lowest Common Ancestor of a Binary Search Tree-zh.html",redirect:"/p/82740a/"},{name:"v-3c52b6c0",path:"/p/cd43df/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3c52b6c0").then(t)}},{path:"/p/cd43df/index.html",redirect:"/p/cd43df/"},{path:"/01.算法/24.leetcode/10236.leetcode236 Lowest Common Ancestor of a Binary Tree-zh.html",redirect:"/p/cd43df/"},{name:"v-d7a396b2",path:"/p/be8ce1/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-d7a396b2").then(t)}},{path:"/p/be8ce1/index.html",redirect:"/p/be8ce1/"},{path:"/01.算法/24.leetcode/10237.leetcode237 Delete Node in a Linked List-zh.html",redirect:"/p/be8ce1/"},{name:"v-2cae356c",path:"/p/7eb89b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2cae356c").then(t)}},{path:"/p/7eb89b/index.html",redirect:"/p/7eb89b/"},{path:"/01.算法/24.leetcode/10238.leetcode238 Product of Array Except Self-zh.html",redirect:"/p/7eb89b/"},{name:"v-2ceda1ea",path:"/p/624423/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2ceda1ea").then(t)}},{path:"/p/624423/index.html",redirect:"/p/624423/"},{path:"/01.算法/24.leetcode/10239.leetcode239 Sliding Window Maximum-zh.html",redirect:"/p/624423/"},{name:"v-4b5829a4",path:"/p/b02c03/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4b5829a4").then(t)}},{path:"/p/b02c03/index.html",redirect:"/p/b02c03/"},{path:"/01.算法/24.leetcode/10240.leetcode240 Search a 2D Matrix II-zh.html",redirect:"/p/b02c03/"},{name:"v-3665f0bc",path:"/p/f642d4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3665f0bc").then(t)}},{path:"/p/f642d4/index.html",redirect:"/p/f642d4/"},{path:"/01.算法/24.leetcode/10241.leetcode241 Different Ways to Add Parentheses-zh.html",redirect:"/p/f642d4/"},{name:"v-1e5f7a6c",path:"/p/3e55e4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1e5f7a6c").then(t)}},{path:"/p/3e55e4/index.html",redirect:"/p/3e55e4/"},{path:"/01.算法/24.leetcode/10243.leetcode243 Shortest Word Distance-zh.html",redirect:"/p/3e55e4/"},{name:"v-b7d5d7be",path:"/p/989be3/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-b7d5d7be").then(t)}},{path:"/p/989be3/index.html",redirect:"/p/989be3/"},{path:"/01.算法/24.leetcode/10242.leetcode242 Valid Anagram-zh.html",redirect:"/p/989be3/"},{name:"v-34b8b412",path:"/p/174423/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-34b8b412").then(t)}},{path:"/p/174423/index.html",redirect:"/p/174423/"},{path:"/01.算法/24.leetcode/10244.leetcode244 Shortest Word Distance II-zh.html",redirect:"/p/174423/"},{name:"v-15f36787",path:"/p/940bbd/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-15f36787").then(t)}},{path:"/p/940bbd/index.html",redirect:"/p/940bbd/"},{path:"/01.算法/24.leetcode/10245.leetcode245 Shortest Word Distance III-zh.html",redirect:"/p/940bbd/"},{name:"v-0a109a26",path:"/p/d1ea39/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0a109a26").then(t)}},{path:"/p/d1ea39/index.html",redirect:"/p/d1ea39/"},{path:"/01.算法/24.leetcode/10246.leetcode246 Strobogrammatic Number-zh.html",redirect:"/p/d1ea39/"},{name:"v-5d80cac8",path:"/p/74a94a/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5d80cac8").then(t)}},{path:"/p/74a94a/index.html",redirect:"/p/74a94a/"},{path:"/01.算法/24.leetcode/10247.leetcode247 Strobogrammatic Number II-zh.html",redirect:"/p/74a94a/"},{name:"v-105f262a",path:"/p/858535/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-105f262a").then(t)}},{path:"/p/858535/index.html",redirect:"/p/858535/"},{path:"/01.算法/24.leetcode/10248.leetcode248 Strobogrammatic Number III-zh.html",redirect:"/p/858535/"},{name:"v-19d98050",path:"/p/9740b7/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-19d98050").then(t)}},{path:"/p/9740b7/index.html",redirect:"/p/9740b7/"},{path:"/01.算法/24.leetcode/10249.leetcode249 Group Shifted Strings-zh.html",redirect:"/p/9740b7/"},{name:"v-2ee1b1e0",path:"/p/fe02f7/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2ee1b1e0").then(t)}},{path:"/p/fe02f7/index.html",redirect:"/p/fe02f7/"},{path:"/01.算法/24.leetcode/10250.leetcode250 Count Univalue Subtrees-zh.html",redirect:"/p/fe02f7/"},{name:"v-7c38df78",path:"/p/91c29b/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7c38df78").then(t)}},{path:"/p/91c29b/index.html",redirect:"/p/91c29b/"},{path:"/01.算法/24.leetcode/10251.leetcode251 Flatten 2D Vector-zh.html",redirect:"/p/91c29b/"},{name:"v-4f15c9b5",path:"/p/8386f0/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4f15c9b5").then(t)}},{path:"/p/8386f0/index.html",redirect:"/p/8386f0/"},{path:"/01.算法/24.leetcode/10252.leetcode252 Meeting Rooms-zh.html",redirect:"/p/8386f0/"},{name:"v-6b004bb0",path:"/p/d0435a/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-6b004bb0").then(t)}},{path:"/p/d0435a/index.html",redirect:"/p/d0435a/"},{path:"/01.算法/24.leetcode/10253.leetcode253 Meeting Rooms II-zh.html",redirect:"/p/d0435a/"},{name:"v-0e5f7767",path:"/p/b4fea1/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0e5f7767").then(t)}},{path:"/p/b4fea1/index.html",redirect:"/p/b4fea1/"},{path:"/01.算法/24.leetcode/10254.leetcode254 Factor Combinations-zh.html",redirect:"/p/b4fea1/"},{name:"v-7a95866c",path:"/p/8ef0f4/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7a95866c").then(t)}},{path:"/p/8ef0f4/index.html",redirect:"/p/8ef0f4/"},{path:"/01.算法/24.leetcode/10255.leetcode255 Verify Preorder Sequence in Binary Search Tree-zh.html",redirect:"/p/8ef0f4/"},{name:"v-472abdca",path:"/p/de5fb9/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-472abdca").then(t)}},{path:"/p/de5fb9/index.html",redirect:"/p/de5fb9/"},{path:"/01.算法/24.leetcode/10256.leetcode256 Paint House-zh.html",redirect:"/p/de5fb9/"},{name:"v-869db188",path:"/p/050274/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-869db188").then(t)}},{path:"/p/050274/index.html",redirect:"/p/050274/"},{path:"/01.算法/24.leetcode/10257.leetcode257 Binary Tree Paths-zh.html",redirect:"/p/050274/"},{name:"v-2fc8e5ed",path:"/p/8e0d44/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2fc8e5ed").then(t)}},{path:"/p/8e0d44/index.html",redirect:"/p/8e0d44/"},{path:"/01.算法/24.leetcode/10258.leetcode258 Add Digits-zh.html",redirect:"/p/8e0d44/"},{name:"v-64923fa7",path:"/p/7a4e4a/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-64923fa7").then(t)}},{path:"/p/7a4e4a/index.html",redirect:"/p/7a4e4a/"},{path:"/01.算法/24.leetcode/10259.leetcode259 3Sum Smaller-zh.html",redirect:"/p/7a4e4a/"},{name:"v-4ed6ea9a",path:"/p/cb9306/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4ed6ea9a").then(t)}},{path:"/p/cb9306/index.html",redirect:"/p/cb9306/"},{path:"/01.算法/24.leetcode/10260.leetcode260 Single Number III-zh.html",redirect:"/p/cb9306/"},{name:"v-12282736",path:"/leetcode/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-12282736").then(t)}},{path:"/leetcode/index.html",redirect:"/leetcode/"},{path:"/01.算法/24.leetcode/27.LeetCode题解.html",redirect:"/leetcode/"},{name:"v-7def93d5",path:"/common-used-meta.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7def93d5").then(t)}},{path:"/02.页面/10.HTML/10.常用meta整理.html",redirect:"/common-used-meta.html"},{name:"v-45d1bfd4",path:"/css-tips.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-45d1bfd4").then(t)}},{path:"/02.页面/20.CSS/00.CSS教程和技巧收藏.html",redirect:"/css-tips.html"},{name:"v-66fb014a",path:"/mixins.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-66fb014a").then(t)}},{path:"/02.页面/25.stylus/10.混入(Mixins).html",redirect:"/mixins.html"},{name:"v-8e4edc24",path:"/npm-common-commands.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-8e4edc24").then(t)}},{path:"/03.技术/01.技术文档/03.npm常用命令.html",redirect:"/npm-common-commands.html"},{name:"v-4798fbce",path:"/github-adv-search-tips.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4798fbce").then(t)}},{path:"/03.技术/02.GitHub技巧/01.GitHub高级搜索技巧.html",redirect:"/github-adv-search-tips.html"},{name:"v-14dd923c",path:"/nodejs-recursive.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-14dd923c").then(t)}},{path:"/03.技术/03.Nodejs/01.nodejs递归读取所有文件.html",redirect:"/nodejs-recursive.html"},{name:"v-38983e24",path:"/baidu-shoulu-github.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-38983e24").then(t)}},{path:"/03.技术/04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html",redirect:"/baidu-shoulu-github.html"},{name:"v-34c996ae",path:"/p/new-commands-principles.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-34c996ae").then(t)}},{path:"/04.前端/25.JavaScript文章/02.new命令原理.html",redirect:"/p/new-commands-principles.html"},{name:"v-30404e92",path:"/vue-dev-prepare.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-30404e92").then(t)}},{path:"/04.前端/30.Vue文章/10.Vue项目开发前的一些准备工作.html",redirect:"/vue-dev-prepare.html"},{name:"v-1165f877",path:"/note/wx-miniprogram/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-1165f877").then(t)}},{path:"/note/wx-miniprogram/index.html",redirect:"/note/wx-miniprogram/"},{path:"/04.前端/40.学习笔记/22.小程序笔记.html",redirect:"/note/wx-miniprogram/"},{name:"v-a4e897ee",path:"/typescript/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-a4e897ee").then(t)}},{path:"/typescript/index.html",redirect:"/typescript/"},{path:"/04.前端/40.学习笔记/23.TypeScript笔记.html",redirect:"/typescript/"},{name:"v-c67a5246",path:"/about/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-c67a5246").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/05.关于/01.关于.html",redirect:"/about/"},{name:"v-18cd99be",path:"/feynman-method.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-18cd99be").then(t)}},{path:"/05.更多/01.学习/00.费曼学习法.html",redirect:"/feynman-method.html"},{name:"v-94956944",path:"/note-methods.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-94956944").then(t)}},{path:"/05.更多/01.学习/01.笔记方法.html",redirect:"/note-methods.html"},{name:"v-4b1784ae",path:"/strategy-for-efficient-learn.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4b1784ae").then(t)}},{path:"/05.更多/01.学习/02.提高学习效率的策略.html",redirect:"/strategy-for-efficient-learn.html"},{name:"v-2c01a8f7",path:"/memory-tips.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-2c01a8f7").then(t)}},{path:"/05.更多/01.学习/03.提高记忆的技巧.html",redirect:"/memory-tips.html"},{name:"v-4cc41921",path:"/autonomy-suggestions.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4cc41921").then(t)}},{path:"/05.更多/01.学习/04.自律小建议.html",redirect:"/autonomy-suggestions.html"},{name:"v-fa4af0ea",path:"/solve-problems-mind.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-fa4af0ea").then(t)}},{path:"/05.更多/01.学习/05.处理问题的思路.html",redirect:"/solve-problems-mind.html"},{name:"v-159f52b8",path:"/search-engine-tips.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-159f52b8").then(t)}},{path:"/05.更多/01.学习/10.搜索引擎使用技巧.html",redirect:"/search-engine-tips.html"},{name:"v-3c880437",path:"/interviews-qa-list.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3c880437").then(t)}},{path:"/05.更多/03.面试/01.面试问题集锦.html",redirect:"/interviews-qa-list.html"},{name:"v-4648f725",path:"/perfectionist-comprehend.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-4648f725").then(t)}},{path:"/05.更多/05.心情杂货/01.一个完美主义者的自我救赎.html",redirect:"/perfectionist-comprehend.html"},{name:"v-3d488047",path:"/why-being-addicted.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3d488047").then(t)}},{path:"/05.更多/05.心情杂货/10.反向拆解让人上瘾的套路，找回自律.html",redirect:"/why-being-addicted.html"},{name:"v-b8aed80e",path:"/two-minutes-rule.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-b8aed80e").then(t)}},{path:"/05.更多/10.实用技巧/01.2分钟规则.html",redirect:"/two-minutes-rule.html"},{name:"v-d294c11a",path:"/friends/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-d294c11a").then(t)}},{path:"/friends/index.html",redirect:"/friends/"},{path:"/05.更多/3000.友情链接.html",redirect:"/friends/"},{name:"v-7e7f13b0",path:"/sites.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7e7f13b0").then(t)}},{path:"/06.收藏夹/01.网站.html",redirect:"/sites.html"},{name:"v-50c4c17c",path:"/resources.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-50c4c17c").then(t)}},{path:"/06.收藏夹/02.资源.html",redirect:"/resources.html"},{name:"v-21e06e58",path:"/vue-resources.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-21e06e58").then(t)}},{path:"/06.收藏夹/03.Vue资源.html",redirect:"/vue-resources.html"},{name:"v-7bb61519",path:"/archives/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7bb61519").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-46832679",path:"/categories/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-46832679").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-3a384e99",path:"/tags/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-3a384e99").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-0f18a2ab",path:"/known-and-unknown.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-0f18a2ab").then(t)}},{path:"/_posts/随笔/你知道的越多，不知道的也就越多.html",redirect:"/known-and-unknown.html"},{name:"v-5d5e3e2b",path:"/life-and-happy.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-5d5e3e2b").then(t)}},{path:"/_posts/随笔/拥抱生活，拥抱快乐.html",redirect:"/life-and-happy.html"},{name:"v-55259a32",path:"/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-55259a32").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-283cafc0",path:"/ecma-script6.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-283cafc0").then(t)}},{path:"/《ES6 教程》笔记/01.ECMAScript 6 简介.html",redirect:"/ecma-script6.html"},{name:"v-11f80eb1",path:"/common-git-commands.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-11f80eb1").then(t)}},{path:"/《Git》学习笔记/10.手册/00.常用Git命令清单.html",redirect:"/common-git-commands.html"},{name:"v-cda926b0",path:"/git-branch-principles.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-cda926b0").then(t)}},{path:"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html",redirect:"/git-branch-principles.html"},{name:"v-b5a93fd2",path:"/javascript-basics.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-b5a93fd2").then(t)}},{path:"/《JavaScript教程》笔记/01.基础.html",redirect:"/javascript-basics.html"},{name:"v-44ea6316",path:"/install-typescript.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-44ea6316").then(t)}},{path:"/《TypeScript 从零实现 axios》/01.初识 TypeScript/02.安装 TypeScript.html",redirect:"/install-typescript.html"},{name:"v-78c8d138",path:"/mvvm-pattern.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-78c8d138").then(t)}},{path:"/《Vue》笔记/01.基础/00.MVVM模式.html",redirect:"/mvvm-pattern.html"},{name:"v-46620dca",path:"/custom-events.html",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-46620dca").then(t)}},{path:"/《Vue》笔记/02.组件/21.自定义事件.html",redirect:"/custom-events.html"},{name:"v-d45a52be",path:"/p/5f3c41/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-d45a52be").then(t)}},{path:"/p/5f3c41/index.html",redirect:"/p/5f3c41/"},{path:"/01.算法/24.leetcode/10103.leetcode103 Binary Tree Zigzag Level Order Traversal-zh.html",redirect:"/p/5f3c41/"},{name:"v-7ee238fd",path:"/p/6985d1/",component:is,beforeEnter:function(n,e,t){Zl("Layout","v-7ee238fd").then(t)}},{path:"/p/6985d1/index.html",redirect:"/p/6985d1/"},{path:"/01.算法/24.leetcode/10233.leetcode233 Number of Digit One-zh.html",redirect:"/p/6985d1/"},{path:"*",component:is}],ls={title:"dbdgs | 大白的故事",description:"大白的技术故事，专注于分享IT前沿技术、干货知识、热点资讯等，同时分享硬核的自媒体赚钱方法、推广技巧和运营实战，技术文章涵盖python,dotnet,node.js,git,github等。",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["link",{rel:"apple-touch-icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"大白的故事,极客中心,个人技术博客,后台开发面试题,技术文档"}],["meta",{name:"theme-color",content:"#11a8cd"}],["link",{rel:"search",type:"application/opensearchdescription+xml",href:"/opensearch.xml",title:"大白的故事"}],["meta",{name:"viewport",content:"width=device-width, initial-scale=1"}],["link",{rel:"alternate",type:"application/rss+xml",href:"https://dbdgs.cn/rss.xml",title:"dbdgs | 大白的故事 RSS Feed"}],["link",{rel:"alternate",type:"application/atom+xml",href:"https://dbdgs.cn/feed.atom",title:"dbdgs | 大白的故事 Atom Feed"}],["link",{rel:"alternate",type:"application/json",href:"https://dbdgs.cn/feed.json",title:"dbdgs | 大白的故事 JSON Feed"}]],pages:[{title:"算法",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.算法",imgUrl:"/img/algo.png",description:"LeetCode、剑指offer、程序员面试金典等算法面试题"}},title:"算法",date:"2021-07-16T21:50:53.000Z",permalink:"/algo",sidebar:!1,article:!1,comment:!1,editLink:!1,description:"",meta:[{name:"twitter:title",content:"算法"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E7%AE%97%E6%B3%95.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"算法"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E7%AE%97%E6%B3%95.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-16T21:50:53.000Z"},{itemprop:"name",content:"算法"},{itemprop:"description",content:""}]},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E7%AE%97%E6%B3%95.html",relativePath:"00.目录页/01.算法.md",key:"v-3dfeac0a",path:"/algo/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/20, 04:23:41"},{title:"技术",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.技术",imgUrl:"/img/other.png",description:"技术文档、教程、技巧、总结等文章"}},title:"技术",date:"2020-03-11T21:50:55.000Z",permalink:"/technology",sidebar:!1,article:!1,comment:!1,editLink:!1,description:"",meta:[{name:"twitter:title",content:"技术"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%8A%80%E6%9C%AF.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"技术"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%8A%80%E6%9C%AF.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-03-11T21:50:55.000Z"},{itemprop:"name",content:"技术"},{itemprop:"description",content:""}]},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%8A%80%E6%9C%AF.html",relativePath:"00.目录页/03.技术.md",key:"v-64dafe41",path:"/technology/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/20, 04:23:41"},{title:"页面",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.页面",imgUrl:"/img/ui.png",description:"html(5)/css(3)，前端页面相关技术"}},title:"页面",date:"2020-03-11T21:50:54.000Z",permalink:"/ui",sidebar:!1,article:!1,comment:!1,editLink:!1,description:"",meta:[{name:"twitter:title",content:"页面"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E9%A1%B5%E9%9D%A2.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"页面"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E9%A1%B5%E9%9D%A2.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-03-11T21:50:54.000Z"},{itemprop:"name",content:"页面"},{itemprop:"description",content:""}]},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E9%A1%B5%E9%9D%A2.html",relativePath:"00.目录页/02.页面.md",key:"v-5e3aa7ac",path:"/ui/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/20, 04:23:41"},{title:"前端",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.前端",imgUrl:"/img/web.png",description:"JavaScript、ES6、Vue框架等前端技术"}},title:"前端",date:"2020-03-11T21:50:53.000Z",permalink:"/web",sidebar:!1,article:!1,comment:!1,editLink:!1,description:"",meta:[{name:"twitter:title",content:"前端"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E5%89%8D%E7%AB%AF.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"前端"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E5%89%8D%E7%AB%AF.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-03-11T21:50:53.000Z"},{itemprop:"name",content:"前端"},{itemprop:"description",content:""}]},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/04.前端.md",key:"v-73c0e481",path:"/web/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/20, 04:23:41"},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"05.更多",imgUrl:"/img/more.png",description:"学习、面试、在线工具等更多文章和页面"}},title:"更多",date:"2020-03-11T21:50:56.000Z",permalink:"/more",sidebar:!1,article:!1,comment:!1,editLink:!1,description:"",meta:[{name:"twitter:title",content:"更多"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.%E6%9B%B4%E5%A4%9A.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"更多"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.%E6%9B%B4%E5%A4%9A.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-03-11T21:50:56.000Z"},{itemprop:"name",content:"更多"},{itemprop:"description",content:""}]},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/05.更多.md",key:"v-14d384af",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode1 两数之和【简单难度】",frontmatter:{title:"leetcode1 两数之和【简单难度】",date:"2021-07-17T09:02:48.000Z",permalink:"/leetcode1/",categories:["leetcode","学习笔记","算法"],tags:["leetcode"],description:"         &nbsp; ● &nbsp;难度:     简单",meta:[{name:"twitter:title",content:"leetcode1 两数之和【简单难度】"},{name:"twitter:description",content:"         &nbsp; ● &nbsp;难度:     简单"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10001.leetcode1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%5B%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6%5D.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode1 两数之和【简单难度】"},{property:"og:description",content:"         &nbsp; ● &nbsp;难度:     简单"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10001.leetcode1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%5B%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6%5D.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-17T09:02:48.000Z"},{property:"article:tag",content:"leetcode"},{itemprop:"name",content:"leetcode1 两数之和【简单难度】"},{itemprop:"description",content:"         &nbsp; ● &nbsp;难度:     简单"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10001.leetcode1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%5B%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6%5D.html",relativePath:"01.算法/24.leetcode/10001.leetcode1 两数之和[简单难度].md",key:"v-254c0b14",path:"/leetcode1/",headers:[{level:3,title:"1. 两数之和",slug:"_1-两数之和",normalizedTitle:"1. 两数之和",charIndex:2},{level:3,title:"英文题目: 2 sum (Two sum)",slug:"英文题目-2-sum-two-sum",normalizedTitle:"英文题目: 2 sum (two sum)",charIndex:504},{level:3,title:"分析:",slug:"分析",normalizedTitle:"分析:",charIndex:1177},{level:3,title:"方法2 AC代码:",slug:"方法2-ac代码",normalizedTitle:"方法2 ac代码:",charIndex:1369},{level:3,title:"方法2的另一种写法:",slug:"方法2的另一种写法",normalizedTitle:"方法2的另一种写法:",charIndex:1964},{level:3,title:"方法3 AC代码:",slug:"方法3-ac代码",normalizedTitle:"方法3 ac代码:",charIndex:2429}],headersStr:"1. 两数之和 英文题目: 2 sum (Two sum) 分析: 方法2 AC代码: 方法2的另一种写法: 方法3 AC代码:",content:"# 1. 两数之和\n\n  ●  难度:   简单   \n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n\n示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n1\n2\n\n\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n1\n2\n\n\n提示：\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * 只会存在一个有效答案\n\n进阶： 你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n\n\n\n# 英文题目: 2 sum (Two sum)\n\nGiven an array of integers nums and an integer target, return _indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.\n\n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9 Output: [0,1]\n\nExplaination: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2: Input: nums = [3,2,4], target = 6 Output: [1,2]\n\nExample 3: Input: nums = [3,3], target = 6 Output: [0,1]\n\nConstraints:\n\n * 2 <= nums.length <= 103\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n\n# 分析:\n\n方法1: 暴力法，复杂度O(n^2)，会TLE(超时);\n\n方法2: hashmap查表，在表中找 target - 当前循环变量i对应的那个数。用一个哈希表(C++中用unordered_map, C#中用dictionary, Python中用dict，Java中可以直接用HashMap)，存储每个数对应的下标，复杂度O(n);\n\n方法3: 快排 + 双指针\n\n\n# 方法2 AC代码:\n\n\n\nclass Solution {\n\tpublic:\n\t\tvector<int> twoSum(vector<int> &nums, int target)\n\t\t{\n\t\t\tunordered_map<int, int> dict;\n\t\t\tvector<int> result;\n\t\t\tfor(int i = 0; i < nums.size(); i++) {\n\t\t\t\tdict[nums[i]] = i; // 顺序的map映射: value->index \n\t\t\t}\n\t\t\tfor(int i = 0; i < nums.size(); i++)\n\t\t\t{\n\t\t\t\tint query = target - nums[i];\n\t\t\t\tif(dict.find(query) != dict.end() && dict[query] > i)  // dict[query] > i是为了防止重复计算 \n\t\t\t\t{\n\t\t\t\t\tresult.push_back(i);\n\t\t\t\t\tresult.push_back(dict[query]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 方法2的另一种写法:\n\nclass Solution {\npublic:\n\tvector<int> twoSum(vector<int> &nums, int target)\n\t{\n\t\tunordered_map<int, int> dict;\n\t\tvector<int> res(2,-1), emptyVect;\n\t\tfor(int i=0;i<nums.size();i++)\n\t\t{\n\t\t\tint query=target-nums[i];\n\t\t\tif(dict.find(query)==dict.end()) dict[nums[i]]=i;     // 逆序的map映射: value->index\n\t\t\telse {\n\t\t\t\tres[1]=i;\n\t\t\t\tres[0]=dict[query];\n\t\t\t\treturn res;\t\n\t\t\t}\n\t\t}\n\t\treturn emptyVect;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n\n# 方法3 AC代码:\n\n * 定义一个struct, 存储 index 和 value\n * 使用两个指针, l 和 r, l++, r--\n\nleft自增, right 自减\n\n注意: 如果要在一个struct上调用STL中的sort方法，需要先为其定义好 compare 函数。\n\n具体代码如下:\n\ntypedef struct node{\n    int index;\n    int value;\n    node(){};\n    node(int i, int v) : index(i), value(v){}\n} Node;\n \nbool compare(const Node& a, const Node& b){\n    return a.value < b.value;\n}\n \nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &nums, int target) {\n         \n        int len = nums.size();\n        assert(len >= 2);         \n         \n        vector<int> ret(2, 0);  // 初始化：ret包含2个值为0的元素\n         \n        vector<Node> nums2(len);\n        for(int i = 0; i < len; i++){\n            nums2[i] = Node(i+1, nums[i]);\n        }\n        \n        sort(nums2.begin(), nums2.end(), compare);  // 在定义的struct上调用快排，T(n)=O(n*log(n))\n         \n        int l = 0;\n        int r = len - 1;\n        while(l < r){\n            int sum = nums2[l].value + nums2[r].value;\n            if(sum == target){\n                ret[0] = min(nums2[l].index, nums2[r].index)-1;     // 注意，这里需要减去1\n                ret[1] = max(nums2[l].index, nums2[r].index)-1;\n                break;\n            } else if(sum < target){\n                l++;\n            } else {\n                r--;\n            }\n        }       \n        return ret;  // 用两个指针来扫\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n",normalizedContent:"# 1. 两数之和\n\n  ●  难度:   简单   \n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n\n示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n1\n2\n\n\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n1\n2\n\n\n提示：\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * 只会存在一个有效答案\n\n进阶： 你可以想出一个时间复杂度小于 o(n2) 的算法吗？\n\n\n\n# 英文题目: 2 sum (two sum)\n\ngiven an array of integers nums and an integer target, return _indices of the two numbers such that they add up to target. you may assume that each input would have exactly one solution, and you may not use the same element twice. you can return the answer in any order.\n\n\nexample 1:\n\ninput: nums = [2,7,11,15], target = 9 output: [0,1]\n\nexplaination: because nums[0] + nums[1] == 9, we return [0, 1].\n\nexample 2: input: nums = [3,2,4], target = 6 output: [1,2]\n\nexample 3: input: nums = [3,3], target = 6 output: [0,1]\n\nconstraints:\n\n * 2 <= nums.length <= 103\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * only one valid answer exists.\n\n\n# 分析:\n\n方法1: 暴力法，复杂度o(n^2)，会tle(超时);\n\n方法2: hashmap查表，在表中找 target - 当前循环变量i对应的那个数。用一个哈希表(c++中用unordered_map, c#中用dictionary, python中用dict，java中可以直接用hashmap)，存储每个数对应的下标，复杂度o(n);\n\n方法3: 快排 + 双指针\n\n\n# 方法2 ac代码:\n\n\n\nclass solution {\n\tpublic:\n\t\tvector<int> twosum(vector<int> &nums, int target)\n\t\t{\n\t\t\tunordered_map<int, int> dict;\n\t\t\tvector<int> result;\n\t\t\tfor(int i = 0; i < nums.size(); i++) {\n\t\t\t\tdict[nums[i]] = i; // 顺序的map映射: value->index \n\t\t\t}\n\t\t\tfor(int i = 0; i < nums.size(); i++)\n\t\t\t{\n\t\t\t\tint query = target - nums[i];\n\t\t\t\tif(dict.find(query) != dict.end() && dict[query] > i)  // dict[query] > i是为了防止重复计算 \n\t\t\t\t{\n\t\t\t\t\tresult.push_back(i);\n\t\t\t\t\tresult.push_back(dict[query]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 方法2的另一种写法:\n\nclass solution {\npublic:\n\tvector<int> twosum(vector<int> &nums, int target)\n\t{\n\t\tunordered_map<int, int> dict;\n\t\tvector<int> res(2,-1), emptyvect;\n\t\tfor(int i=0;i<nums.size();i++)\n\t\t{\n\t\t\tint query=target-nums[i];\n\t\t\tif(dict.find(query)==dict.end()) dict[nums[i]]=i;     // 逆序的map映射: value->index\n\t\t\telse {\n\t\t\t\tres[1]=i;\n\t\t\t\tres[0]=dict[query];\n\t\t\t\treturn res;\t\n\t\t\t}\n\t\t}\n\t\treturn emptyvect;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n\n# 方法3 ac代码:\n\n * 定义一个struct, 存储 index 和 value\n * 使用两个指针, l 和 r, l++, r--\n\nleft自增, right 自减\n\n注意: 如果要在一个struct上调用stl中的sort方法，需要先为其定义好 compare 函数。\n\n具体代码如下:\n\ntypedef struct node{\n    int index;\n    int value;\n    node(){};\n    node(int i, int v) : index(i), value(v){}\n} node;\n \nbool compare(const node& a, const node& b){\n    return a.value < b.value;\n}\n \nclass solution {\npublic:\n    vector<int> twosum(vector<int> &nums, int target) {\n         \n        int len = nums.size();\n        assert(len >= 2);         \n         \n        vector<int> ret(2, 0);  // 初始化：ret包含2个值为0的元素\n         \n        vector<node> nums2(len);\n        for(int i = 0; i < len; i++){\n            nums2[i] = node(i+1, nums[i]);\n        }\n        \n        sort(nums2.begin(), nums2.end(), compare);  // 在定义的struct上调用快排，t(n)=o(n*log(n))\n         \n        int l = 0;\n        int r = len - 1;\n        while(l < r){\n            int sum = nums2[l].value + nums2[r].value;\n            if(sum == target){\n                ret[0] = min(nums2[l].index, nums2[r].index)-1;     // 注意，这里需要减去1\n                ret[1] = max(nums2[l].index, nums2[r].index)-1;\n                break;\n            } else if(sum < target){\n                l++;\n            } else {\n                r--;\n            }\n        }       \n        return ret;  // 用两个指针来扫\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode2 Add Two Numbers",frontmatter:{title:"leetcode2 Add Two Numbers",date:"2021-07-20T04:24:14.000Z",permalink:"/p/244378/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0002.Add%20Two%20Numbers/images/addtwonumber1.jpg"},{name:"twitter:title",content:"leetcode2 Add Two Numbers"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0002.Add%20Two%20Numbers/images/addtwonumber1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10002.leetcode2%20Add%20Two%20Numbers.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode2 Add Two Numbers"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0002.Add%20Two%20Numbers/images/addtwonumber1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10002.leetcode2%20Add%20Two%20Numbers.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode2 Add Two Numbers"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0002.Add%20Two%20Numbers/images/addtwonumber1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10002.leetcode2%20Add%20Two%20Numbers.html",relativePath:"01.算法/24.leetcode/10002.leetcode2 Add Two Numbers.md",key:"v-39f537e0",path:"/p/244378/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:31},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:425},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:432},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1113},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2007},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2879},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:3611},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:4503},{level:3,title:"Ruby",slug:"ruby",normalizedTitle:"ruby",charIndex:5242},{level:3,title:"Swift",slug:"swift",normalizedTitle:"swift",charIndex:5960},{level:3,title:"Nim",slug:"nim",normalizedTitle:"nim",charIndex:6920},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:7186}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript C# Go Ruby Swift Nim ...",content:'# 2. 两数相加\n\nEnglish Version\n\n\n# 题目描述\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n \n\n示例 1：\n\n\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n\n\n示例 2：\n\n\n输入：l1 = [0], l2 = [0]\n输出：[0]\n\n\n示例 3：\n\n\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n\n\n \n\n提示：\n\n * 每个链表中的节点数在范围 [1, 100] 内\n * 0 <= Node.val <= 9\n * 题目数据保证列表表示的数字不含前导零\n\n\n# 解法\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummy = ListNode()\n        carry, cur = 0, dummy\n        while l1 or l2 or carry:\n            s = (0 if not l1 else l1.val) + (0 if not l2 else l2.val) + carry\n            carry, val = divmod(s, 10)\n            cur.next = ListNode(val)\n            cur = cur.next\n            l1 = None if not l1 else l1.next\n            l2 = None if not l2 else l2.next\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        int carry = 0;\n        ListNode cur = dummy;\n        while (l1 != null || l2 != null || carry != 0) {\n            int s = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;\n            carry = s / 10;\n            cur.next = new ListNode(s % 10);\n            cur = cur.next;\n            l1 = l1 == null ? null : l1.next;\n            l2 = l2 == null ? null : l2.next;\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode();\n        int carry = 0;\n        ListNode* cur = dummy;\n        while (l1 || l2 || carry) {\n            int s = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\n            carry = s / 10;\n            cur->next = new ListNode(s % 10);\n            cur = cur->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function(l1, l2) {\n    const dummy = new ListNode();\n    let carry = 0;\n    let cur = dummy;\n    while (l1 || l2 || carry) {\n        const s = (l1?.val || 0) + (l2?.val || 0) + carry;\n        carry = Math.floor(s / 10);\n        cur.next = new ListNode(s % 10);\n        cur = cur.next;\n        l1 = l1?.next;\n        l2 = l2?.next;\n    }\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# C#\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        int carry = 0;\n        ListNode cur = dummy;\n        while (l1 != null || l2 != null || carry != 0) {\n            int s = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;\n            carry = s / 10;\n            cur.next = new ListNode(s % 10);\n            cur = cur.next;\n            l1 = l1 == null ? null : l1.next;\n            l2 = l2 == null ? null : l2.next;\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    dummy := &ListNode{}\n    carry := 0\n    cur := dummy\n    for l1 != nil || l2 != nil || carry != 0 {\n        s := carry\n        if l1 != nil {\n            s += l1.Val\n        }\n        if l2 != nil {\n            s += l2.Val\n        }\n        carry = s / 10\n        cur.Next = &ListNode{s % 10, nil}\n        cur = cur.Next\n        if l1 != nil {\n            l1 = l1.Next\n        }\n        if l2 != nil {\n            l2 = l2.Next\n        }\n    }\n    return dummy.Next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# Ruby\n\n# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} l1\n# @param {ListNode} l2\n# @return {ListNode}\ndef add_two_numbers(l1, l2)\n    dummy = ListNode.new()\n    carry = 0\n    cur = dummy\n    while !l1.nil? || !l2.nil? || carry > 0\n        s = (l1.nil? ? 0 : l1.val) + (l2.nil? ? 0 : l2.val) + carry\n        carry = s / 10\n        cur.next = ListNode.new(s % 10)\n        cur = cur.next\n        l1 = l1.nil? ? l1 : l1.next\n        l2 = l2.nil? ? l2 : l2.next\n    end\n    dummy.next\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Swift\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n        var dummy = ListNode.init()\n        var carry = 0\n        var l1 = l1\n        var l2 = l2\n        var cur = dummy\n        while l1 != nil || l2 != nil || carry != 0 {\n            let s = (l1?.val ?? 0) + (l2?.val ?? 0) + carry\n            carry = s / 10\n            cur.next = ListNode.init(s % 10)\n            cur = cur.next!\n            l1 = l1?.next\n            l2 = l2?.next\n        }\n        return dummy.next\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# Nim\n\n#[\n    # Driver code in the solution file\n    # Definition for singly-linked list.\n    type\n    Node[int] = ref object\n        value: int\n        next: Node[int]\n\n    SinglyLinkedList[T] = object\n        head, tail: Node[T]  \n]#\n\n# More efficient code churning ...\nproc addTwoNumbers(l1: var SinglyLinkedList, l2: var SinglyLinkedList): SinglyLinkedList[int] =\n  var\n    aggregate: SinglyLinkedList\n    psum: seq[char]\n    temp_la, temp_lb: seq[int]\n\n  while not l1.head.isNil:\n    temp_la.add(l1.head.value)\n    l1.head = l1.head.next\n\n  while not l2.head.isNil:\n    temp_lb.add(l2.head.value)\n    l2.head = l2.head.next\n\n  psum = reversed($(reversed(temp_la).join("").parseInt() + reversed(temp_lb).join("").parseInt()))\n  for i in psum: aggregate.append(($i).parseInt())\n\n  result = aggregate\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 2. 两数相加\n\nenglish version\n\n\n# 题目描述\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n \n\n示例 1：\n\n\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n\n\n示例 2：\n\n\n输入：l1 = [0], l2 = [0]\n输出：[0]\n\n\n示例 3：\n\n\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n\n\n \n\n提示：\n\n * 每个链表中的节点数在范围 [1, 100] 内\n * 0 <= node.val <= 9\n * 题目数据保证列表表示的数字不含前导零\n\n\n# 解法\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def addtwonumbers(self, l1: listnode, l2: listnode) -> listnode:\n        dummy = listnode()\n        carry, cur = 0, dummy\n        while l1 or l2 or carry:\n            s = (0 if not l1 else l1.val) + (0 if not l2 else l2.val) + carry\n            carry, val = divmod(s, 10)\n            cur.next = listnode(val)\n            cur = cur.next\n            l1 = none if not l1 else l1.next\n            l2 = none if not l2 else l2.next\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode addtwonumbers(listnode l1, listnode l2) {\n        listnode dummy = new listnode(0);\n        int carry = 0;\n        listnode cur = dummy;\n        while (l1 != null || l2 != null || carry != 0) {\n            int s = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;\n            carry = s / 10;\n            cur.next = new listnode(s % 10);\n            cur = cur.next;\n            l1 = l1 == null ? null : l1.next;\n            l2 = l2 == null ? null : l2.next;\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* addtwonumbers(listnode* l1, listnode* l2) {\n        listnode* dummy = new listnode();\n        int carry = 0;\n        listnode* cur = dummy;\n        while (l1 || l2 || carry) {\n            int s = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\n            carry = s / 10;\n            cur->next = new listnode(s % 10);\n            cur = cur->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} l1\n * @param {listnode} l2\n * @return {listnode}\n */\nvar addtwonumbers = function(l1, l2) {\n    const dummy = new listnode();\n    let carry = 0;\n    let cur = dummy;\n    while (l1 || l2 || carry) {\n        const s = (l1?.val || 0) + (l2?.val || 0) + carry;\n        carry = math.floor(s / 10);\n        cur.next = new listnode(s % 10);\n        cur = cur.next;\n        l1 = l1?.next;\n        l2 = l2?.next;\n    }\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# c#\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     public int val;\n *     public listnode next;\n *     public listnode(int val=0, listnode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class solution {\n    public listnode addtwonumbers(listnode l1, listnode l2) {\n        listnode dummy = new listnode();\n        int carry = 0;\n        listnode cur = dummy;\n        while (l1 != null || l2 != null || carry != 0) {\n            int s = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;\n            carry = s / 10;\n            cur.next = new listnode(s % 10);\n            cur = cur.next;\n            l1 = l1 == null ? null : l1.next;\n            l2 = l2 == null ? null : l2.next;\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\nfunc addtwonumbers(l1 *listnode, l2 *listnode) *listnode {\n    dummy := &listnode{}\n    carry := 0\n    cur := dummy\n    for l1 != nil || l2 != nil || carry != 0 {\n        s := carry\n        if l1 != nil {\n            s += l1.val\n        }\n        if l2 != nil {\n            s += l2.val\n        }\n        carry = s / 10\n        cur.next = &listnode{s % 10, nil}\n        cur = cur.next\n        if l1 != nil {\n            l1 = l1.next\n        }\n        if l2 != nil {\n            l2 = l2.next\n        }\n    }\n    return dummy.next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# ruby\n\n# definition for singly-linked list.\n# class listnode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {listnode} l1\n# @param {listnode} l2\n# @return {listnode}\ndef add_two_numbers(l1, l2)\n    dummy = listnode.new()\n    carry = 0\n    cur = dummy\n    while !l1.nil? || !l2.nil? || carry > 0\n        s = (l1.nil? ? 0 : l1.val) + (l2.nil? ? 0 : l2.val) + carry\n        carry = s / 10\n        cur.next = listnode.new(s % 10)\n        cur = cur.next\n        l1 = l1.nil? ? l1 : l1.next\n        l2 = l2.nil? ? l2 : l2.next\n    end\n    dummy.next\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# swift\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     public var val: int\n *     public var next: listnode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: int) { self.val = val; self.next = nil; }\n *     public init(_ val: int, _ next: listnode?) { self.val = val; self.next = next; }\n * }\n */\nclass solution {\n    func addtwonumbers(_ l1: listnode?, _ l2: listnode?) -> listnode? {\n        var dummy = listnode.init()\n        var carry = 0\n        var l1 = l1\n        var l2 = l2\n        var cur = dummy\n        while l1 != nil || l2 != nil || carry != 0 {\n            let s = (l1?.val ?? 0) + (l2?.val ?? 0) + carry\n            carry = s / 10\n            cur.next = listnode.init(s % 10)\n            cur = cur.next!\n            l1 = l1?.next\n            l2 = l2?.next\n        }\n        return dummy.next\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# nim\n\n#[\n    # driver code in the solution file\n    # definition for singly-linked list.\n    type\n    node[int] = ref object\n        value: int\n        next: node[int]\n\n    singlylinkedlist[t] = object\n        head, tail: node[t]  \n]#\n\n# more efficient code churning ...\nproc addtwonumbers(l1: var singlylinkedlist, l2: var singlylinkedlist): singlylinkedlist[int] =\n  var\n    aggregate: singlylinkedlist\n    psum: seq[char]\n    temp_la, temp_lb: seq[int]\n\n  while not l1.head.isnil:\n    temp_la.add(l1.head.value)\n    l1.head = l1.head.next\n\n  while not l2.head.isnil:\n    temp_lb.add(l2.head.value)\n    l2.head = l2.head.next\n\n  psum = reversed($(reversed(temp_la).join("").parseint() + reversed(temp_lb).join("").parseint()))\n  for i in psum: aggregate.append(($i).parseint())\n\n  result = aggregate\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode3 Longest Substring Without Repeating Characters",frontmatter:{title:"leetcode3 Longest Substring Without Repeating Characters",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a2420b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode3 Longest Substring Without Repeating Characters"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10003.leetcode3%20Longest%20Substring%20Without%20Repeating%20Characters.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode3 Longest Substring Without Repeating Characters"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10003.leetcode3%20Longest%20Substring%20Without%20Repeating%20Characters.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode3 Longest Substring Without Repeating Characters"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10003.leetcode3%20Longest%20Substring%20Without%20Repeating%20Characters.html",relativePath:"01.算法/24.leetcode/10003.leetcode3 Longest Substring Without Repeating Characters.md",key:"v-11eba928",path:"/p/a2420b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:414},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:552},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1087},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:1761},{level:3,title:"Swift",slug:"swift",normalizedTitle:"swift",charIndex:2258},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2907}],headersStr:"题目描述 解法 Python3 Java TypeScript Swift ...",content:'# 3. 无重复字符的最长子串\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n \n\n示例 1:\n\n\n输入: s = "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n\n示例 2:\n\n\n输入: s = "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n\n\n示例 3:\n\n\n输入: s = "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n\n\n示例 4:\n\n\n输入: s = ""\n输出: 0\n\n\n \n\n提示：\n\n * 0 <= s.length <= 5 * 104\n * s 由英文字母、数字、符号和空格组成\n\n\n# 解法\n\n * 定义一个哈希表存放字符及其出现的位置；\n * 定义 i, j 分别表示不重复子串的开始位置和结束位置；\n * j 向后遍历，若遇到与 [i, j] 区间内字符相同的元素，更新 i 的值，此时 [i, j] 区间内不存在重复字符，计算 res 的最大值。\n\n\n# Python3\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        res, chars = 0, dict()\n        i = j = 0\n        while j < len(s):\n            if s[j] in chars:\n                # chars[s[j]]+1 可能比 i 还小，通过 max 函数来锁住左边界\n                # e.g. 在"tmmzuxt"这个字符串中，遍历到最后一步时，最后一个字符\'t\'和第一个字符\'t\'是相等的。如果没有 max 函数，i 就会回到第一个\'t\'的索引0处的下一个位置\n                i = max(i, chars[s[j]] + 1)\n            res = max(res, j - i + 1)\n            chars[s[j]] = j\n            j += 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int res = 0;\n        Map<Character, Integer> chars = new HashMap<>();\n        for (int i = 0, j = 0; j < s.length(); ++j) {\n            char c = s.charAt(j);\n            if (chars.containsKey(c)) {\n                // chars.get(c)+1 可能比 i 还小，通过 max 函数来锁住左边界\n                // e.g. 在"tmmzuxt"这个字符串中，遍历到最后一步时，最后一个字符\'t\'和第一个字符\'t\'是相等的。如果没有 max 函数，i 就会回到第一个\'t\'的索引0处的下一个位置\n                i = Math.max(i, chars.get(c) + 1);\n            }\n            chars.put(c, j);\n            res = Math.max(res, j - i + 1);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# TypeScript\n\nfunction lengthOfLongestSubstring(s: string): number {\n    // 滑动窗口+哈希表\n    let left = -1;\n    let maxLen = 0;\n    let hashTable = new Map();\n    for (let right = 0; right < s.length; right++) {\n        let cur = s.charAt(right);\n        if (hashTable.has(cur)) {\n          left = Math.max(left, hashTable.get(cur));\n        }\n        hashTable.set(cur, right);\n        maxLen = Math.max(maxLen, right - left);\n    }\n      return maxLen;\n  };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Swift\n\nclass Solution {\n    func lengthOfLongestSubstring(_ s: String) -> Int {\n        var map = [Character: Int]()\n        var currentStartingIndex = 0\n        var i = 0\n        var maxLength = 0\n        for char in s {\n            if map[char] != nil {\n                if map[char]! >= currentStartingIndex {\n                    maxLength = max(maxLength, i - currentStartingIndex)\n                    currentStartingIndex = map[char]! + 1\n                }\n            }\n            map[char] = i\n            i += 1\n        }\n        return max(maxLength, i - currentStartingIndex)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 3. 无重复字符的最长子串\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n \n\n示例 1:\n\n\n输入: s = "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n\n示例 2:\n\n\n输入: s = "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n\n\n示例 3:\n\n\n输入: s = "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n\n\n示例 4:\n\n\n输入: s = ""\n输出: 0\n\n\n \n\n提示：\n\n * 0 <= s.length <= 5 * 104\n * s 由英文字母、数字、符号和空格组成\n\n\n# 解法\n\n * 定义一个哈希表存放字符及其出现的位置；\n * 定义 i, j 分别表示不重复子串的开始位置和结束位置；\n * j 向后遍历，若遇到与 [i, j] 区间内字符相同的元素，更新 i 的值，此时 [i, j] 区间内不存在重复字符，计算 res 的最大值。\n\n\n# python3\n\nclass solution:\n    def lengthoflongestsubstring(self, s: str) -> int:\n        res, chars = 0, dict()\n        i = j = 0\n        while j < len(s):\n            if s[j] in chars:\n                # chars[s[j]]+1 可能比 i 还小，通过 max 函数来锁住左边界\n                # e.g. 在"tmmzuxt"这个字符串中，遍历到最后一步时，最后一个字符\'t\'和第一个字符\'t\'是相等的。如果没有 max 函数，i 就会回到第一个\'t\'的索引0处的下一个位置\n                i = max(i, chars[s[j]] + 1)\n            res = max(res, j - i + 1)\n            chars[s[j]] = j\n            j += 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\nclass solution {\n    public int lengthoflongestsubstring(string s) {\n        int res = 0;\n        map<character, integer> chars = new hashmap<>();\n        for (int i = 0, j = 0; j < s.length(); ++j) {\n            char c = s.charat(j);\n            if (chars.containskey(c)) {\n                // chars.get(c)+1 可能比 i 还小，通过 max 函数来锁住左边界\n                // e.g. 在"tmmzuxt"这个字符串中，遍历到最后一步时，最后一个字符\'t\'和第一个字符\'t\'是相等的。如果没有 max 函数，i 就会回到第一个\'t\'的索引0处的下一个位置\n                i = math.max(i, chars.get(c) + 1);\n            }\n            chars.put(c, j);\n            res = math.max(res, j - i + 1);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# typescript\n\nfunction lengthoflongestsubstring(s: string): number {\n    // 滑动窗口+哈希表\n    let left = -1;\n    let maxlen = 0;\n    let hashtable = new map();\n    for (let right = 0; right < s.length; right++) {\n        let cur = s.charat(right);\n        if (hashtable.has(cur)) {\n          left = math.max(left, hashtable.get(cur));\n        }\n        hashtable.set(cur, right);\n        maxlen = math.max(maxlen, right - left);\n    }\n      return maxlen;\n  };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# swift\n\nclass solution {\n    func lengthoflongestsubstring(_ s: string) -> int {\n        var map = [character: int]()\n        var currentstartingindex = 0\n        var i = 0\n        var maxlength = 0\n        for char in s {\n            if map[char] != nil {\n                if map[char]! >= currentstartingindex {\n                    maxlength = max(maxlength, i - currentstartingindex)\n                    currentstartingindex = map[char]! + 1\n                }\n            }\n            map[char] = i\n            i += 1\n        }\n        return max(maxlength, i - currentstartingindex)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode4 寻找两个正序数组的中位数【困难难度】",frontmatter:{title:"leetcode4 寻找两个正序数组的中位数【困难难度】",date:"2021-07-17T11:23:48.000Z",permalink:"/leetcode4/",categories:["leetcode","学习笔记","算法"],tags:["leetcode"],description:"         &nbsp; ● &nbsp;难度:     困难",meta:[{name:"twitter:title",content:"leetcode4 寻找两个正序数组的中位数【困难难度】"},{name:"twitter:description",content:"         &nbsp; ● &nbsp;难度:     困难"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10004.leetcode4%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%5B%E5%9B%B0%E9%9A%BE%E9%9A%BE%E5%BA%A6%5D.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode4 寻找两个正序数组的中位数【困难难度】"},{property:"og:description",content:"         &nbsp; ● &nbsp;难度:     困难"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10004.leetcode4%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%5B%E5%9B%B0%E9%9A%BE%E9%9A%BE%E5%BA%A6%5D.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-17T11:23:48.000Z"},{property:"article:tag",content:"leetcode"},{itemprop:"name",content:"leetcode4 寻找两个正序数组的中位数【困难难度】"},{itemprop:"description",content:"         &nbsp; ● &nbsp;难度:     困难"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10004.leetcode4%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%5B%E5%9B%B0%E9%9A%BE%E9%9A%BE%E5%BA%A6%5D.html",relativePath:"01.算法/24.leetcode/10004.leetcode4 寻找两个正序数组的中位数[困难难度].md",key:"v-2dfb486b",path:"/leetcode4/",headers:[{level:3,title:"4. 寻找两个正序数组的中位数",slug:"_4-寻找两个正序数组的中位数",normalizedTitle:"4. 寻找两个正序数组的中位数",charIndex:2},{level:3,title:"英文题目: Median of two sorted arrays",slug:"英文题目-median-of-two-sorted-arrays",normalizedTitle:"英文题目: median of two sorted arrays",charIndex:22},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:682},{level:3,title:"已AC的C++代码:",slug:"已ac的c-代码",normalizedTitle:"已ac的c++代码:",charIndex:784}],headersStr:"4. 寻找两个正序数组的中位数 英文题目: Median of two sorted arrays 思路 已AC的C++代码:",content:"# 4. 寻找两个正序数组的中位数\n\n\n# 英文题目: Median of two sorted arrays\n\n  ●  难度:   困难   \n\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n\n示例 1：\n\n输入：nums1 = [1,3], nums2 = [2]\n输出：2.00000\n解释：合并数组 = [1,2,3] ，中位数 2\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums1 = [1,2], nums2 = [3,4]\n输出：2.50000\n解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n\n\n1\n2\n3\n\n\n示例 3：\n\n输入：nums1 = [0,0], nums2 = [0,0]\n输出：0.00000\n\n\n1\n2\n\n\n示例 4：\n\n输入：nums1 = [], nums2 = [1]\n输出：1.00000\n\n\n1\n2\n\n\n示例 5：\n\n输入：nums1 = [2], nums2 = []\n输出：2.00000\n\n\n1\n2\n\n\n提示：\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106\n\n**进阶：**你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？\n\n\n\n# 思路\n\n先合并两个有序数组，然后根据数组长度的奇偶来取到中位数。如果是偶数个，就取中间两个的平均数；如果是奇数个，直接取最中间的即可。\n\n与 leetcode 88. 合并两个有序数组 类似。\n\n\n\n# 已AC的C++代码:\n\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> nums;         \n        double res;\n        int m = nums1.size();\n        int n = nums2.size();\n        int len;\n\n        int i = 0, j = 0;\n        while (i < m && j < n)  // 只要一个指针扫到数组末尾，循环结束\n        {\n            if(nums1[i] <= nums2[j])\n            {\n                nums.push_back(nums1[i]);\n                i++;\n            }\n            else {\n                nums.push_back(nums2[j]);\n                j++;\n            }\n        }\n\n        while(i < m)  // 数组nums1没跑完，nums2已跑完时\n        {\n            nums.push_back(nums1[i]);\n            i++;\n        }\n\n        while(j < n)  // 数组nums2没跑完，nums1已跑完时\n        {\n            nums.push_back(nums2[j]);\n            j++;\n        }\n        len = nums.size();\n        if(len % 2 == 0)\n        {\n            res = (nums[len/2] + nums[len/2-1])/2.0;\n        }\n        else res = nums[len/2];\n\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n参考: https://leetcode-cn.com/submissions/detail/194261796/",normalizedContent:"# 4. 寻找两个正序数组的中位数\n\n\n# 英文题目: median of two sorted arrays\n\n  ●  难度:   困难   \n\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n\n示例 1：\n\n输入：nums1 = [1,3], nums2 = [2]\n输出：2.00000\n解释：合并数组 = [1,2,3] ，中位数 2\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums1 = [1,2], nums2 = [3,4]\n输出：2.50000\n解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n\n\n1\n2\n3\n\n\n示例 3：\n\n输入：nums1 = [0,0], nums2 = [0,0]\n输出：0.00000\n\n\n1\n2\n\n\n示例 4：\n\n输入：nums1 = [], nums2 = [1]\n输出：1.00000\n\n\n1\n2\n\n\n示例 5：\n\n输入：nums1 = [2], nums2 = []\n输出：2.00000\n\n\n1\n2\n\n\n提示：\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106\n\n**进阶：**你能设计一个时间复杂度为 o(log (m+n)) 的算法解决此问题吗？\n\n\n\n# 思路\n\n先合并两个有序数组，然后根据数组长度的奇偶来取到中位数。如果是偶数个，就取中间两个的平均数；如果是奇数个，直接取最中间的即可。\n\n与 leetcode 88. 合并两个有序数组 类似。\n\n\n\n# 已ac的c++代码:\n\nclass solution {\npublic:\n    double findmediansortedarrays(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> nums;         \n        double res;\n        int m = nums1.size();\n        int n = nums2.size();\n        int len;\n\n        int i = 0, j = 0;\n        while (i < m && j < n)  // 只要一个指针扫到数组末尾，循环结束\n        {\n            if(nums1[i] <= nums2[j])\n            {\n                nums.push_back(nums1[i]);\n                i++;\n            }\n            else {\n                nums.push_back(nums2[j]);\n                j++;\n            }\n        }\n\n        while(i < m)  // 数组nums1没跑完，nums2已跑完时\n        {\n            nums.push_back(nums1[i]);\n            i++;\n        }\n\n        while(j < n)  // 数组nums2没跑完，nums1已跑完时\n        {\n            nums.push_back(nums2[j]);\n            j++;\n        }\n        len = nums.size();\n        if(len % 2 == 0)\n        {\n            res = (nums[len/2] + nums[len/2-1])/2.0;\n        }\n        else res = nums[len/2];\n\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n参考: https://leetcode-cn.com/submissions/detail/194261796/",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode5 Longest Palindromic Substring",frontmatter:{title:"leetcode5 Longest Palindromic Substring",date:"2021-07-20T04:24:14.000Z",permalink:"/p/804ab4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode5 Longest Palindromic Substring"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10005.leetcode5%20Longest%20Palindromic%20Substring.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode5 Longest Palindromic Substring"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10005.leetcode5%20Longest%20Palindromic%20Substring.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode5 Longest Palindromic Substring"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10005.leetcode5%20Longest%20Palindromic%20Substring.html",relativePath:"01.算法/24.leetcode/10005.leetcode5 Longest Palindromic Substring.md",key:"v-4abfd090",path:"/p/804ab4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:275},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:282},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:301},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:317}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 5. 最长回文子串\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个字符串 s，找到 s 中最长的回文子串。\n\n \n\n示例 1：\n\n\n输入：s = "babad"\n输出："bab"\n解释："aba" 同样是符合题意的答案。\n\n\n示例 2：\n\n\n输入：s = "cbbd"\n输出："bb"\n\n\n示例 3：\n\n\n输入：s = "a"\n输出："a"\n\n\n示例 4：\n\n\n输入：s = "ac"\n输出："a"\n\n\n \n\n提示：\n\n * 1 <= s.length <= 1000\n * s 仅由数字和英文字母（大写和/或小写）组成\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 5. 最长回文子串\n\nenglish version\n\n\n# 题目描述\n\n给你一个字符串 s，找到 s 中最长的回文子串。\n\n \n\n示例 1：\n\n\n输入：s = "babad"\n输出："bab"\n解释："aba" 同样是符合题意的答案。\n\n\n示例 2：\n\n\n输入：s = "cbbd"\n输出："bb"\n\n\n示例 3：\n\n\n输入：s = "a"\n输出："a"\n\n\n示例 4：\n\n\n输入：s = "ac"\n输出："a"\n\n\n \n\n提示：\n\n * 1 <= s.length <= 1000\n * s 仅由数字和英文字母（大写和/或小写）组成\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode6 ZigZag Conversion",frontmatter:{title:"leetcode6 ZigZag Conversion",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a57b35/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode6 ZigZag Conversion"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10006.leetcode6%20ZigZag%20Conversion.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode6 ZigZag Conversion"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10006.leetcode6%20ZigZag%20Conversion.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode6 ZigZag Conversion"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10006.leetcode6%20ZigZag%20Conversion.html",relativePath:"01.算法/24.leetcode/10006.leetcode6 ZigZag Conversion.md",key:"v-4a700847",path:"/p/a57b35/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:604},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:611},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:630},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:646}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 6. Z 字形变换\n\nEnglish Version\n\n\n# 题目描述\n\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：\n\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\n\nstring convert(string s, int numRows);\n\n \n\n示例 1：\n\n\n输入：s = "PAYPALISHIRING", numRows = 3\n输出："PAHNAPLSIIGYIR"\n\n\n示例 2：\n\n\n输入：s = "PAYPALISHIRING", numRows = 4\n输出："PINALSIGYAHRPI"\n解释：\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n\n示例 3：\n\n\n输入：s = "A", numRows = 1\n输出："A"\n\n\n \n\n提示：\n\n * 1 <= s.length <= 1000\n * s 由英文字母（小写和大写）、\',\' 和 \'.\' 组成\n * 1 <= numRows <= 1000\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 6. z 字形变换\n\nenglish version\n\n\n# 题目描述\n\n将一个给定字符串 s 根据给定的行数 numrows ，以从上往下、从左到右进行 z 字形排列。\n\n比如输入字符串为 "paypalishiring" 行数为 3 时，排列如下：\n\n\np   a   h   n\na p l s i i g\ny   i   r\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："pahnaplsiigyir"。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\n\nstring convert(string s, int numrows);\n\n \n\n示例 1：\n\n\n输入：s = "paypalishiring", numrows = 3\n输出："pahnaplsiigyir"\n\n\n示例 2：\n\n\n输入：s = "paypalishiring", numrows = 4\n输出："pinalsigyahrpi"\n解释：\np     i    n\na   l s  i g\ny a   h r\np     i\n\n\n示例 3：\n\n\n输入：s = "a", numrows = 1\n输出："a"\n\n\n \n\n提示：\n\n * 1 <= s.length <= 1000\n * s 由英文字母（小写和大写）、\',\' 和 \'.\' 组成\n * 1 <= numrows <= 1000\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode7 Reverse Integer",frontmatter:{title:"leetcode7 Reverse Integer",date:"2021-07-20T04:24:14.000Z",permalink:"/p/786ee4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode7 Reverse Integer"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10007.leetcode7%20Reverse%20Integer.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode7 Reverse Integer"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10007.leetcode7%20Reverse%20Integer.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode7 Reverse Integer"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10007.leetcode7%20Reverse%20Integer.html",relativePath:"01.算法/24.leetcode/10007.leetcode7 Reverse Integer.md",key:"v-176ecc6d",path:"/p/786ee4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:31},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:303},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:310},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:530},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:858},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1125},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1408}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript ...",content:"# 7. 整数反转\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n\n如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。\n\n假设环境不允许存储 64 位整数（有符号或无符号）。\n\n \n\n示例 1：\n\n\n输入：x = 123\n输出：321\n\n\n示例 2：\n\n\n输入：x = -123\n输出：-321\n\n\n示例 3：\n\n\n输入：x = 120\n输出：21\n\n\n示例 4：\n\n\n输入：x = 0\n输出：0\n\n\n \n\n提示：\n\n * -231 <= x <= 231 - 1\n\n\n# 解法\n\n\n# Python3\n\n转字符串，进行翻转。\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        y = int(str(abs(x))[::-1])\n        res = -y if x < 0 else y\n        return 0 if res < -2**31 or res > 2**31 -1 else res\n\n\n1\n2\n3\n4\n5\n\n\n\n# Java\n\nclass Solution {\n    public int reverse(int x) {\n        long res = 0;\n        // 考虑负数情况，所以这里条件为: x != 0\n        while (x != 0) {\n            res = res * 10 + (x % 10);\n            x /= 10;\n        }\n        return res < Integer.MIN_VALUE || res > Integer.MAX_VALUE ? 0 : (int) res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        long long ans = 0;\n        while (x) {\n            ans = ans * 10 + x % 10;\n            x /= 10;\n        }\n        return ans < INT_MIN || ans > INT_MAX ? 0 : ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# JavaScript\n\n/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function (x) {\n  let res = 0;\n  while (x) {\n    res = res * 10 + (x % 10);\n    x = ~~(x / 10);\n  }\n  return res < Math.pow(-2, 31) || res > Math.pow(2, 31) - 1 ? 0 : res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 7. 整数反转\n\nenglish version\n\n\n# 题目描述\n\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n\n如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。\n\n假设环境不允许存储 64 位整数（有符号或无符号）。\n\n \n\n示例 1：\n\n\n输入：x = 123\n输出：321\n\n\n示例 2：\n\n\n输入：x = -123\n输出：-321\n\n\n示例 3：\n\n\n输入：x = 120\n输出：21\n\n\n示例 4：\n\n\n输入：x = 0\n输出：0\n\n\n \n\n提示：\n\n * -231 <= x <= 231 - 1\n\n\n# 解法\n\n\n# python3\n\n转字符串，进行翻转。\n\nclass solution:\n    def reverse(self, x: int) -> int:\n        y = int(str(abs(x))[::-1])\n        res = -y if x < 0 else y\n        return 0 if res < -2**31 or res > 2**31 -1 else res\n\n\n1\n2\n3\n4\n5\n\n\n\n# java\n\nclass solution {\n    public int reverse(int x) {\n        long res = 0;\n        // 考虑负数情况，所以这里条件为: x != 0\n        while (x != 0) {\n            res = res * 10 + (x % 10);\n            x /= 10;\n        }\n        return res < integer.min_value || res > integer.max_value ? 0 : (int) res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# c++\n\nclass solution {\npublic:\n    int reverse(int x) {\n        long long ans = 0;\n        while (x) {\n            ans = ans * 10 + x % 10;\n            x /= 10;\n        }\n        return ans < int_min || ans > int_max ? 0 : ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# javascript\n\n/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function (x) {\n  let res = 0;\n  while (x) {\n    res = res * 10 + (x % 10);\n    x = ~~(x / 10);\n  }\n  return res < math.pow(-2, 31) || res > math.pow(2, 31) - 1 ? 0 : res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode8 String to Integer (atoi)",frontmatter:{title:"leetcode8 String to Integer (atoi)",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d5e058/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode8 String to Integer (atoi)"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10008.leetcode8%20String%20to%20Integer%20(atoi).html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode8 String to Integer (atoi)"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10008.leetcode8%20String%20to%20Integer%20(atoi).html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode8 String to Integer (atoi)"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10008.leetcode8%20String%20to%20Integer%20(atoi).html",relativePath:"01.算法/24.leetcode/10008.leetcode8 String to Integer (atoi).md",key:"v-29b3469e",path:"/p/d5e058/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:41},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:2003},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:2047},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2888},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3760}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 8. 字符串转换整数 (atoi)\n\nEnglish Version\n\n\n# 题目描述\n\n请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。\n\n函数 myAtoi(string s) 的算法如下：\n\n * 读入字符串并丢弃无用的前导空格\n * 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n * 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n * 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。\n * 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。\n * 返回整数作为最终结果。\n\n注意：\n\n * 本题中的空白字符只包括空格字符 \' \' 。\n * 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\n\n \n\n示例 1：\n\n\n输入：s = "42"\n输出：42\n解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n第 1 步："42"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："42"（当前没有读入字符，因为这里不存在 \'-\' 或者 \'+\'）\n         ^\n第 3 步："42"（读入 "42"）\n           ^\n解析得到整数 42 。\n由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。\n\n示例 2：\n\n\n输入：s = "   -42"\n输出：-42\n解释：\n第 1 步："   -42"（读入前导空格，但忽视掉）\n            ^\n第 2 步："   -42"（读入 \'-\' 字符，所以结果应该是负数）\n             ^\n第 3 步："   -42"（读入 "42"）\n               ^\n解析得到整数 -42 。\n由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。\n\n\n示例 3：\n\n\n输入：s = "4193 with words"\n输出：4193\n解释：\n第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 \'-\' 或者 \'+\'）\n         ^\n第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n解析得到整数 4193 。\n由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。\n\n\n示例 4：\n\n\n输入：s = "words and 987"\n输出：0\n解释：\n第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："words and 987"（当前没有读入字符，因为这里不存在 \'-\' 或者 \'+\'）\n         ^\n第 3 步："words and 987"（由于当前字符 \'w\' 不是一个数字，所以读入停止）\n         ^\n解析得到整数 0 ，因为没有读入任何数字。\n由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。\n\n示例 5：\n\n\n输入：s = "-91283472332"\n输出：-2147483648\n解释：\n第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："-91283472332"（读入 \'-\' 字符，所以结果应该是负数）\n          ^\n第 3 步："-91283472332"（读入 "91283472332"）\n                     ^\n解析得到整数 -91283472332 。\n由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。\n\n \n\n提示：\n\n * 0 <= s.length <= 200\n * s 由英文字母（大写和小写）、数字（0-9）、\' \'、\'+\'、\'-\' 和 \'.\' 组成\n\n\n# 解法\n\n遍历字符串，注意做溢出处理。\n\n同面试题 67. 把字符串转换成整数。\n\n\n# Python3\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        if not s:\n            return 0\n        n = len(s)\n        if n == 0:\n            return 0\n        i = 0\n        while s[i] == \' \':\n            i += 1\n            # 仅包含空格\n            if i == n:\n                return 0\n        sign = -1 if s[i] == \'-\' else 1\n        if s[i] in [\'-\', \'+\']:\n            i += 1\n        res, flag = 0, (2 ** 31 - 1) // 10\n        while i < n:\n            # 非数字，跳出循环体\n            if not s[i].isdigit():\n                break\n            c = int(s[i])\n            # 溢出判断\n            if res > flag or (res == flag and c > 7):\n                return 2 ** 31 - 1 if sign > 0 else -2 ** 31\n            res = res * 10 + c\n            i += 1\n        return sign * res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# Java\n\nclass Solution {\n    public int myAtoi(String s) {\n        if (s == null) return 0;\n        int n = s.length();\n        if (n == 0) return 0;\n        int i = 0;\n        while (s.charAt(i) == \' \') {\n            // 仅包含空格\n            if (++i == n) return 0;\n        }\n        int sign = 1;\n        if (s.charAt(i) == \'-\') sign = -1;\n        if (s.charAt(i) == \'-\' || s.charAt(i) == \'+\') ++i;\n        int res = 0, flag = Integer.MAX_VALUE / 10;\n        for (; i < n; ++i) {\n            // 非数字，跳出循环体\n            if (s.charAt(i) < \'0\' || s.charAt(i) > \'9\') break;\n            // 溢出判断\n            if (res > flag || (res == flag && s.charAt(i) > \'7\')) return sign > 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n            res = res * 10 + (s.charAt(i) - \'0\');\n        }\n        return sign * res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 8. 字符串转换整数 (atoi)\n\nenglish version\n\n\n# 题目描述\n\n请你来实现一个 myatoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 c/c++ 中的 atoi 函数）。\n\n函数 myatoi(string s) 的算法如下：\n\n * 读入字符串并丢弃无用的前导空格\n * 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n * 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n * 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。\n * 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。\n * 返回整数作为最终结果。\n\n注意：\n\n * 本题中的空白字符只包括空格字符 \' \' 。\n * 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\n\n \n\n示例 1：\n\n\n输入：s = "42"\n输出：42\n解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n第 1 步："42"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："42"（当前没有读入字符，因为这里不存在 \'-\' 或者 \'+\'）\n         ^\n第 3 步："42"（读入 "42"）\n           ^\n解析得到整数 42 。\n由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。\n\n示例 2：\n\n\n输入：s = "   -42"\n输出：-42\n解释：\n第 1 步："   -42"（读入前导空格，但忽视掉）\n            ^\n第 2 步："   -42"（读入 \'-\' 字符，所以结果应该是负数）\n             ^\n第 3 步："   -42"（读入 "42"）\n               ^\n解析得到整数 -42 。\n由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。\n\n\n示例 3：\n\n\n输入：s = "4193 with words"\n输出：4193\n解释：\n第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 \'-\' 或者 \'+\'）\n         ^\n第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n解析得到整数 4193 。\n由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。\n\n\n示例 4：\n\n\n输入：s = "words and 987"\n输出：0\n解释：\n第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："words and 987"（当前没有读入字符，因为这里不存在 \'-\' 或者 \'+\'）\n         ^\n第 3 步："words and 987"（由于当前字符 \'w\' 不是一个数字，所以读入停止）\n         ^\n解析得到整数 0 ，因为没有读入任何数字。\n由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。\n\n示例 5：\n\n\n输入：s = "-91283472332"\n输出：-2147483648\n解释：\n第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："-91283472332"（读入 \'-\' 字符，所以结果应该是负数）\n          ^\n第 3 步："-91283472332"（读入 "91283472332"）\n                     ^\n解析得到整数 -91283472332 。\n由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。\n\n \n\n提示：\n\n * 0 <= s.length <= 200\n * s 由英文字母（大写和小写）、数字（0-9）、\' \'、\'+\'、\'-\' 和 \'.\' 组成\n\n\n# 解法\n\n遍历字符串，注意做溢出处理。\n\n同面试题 67. 把字符串转换成整数。\n\n\n# python3\n\nclass solution:\n    def myatoi(self, s: str) -> int:\n        if not s:\n            return 0\n        n = len(s)\n        if n == 0:\n            return 0\n        i = 0\n        while s[i] == \' \':\n            i += 1\n            # 仅包含空格\n            if i == n:\n                return 0\n        sign = -1 if s[i] == \'-\' else 1\n        if s[i] in [\'-\', \'+\']:\n            i += 1\n        res, flag = 0, (2 ** 31 - 1) // 10\n        while i < n:\n            # 非数字，跳出循环体\n            if not s[i].isdigit():\n                break\n            c = int(s[i])\n            # 溢出判断\n            if res > flag or (res == flag and c > 7):\n                return 2 ** 31 - 1 if sign > 0 else -2 ** 31\n            res = res * 10 + c\n            i += 1\n        return sign * res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# java\n\nclass solution {\n    public int myatoi(string s) {\n        if (s == null) return 0;\n        int n = s.length();\n        if (n == 0) return 0;\n        int i = 0;\n        while (s.charat(i) == \' \') {\n            // 仅包含空格\n            if (++i == n) return 0;\n        }\n        int sign = 1;\n        if (s.charat(i) == \'-\') sign = -1;\n        if (s.charat(i) == \'-\' || s.charat(i) == \'+\') ++i;\n        int res = 0, flag = integer.max_value / 10;\n        for (; i < n; ++i) {\n            // 非数字，跳出循环体\n            if (s.charat(i) < \'0\' || s.charat(i) > \'9\') break;\n            // 溢出判断\n            if (res > flag || (res == flag && s.charat(i) > \'7\')) return sign > 0 ? integer.max_value : integer.min_value;\n            res = res * 10 + (s.charat(i) - \'0\');\n        }\n        return sign * res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode9 Palindrome Number",frontmatter:{title:"leetcode9 Palindrome Number",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d52cd1/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode9 Palindrome Number"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10009.leetcode9%20Palindrome%20Number.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode9 Palindrome Number"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10009.leetcode9%20Palindrome%20Number.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode9 Palindrome Number"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10009.leetcode9%20Palindrome%20Number.html",relativePath:"01.算法/24.leetcode/10009.leetcode9 Palindrome Number.md",key:"v-6b8abe87",path:"/p/d52cd1/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:30},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:397},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:404},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:653},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:927}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 9. 回文数\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。\n\n \n\n示例 1：\n\n\n输入：x = 121\n输出：true\n\n\n示例 2：\n\n\n输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n\n示例 3：\n\n\n输入：x = 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。\n\n\n示例 4：\n\n\n输入：x = -101\n输出：false\n\n\n \n\n提示：\n\n * -231 <= x <= 231 - 1\n\n \n\n进阶：你能不将整数转为字符串来解决这个问题吗？\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        y, t = 0, x\n        while t:\n            y = y * 10 + t % 10\n            t //= 10\n        return x == y\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Java\n\nclass Solution {\n    public boolean isPalindrome(int x) {\n        if (x < 0) return false;\n        int y = 0, t = x;\n        while (t != 0) {\n            y = y * 10 + t % 10;\n            t /= 10;\n        }\n        return x == y;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 9. 回文数\n\nenglish version\n\n\n# 题目描述\n\n给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。\n\n \n\n示例 1：\n\n\n输入：x = 121\n输出：true\n\n\n示例 2：\n\n\n输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n\n示例 3：\n\n\n输入：x = 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。\n\n\n示例 4：\n\n\n输入：x = -101\n输出：false\n\n\n \n\n提示：\n\n * -231 <= x <= 231 - 1\n\n \n\n进阶：你能不将整数转为字符串来解决这个问题吗？\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def ispalindrome(self, x: int) -> bool:\n        if x < 0:\n            return false\n        y, t = 0, x\n        while t:\n            y = y * 10 + t % 10\n            t //= 10\n        return x == y\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# java\n\nclass solution {\n    public boolean ispalindrome(int x) {\n        if (x < 0) return false;\n        int y = 0, t = x;\n        while (t != 0) {\n            y = y * 10 + t % 10;\n            t /= 10;\n        }\n        return x == y;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode10 Regular Expression Matching",frontmatter:{title:"leetcode10 Regular Expression Matching",date:"2021-07-20T04:24:14.000Z",permalink:"/p/10dbda/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode10 Regular Expression Matching"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10010.leetcode10%20Regular%20Expression%20Matching.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode10 Regular Expression Matching"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10010.leetcode10%20Regular%20Expression%20Matching.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode10 Regular Expression Matching"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10010.leetcode10%20Regular%20Expression%20Matching.html",relativePath:"01.算法/24.leetcode/10010.leetcode10 Regular Expression Matching.md",key:"v-4e764050",path:"/p/10dbda/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:724},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:731},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:750},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:766}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 10. 正则表达式匹配\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 \'.\' 和 \'*\' 的正则表达式匹配。\n\n * \'.\' 匹配任意单个字符\n * \'*\' 匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n\n \n\n示例 1：\n\n\n输入：s = "aa" p = "a"\n输出：false\n解释："a" 无法匹配 "aa" 整个字符串。\n\n\n示例 2:\n\n\n输入：s = "aa" p = "a*"\n输出：true\n解释：因为 \'*\' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 \'a\'。因此，字符串 "aa" 可被视为 \'a\' 重复了一次。\n\n\n示例 3：\n\n\n输入：s = "ab" p = ".*"\n输出：true\n解释：".*" 表示可匹配零个或多个（\'*\'）任意字符（\'.\'）。\n\n\n示例 4：\n\n\n输入：s = "aab" p = "c*a*b"\n输出：true\n解释：因为 \'*\' 表示零个或多个，这里 \'c\' 为 0 个, \'a\' 被重复一次。因此可以匹配字符串 "aab"。\n\n\n示例 5：\n\n\n输入：s = "mississippi" p = "mis*is*p*."\n输出：false\n\n \n\n提示：\n\n * 0 <= s.length <= 20\n * 0 <= p.length <= 30\n * s 可能为空，且只包含从 a-z 的小写字母。\n * p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n * 保证每次出现字符 * 时，前面都匹配到有效的字符\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 10. 正则表达式匹配\n\nenglish version\n\n\n# 题目描述\n\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 \'.\' 和 \'*\' 的正则表达式匹配。\n\n * \'.\' 匹配任意单个字符\n * \'*\' 匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n\n \n\n示例 1：\n\n\n输入：s = "aa" p = "a"\n输出：false\n解释："a" 无法匹配 "aa" 整个字符串。\n\n\n示例 2:\n\n\n输入：s = "aa" p = "a*"\n输出：true\n解释：因为 \'*\' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 \'a\'。因此，字符串 "aa" 可被视为 \'a\' 重复了一次。\n\n\n示例 3：\n\n\n输入：s = "ab" p = ".*"\n输出：true\n解释：".*" 表示可匹配零个或多个（\'*\'）任意字符（\'.\'）。\n\n\n示例 4：\n\n\n输入：s = "aab" p = "c*a*b"\n输出：true\n解释：因为 \'*\' 表示零个或多个，这里 \'c\' 为 0 个, \'a\' 被重复一次。因此可以匹配字符串 "aab"。\n\n\n示例 5：\n\n\n输入：s = "mississippi" p = "mis*is*p*."\n输出：false\n\n \n\n提示：\n\n * 0 <= s.length <= 20\n * 0 <= p.length <= 30\n * s 可能为空，且只包含从 a-z 的小写字母。\n * p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n * 保证每次出现字符 * 时，前面都匹配到有效的字符\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode11 盛最多水的容器【中等难度】",frontmatter:{title:"leetcode11 盛最多水的容器【中等难度】",date:"2021-07-17T11:17:20.000Z",permalink:"/leetcode11/",categories:["leetcode","学习笔记","算法"],tags:["leetcode"],description:"         &nbsp; ● &nbsp;难度:     中等",meta:[{name:"image",content:"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"},{name:"twitter:title",content:"leetcode11 盛最多水的容器【中等难度】"},{name:"twitter:description",content:"         &nbsp; ● &nbsp;难度:     中等"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10011.leetcode11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%5B%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%5D.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode11 盛最多水的容器【中等难度】"},{property:"og:description",content:"         &nbsp; ● &nbsp;难度:     中等"},{property:"og:image",content:"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10011.leetcode11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%5B%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%5D.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-17T11:17:20.000Z"},{property:"article:tag",content:"leetcode"},{itemprop:"name",content:"leetcode11 盛最多水的容器【中等难度】"},{itemprop:"description",content:"         &nbsp; ● &nbsp;难度:     中等"},{itemprop:"image",content:"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10011.leetcode11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%5B%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%5D.html",relativePath:"01.算法/24.leetcode/10011.leetcode11-盛最多水的容器[中等难度].md",key:"v-f5686124",path:"/leetcode11/",headers:[{level:3,title:"11. 盛最多水的容器",slug:"_11-盛最多水的容器",normalizedTitle:"11. 盛最多水的容器",charIndex:2},{level:3,title:"英文题: Container with most water",slug:"英文题-container-with-most-water",normalizedTitle:"英文题: container with most water",charIndex:18},{level:3,title:"分析:",slug:"分析",normalizedTitle:"分析:",charIndex:531},{level:3,title:"已AC的C++代码:",slug:"已ac的c-代码",normalizedTitle:"已ac的c++代码:",charIndex:645}],headersStr:"11. 盛最多水的容器 英文题: Container with most water 分析: 已AC的C++代码:",content:"# 11. 盛最多水的容器\n\n\n# 英文题: Container with most water\n\n  ●  难度:   中等   \n\n给你 n 个非负整数 a1，a2，...，a``n，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n说明： 你不能倾斜容器。\n\n示例 1：\n\n\n\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49 \n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：height = [1,1]\n输出：1\n\n\n1\n2\n\n\n示例 3：\n\n输入：height = [4,3,2,1,4]\n输出：16\n\n\n1\n2\n\n\n示例 4：\n\n输入：height = [1,2,1]\n输出：2\n\n\n1\n2\n\n\n提示：\n\n * n = height.length\n * 2 <= n <= 3 * 104\n * 0 <= height[i] <= 3 * 104\n\n\n# 分析:\n\n使用双指针(左右对撞型)，以打擂台的方式更新值。\n\n面积 area = 首尾高度差x水平index之差 = min(height[left], height[right]) * (right - left)\n\n\n\n# 已AC的C++代码:\n\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int len = height.size();\n        int left = 0;\n        int right = len - 1;\n\n        int maxArea = INT_MIN;        \n        while(left < right)\n        {\n            int area = min(height[left], height[right]) * (right - left);\n            if(area > maxArea)\n                maxArea = area;\n            \n            if(height[left] <= height[right])\n                left++;\n            else right--;\n        }\n        return maxArea;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# 11. 盛最多水的容器\n\n\n# 英文题: container with most water\n\n  ●  难度:   中等   \n\n给你 n 个非负整数 a1，a2，...，a``n，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n说明： 你不能倾斜容器。\n\n示例 1：\n\n\n\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49 \n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：height = [1,1]\n输出：1\n\n\n1\n2\n\n\n示例 3：\n\n输入：height = [4,3,2,1,4]\n输出：16\n\n\n1\n2\n\n\n示例 4：\n\n输入：height = [1,2,1]\n输出：2\n\n\n1\n2\n\n\n提示：\n\n * n = height.length\n * 2 <= n <= 3 * 104\n * 0 <= height[i] <= 3 * 104\n\n\n# 分析:\n\n使用双指针(左右对撞型)，以打擂台的方式更新值。\n\n面积 area = 首尾高度差x水平index之差 = min(height[left], height[right]) * (right - left)\n\n\n\n# 已ac的c++代码:\n\nclass solution {\npublic:\n    int maxarea(vector<int>& height) {\n        int len = height.size();\n        int left = 0;\n        int right = len - 1;\n\n        int maxarea = int_min;        \n        while(left < right)\n        {\n            int area = min(height[left], height[right]) * (right - left);\n            if(area > maxarea)\n                maxarea = area;\n            \n            if(height[left] <= height[right])\n                left++;\n            else right--;\n        }\n        return maxarea;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode12 Integer to Roman",frontmatter:{title:"leetcode12 Integer to Roman",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a5942d/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode12 Integer to Roman"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10012.leetcode12%20Integer%20to%20Roman.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode12 Integer to Roman"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10012.leetcode12%20Integer%20to%20Roman.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode12 Integer to Roman"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10012.leetcode12%20Integer%20to%20Roman.html",relativePath:"01.算法/24.leetcode/10012.leetcode12 Integer to Roman.md",key:"v-3ef721a4",path:"/p/a5942d/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:836},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:852},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1266},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1831},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2348}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:'# 12. 整数转罗马数字\n\nEnglish Version\n\n\n# 题目描述\n\n罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n\n\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\n * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \n * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n\n \n\n示例 1:\n\n\n输入: 3\n输出: "III"\n\n示例 2:\n\n\n输入: 4\n输出: "IV"\n\n示例 3:\n\n\n输入: 9\n输出: "IX"\n\n示例 4:\n\n\n输入: 58\n输出: "LVIII"\n解释: L = 50, V = 5, III = 3.\n\n\n示例 5:\n\n\n输入: 1994\n输出: "MCMXCIV"\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n\n \n\n提示：\n\n * 1 <= num <= 3999\n\n\n# 解法\n\n贪心算法实现。\n\n\n# Python3\n\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        nums = [(1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\')]\n        res = []\n        for k, v in nums:\n            while num >= k:\n                num -= k\n                res.append(v)\n        return \'\'.join(res)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Java\n\nclass Solution {\n    public String intToRoman(int num) {\n        int[] nums = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] romans = new String[]{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < nums.length; ++i) {\n            while (num >= nums[i]) {\n                num -= nums[i];\n                sb.append(romans[i]);\n            }\n        }\n        return sb.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# C++\n\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        vector<int> nums{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        vector<string> romans{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};\n        string ans;\n        for (int i = 0; i < nums.size(); ++i) {\n            while (num >= nums[i]) {\n                num -= nums[i];\n                ans.append(romans[i]);\n            }\n        }\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 12. 整数转罗马数字\n\nenglish version\n\n\n# 题目描述\n\n罗马数字包含以下七种字符： i， v， x， l，c，d 和 m。\n\n\n字符          数值\ni             1\nv             5\nx             10\nl             50\nc             100\nd             500\nm             1000\n\n例如， 罗马数字 2 写做 ii ，即为两个并列的 1。12 写做 xii ，即为 x + ii 。 27 写做  xxvii, 即为 xx + v + ii 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 iiii，而是 iv。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 ix。这个特殊的规则只适用于以下六种情况：\n\n * i 可以放在 v (5) 和 x (10) 的左边，来表示 4 和 9。\n * x 可以放在 l (50) 和 c (100) 的左边，来表示 40 和 90。 \n * c 可以放在 d (500) 和 m (1000) 的左边，来表示 400 和 900。\n\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n\n \n\n示例 1:\n\n\n输入: 3\n输出: "iii"\n\n示例 2:\n\n\n输入: 4\n输出: "iv"\n\n示例 3:\n\n\n输入: 9\n输出: "ix"\n\n示例 4:\n\n\n输入: 58\n输出: "lviii"\n解释: l = 50, v = 5, iii = 3.\n\n\n示例 5:\n\n\n输入: 1994\n输出: "mcmxciv"\n解释: m = 1000, cm = 900, xc = 90, iv = 4.\n\n \n\n提示：\n\n * 1 <= num <= 3999\n\n\n# 解法\n\n贪心算法实现。\n\n\n# python3\n\nclass solution:\n    def inttoroman(self, num: int) -> str:\n        nums = [(1000, \'m\'), (900, \'cm\'), (500, \'d\'), (400, \'cd\'), (100, \'c\'), (90, \'xc\'), (50, \'l\'), (40, \'xl\'), (10, \'x\'), (9, \'ix\'), (5, \'v\'), (4, \'iv\'), (1, \'i\')]\n        res = []\n        for k, v in nums:\n            while num >= k:\n                num -= k\n                res.append(v)\n        return \'\'.join(res)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# java\n\nclass solution {\n    public string inttoroman(int num) {\n        int[] nums = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string[] romans = new string[]{"m", "cm", "d", "cd", "c", "xc", "l", "xl", "x", "ix", "v", "iv", "i"};\n        stringbuilder sb = new stringbuilder();\n        for (int i = 0; i < nums.length; ++i) {\n            while (num >= nums[i]) {\n                num -= nums[i];\n                sb.append(romans[i]);\n            }\n        }\n        return sb.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# c++\n\nclass solution {\npublic:\n    string inttoroman(int num) {\n        vector<int> nums{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        vector<string> romans{"m", "cm", "d", "cd", "c", "xc", "l", "xl", "x", "ix", "v", "iv", "i"};\n        string ans;\n        for (int i = 0; i < nums.size(); ++i) {\n            while (num >= nums[i]) {\n                num -= nums[i];\n                ans.append(romans[i]);\n            }\n        }\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode13 Roman to Integer",frontmatter:{title:"leetcode13 Roman to Integer",date:"2021-07-20T04:24:14.000Z",permalink:"/p/07f2a8/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode13 Roman to Integer"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10013.leetcode13%20Roman%20to%20Integer.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode13 Roman to Integer"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10013.leetcode13%20Roman%20to%20Integer.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode13 Roman to Integer"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10013.leetcode13%20Roman%20to%20Integer.html",relativePath:"01.算法/24.leetcode/10013.leetcode13 Roman to Integer.md",key:"v-56ad6238",path:"/p/07f2a8/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1062},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1069},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1783},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2719},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3318}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 13. 罗马数字转整数\n\nEnglish Version\n\n\n# 题目描述\n\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n\n\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\n * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \n * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n \n\n示例 1:\n\n\n输入: \"III\"\n输出: 3\n\n示例 2:\n\n\n输入: \"IV\"\n输出: 4\n\n示例 3:\n\n\n输入: \"IX\"\n输出: 9\n\n示例 4:\n\n\n输入: \"LVIII\"\n输出: 58\n解释: L = 50, V= 5, III = 3.\n\n\n示例 5:\n\n\n输入: \"MCMXCIV\"\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n\n \n\n提示：\n\n * 1 <= s.length <= 15\n * s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')\n * 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内\n * 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\n * IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\n * 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        nums = {\n            'M': 1000,\n            'CM': 900,\n            'D': 500,\n            'CD': 400,\n            'C': 100,\n            'XC': 90,\n            'L': 50,\n            'XL': 40,\n            'X': 10,\n            'IX': 9,\n            'V': 5,\n            'IV': 4,\n            'I': 1\n        }\n        i = res = 0\n        while i < len(s):\n            if i + 1 < len(s) and s[i:i + 2] in nums:\n                res += nums[s[i: i + 2]]\n                i += 2\n            else:\n                res += nums[s[i: i + 1]]\n                i += 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java\n\nclass Solution {\n    public int romanToInt(String s) {\n        Map<String, Integer> nums = new HashMap<>();\n        nums.put(\"M\", 1000);\n        nums.put(\"CM\", 900);\n        nums.put(\"D\", 500);\n        nums.put(\"CD\", 400);\n        nums.put(\"C\", 100);\n        nums.put(\"XC\", 90);\n        nums.put(\"L\", 50);\n        nums.put(\"XL\", 40);\n        nums.put(\"X\", 10);\n        nums.put(\"IX\", 9);\n        nums.put(\"V\", 5);\n        nums.put(\"IV\", 4);\n        nums.put(\"I\", 1);\n        int res = 0;\n        for (int i = 0; i < s.length();) {\n            if (i + 1 < s.length() && nums.get(s.substring(i, i + 2)) != null) {\n                res += nums.get(s.substring(i, i + 2));\n                i += 2;\n            } else {\n                res += nums.get(s.substring(i, i + 1));\n                i += 1;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# C++\n\nclass Solution {\n   public:\n    int romanToInt(string s) {\n        unordered_map<char, int> nums{\n            {'I', 1},\n            {'V', 5},\n            {'X', 10},\n            {'L', 50},\n            {'C', 100},\n            {'D', 500},\n            {'M', 1000},\n        };\n        int ans = 0;\n        for (int i = 0; i < s.size() - 1; ++i) {\n            if (nums[s[i]] < nums[s[i + 1]])\n                ans -= nums[s[i]];\n            else\n                ans += nums[s[i]];\n        }\n        return ans + nums[s.back()];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 13. 罗马数字转整数\n\nenglish version\n\n\n# 题目描述\n\n罗马数字包含以下七种字符: i， v， x， l，c，d 和 m。\n\n\n字符          数值\ni             1\nv             5\nx             10\nl             50\nc             100\nd             500\nm             1000\n\n例如， 罗马数字 2 写做 ii ，即为两个并列的 1。12 写做 xii ，即为 x + ii 。 27 写做  xxvii, 即为 xx + v + ii 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 iiii，而是 iv。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 ix。这个特殊的规则只适用于以下六种情况：\n\n * i 可以放在 v (5) 和 x (10) 的左边，来表示 4 和 9。\n * x 可以放在 l (50) 和 c (100) 的左边，来表示 40 和 90。 \n * c 可以放在 d (500) 和 m (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n \n\n示例 1:\n\n\n输入: \"iii\"\n输出: 3\n\n示例 2:\n\n\n输入: \"iv\"\n输出: 4\n\n示例 3:\n\n\n输入: \"ix\"\n输出: 9\n\n示例 4:\n\n\n输入: \"lviii\"\n输出: 58\n解释: l = 50, v= 5, iii = 3.\n\n\n示例 5:\n\n\n输入: \"mcmxciv\"\n输出: 1994\n解释: m = 1000, cm = 900, xc = 90, iv = 4.\n\n \n\n提示：\n\n * 1 <= s.length <= 15\n * s 仅含字符 ('i', 'v', 'x', 'l', 'c', 'd', 'm')\n * 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内\n * 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\n * il 和 im 这样的例子并不符合题目要求，49 应该写作 xlix，999 应该写作 cmxcix 。\n * 关于罗马数字的详尽书写规则，可以参考 罗马数字 - mathematics 。\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def romantoint(self, s: str) -> int:\n        nums = {\n            'm': 1000,\n            'cm': 900,\n            'd': 500,\n            'cd': 400,\n            'c': 100,\n            'xc': 90,\n            'l': 50,\n            'xl': 40,\n            'x': 10,\n            'ix': 9,\n            'v': 5,\n            'iv': 4,\n            'i': 1\n        }\n        i = res = 0\n        while i < len(s):\n            if i + 1 < len(s) and s[i:i + 2] in nums:\n                res += nums[s[i: i + 2]]\n                i += 2\n            else:\n                res += nums[s[i: i + 1]]\n                i += 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java\n\nclass solution {\n    public int romantoint(string s) {\n        map<string, integer> nums = new hashmap<>();\n        nums.put(\"m\", 1000);\n        nums.put(\"cm\", 900);\n        nums.put(\"d\", 500);\n        nums.put(\"cd\", 400);\n        nums.put(\"c\", 100);\n        nums.put(\"xc\", 90);\n        nums.put(\"l\", 50);\n        nums.put(\"xl\", 40);\n        nums.put(\"x\", 10);\n        nums.put(\"ix\", 9);\n        nums.put(\"v\", 5);\n        nums.put(\"iv\", 4);\n        nums.put(\"i\", 1);\n        int res = 0;\n        for (int i = 0; i < s.length();) {\n            if (i + 1 < s.length() && nums.get(s.substring(i, i + 2)) != null) {\n                res += nums.get(s.substring(i, i + 2));\n                i += 2;\n            } else {\n                res += nums.get(s.substring(i, i + 1));\n                i += 1;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# c++\n\nclass solution {\n   public:\n    int romantoint(string s) {\n        unordered_map<char, int> nums{\n            {'i', 1},\n            {'v', 5},\n            {'x', 10},\n            {'l', 50},\n            {'c', 100},\n            {'d', 500},\n            {'m', 1000},\n        };\n        int ans = 0;\n        for (int i = 0; i < s.size() - 1; ++i) {\n            if (nums[s[i]] < nums[s[i + 1]])\n                ans -= nums[s[i]];\n            else\n                ans += nums[s[i]];\n        }\n        return ans + nums[s.back()];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode14 Longest Common Prefix",frontmatter:{title:"leetcode14 Longest Common Prefix",date:"2021-07-20T04:24:14.000Z",permalink:"/p/bbae3d/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode14 Longest Common Prefix"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10014.leetcode14%20Longest%20Common%20Prefix.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode14 Longest Common Prefix"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10014.leetcode14%20Longest%20Common%20Prefix.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode14 Longest Common Prefix"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10014.leetcode14%20Longest%20Common%20Prefix.html",relativePath:"01.算法/24.leetcode/10014.leetcode14 Longest Common Prefix.md",key:"v-057873f0",path:"/p/bbae3d/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:299},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:306},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:681},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1169},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1647}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:'# 14. 最长公共前缀\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 ""。\n\n \n\n示例 1：\n\n\n输入：strs = ["flower","flow","flight"]\n输出："fl"\n\n\n示例 2：\n\n\n输入：strs = ["dog","racecar","car"]\n输出：""\n解释：输入不存在公共前缀。\n\n \n\n提示：\n\n * 0 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] 仅由小写英文字母组成\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        n = len(strs)\n        if n == 0:\n            return \'\'\n        for i in range(len(strs[0])):\n            for j in range(1, n):\n                if len(strs[j]) <= i or strs[j][i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Java\n\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        int n;\n        if ((n = strs.length) == 0) return "";\n        for (int i = 0; i < strs[0].length(); ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (strs[j].length() <= i || strs[j].charAt(i) != strs[0].charAt(i)) {\n                    return strs[0].substring(0, i);\n                }\n            }\n        }\n        return strs[0];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# C++\n\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        int n;\n        if ((n = strs.size()) == 0) return "";\n        for (int i = 0; i < strs[0].size(); ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (strs[j].size() <= i || strs[j][i] != strs[0][i]) {\n                    return strs[0].substr(0, i);\n                }\n            }\n        }\n        return strs[0];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 14. 最长公共前缀\n\nenglish version\n\n\n# 题目描述\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 ""。\n\n \n\n示例 1：\n\n\n输入：strs = ["flower","flow","flight"]\n输出："fl"\n\n\n示例 2：\n\n\n输入：strs = ["dog","racecar","car"]\n输出：""\n解释：输入不存在公共前缀。\n\n \n\n提示：\n\n * 0 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] 仅由小写英文字母组成\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def longestcommonprefix(self, strs: list[str]) -> str:\n        n = len(strs)\n        if n == 0:\n            return \'\'\n        for i in range(len(strs[0])):\n            for j in range(1, n):\n                if len(strs[j]) <= i or strs[j][i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# java\n\nclass solution {\n    public string longestcommonprefix(string[] strs) {\n        int n;\n        if ((n = strs.length) == 0) return "";\n        for (int i = 0; i < strs[0].length(); ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (strs[j].length() <= i || strs[j].charat(i) != strs[0].charat(i)) {\n                    return strs[0].substring(0, i);\n                }\n            }\n        }\n        return strs[0];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# c++\n\nclass solution {\npublic:\n    string longestcommonprefix(vector<string>& strs) {\n        int n;\n        if ((n = strs.size()) == 0) return "";\n        for (int i = 0; i < strs[0].size(); ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (strs[j].size() <= i || strs[j][i] != strs[0][i]) {\n                    return strs[0].substr(0, i);\n                }\n            }\n        }\n        return strs[0];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode15 3Sum",frontmatter:{title:"leetcode15 3Sum",date:"2021-07-20T04:24:14.000Z",permalink:"/p/42c6e3/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode15 3Sum"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10015.leetcode15%203Sum.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode15 3Sum"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10015.leetcode15%203Sum.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode15 3Sum"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10015.leetcode15%203Sum.html",relativePath:"01.算法/24.leetcode/10015.leetcode15 3Sum.md",key:"v-365c4844",path:"/p/42c6e3/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:333},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:355},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1345},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2576},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3640}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 15. 三数之和\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n \n\n示例 1：\n\n\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n\n\n示例 2：\n\n\n输入：nums = []\n输出：[]\n\n\n示例 3：\n\n\n输入：nums = [0]\n输出：[]\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 3000\n * -105 <= nums[i] <= 105\n\n\n# 解法\n\n“排序 + 双指针”实现。\n\n\n# Python3\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        if nums is None or len(nums) < 3:\n            return []\n        nums.sort()\n        n = len(nums)\n        res = []\n        for i in range(n - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            p, q = i + 1, n - 1\n            while p < q:\n                if p > i + 1 and nums[p] == nums[p - 1]:\n                    p += 1\n                    continue\n                if q < n - 1 and nums[q] == nums[q + 1]:\n                    q -= 1\n                    continue\n                if nums[i] + nums[p] + nums[q] < 0:\n                    p += 1\n                elif nums[i] + nums[p] + nums[q] > 0:\n                    q -= 1\n                else:\n                    res.append([nums[i], nums[p], nums[q]])\n                    p += 1\n                    q -= 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Java\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        int n;\n        if (nums == null || (n = nums.length) < 3) {\n            return Collections.emptyList();\n        }\n        Arrays.sort(nums);\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < n - 2; ++i) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            int p = i + 1, q = n - 1;\n            while (p < q) {\n                if (p > i + 1 && nums[p] == nums[p - 1]) {\n                    ++p;\n                    continue;\n                }\n                if (q < n - 1 && nums[q] == nums[q + 1]) {\n                    --q;\n                    continue;\n                }\n                if (nums[p] + nums[q] + nums[i] < 0) {\n                    ++p;\n                } else if (nums[p] + nums[q] + nums[i] > 0) {\n                    --q;\n                } else {\n                    res.add(Arrays.asList(nums[p], nums[q], nums[i]));\n                    ++p;\n                    --q;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function (nums) {\n    let len = nums.length;\n    if (len < 3) return [];\n    let res = [];\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i < len - 2; i++) {\n        if (nums[i] > 0) break;\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        let left = i + 1, right = len - 1;\n        while (left < right) {\n            if (nums[i] + nums[left] + nums[right] === 0) {\n                res.push([nums[i], nums[left], nums[right]]);\n                while (nums[left] === nums[left + 1]) left++;\n                left++;\n                while (nums[right] === nums[right - 1]) right--;\n                right--;\n                continue;\n            } else if (nums[i] + nums[left] + nums[right] > 0) {\n                right--;\n                continue;\n            } else {\n                left++;\n                continue;\n            }\n        }\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 15. 三数之和\n\nenglish version\n\n\n# 题目描述\n\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n \n\n示例 1：\n\n\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n\n\n示例 2：\n\n\n输入：nums = []\n输出：[]\n\n\n示例 3：\n\n\n输入：nums = [0]\n输出：[]\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 3000\n * -105 <= nums[i] <= 105\n\n\n# 解法\n\n“排序 + 双指针”实现。\n\n\n# python3\n\nclass solution:\n    def threesum(self, nums: list[int]) -> list[list[int]]:\n        if nums is none or len(nums) < 3:\n            return []\n        nums.sort()\n        n = len(nums)\n        res = []\n        for i in range(n - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            p, q = i + 1, n - 1\n            while p < q:\n                if p > i + 1 and nums[p] == nums[p - 1]:\n                    p += 1\n                    continue\n                if q < n - 1 and nums[q] == nums[q + 1]:\n                    q -= 1\n                    continue\n                if nums[i] + nums[p] + nums[q] < 0:\n                    p += 1\n                elif nums[i] + nums[p] + nums[q] > 0:\n                    q -= 1\n                else:\n                    res.append([nums[i], nums[p], nums[q]])\n                    p += 1\n                    q -= 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# java\n\nclass solution {\n    public list<list<integer>> threesum(int[] nums) {\n        int n;\n        if (nums == null || (n = nums.length) < 3) {\n            return collections.emptylist();\n        }\n        arrays.sort(nums);\n        list<list<integer>> res = new arraylist<>();\n        for (int i = 0; i < n - 2; ++i) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            int p = i + 1, q = n - 1;\n            while (p < q) {\n                if (p > i + 1 && nums[p] == nums[p - 1]) {\n                    ++p;\n                    continue;\n                }\n                if (q < n - 1 && nums[q] == nums[q + 1]) {\n                    --q;\n                    continue;\n                }\n                if (nums[p] + nums[q] + nums[i] < 0) {\n                    ++p;\n                } else if (nums[p] + nums[q] + nums[i] > 0) {\n                    --q;\n                } else {\n                    res.add(arrays.aslist(nums[p], nums[q], nums[i]));\n                    ++p;\n                    --q;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threesum = function (nums) {\n    let len = nums.length;\n    if (len < 3) return [];\n    let res = [];\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i < len - 2; i++) {\n        if (nums[i] > 0) break;\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        let left = i + 1, right = len - 1;\n        while (left < right) {\n            if (nums[i] + nums[left] + nums[right] === 0) {\n                res.push([nums[i], nums[left], nums[right]]);\n                while (nums[left] === nums[left + 1]) left++;\n                left++;\n                while (nums[right] === nums[right - 1]) right--;\n                right--;\n                continue;\n            } else if (nums[i] + nums[left] + nums[right] > 0) {\n                right--;\n                continue;\n            } else {\n                left++;\n                continue;\n            }\n        }\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode16 3Sum Closest",frontmatter:{title:"leetcode16 3Sum Closest",date:"2021-07-20T04:24:14.000Z",permalink:"/p/5fe737/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode16 3Sum Closest"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10016.leetcode16%203Sum%20Closest.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode16 3Sum Closest"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10016.leetcode16%203Sum%20Closest.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode16 3Sum Closest"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10016.leetcode16%203Sum%20Closest.html",relativePath:"01.算法/24.leetcode/10016.leetcode16 3Sum Closest.md",key:"v-75251f27",path:"/p/5fe737/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:321},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:336},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1328},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2522},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3915}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 16. 最接近的三数之和\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n \n\n示例：\n\n输入：nums = [-1,2,1,-4], target = 1\n输出：2\n解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。\n\n\n \n\n提示：\n\n * 3 <= nums.length <= 10^3\n * -10^3 <= nums[i] <= 10^3\n * -10^4 <= target <= 10^4\n\n\n# 解法\n\n双指针解决。\n\n\n# Python3\n\nclass Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        def twoSumClosest(nums, start, end, target):\n            res = 0\n            diff = 10000\n            while start < end:\n                val = nums[start] + nums[end]\n                if val == target:\n                    return val\n                if abs(val - target) < diff:\n                    res = val\n                    diff = abs(val - target)\n                if val < target:\n                    start += 1\n                else:\n                    end -= 1\n            return res\n\n        nums.sort()\n        res, n = 0, len(nums)\n        diff = 10000\n        for i in range(n - 2):\n            t = twoSumClosest(nums, i + 1, n - 1, target - nums[i])\n            if abs(nums[i] + t - target) < diff:\n                res = nums[i] + t\n                diff = abs(nums[i] + t - target)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Java\n\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int res = 0;\n        int n = nums.length;\n        int diff = Integer.MAX_VALUE;\n        for (int i = 0; i < n - 2; ++i) {\n            int t = twoSumClosest(nums, i + 1, n - 1, target - nums[i]);\n            if (Math.abs(nums[i] + t - target) < diff) {\n                res = nums[i] + t;\n                diff = Math.abs(nums[i] + t - target);\n            }\n        }\n        return res;\n    }\n\n    private int twoSumClosest(int[] nums, int start, int end, int target) {\n        int res = 0;\n        int diff = Integer.MAX_VALUE;\n        while (start < end) {\n            int val = nums[start] + nums[end];\n            if (val == target) {\n                return val;\n            }\n            if (Math.abs(val - target) < diff) {\n                res = val;\n                diff = Math.abs(val - target);\n            }\n            if (val < target) {\n                ++start;\n            } else {\n                --end;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threeSumClosest = function (nums, target) {\n    let len = nums.length;\n    nums.sort((a, b) => a - b);\n    let diff = Infinity;\n    let res;\n    for (let i = 0; i < len - 2; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        let left = i + 1, right = len - 1;\n        let cur = nums[i] + nums[i + 1] + nums[i + 2];\n        if (cur > target) {\n            let newDiff = Math.abs((cur - target))\n            if (newDiff < diff) {\n                diff = newDiff;\n                res = cur;\n            }\n            break;\n        }\n        while (left < right) {\n            cur = nums[i] + nums[left] + nums[right];\n            if (cur === target) return target;\n            let newDiff = Math.abs((cur - target))\n            if (newDiff < diff) {\n                diff = newDiff;\n                res = cur;\n            }\n            if (cur < target) {\n                while (nums[left] === nums[left + 1]) left++;\n                left++;\n                continue;\n            } else {\n                while (nums[right] === nums[right - 1]) right--;\n                right--;\n                continue;\n            }\n        }\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 16. 最接近的三数之和\n\nenglish version\n\n\n# 题目描述\n\n给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n \n\n示例：\n\n输入：nums = [-1,2,1,-4], target = 1\n输出：2\n解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。\n\n\n \n\n提示：\n\n * 3 <= nums.length <= 10^3\n * -10^3 <= nums[i] <= 10^3\n * -10^4 <= target <= 10^4\n\n\n# 解法\n\n双指针解决。\n\n\n# python3\n\nclass solution:\n    def threesumclosest(self, nums: list[int], target: int) -> int:\n        def twosumclosest(nums, start, end, target):\n            res = 0\n            diff = 10000\n            while start < end:\n                val = nums[start] + nums[end]\n                if val == target:\n                    return val\n                if abs(val - target) < diff:\n                    res = val\n                    diff = abs(val - target)\n                if val < target:\n                    start += 1\n                else:\n                    end -= 1\n            return res\n\n        nums.sort()\n        res, n = 0, len(nums)\n        diff = 10000\n        for i in range(n - 2):\n            t = twosumclosest(nums, i + 1, n - 1, target - nums[i])\n            if abs(nums[i] + t - target) < diff:\n                res = nums[i] + t\n                diff = abs(nums[i] + t - target)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# java\n\nclass solution {\n    public int threesumclosest(int[] nums, int target) {\n        arrays.sort(nums);\n        int res = 0;\n        int n = nums.length;\n        int diff = integer.max_value;\n        for (int i = 0; i < n - 2; ++i) {\n            int t = twosumclosest(nums, i + 1, n - 1, target - nums[i]);\n            if (math.abs(nums[i] + t - target) < diff) {\n                res = nums[i] + t;\n                diff = math.abs(nums[i] + t - target);\n            }\n        }\n        return res;\n    }\n\n    private int twosumclosest(int[] nums, int start, int end, int target) {\n        int res = 0;\n        int diff = integer.max_value;\n        while (start < end) {\n            int val = nums[start] + nums[end];\n            if (val == target) {\n                return val;\n            }\n            if (math.abs(val - target) < diff) {\n                res = val;\n                diff = math.abs(val - target);\n            }\n            if (val < target) {\n                ++start;\n            } else {\n                --end;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threesumclosest = function (nums, target) {\n    let len = nums.length;\n    nums.sort((a, b) => a - b);\n    let diff = infinity;\n    let res;\n    for (let i = 0; i < len - 2; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        let left = i + 1, right = len - 1;\n        let cur = nums[i] + nums[i + 1] + nums[i + 2];\n        if (cur > target) {\n            let newdiff = math.abs((cur - target))\n            if (newdiff < diff) {\n                diff = newdiff;\n                res = cur;\n            }\n            break;\n        }\n        while (left < right) {\n            cur = nums[i] + nums[left] + nums[right];\n            if (cur === target) return target;\n            let newdiff = math.abs((cur - target))\n            if (newdiff < diff) {\n                diff = newdiff;\n                res = cur;\n            }\n            if (cur < target) {\n                while (nums[left] === nums[left + 1]) left++;\n                left++;\n                continue;\n            } else {\n                while (nums[right] === nums[right - 1]) right--;\n                right--;\n                continue;\n            }\n        }\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode17 Letter Combinations of a Phone Number",frontmatter:{title:"leetcode17 Letter Combinations of a Phone Number",date:"2021-07-20T04:24:14.000Z",permalink:"/p/942fa8/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0017.Letter%20Combinations%20of%20a%20Phone%20Number/images/17_telephone_keypad.png"},{name:"twitter:title",content:"leetcode17 Letter Combinations of a Phone Number"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0017.Letter%20Combinations%20of%20a%20Phone%20Number/images/17_telephone_keypad.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10017.leetcode17%20Letter%20Combinations%20of%20a%20Phone%20Number.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode17 Letter Combinations of a Phone Number"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0017.Letter%20Combinations%20of%20a%20Phone%20Number/images/17_telephone_keypad.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10017.leetcode17%20Letter%20Combinations%20of%20a%20Phone%20Number.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode17 Letter Combinations of a Phone Number"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0017.Letter%20Combinations%20of%20a%20Phone%20Number/images/17_telephone_keypad.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10017.leetcode17%20Letter%20Combinations%20of%20a%20Phone%20Number.html",relativePath:"01.算法/24.leetcode/10017.leetcode17 Letter Combinations of a Phone Number.md",key:"v-5873af27",path:"/p/942fa8/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:359},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:366},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1002},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2097}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 17. 电话号码的字母组合\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n\n\n \n\n示例 1：\n\n\n输入：digits = "23"\n输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]\n\n\n示例 2：\n\n\n输入：digits = ""\n输出：[]\n\n\n示例 3：\n\n\n输入：digits = "2"\n输出：["a","b","c"]\n\n\n \n\n提示：\n\n * 0 <= digits.length <= 4\n * digits[i] 是范围 [\'2\', \'9\'] 的一个数字。\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        n = len(digits)\n        if n == 0:\n            return []\n        chars = [\'abc\', \'def\', \'ghi\', \'jkl\', \'mno\', \'pqrs\', \'tuv\', \'wxyz\']\n        strs = [chars[int(d) - 2] for d in digits]\n        res = []\n        for s in strs:\n            if not res:\n                res = list(s)\n            else:\n                cache = []\n                for item in res:\n                    for letter in s:\n                        cache.append(item + letter)\n                res = cache\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Java\n\nclass Solution {\n    public List<String> letterCombinations(String digits) {\n        int n;\n        if ((n = digits.length()) == 0) return Collections.emptyList();\n        List<String> chars = Arrays.asList("abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz");\n\n        List<String> strs = new ArrayList<>();\n        for (char c : digits.toCharArray()) {\n            strs.add(chars.get(c - \'0\' - 2));\n        }\n        List<String> res = new ArrayList<>();\n        for (String str : strs) {\n            if (res.size() == 0) {\n                for (char c : str.toCharArray()) {\n                    res.add(String.valueOf(c));\n                }\n            } else {\n                List<String> cache = new ArrayList<>();\n                for (String item : res) {\n                    for (char c : str.toCharArray()) {\n                        cache.add(item + String.valueOf(c));\n                    }\n                }\n                res = cache;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 17. 电话号码的字母组合\n\nenglish version\n\n\n# 题目描述\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n\n\n \n\n示例 1：\n\n\n输入：digits = "23"\n输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]\n\n\n示例 2：\n\n\n输入：digits = ""\n输出：[]\n\n\n示例 3：\n\n\n输入：digits = "2"\n输出：["a","b","c"]\n\n\n \n\n提示：\n\n * 0 <= digits.length <= 4\n * digits[i] 是范围 [\'2\', \'9\'] 的一个数字。\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def lettercombinations(self, digits: str) -> list[str]:\n        n = len(digits)\n        if n == 0:\n            return []\n        chars = [\'abc\', \'def\', \'ghi\', \'jkl\', \'mno\', \'pqrs\', \'tuv\', \'wxyz\']\n        strs = [chars[int(d) - 2] for d in digits]\n        res = []\n        for s in strs:\n            if not res:\n                res = list(s)\n            else:\n                cache = []\n                for item in res:\n                    for letter in s:\n                        cache.append(item + letter)\n                res = cache\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# java\n\nclass solution {\n    public list<string> lettercombinations(string digits) {\n        int n;\n        if ((n = digits.length()) == 0) return collections.emptylist();\n        list<string> chars = arrays.aslist("abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz");\n\n        list<string> strs = new arraylist<>();\n        for (char c : digits.tochararray()) {\n            strs.add(chars.get(c - \'0\' - 2));\n        }\n        list<string> res = new arraylist<>();\n        for (string str : strs) {\n            if (res.size() == 0) {\n                for (char c : str.tochararray()) {\n                    res.add(string.valueof(c));\n                }\n            } else {\n                list<string> cache = new arraylist<>();\n                for (string item : res) {\n                    for (char c : str.tochararray()) {\n                        cache.add(item + string.valueof(c));\n                    }\n                }\n                res = cache;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode18 4Sum",frontmatter:{title:"leetcode18 4Sum",date:"2021-07-20T04:24:14.000Z",permalink:"/p/1935e9/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode18 4Sum"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10018.leetcode18%204Sum.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode18 4Sum"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10018.leetcode18%204Sum.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode18 4Sum"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10018.leetcode18%204Sum.html",relativePath:"01.算法/24.leetcode/10018.leetcode18 4Sum.md",key:"v-406283e4",path:"/p/1935e9/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:393},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:415},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1652},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:3200},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4668}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 18. 四数之和\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n\n注意：答案中不可以包含重复的四元组。\n\n \n\n示例 1：\n\n\n输入：nums = [1,0,-1,0,-2,2], target = 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\n示例 2：\n\n\n输入：nums = [], target = 0\n输出：[]\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n\n\n# 解法\n\n“排序 + 双指针”实现。\n\n\n# Python3\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        res = []\n        if nums is None or len(nums) < 4:\n            return res\n        n = len(nums)\n        nums.sort()\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                p, q = j + 1, n - 1\n                while p < q:\n                    if p > j + 1 and nums[p] == nums[p - 1]:\n                        p += 1\n                        continue\n                    if q < n - 1 and nums[q] == nums[q + 1]:\n                        q -= 1\n                        continue\n                    t = nums[i] + nums[j] + nums[p] + nums[q]\n                    if t == target:\n                        res.append([nums[i], nums[j], nums[p], nums[q]])\n                        p += 1\n                        q -= 1\n                    elif t < target:\n                        p += 1\n                    else:\n                        q -= 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# Java\n\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        int n;\n        if (nums == null || (n = (nums.length)) < 4) {\n            return Collections.emptyList();\n        }\n        Arrays.sort(nums);\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < n - 3; ++i) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            for (int j = i + 1; j < n - 2; ++j) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\n                    continue;\n                }\n                int p = j + 1, q = n - 1;\n                while (p < q) {\n                    if (p > j + 1 && nums[p] == nums[p - 1]) {\n                        ++p;\n                        continue;\n                    }\n                    if (q < n - 1 && nums[q] == nums[q + 1]) {\n                        --q;\n                        continue;\n                    }\n                    int t = nums[i] + nums[j] + nums[p] + nums[q];\n                    if (t == target) {\n                        res.add(Arrays.asList(nums[i], nums[j], nums[p], nums[q]));\n                        ++p;\n                        --q;\n                    } else if (t < target) {\n                        ++p;\n                    } else {\n                        --q;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function (nums, target) {\n    let len = nums.length;\n    let res = [];\n    if (len < 4) return [];\n    nums.sort((a, b) => a - b);\n    for (i = 0; i < len - 3; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        if (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 3] < target) continue;\n        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;\n        for (j = i + 1; j < len - 2; j++) {\n            if (j > i + 1 && nums[j] === nums[j - 1]) continue;\n            let left = j + 1, right = len - 1;\n            while (left < right) {\n                if (nums[i] + nums[j] + nums[left] + nums[right] === target) {\n                    res.push([nums[i], nums[j], nums[left], nums[right]]);\n                    while (nums[left] === nums[left + 1]) left++;\n                    left++;\n                    while (nums[right] === nums[right - 1]) right--;\n                    right--;\n                    continue;\n                } else if (nums[i] + nums[j] + nums[left] + nums[right] > target) {\n                    right--;\n                    continue;\n                } else {\n                    left++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 18. 四数之和\n\nenglish version\n\n\n# 题目描述\n\n给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n\n注意：答案中不可以包含重复的四元组。\n\n \n\n示例 1：\n\n\n输入：nums = [1,0,-1,0,-2,2], target = 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\n示例 2：\n\n\n输入：nums = [], target = 0\n输出：[]\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n\n\n# 解法\n\n“排序 + 双指针”实现。\n\n\n# python3\n\nclass solution:\n    def foursum(self, nums: list[int], target: int) -> list[list[int]]:\n        res = []\n        if nums is none or len(nums) < 4:\n            return res\n        n = len(nums)\n        nums.sort()\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                p, q = j + 1, n - 1\n                while p < q:\n                    if p > j + 1 and nums[p] == nums[p - 1]:\n                        p += 1\n                        continue\n                    if q < n - 1 and nums[q] == nums[q + 1]:\n                        q -= 1\n                        continue\n                    t = nums[i] + nums[j] + nums[p] + nums[q]\n                    if t == target:\n                        res.append([nums[i], nums[j], nums[p], nums[q]])\n                        p += 1\n                        q -= 1\n                    elif t < target:\n                        p += 1\n                    else:\n                        q -= 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# java\n\nclass solution {\n    public list<list<integer>> foursum(int[] nums, int target) {\n        int n;\n        if (nums == null || (n = (nums.length)) < 4) {\n            return collections.emptylist();\n        }\n        arrays.sort(nums);\n        list<list<integer>> res = new arraylist<>();\n        for (int i = 0; i < n - 3; ++i) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            for (int j = i + 1; j < n - 2; ++j) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\n                    continue;\n                }\n                int p = j + 1, q = n - 1;\n                while (p < q) {\n                    if (p > j + 1 && nums[p] == nums[p - 1]) {\n                        ++p;\n                        continue;\n                    }\n                    if (q < n - 1 && nums[q] == nums[q + 1]) {\n                        --q;\n                        continue;\n                    }\n                    int t = nums[i] + nums[j] + nums[p] + nums[q];\n                    if (t == target) {\n                        res.add(arrays.aslist(nums[i], nums[j], nums[p], nums[q]));\n                        ++p;\n                        --q;\n                    } else if (t < target) {\n                        ++p;\n                    } else {\n                        --q;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar foursum = function (nums, target) {\n    let len = nums.length;\n    let res = [];\n    if (len < 4) return [];\n    nums.sort((a, b) => a - b);\n    for (i = 0; i < len - 3; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        if (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 3] < target) continue;\n        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;\n        for (j = i + 1; j < len - 2; j++) {\n            if (j > i + 1 && nums[j] === nums[j - 1]) continue;\n            let left = j + 1, right = len - 1;\n            while (left < right) {\n                if (nums[i] + nums[j] + nums[left] + nums[right] === target) {\n                    res.push([nums[i], nums[j], nums[left], nums[right]]);\n                    while (nums[left] === nums[left + 1]) left++;\n                    left++;\n                    while (nums[right] === nums[right - 1]) right--;\n                    right--;\n                    continue;\n                } else if (nums[i] + nums[j] + nums[left] + nums[right] > target) {\n                    right--;\n                    continue;\n                } else {\n                    left++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode19 Remove Nth Node From End of List",frontmatter:{title:"leetcode19 Remove Nth Node From End of List",date:"2021-07-20T04:24:14.000Z",permalink:"/p/e99d7b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0019.Remove%20Nth%20Node%20From%20End%20of%20List/images/remove_ex1.jpg"},{name:"twitter:title",content:"leetcode19 Remove Nth Node From End of List"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0019.Remove%20Nth%20Node%20From%20End%20of%20List/images/remove_ex1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10019.leetcode19%20Remove%20Nth%20Node%20From%20End%20of%20List.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode19 Remove Nth Node From End of List"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0019.Remove%20Nth%20Node%20From%20End%20of%20List/images/remove_ex1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10019.leetcode19%20Remove%20Nth%20Node%20From%20End%20of%20List.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode19 Remove Nth Node From End of List"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0019.Remove%20Nth%20Node%20From%20End%20of%20List/images/remove_ex1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10019.leetcode19%20Remove%20Nth%20Node%20From%20End%20of%20List.html",relativePath:"01.算法/24.leetcode/10019.leetcode19 Remove Nth Node From End of List.md",key:"v-ff6467ec",path:"/p/e99d7b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:42},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:319},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:335},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:874},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1627},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2415},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2922},{level:3,title:"Ruby",slug:"ruby",normalizedTitle:"ruby",charIndex:3577},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4203}],headersStr:"题目描述 解法 Python3 Java C++ Go JavaScript Ruby ...",content:"# 19. 删除链表的倒数第 N 个结点\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n\n进阶：你能尝试使用一趟扫描实现吗？\n\n \n\n示例 1：\n\n\n输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]\n\n\n示例 2：\n\n\n输入：head = [1], n = 1\n输出：[]\n\n\n示例 3：\n\n\n输入：head = [1,2], n = 1\n输出：[1]\n\n\n \n\n提示：\n\n * 链表中结点的数目为 sz\n * 1 <= sz <= 30\n * 0 <= Node.val <= 100\n * 1 <= n <= sz\n\n\n# 解法\n\n利用快慢指针。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = ListNode(next=head)\n        fast = slow = dummy\n        for _ in range(n):\n            fast = fast.next\n        while fast.next:\n            slow, fast = slow.next, fast.next\n        slow.next = slow.next.next\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode fast = dummy, slow = dummy;\n        while (n-- > 0) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        slow.next = slow.next.next;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* fast = dummy;\n        ListNode* slow = dummy;\n        while (n--) {\n            fast = fast->next;\n        }\n        while (fast->next) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        slow->next = slow->next->next;\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    dummy := &ListNode{0, head}\n    fast := dummy\n    slow := dummy\n    for n > 0 {\n        fast = fast.Next\n        n -= 1\n    }\n    for fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next\n    }\n    slow.Next = slow.Next.Next\n    return dummy.Next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function(head, n) {\n    const dummy = new ListNode(0, head);\n    let fast = dummy, slow = dummy;\n    while (n--) {\n        fast = fast.next;\n    }\n    while (fast.next) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    slow.next = slow.next.next;\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Ruby\n\n# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} n\n# @return {ListNode}\ndef remove_nth_from_end(head, n)\n    dummy = ListNode.new(0, head)\n    fast = slow = dummy\n    while n > 0\n        fast = fast.next\n        n -= 1\n    end\n    while fast.next\n        slow = slow.next\n        fast = fast.next\n    end\n    slow.next = slow.next.next\n    return dummy.next\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 19. 删除链表的倒数第 n 个结点\n\nenglish version\n\n\n# 题目描述\n\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n\n进阶：你能尝试使用一趟扫描实现吗？\n\n \n\n示例 1：\n\n\n输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]\n\n\n示例 2：\n\n\n输入：head = [1], n = 1\n输出：[]\n\n\n示例 3：\n\n\n输入：head = [1,2], n = 1\n输出：[1]\n\n\n \n\n提示：\n\n * 链表中结点的数目为 sz\n * 1 <= sz <= 30\n * 0 <= node.val <= 100\n * 1 <= n <= sz\n\n\n# 解法\n\n利用快慢指针。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def removenthfromend(self, head: listnode, n: int) -> listnode:\n        dummy = listnode(next=head)\n        fast = slow = dummy\n        for _ in range(n):\n            fast = fast.next\n        while fast.next:\n            slow, fast = slow.next, fast.next\n        slow.next = slow.next.next\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode removenthfromend(listnode head, int n) {\n        listnode dummy = new listnode(0, head);\n        listnode fast = dummy, slow = dummy;\n        while (n-- > 0) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        slow.next = slow.next.next;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* removenthfromend(listnode* head, int n) {\n        listnode* dummy = new listnode(0, head);\n        listnode* fast = dummy;\n        listnode* slow = dummy;\n        while (n--) {\n            fast = fast->next;\n        }\n        while (fast->next) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        slow->next = slow->next->next;\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\nfunc removenthfromend(head *listnode, n int) *listnode {\n    dummy := &listnode{0, head}\n    fast := dummy\n    slow := dummy\n    for n > 0 {\n        fast = fast.next\n        n -= 1\n    }\n    for fast.next != nil {\n        slow = slow.next\n        fast = fast.next\n    }\n    slow.next = slow.next.next\n    return dummy.next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @param {number} n\n * @return {listnode}\n */\nvar removenthfromend = function(head, n) {\n    const dummy = new listnode(0, head);\n    let fast = dummy, slow = dummy;\n    while (n--) {\n        fast = fast.next;\n    }\n    while (fast.next) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    slow.next = slow.next.next;\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# ruby\n\n# definition for singly-linked list.\n# class listnode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {listnode} head\n# @param {integer} n\n# @return {listnode}\ndef remove_nth_from_end(head, n)\n    dummy = listnode.new(0, head)\n    fast = slow = dummy\n    while n > 0\n        fast = fast.next\n        n -= 1\n    end\n    while fast.next\n        slow = slow.next\n        fast = fast.next\n    end\n    slow.next = slow.next.next\n    return dummy.next\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode20 Valid Parentheses",frontmatter:{title:"leetcode20 Valid Parentheses",date:"2021-07-20T04:24:14.000Z",permalink:"/p/0afb6c/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode20 Valid Parentheses"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10020.leetcode20%20Valid%20Parentheses.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode20 Valid Parentheses"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10020.leetcode20%20Valid%20Parentheses.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode20 Valid Parentheses"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10020.leetcode20%20Valid%20Parentheses.html",relativePath:"01.算法/24.leetcode/10020.leetcode20 Valid Parentheses.md",key:"v-28ca9b09",path:"/p/0afb6c/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:364},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:485},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:820},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1406},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1942}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 20. 有效的括号\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n 1. 左括号必须用相同类型的右括号闭合。\n 2. 左括号必须以正确的顺序闭合。\n\n \n\n示例 1：\n\n\n输入：s = \"()\"\n输出：true\n\n\n示例 2：\n\n\n输入：s = \"()[]{}\"\n输出：true\n\n\n示例 3：\n\n\n输入：s = \"(]\"\n输出：false\n\n\n示例 4：\n\n\n输入：s = \"([)]\"\n输出：false\n\n\n示例 5：\n\n\n输入：s = \"{[]}\"\n输出：true\n\n \n\n提示：\n\n * 1 <= s.length <= 104\n * s 仅由括号 '()[]{}' 组成\n\n\n# 解法\n\n栈实现。\n\n遍历括号字符串，遇到左括号时，将左括号压入栈中；遇到右括号时，弹出栈顶元素（栈若为空，直接返回 false），判断是否是相同类型的括号。若不匹配，直接返回 false。\n\n遍历结束，栈若为空，说明括号字符串有效。\n\n\n# Python3\n\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        q = []\n        parentheses = {'()', '[]', '{}'}\n        for ch in s:\n            if ch in '([{':\n                q.append(ch)\n            elif not q or q.pop() + ch not in parentheses:\n                return False\n        return not q\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Java\n\nclass Solution {\n    public boolean isValid(String s) {\n        char[] chars = s.toCharArray();\n        Deque<Character> q = new ArrayDeque<>();\n        for (char ch : chars) {\n            boolean left = ch == '(' || ch == '[' || ch == '{';\n            if (left) q.push(ch);\n            else if (q.isEmpty() || !match(q.pop(), ch)) return false;\n        }\n        return q.isEmpty();\n    }\n\n    private boolean match(char l, char r) {\n        return (l == '(' && r == ')') || (l == '{' && r == '}') || (l == '[' && r == ']');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# C++\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> q;\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            if (s[i] == '{' || s[i] == '[' || s[i] == '(') q.push(s[i]);\n            else if (q.empty() || !match(q.top(), s[i])) return false;\n            else q.pop();\n        }\n        return q.empty();\n    }\nprivate:\n    bool match(char l, char r) {\n        return (l == '(' && r == ')') || (l == '[' && r == ']') || (l == '{' && r == '}');\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 20. 有效的括号\n\nenglish version\n\n\n# 题目描述\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n 1. 左括号必须用相同类型的右括号闭合。\n 2. 左括号必须以正确的顺序闭合。\n\n \n\n示例 1：\n\n\n输入：s = \"()\"\n输出：true\n\n\n示例 2：\n\n\n输入：s = \"()[]{}\"\n输出：true\n\n\n示例 3：\n\n\n输入：s = \"(]\"\n输出：false\n\n\n示例 4：\n\n\n输入：s = \"([)]\"\n输出：false\n\n\n示例 5：\n\n\n输入：s = \"{[]}\"\n输出：true\n\n \n\n提示：\n\n * 1 <= s.length <= 104\n * s 仅由括号 '()[]{}' 组成\n\n\n# 解法\n\n栈实现。\n\n遍历括号字符串，遇到左括号时，将左括号压入栈中；遇到右括号时，弹出栈顶元素（栈若为空，直接返回 false），判断是否是相同类型的括号。若不匹配，直接返回 false。\n\n遍历结束，栈若为空，说明括号字符串有效。\n\n\n# python3\n\nclass solution:\n    def isvalid(self, s: str) -> bool:\n        q = []\n        parentheses = {'()', '[]', '{}'}\n        for ch in s:\n            if ch in '([{':\n                q.append(ch)\n            elif not q or q.pop() + ch not in parentheses:\n                return false\n        return not q\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# java\n\nclass solution {\n    public boolean isvalid(string s) {\n        char[] chars = s.tochararray();\n        deque<character> q = new arraydeque<>();\n        for (char ch : chars) {\n            boolean left = ch == '(' || ch == '[' || ch == '{';\n            if (left) q.push(ch);\n            else if (q.isempty() || !match(q.pop(), ch)) return false;\n        }\n        return q.isempty();\n    }\n\n    private boolean match(char l, char r) {\n        return (l == '(' && r == ')') || (l == '{' && r == '}') || (l == '[' && r == ']');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# c++\n\nclass solution {\npublic:\n    bool isvalid(string s) {\n        stack<char> q;\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            if (s[i] == '{' || s[i] == '[' || s[i] == '(') q.push(s[i]);\n            else if (q.empty() || !match(q.top(), s[i])) return false;\n            else q.pop();\n        }\n        return q.empty();\n    }\nprivate:\n    bool match(char l, char r) {\n        return (l == '(' && r == ')') || (l == '[' && r == ']') || (l == '{' && r == '}');\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode21 Merge Two Sorted Lists",frontmatter:{title:"leetcode21 Merge Two Sorted Lists",date:"2021-07-20T04:24:14.000Z",permalink:"/p/163bb4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0021.Merge%20Two%20Sorted%20Lists/images/merge_ex1.jpg"},{name:"twitter:title",content:"leetcode21 Merge Two Sorted Lists"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0021.Merge%20Two%20Sorted%20Lists/images/merge_ex1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10021.leetcode21%20Merge%20Two%20Sorted%20Lists.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode21 Merge Two Sorted Lists"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0021.Merge%20Two%20Sorted%20Lists/images/merge_ex1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10021.leetcode21%20Merge%20Two%20Sorted%20Lists.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode21 Merge Two Sorted Lists"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0021.Merge%20Two%20Sorted%20Lists/images/merge_ex1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10021.leetcode21%20Merge%20Two%20Sorted%20Lists.html",relativePath:"01.算法/24.leetcode/10021.leetcode21 Merge Two Sorted Lists.md",key:"v-6e501801",path:"/p/163bb4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:313},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:358},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:980},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1829},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2681},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:3399},{level:3,title:"Ruby",slug:"ruby",normalizedTitle:"ruby",charIndex:4037},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:4698},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:5545}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go Ruby C# ...",content:"# 21. 合并两个有序链表\n\nEnglish Version\n\n\n# 题目描述\n\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n示例 1：\n\n\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n\n\n示例 2：\n\n\n输入：l1 = [], l2 = []\n输出：[]\n\n\n示例 3：\n\n\n输入：l1 = [], l2 = [0]\n输出：[0]\n\n\n \n\n提示：\n\n * 两个链表的节点数目范围是 [0, 50]\n * -100 <= Node.val <= 100\n * l1 和 l2 均按 非递减顺序 排列\n\n\n# 解法\n\n迭代遍历两链表，比较节点值 val 的大小，进行节点串联，得到最终链表。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummy = ListNode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        cur.next = l1 or l2\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode();\n        ListNode* cur = dummy;\n        while (l1 && l2) {\n            if (l1->val <= l2->val) {\n                cur->next = l1;\n                l1 = l1->next;\n            } else {\n                cur->next = l2;\n                l2 = l2->next;\n            }\n            cur = cur->next;\n        }\n        cur->next = l1 ? l1 : l2;\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar mergeTwoLists = function(l1, l2) {\n    const dummy = new ListNode();\n    let cur = dummy;\n    while (l1 && l2) {\n        if (l1.val <= l2.val) {\n            cur.next = l1;\n            l1 = l1.next;\n        } else {\n            cur.next = l2;\n            l2 = l2.next;\n        }\n        cur = cur.next;\n    }\n    cur.next = l1 || l2;\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {\n    dummy := &ListNode{}\n    cur := dummy\n    for l1 != nil && l2 != nil {\n        if l1.Val <= l2.Val {\n            cur.Next = l1\n            l1 = l1.Next\n        } else {\n            cur.Next = l2\n            l2 = l2.Next\n        }\n        cur = cur.Next\n    }\n    if l1 != nil {\n        cur.Next = l1\n    } else if l2 != nil {\n        cur.Next = l2\n    }\n    return dummy.Next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Ruby\n\n# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} l1\n# @param {ListNode} l2\n# @return {ListNode}\ndef merge_two_lists(l1, l2)\n    dummy = ListNode.new()\n    cur = dummy\n    while l1 && l2\n        if l1.val <= l2.val\n            cur.next = l1\n            l1 = l1.next\n        else\n            cur.next = l2\n            l2 = l2.next\n        end\n        cur = cur.next\n    end\n    cur.next = l1 || l2\n    dummy.next\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# C#\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 21. 合并两个有序链表\n\nenglish version\n\n\n# 题目描述\n\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n示例 1：\n\n\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n\n\n示例 2：\n\n\n输入：l1 = [], l2 = []\n输出：[]\n\n\n示例 3：\n\n\n输入：l1 = [], l2 = [0]\n输出：[0]\n\n\n \n\n提示：\n\n * 两个链表的节点数目范围是 [0, 50]\n * -100 <= node.val <= 100\n * l1 和 l2 均按 非递减顺序 排列\n\n\n# 解法\n\n迭代遍历两链表，比较节点值 val 的大小，进行节点串联，得到最终链表。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def mergetwolists(self, l1: listnode, l2: listnode) -> listnode:\n        dummy = listnode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        cur.next = l1 or l2\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode mergetwolists(listnode l1, listnode l2) {\n        listnode dummy = new listnode(0);\n        listnode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* mergetwolists(listnode* l1, listnode* l2) {\n        listnode* dummy = new listnode();\n        listnode* cur = dummy;\n        while (l1 && l2) {\n            if (l1->val <= l2->val) {\n                cur->next = l1;\n                l1 = l1->next;\n            } else {\n                cur->next = l2;\n                l2 = l2->next;\n            }\n            cur = cur->next;\n        }\n        cur->next = l1 ? l1 : l2;\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} l1\n * @param {listnode} l2\n * @return {listnode}\n */\nvar mergetwolists = function(l1, l2) {\n    const dummy = new listnode();\n    let cur = dummy;\n    while (l1 && l2) {\n        if (l1.val <= l2.val) {\n            cur.next = l1;\n            l1 = l1.next;\n        } else {\n            cur.next = l2;\n            l2 = l2.next;\n        }\n        cur = cur.next;\n    }\n    cur.next = l1 || l2;\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\nfunc mergetwolists(l1 *listnode, l2 *listnode) *listnode {\n    dummy := &listnode{}\n    cur := dummy\n    for l1 != nil && l2 != nil {\n        if l1.val <= l2.val {\n            cur.next = l1\n            l1 = l1.next\n        } else {\n            cur.next = l2\n            l2 = l2.next\n        }\n        cur = cur.next\n    }\n    if l1 != nil {\n        cur.next = l1\n    } else if l2 != nil {\n        cur.next = l2\n    }\n    return dummy.next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# ruby\n\n# definition for singly-linked list.\n# class listnode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {listnode} l1\n# @param {listnode} l2\n# @return {listnode}\ndef merge_two_lists(l1, l2)\n    dummy = listnode.new()\n    cur = dummy\n    while l1 && l2\n        if l1.val <= l2.val\n            cur.next = l1\n            l1 = l1.next\n        else\n            cur.next = l2\n            l2 = l2.next\n        end\n        cur = cur.next\n    end\n    cur.next = l1 || l2\n    dummy.next\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# c#\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     public int val;\n *     public listnode next;\n *     public listnode(int val=0, listnode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class solution {\n    public listnode mergetwolists(listnode l1, listnode l2) {\n        listnode dummy = new listnode();\n        listnode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode22 Generate Parentheses",frontmatter:{title:"leetcode22 Generate Parentheses",date:"2021-07-20T04:24:14.000Z",permalink:"/p/cc1223/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode22 Generate Parentheses"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10022.leetcode22%20Generate%20Parentheses.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode22 Generate Parentheses"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10022.leetcode22%20Generate%20Parentheses.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode22 Generate Parentheses"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10022.leetcode22%20Generate%20Parentheses.html",relativePath:"01.算法/24.leetcode/10022.leetcode22 Generate Parentheses.md",key:"v-40daeab2",path:"/p/cc1223/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:215},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:227},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:688},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:1258},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1754},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2263},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2634}],headersStr:"题目描述 解法 Python3 Java TypeScript C++ Go ...",content:'# 22. 括号生成\n\nEnglish Version\n\n\n# 题目描述\n\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n \n\n示例 1：\n\n\n输入：n = 3\n输出：["((()))","(()())","(())()","()(())","()()()"]\n\n\n示例 2：\n\n\n输入：n = 1\n输出：["()"]\n\n\n \n\n提示：\n\n * 1 <= n <= 8\n\n\n# 解法\n\ndfs\n\n\n# Python3\n\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        def dfs(ans, l, r, n):\n            if len(ans) == (n << 1):\n                self.res.append(ans)\n                return\n            if l < n:\n                dfs(ans + \'(\', l + 1, r, n)\n            if r < l:\n                dfs(ans + \')\', l, r + 1, n)\n        \n        self.res = []\n        dfs(\'\', 0, 0, n)\n        return self.res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Java\n\nclass Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        dfs(res, "", 0, 0, n);\n        return res;\n    }\n\n    private void dfs(List<String> res, String ans, int l, int r, int n) {\n        if (ans.length() == (n << 1)) {\n            res.add(ans);\n            return;\n        }\n        if (l < n) {\n            dfs(res, ans + "(", l + 1, r, n);\n        }\n        if (r < l) {\n            dfs(res, ans + ")", l, r + 1, n);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# TypeScript\n\nfunction generateParenthesis(n: number): string[] {\n    let ans = [];\n    dfs(n, 0, 0, \'\', ans);\n    return ans;\n};\n\nfunction dfs(n: number, left: number, right: number, str: string, ans: string[]) {\n    if (str.length == 2 * n) {\n        ans.push(str);\n        return;\n    }\n    if (left < n) {\n        dfs(n, left + 1, right, str + \'(\', ans);\n    }\n    if (right < left) {\n        dfs(n, left, right + 1, str + \')\', ans);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# C++\n\nclass Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> res;\n        dfs(res, "", 0, 0, n);\n        return res;\n    }\n\nprivate:\n    void dfs(vector<string>& res, string ans, int l, int r, int n) {\n        if (ans.size() == (n << 1)) {\n            res.push_back(ans);\n            return;\n        }\n        if (l < n) dfs(res, ans + "(", l + 1, r, n);\n        if (r < l) dfs(res, ans + ")", l, r + 1, n);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Go\n\nfunc generateParenthesis(n int) []string {\n\tres := new([]string)\n\tdfs(res, "", 0, 0, n)\n\treturn *res\n}\n\nfunc dfs(res *[]string, ans string, l, r, n int) {\n\tif len(ans) == (n << 1) {\n\t\t*res = append(*res, ans)\n\t\treturn\n\t}\n\tif l < n {\n\t\tdfs(res, ans+"(", l+1, r, n)\n\t}\n\tif r < l {\n\t\tdfs(res, ans+")", l, r+1, n)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 22. 括号生成\n\nenglish version\n\n\n# 题目描述\n\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n \n\n示例 1：\n\n\n输入：n = 3\n输出：["((()))","(()())","(())()","()(())","()()()"]\n\n\n示例 2：\n\n\n输入：n = 1\n输出：["()"]\n\n\n \n\n提示：\n\n * 1 <= n <= 8\n\n\n# 解法\n\ndfs\n\n\n# python3\n\nclass solution:\n    def generateparenthesis(self, n: int) -> list[str]:\n        def dfs(ans, l, r, n):\n            if len(ans) == (n << 1):\n                self.res.append(ans)\n                return\n            if l < n:\n                dfs(ans + \'(\', l + 1, r, n)\n            if r < l:\n                dfs(ans + \')\', l, r + 1, n)\n        \n        self.res = []\n        dfs(\'\', 0, 0, n)\n        return self.res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# java\n\nclass solution {\n    public list<string> generateparenthesis(int n) {\n        list<string> res = new arraylist<>();\n        dfs(res, "", 0, 0, n);\n        return res;\n    }\n\n    private void dfs(list<string> res, string ans, int l, int r, int n) {\n        if (ans.length() == (n << 1)) {\n            res.add(ans);\n            return;\n        }\n        if (l < n) {\n            dfs(res, ans + "(", l + 1, r, n);\n        }\n        if (r < l) {\n            dfs(res, ans + ")", l, r + 1, n);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# typescript\n\nfunction generateparenthesis(n: number): string[] {\n    let ans = [];\n    dfs(n, 0, 0, \'\', ans);\n    return ans;\n};\n\nfunction dfs(n: number, left: number, right: number, str: string, ans: string[]) {\n    if (str.length == 2 * n) {\n        ans.push(str);\n        return;\n    }\n    if (left < n) {\n        dfs(n, left + 1, right, str + \'(\', ans);\n    }\n    if (right < left) {\n        dfs(n, left, right + 1, str + \')\', ans);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# c++\n\nclass solution {\npublic:\n    vector<string> generateparenthesis(int n) {\n        vector<string> res;\n        dfs(res, "", 0, 0, n);\n        return res;\n    }\n\nprivate:\n    void dfs(vector<string>& res, string ans, int l, int r, int n) {\n        if (ans.size() == (n << 1)) {\n            res.push_back(ans);\n            return;\n        }\n        if (l < n) dfs(res, ans + "(", l + 1, r, n);\n        if (r < l) dfs(res, ans + ")", l, r + 1, n);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# go\n\nfunc generateparenthesis(n int) []string {\n\tres := new([]string)\n\tdfs(res, "", 0, 0, n)\n\treturn *res\n}\n\nfunc dfs(res *[]string, ans string, l, r, n int) {\n\tif len(ans) == (n << 1) {\n\t\t*res = append(*res, ans)\n\t\treturn\n\t}\n\tif l < n {\n\t\tdfs(res, ans+"(", l+1, r, n)\n\t}\n\tif r < l {\n\t\tdfs(res, ans+")", l, r+1, n)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode23 Merge k Sorted Lists",frontmatter:{title:"leetcode23 Merge k Sorted Lists",date:"2021-07-20T04:24:14.000Z",permalink:"/p/e16635/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode23 Merge k Sorted Lists"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10023.leetcode23%20Merge%20k%20Sorted%20Lists.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode23 Merge k Sorted Lists"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10023.leetcode23%20Merge%20k%20Sorted%20Lists.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode23 Merge k Sorted Lists"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10023.leetcode23%20Merge%20k%20Sorted%20Lists.html",relativePath:"01.算法/24.leetcode/10023.leetcode23 Merge k Sorted Lists.md",key:"v-076af421",path:"/p/e16635/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:472},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:510},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1412},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2598},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:3785},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:4681},{level:3,title:"Ruby",slug:"ruby",normalizedTitle:"ruby",charIndex:5639},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:6457},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:7623}],headersStr:"题目描述 解法 Python3 Java C++ Go JavaScript Ruby C# ...",content:"# 23. 合并K个升序链表\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n \n\n示例 1：\n\n输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6\n\n\n示例 2：\n\n输入：lists = []\n输出：[]\n\n\n示例 3：\n\n输入：lists = [[]]\n输出：[]\n\n\n \n\n提示：\n\n * k == lists.length\n * 0 <= k <= 10^4\n * 0 <= lists[i].length <= 500\n * -10^4 <= lists[i][j] <= 10^4\n * lists[i] 按 升序 排列\n * lists[i].length 的总和不超过 10^4\n\n\n# 解法\n\n合并前后两个链表，结果放在后一个链表位置上，依次循环下去。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        if not lists:\n            return None\n        n = len(lists)\n        for i in range(1, n):\n            lists[i] = self.mergeTwoLists(lists[i - 1], lists[i])\n        return lists[n - 1]\n\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummy = ListNode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        cur.next = l1 or l2\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        int n;\n        if (lists == null || (n = lists.length) == 0) {\n            return null;\n        }\n        for (int i = 1; i < n; ++i) {\n            lists[i] = mergeTwoLists(lists[i - 1], lists[i]);\n        }\n        return lists[n - 1];\n    }\n\n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        int n = lists.size();\n        if (n == 0) {\n            return nullptr;\n        }\n        for (int i = 1; i < n; ++i) {\n            lists[i] = mergeTwoLists(lists[i - 1], lists[i]);\n        }\n        return lists[n - 1];\n    }\n\nprivate:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode();\n        ListNode* cur = dummy;\n        while (l1 && l2) {\n            if (l1->val <= l2->val) {\n                cur->next = l1;\n                l1 = l1->next;\n            } else {\n                cur->next = l2;\n                l2 = l2->next;\n            }\n            cur = cur->next;\n        }\n        cur->next = l1 ? l1 : l2;\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc mergeKLists(lists []*ListNode) *ListNode {\n    n := len(lists)\n    if n == 0 {\n        return nil\n    }\n    for i := 1; i < n; i++ {\n        lists[i] = mergeTwoLists(lists[i-1], lists[i])\n    }\n    return lists[n-1]\n}\n\n func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {\n    dummy := &ListNode{}\n    cur := dummy\n    for l1 != nil && l2 != nil {\n        if l1.Val <= l2.Val {\n            cur.Next = l1\n            l1 = l1.Next\n        } else {\n            cur.Next = l2\n            l2 = l2.Next\n        }\n        cur = cur.Next\n    }\n    if l1 != nil {\n        cur.Next = l1\n    } else if l2 != nil {\n        cur.Next = l2\n    }\n    return dummy.Next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n    const n = lists.length;\n    if (n == 0) {\n        return null;\n    }\n    for (let i = 1; i < n; ++i) {\n        lists[i] = mergeTwoLists(lists[i - 1], lists[i]);\n    }\n    return lists[n - 1];\n};\n\nfunction mergeTwoLists(l1, l2) {\n    const dummy = new ListNode();\n    let cur = dummy;\n    while (l1 && l2) {\n        if (l1.val <= l2.val) {\n            cur.next = l1;\n            l1 = l1.next;\n        } else {\n            cur.next = l2;\n            l2 = l2.next;\n        }\n        cur = cur.next;\n    }\n    cur.next = l1 || l2;\n    return dummy.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# Ruby\n\n# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode[]} lists\n# @return {ListNode}\ndef merge_k_lists(lists)\n    n = lists.length\n    i = 1\n    while i < n\n        lists[i] = merge_two_lists(lists[i - 1], lists[i])\n        i += 1\n    end\n    lists[n - 1]\nend\n\ndef merge_two_lists(l1, l2)\n  dummy = ListNode.new()\n  cur = dummy\n  while l1 && l2\n      if l1.val <= l2.val\n          cur.next = l1\n          l1 = l1.next\n      else\n          cur.next = l2\n          l2 = l2.next\n      end\n      cur = cur.next\n  end\n  cur.next = l1 || l2\n  dummy.next\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# C#\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeKLists(ListNode[] lists) {\n        int n = lists.Length;\n        if (n == 0) {\n            return null;\n        }\n        for (int i = 1; i < n; ++i) {\n            lists[i] = MergeTwoLists(lists[i - 1], lists[i]);\n        }\n        return lists[n - 1];\n    }\n\n    private ListNode MergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 23. 合并k个升序链表\n\nenglish version\n\n\n# 题目描述\n\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n \n\n示例 1：\n\n输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6\n\n\n示例 2：\n\n输入：lists = []\n输出：[]\n\n\n示例 3：\n\n输入：lists = [[]]\n输出：[]\n\n\n \n\n提示：\n\n * k == lists.length\n * 0 <= k <= 10^4\n * 0 <= lists[i].length <= 500\n * -10^4 <= lists[i][j] <= 10^4\n * lists[i] 按 升序 排列\n * lists[i].length 的总和不超过 10^4\n\n\n# 解法\n\n合并前后两个链表，结果放在后一个链表位置上，依次循环下去。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def mergeklists(self, lists: list[listnode]) -> listnode:\n        if not lists:\n            return none\n        n = len(lists)\n        for i in range(1, n):\n            lists[i] = self.mergetwolists(lists[i - 1], lists[i])\n        return lists[n - 1]\n\n    def mergetwolists(self, l1: listnode, l2: listnode) -> listnode:\n        dummy = listnode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        cur.next = l1 or l2\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode mergeklists(listnode[] lists) {\n        int n;\n        if (lists == null || (n = lists.length) == 0) {\n            return null;\n        }\n        for (int i = 1; i < n; ++i) {\n            lists[i] = mergetwolists(lists[i - 1], lists[i]);\n        }\n        return lists[n - 1];\n    }\n\n    private listnode mergetwolists(listnode l1, listnode l2) {\n        listnode dummy = new listnode();\n        listnode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* mergeklists(vector<listnode*>& lists) {\n        int n = lists.size();\n        if (n == 0) {\n            return nullptr;\n        }\n        for (int i = 1; i < n; ++i) {\n            lists[i] = mergetwolists(lists[i - 1], lists[i]);\n        }\n        return lists[n - 1];\n    }\n\nprivate:\n    listnode* mergetwolists(listnode* l1, listnode* l2) {\n        listnode* dummy = new listnode();\n        listnode* cur = dummy;\n        while (l1 && l2) {\n            if (l1->val <= l2->val) {\n                cur->next = l1;\n                l1 = l1->next;\n            } else {\n                cur->next = l2;\n                l2 = l2->next;\n            }\n            cur = cur->next;\n        }\n        cur->next = l1 ? l1 : l2;\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\nfunc mergeklists(lists []*listnode) *listnode {\n    n := len(lists)\n    if n == 0 {\n        return nil\n    }\n    for i := 1; i < n; i++ {\n        lists[i] = mergetwolists(lists[i-1], lists[i])\n    }\n    return lists[n-1]\n}\n\n func mergetwolists(l1 *listnode, l2 *listnode) *listnode {\n    dummy := &listnode{}\n    cur := dummy\n    for l1 != nil && l2 != nil {\n        if l1.val <= l2.val {\n            cur.next = l1\n            l1 = l1.next\n        } else {\n            cur.next = l2\n            l2 = l2.next\n        }\n        cur = cur.next\n    }\n    if l1 != nil {\n        cur.next = l1\n    } else if l2 != nil {\n        cur.next = l2\n    }\n    return dummy.next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode[]} lists\n * @return {listnode}\n */\nvar mergeklists = function(lists) {\n    const n = lists.length;\n    if (n == 0) {\n        return null;\n    }\n    for (let i = 1; i < n; ++i) {\n        lists[i] = mergetwolists(lists[i - 1], lists[i]);\n    }\n    return lists[n - 1];\n};\n\nfunction mergetwolists(l1, l2) {\n    const dummy = new listnode();\n    let cur = dummy;\n    while (l1 && l2) {\n        if (l1.val <= l2.val) {\n            cur.next = l1;\n            l1 = l1.next;\n        } else {\n            cur.next = l2;\n            l2 = l2.next;\n        }\n        cur = cur.next;\n    }\n    cur.next = l1 || l2;\n    return dummy.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# ruby\n\n# definition for singly-linked list.\n# class listnode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {listnode[]} lists\n# @return {listnode}\ndef merge_k_lists(lists)\n    n = lists.length\n    i = 1\n    while i < n\n        lists[i] = merge_two_lists(lists[i - 1], lists[i])\n        i += 1\n    end\n    lists[n - 1]\nend\n\ndef merge_two_lists(l1, l2)\n  dummy = listnode.new()\n  cur = dummy\n  while l1 && l2\n      if l1.val <= l2.val\n          cur.next = l1\n          l1 = l1.next\n      else\n          cur.next = l2\n          l2 = l2.next\n      end\n      cur = cur.next\n  end\n  cur.next = l1 || l2\n  dummy.next\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# c#\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     public int val;\n *     public listnode next;\n *     public listnode(int val=0, listnode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class solution {\n    public listnode mergeklists(listnode[] lists) {\n        int n = lists.length;\n        if (n == 0) {\n            return null;\n        }\n        for (int i = 1; i < n; ++i) {\n            lists[i] = mergetwolists(lists[i - 1], lists[i]);\n        }\n        return lists[n - 1];\n    }\n\n    private listnode mergetwolists(listnode l1, listnode l2) {\n        listnode dummy = new listnode();\n        listnode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode24 Swap Nodes in Pairs",frontmatter:{title:"leetcode24 Swap Nodes in Pairs",date:"2021-07-20T04:24:14.000Z",permalink:"/p/5421f4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0024.Swap%20Nodes%20in%20Pairs/images/swap_ex1.jpg"},{name:"twitter:title",content:"leetcode24 Swap Nodes in Pairs"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0024.Swap%20Nodes%20in%20Pairs/images/swap_ex1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10024.leetcode24%20Swap%20Nodes%20in%20Pairs.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode24 Swap Nodes in Pairs"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0024.Swap%20Nodes%20in%20Pairs/images/swap_ex1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10024.leetcode24%20Swap%20Nodes%20in%20Pairs.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode24 Swap Nodes in Pairs"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0024.Swap%20Nodes%20in%20Pairs/images/swap_ex1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10024.leetcode24%20Swap%20Nodes%20in%20Pairs.html",relativePath:"01.算法/24.leetcode/10024.leetcode24 Swap Nodes in Pairs.md",key:"v-69d0e2bb",path:"/p/5421f4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:322},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:386},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:928},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1685},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2328},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:3119},{level:3,title:"Ruby",slug:"ruby",normalizedTitle:"ruby",charIndex:3599},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4192}],headersStr:"题目描述 解法 Python3 Java JavaScript C++ Go Ruby ...",content:"# 24. 两两交换链表中的节点\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n \n\n示例 1：\n\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n\n示例 2：\n\n\n输入：head = []\n输出：[]\n\n\n示例 3：\n\n\n输入：head = [1]\n输出：[1]\n\n\n \n\n提示：\n\n * 链表中节点的数目在范围 [0, 100] 内\n * 0 <= Node.val <= 100\n\n \n\n进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\n\n\n# 解法\n\n设置虚拟头节点 dummy，pre 指针初始指向 dummy，遍历链表，每次交换 pre 后面的两个节点即可。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode(next=head)\n        pre, cur = dummy, head\n        while cur and cur.next:\n            t = cur.next\n            cur.next = t.next\n            t.next = cur\n            pre.next = t\n            pre, cur = cur, cur.next\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy, cur = head;\n        while (cur != null && cur.next != null) {\n            ListNode t = cur.next;\n            cur.next = t.next;\n            t.next = cur;\n            pre.next = t;\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    const dummy = new ListNode(0, head);\n    let pre = dummy;\n    let cur = head;\n    while (cur && cur.next) {\n        const t = cur.next;\n        cur.next = t.next;\n        t.next = cur;\n        pre.next = t;\n        pre = cur;\n        cur = cur.next;\n    }\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode *dummy = new ListNode(0, head);\n        ListNode *pre = dummy, *cur = head;\n        while (cur != nullptr && cur->next != nullptr) {\n            ListNode *t = cur->next;\n            cur->next = t->next;\n            t->next = cur;\n            pre->next = t;\n            pre = cur;\n            cur = cur->next;\n        }\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n    dummy := &ListNode{0, head}\n    pre, cur := dummy, head\n    for cur != nil && cur.Next != nil {\n        t := cur.Next\n        cur.Next = t.Next\n        t.Next = cur\n        pre.Next = t\n        pre = cur\n        cur = cur.Next\n    }\n    return dummy.Next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Ruby\n\n# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef swap_pairs(head)\n    dummy = ListNode.new(0, head)\n    pre = dummy\n    cur = head\n    while !cur.nil? && !cur.next.nil?\n        t = cur.next\n        cur.next = t.next\n        t.next = cur\n        pre.next = t\n        pre = cur\n        cur = cur.next\n    end\n    dummy.next\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 24. 两两交换链表中的节点\n\nenglish version\n\n\n# 题目描述\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n \n\n示例 1：\n\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n\n示例 2：\n\n\n输入：head = []\n输出：[]\n\n\n示例 3：\n\n\n输入：head = [1]\n输出：[1]\n\n\n \n\n提示：\n\n * 链表中节点的数目在范围 [0, 100] 内\n * 0 <= node.val <= 100\n\n \n\n进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\n\n\n# 解法\n\n设置虚拟头节点 dummy，pre 指针初始指向 dummy，遍历链表，每次交换 pre 后面的两个节点即可。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def swappairs(self, head: listnode) -> listnode:\n        dummy = listnode(next=head)\n        pre, cur = dummy, head\n        while cur and cur.next:\n            t = cur.next\n            cur.next = t.next\n            t.next = cur\n            pre.next = t\n            pre, cur = cur, cur.next\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode swappairs(listnode head) {\n        listnode dummy = new listnode(0, head);\n        listnode pre = dummy, cur = head;\n        while (cur != null && cur.next != null) {\n            listnode t = cur.next;\n            cur.next = t.next;\n            t.next = cur;\n            pre.next = t;\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {listnode}\n */\nvar swappairs = function(head) {\n    const dummy = new listnode(0, head);\n    let pre = dummy;\n    let cur = head;\n    while (cur && cur.next) {\n        const t = cur.next;\n        cur.next = t.next;\n        t.next = cur;\n        pre.next = t;\n        pre = cur;\n        cur = cur.next;\n    }\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* swappairs(listnode* head) {\n        listnode *dummy = new listnode(0, head);\n        listnode *pre = dummy, *cur = head;\n        while (cur != nullptr && cur->next != nullptr) {\n            listnode *t = cur->next;\n            cur->next = t->next;\n            t->next = cur;\n            pre->next = t;\n            pre = cur;\n            cur = cur->next;\n        }\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\nfunc swappairs(head *listnode) *listnode {\n    dummy := &listnode{0, head}\n    pre, cur := dummy, head\n    for cur != nil && cur.next != nil {\n        t := cur.next\n        cur.next = t.next\n        t.next = cur\n        pre.next = t\n        pre = cur\n        cur = cur.next\n    }\n    return dummy.next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# ruby\n\n# definition for singly-linked list.\n# class listnode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {listnode} head\n# @return {listnode}\ndef swap_pairs(head)\n    dummy = listnode.new(0, head)\n    pre = dummy\n    cur = head\n    while !cur.nil? && !cur.next.nil?\n        t = cur.next\n        cur.next = t.next\n        t.next = cur\n        pre.next = t\n        pre = cur\n        cur = cur.next\n    end\n    dummy.next\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode25 Reverse Nodes in k-Group",frontmatter:{title:"leetcode25 Reverse Nodes in k-Group",date:"2021-07-20T04:24:14.000Z",permalink:"/p/222c60/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0025.Reverse%20Nodes%20in%20k-Group/images/reverse_ex1.jpg"},{name:"twitter:title",content:"leetcode25 Reverse Nodes in k-Group"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0025.Reverse%20Nodes%20in%20k-Group/images/reverse_ex1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10025.leetcode25%20Reverse%20Nodes%20in%20k-Group.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode25 Reverse Nodes in k-Group"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0025.Reverse%20Nodes%20in%20k-Group/images/reverse_ex1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10025.leetcode25%20Reverse%20Nodes%20in%20k-Group.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode25 Reverse Nodes in k-Group"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0025.Reverse%20Nodes%20in%20k-Group/images/reverse_ex1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10025.leetcode25%20Reverse%20Nodes%20in%20k-Group.html",relativePath:"01.算法/24.leetcode/10025.leetcode25 Reverse Nodes in k-Group.md",key:"v-445308e1",path:"/p/222c60/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:501},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:508},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1491},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:2788},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:4144},{level:3,title:"C#",slug:"c",normalizedTitle:"c#",charIndex:5048},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3249}],headersStr:"题目描述 解法 Python3 Java TypeScript Go C# ...",content:"# 25. K 个一组翻转链表\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\n\nk 是一个正整数，它的值小于或等于链表的长度。\n\n如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n进阶：\n\n * 你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n * 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n \n\n示例 1：\n\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[2,1,4,3,5]\n\n\n示例 2：\n\n\n输入：head = [1,2,3,4,5], k = 3\n输出：[3,2,1,4,5]\n\n\n示例 3：\n\n\n输入：head = [1,2,3,4,5], k = 1\n输出：[1,2,3,4,5]\n\n\n示例 4：\n\n\n输入：head = [1], k = 1\n输出：[1]\n\n\n提示：\n\n * 列表中节点的数量在范围 sz 内\n * 1 <= sz <= 5000\n * 0 <= Node.val <= 1000\n * 1 <= k <= sz\n\n\n# 解法\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        def reverseList(head):\n            pre, p = None, head\n            while p:\n                q = p.next\n                p.next = pre\n                pre = p\n                p = q\n            return pre\n\n        dummy = ListNode(next=head)\n        pre = cur = dummy\n        while cur.next:\n            for _ in range(k):\n                cur = cur.next\n                if cur is None:\n                    return dummy.next\n            t = cur.next\n            cur.next = None\n            start = pre.next\n            pre.next = reverseList(start)\n            start.next = t\n            pre = start\n            cur = pre\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy, cur = dummy;\n        while (cur.next != null) {\n            for (int i = 0; i < k && cur != null; ++i) {\n                cur = cur.next;\n            }\n            if (cur == null) {\n                return dummy.next;\n            }\n            ListNode t = cur.next;\n            cur.next = null;\n            ListNode start = pre.next;\n            pre.next = reverseList(start);\n            start.next = t;\n            pre = start;\n            cur = pre;\n        }\n        return dummy.next;\n    }\n\n    private ListNode reverseList(ListNode head) {\n        ListNode pre = null, p = head;\n        while (p != null) {\n            ListNode q = p.next;\n            p.next = pre;\n            pre = p;\n            p = q;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# TypeScript\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction reverseKGroup(head: ListNode | null, k: number): ListNode | null {\n    let dummy = new ListNode(0, head);\n    let pre = dummy;\n    // pre->head-> ... ->tail-> next\n    while (head != null) {\n        let tail = pre;\n        for (let i=0; i<k; ++i) {\n            tail = tail.next;\n            if (tail == null) {\n                return dummy.next;\n            }\n        }\n        let t = tail.next;\n        [head, tail] = reverse(head, tail);\n        // set next\n        pre.next = head;\n        tail.next = t;\n        // set new pre and new head\n        pre = tail;\n        head = t;\n    }\n    return dummy.next;\n};\n\nfunction reverse (head: ListNode, tail: ListNode) {\n    let cur = head;\n    let pre = tail.next;\n    // head -> next -> ... -> tail -> pre\n    while (pre != tail) {\n        let t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    return [tail, head]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n\tdummy := &ListNode{0, head}\n\tpre := dummy\n\tcur := dummy\n\tfor cur.Next != nil {\n\t\tfor i := 0; i < k && cur != nil; i++ {\n\t\t\tcur = cur.Next\n\t\t}\n\t\tif cur == nil {\n\t\t\treturn dummy.Next\n\t\t}\n\t\tt := cur.Next\n\t\tcur.Next = nil\n\t\tstart := pre.Next\n\t\tpre.Next = reverseList(start)\n\t\tstart.Next = t\n\t\tpre = start\n\t\tcur = pre\n\t}\n\treturn dummy.Next\n}\n\nfunc reverseList(head *ListNode) *ListNode {\n\tif head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\tdummyHead := &ListNode{}\n\tcur := head\n\tfor cur != nil {\n\t\ttmp := cur.Next\n\t\tcur.Next = dummyHead.Next\n\t\tdummyHead.Next = cur\n\t\tcur = tmp\n\t}\n\treturn dummyHead.Next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# C#\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ReverseKGroup(ListNode head, int k) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy, cur = dummy;\n        while (cur.next != null)\n        {\n            for (int i = 0; i < k && cur != null; ++i)\n            {\n                cur = cur.next;\n            }\n            if (cur == null)\n            {\n                return dummy.next;\n            }\n            ListNode t = cur.next;\n            cur.next = null;\n            ListNode start = pre.next;\n            pre.next = ReverseList(start);\n            start.next = t;\n            pre = start;\n            cur = pre;\n        }\n        return dummy.next;\n    }\n\n    private ListNode ReverseList(ListNode head) {\n        ListNode pre = null, p = head;\n        while (p != null)\n        {\n            ListNode q = p.next;\n            p.next = pre;\n            pre = p;\n            p = q;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 25. k 个一组翻转链表\n\nenglish version\n\n\n# 题目描述\n\n给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\n\nk 是一个正整数，它的值小于或等于链表的长度。\n\n如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n进阶：\n\n * 你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n * 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n \n\n示例 1：\n\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[2,1,4,3,5]\n\n\n示例 2：\n\n\n输入：head = [1,2,3,4,5], k = 3\n输出：[3,2,1,4,5]\n\n\n示例 3：\n\n\n输入：head = [1,2,3,4,5], k = 1\n输出：[1,2,3,4,5]\n\n\n示例 4：\n\n\n输入：head = [1], k = 1\n输出：[1]\n\n\n提示：\n\n * 列表中节点的数量在范围 sz 内\n * 1 <= sz <= 5000\n * 0 <= node.val <= 1000\n * 1 <= k <= sz\n\n\n# 解法\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def reversekgroup(self, head: listnode, k: int) -> listnode:\n        def reverselist(head):\n            pre, p = none, head\n            while p:\n                q = p.next\n                p.next = pre\n                pre = p\n                p = q\n            return pre\n\n        dummy = listnode(next=head)\n        pre = cur = dummy\n        while cur.next:\n            for _ in range(k):\n                cur = cur.next\n                if cur is none:\n                    return dummy.next\n            t = cur.next\n            cur.next = none\n            start = pre.next\n            pre.next = reverselist(start)\n            start.next = t\n            pre = start\n            cur = pre\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode reversekgroup(listnode head, int k) {\n        listnode dummy = new listnode(0, head);\n        listnode pre = dummy, cur = dummy;\n        while (cur.next != null) {\n            for (int i = 0; i < k && cur != null; ++i) {\n                cur = cur.next;\n            }\n            if (cur == null) {\n                return dummy.next;\n            }\n            listnode t = cur.next;\n            cur.next = null;\n            listnode start = pre.next;\n            pre.next = reverselist(start);\n            start.next = t;\n            pre = start;\n            cur = pre;\n        }\n        return dummy.next;\n    }\n\n    private listnode reverselist(listnode head) {\n        listnode pre = null, p = head;\n        while (p != null) {\n            listnode q = p.next;\n            p.next = pre;\n            pre = p;\n            p = q;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# typescript\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     val: number\n *     next: listnode | null\n *     constructor(val?: number, next?: listnode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction reversekgroup(head: listnode | null, k: number): listnode | null {\n    let dummy = new listnode(0, head);\n    let pre = dummy;\n    // pre->head-> ... ->tail-> next\n    while (head != null) {\n        let tail = pre;\n        for (let i=0; i<k; ++i) {\n            tail = tail.next;\n            if (tail == null) {\n                return dummy.next;\n            }\n        }\n        let t = tail.next;\n        [head, tail] = reverse(head, tail);\n        // set next\n        pre.next = head;\n        tail.next = t;\n        // set new pre and new head\n        pre = tail;\n        head = t;\n    }\n    return dummy.next;\n};\n\nfunction reverse (head: listnode, tail: listnode) {\n    let cur = head;\n    let pre = tail.next;\n    // head -> next -> ... -> tail -> pre\n    while (pre != tail) {\n        let t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    return [tail, head]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\nfunc reversekgroup(head *listnode, k int) *listnode {\n\tdummy := &listnode{0, head}\n\tpre := dummy\n\tcur := dummy\n\tfor cur.next != nil {\n\t\tfor i := 0; i < k && cur != nil; i++ {\n\t\t\tcur = cur.next\n\t\t}\n\t\tif cur == nil {\n\t\t\treturn dummy.next\n\t\t}\n\t\tt := cur.next\n\t\tcur.next = nil\n\t\tstart := pre.next\n\t\tpre.next = reverselist(start)\n\t\tstart.next = t\n\t\tpre = start\n\t\tcur = pre\n\t}\n\treturn dummy.next\n}\n\nfunc reverselist(head *listnode) *listnode {\n\tif head == nil || head.next == nil {\n\t\treturn head\n\t}\n\tdummyhead := &listnode{}\n\tcur := head\n\tfor cur != nil {\n\t\ttmp := cur.next\n\t\tcur.next = dummyhead.next\n\t\tdummyhead.next = cur\n\t\tcur = tmp\n\t}\n\treturn dummyhead.next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# c#\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     public int val;\n *     public listnode next;\n *     public listnode(int val=0, listnode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class solution {\n    public listnode reversekgroup(listnode head, int k) {\n        listnode dummy = new listnode(0, head);\n        listnode pre = dummy, cur = dummy;\n        while (cur.next != null)\n        {\n            for (int i = 0; i < k && cur != null; ++i)\n            {\n                cur = cur.next;\n            }\n            if (cur == null)\n            {\n                return dummy.next;\n            }\n            listnode t = cur.next;\n            cur.next = null;\n            listnode start = pre.next;\n            pre.next = reverselist(start);\n            start.next = t;\n            pre = start;\n            cur = pre;\n        }\n        return dummy.next;\n    }\n\n    private listnode reverselist(listnode head) {\n        listnode pre = null, p = head;\n        while (p != null)\n        {\n            listnode q = p.next;\n            p.next = pre;\n            pre = p;\n            p = q;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode26 Remove Duplicates from Sorted Array",frontmatter:{title:"leetcode26 Remove Duplicates from Sorted Array",date:"2021-07-20T04:24:14.000Z",permalink:"/p/dbd8bb/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode26 Remove Duplicates from Sorted Array"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10026.leetcode26%20Remove%20Duplicates%20from%20Sorted%20Array.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode26 Remove Duplicates from Sorted Array"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10026.leetcode26%20Remove%20Duplicates%20from%20Sorted%20Array.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode26 Remove Duplicates from Sorted Array"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10026.leetcode26%20Remove%20Duplicates%20from%20Sorted%20Array.html",relativePath:"01.算法/24.leetcode/10026.leetcode26 Remove Duplicates from Sorted Array.md",key:"v-9638d2dc",path:"/p/dbd8bb/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:778},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:785},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1096},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1400},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1714},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1997},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:2312},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2753}],headersStr:"题目描述 解法 Python3 Java JavaScript Go C++ C# ...",content:"# 26. 删除有序数组中的重复项\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n \n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n\n\n\n示例 1：\n\n\n输入：nums = [1,1,2]\n输出：2, nums = [1,2]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n\n示例 2：\n\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 3 * 104\n * -104 <= nums[i] <= 104\n * nums 已按升序排列\n\n \n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        cnt, n = 0, len(nums)\n        for i in range(1, n):\n            if nums[i] == nums[i - 1]:\n                cnt += 1\n            else:\n                nums[i - cnt] = nums[i]\n        return n - cnt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Java\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int cnt = 0, n = nums.length;\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] == nums[i - 1]) ++cnt;\n            else nums[i - cnt] = nums[i];\n        }\n        return n - cnt;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n  let cnt = 0;\n  const n = nums.length;\n  for (let i = 1; i < n; ++i) {\n    if (nums[i] == nums[i - 1]) ++cnt;\n    else nums[i - cnt] = nums[i];\n  }\n  return n - cnt;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Go\n\nfunc removeDuplicates(nums []int) int {\n    cnt := 0\n    n := len(nums)\n    for i := 1; i < n; i++ {\n        if nums[i] == nums[i - 1] {\n            cnt++\n        } else {\n            nums[i - cnt] = nums[i]\n        }\n    }\n    return n - cnt\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int cnt = 0, n = nums.size();\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] == nums[i - 1]) ++cnt;\n            else nums[i - cnt] = nums[i];\n        }\n        return n - cnt;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# C#\n\npublic class Solution {\n    public int RemoveDuplicates(int[] nums) {\n        int cnt = 0;\n        int n = nums.Length;\n        for (int i = 1; i < n; ++i)\n        {\n            if (nums[i] == nums[i - 1])\n            {\n                ++cnt;\n            }\n            else\n            {\n                nums[i - cnt] = nums[i];\n            }\n        }\n        return n - cnt;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 26. 删除有序数组中的重复项\n\nenglish version\n\n\n# 题目描述\n\n给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 o(1) 额外空间的条件下完成。\n\n \n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeduplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n\n\n\n示例 1：\n\n\n输入：nums = [1,1,2]\n输出：2, nums = [1,2]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n\n示例 2：\n\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 3 * 104\n * -104 <= nums[i] <= 104\n * nums 已按升序排列\n\n \n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def removeduplicates(self, nums: list[int]) -> int:\n        cnt, n = 0, len(nums)\n        for i in range(1, n):\n            if nums[i] == nums[i - 1]:\n                cnt += 1\n            else:\n                nums[i - cnt] = nums[i]\n        return n - cnt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# java\n\nclass solution {\n    public int removeduplicates(int[] nums) {\n        int cnt = 0, n = nums.length;\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] == nums[i - 1]) ++cnt;\n            else nums[i - cnt] = nums[i];\n        }\n        return n - cnt;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeduplicates = function (nums) {\n  let cnt = 0;\n  const n = nums.length;\n  for (let i = 1; i < n; ++i) {\n    if (nums[i] == nums[i - 1]) ++cnt;\n    else nums[i - cnt] = nums[i];\n  }\n  return n - cnt;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# go\n\nfunc removeduplicates(nums []int) int {\n    cnt := 0\n    n := len(nums)\n    for i := 1; i < n; i++ {\n        if nums[i] == nums[i - 1] {\n            cnt++\n        } else {\n            nums[i - cnt] = nums[i]\n        }\n    }\n    return n - cnt\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# c++\n\nclass solution {\npublic:\n    int removeduplicates(vector<int>& nums) {\n        int cnt = 0, n = nums.size();\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] == nums[i - 1]) ++cnt;\n            else nums[i - cnt] = nums[i];\n        }\n        return n - cnt;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# c#\n\npublic class solution {\n    public int removeduplicates(int[] nums) {\n        int cnt = 0;\n        int n = nums.length;\n        for (int i = 1; i < n; ++i)\n        {\n            if (nums[i] == nums[i - 1])\n            {\n                ++cnt;\n            }\n            else\n            {\n                nums[i - cnt] = nums[i];\n            }\n        }\n        return n - cnt;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode27 Remove Element",frontmatter:{title:"leetcode27 Remove Element",date:"2021-07-20T04:24:14.000Z",permalink:"/p/ac2720/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode27 Remove Element"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10027.leetcode27%20Remove%20Element.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode27 Remove Element"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10027.leetcode27%20Remove%20Element.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode27 Remove Element"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10027.leetcode27%20Remove%20Element.html",relativePath:"01.算法/24.leetcode/10027.leetcode27 Remove Element.md",key:"v-eed23472",path:"/p/ac2720/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:874},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:881},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1188},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1490},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1803},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2137},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2412}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go ...",content:"# 27. 移除元素\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n \n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n\n \n\n示例 1：\n\n\n输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n\n\n示例 2：\n\n\n输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,4,0,3]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 100\n * 0 <= nums[i] <= 50\n * 0 <= val <= 100\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        cnt, n = 0, len(nums)\n        for i in range(n):\n            if nums[i] == val:\n                cnt += 1\n            else:\n                nums[i - cnt] = nums[i]\n        return n - cnt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Java\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int cnt = 0, n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == val) ++cnt;\n            else nums[i - cnt] = nums[i];\n        }\n        return n - cnt;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int cnt = 0, n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == val) ++cnt;\n            else nums[i - cnt] = nums[i];\n        }\n        return n - cnt;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function (nums, val) {\n  let cnt = 0;\n  const n = nums.length;\n  for (let i = 0; i < n; ++i) {\n    if (nums[i] == val) ++cnt;\n    else nums[i - cnt] = nums[i];\n  }\n  return n - cnt;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Go\n\nfunc removeElement(nums []int, val int) int {\n    cnt, n := 0, len(nums)\n    for i := 0; i < n; i++ {\n        if (nums[i] == val) {\n            cnt++\n        } else {\n            nums[i - cnt] = nums[i]\n        }\n    }\n    return n - cnt\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 27. 移除元素\n\nenglish version\n\n\n# 题目描述\n\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 o(1) 额外空间并 原地 修改输入数组。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n \n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeelement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n\n \n\n示例 1：\n\n\n输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n\n\n示例 2：\n\n\n输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,4,0,3]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 100\n * 0 <= nums[i] <= 50\n * 0 <= val <= 100\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def removeelement(self, nums: list[int], val: int) -> int:\n        cnt, n = 0, len(nums)\n        for i in range(n):\n            if nums[i] == val:\n                cnt += 1\n            else:\n                nums[i - cnt] = nums[i]\n        return n - cnt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# java\n\nclass solution {\n    public int removeelement(int[] nums, int val) {\n        int cnt = 0, n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == val) ++cnt;\n            else nums[i - cnt] = nums[i];\n        }\n        return n - cnt;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# c++\n\nclass solution {\npublic:\n    int removeelement(vector<int>& nums, int val) {\n        int cnt = 0, n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == val) ++cnt;\n            else nums[i - cnt] = nums[i];\n        }\n        return n - cnt;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeelement = function (nums, val) {\n  let cnt = 0;\n  const n = nums.length;\n  for (let i = 0; i < n; ++i) {\n    if (nums[i] == val) ++cnt;\n    else nums[i - cnt] = nums[i];\n  }\n  return n - cnt;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# go\n\nfunc removeelement(nums []int, val int) int {\n    cnt, n := 0, len(nums)\n    for i := 0; i < n; i++ {\n        if (nums[i] == val) {\n            cnt++\n        } else {\n            nums[i - cnt] = nums[i]\n        }\n    }\n    return n - cnt\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode28 Implement strStr()",frontmatter:{title:"leetcode28 Implement strStr()",date:"2021-07-20T04:24:14.000Z",permalink:"/p/612dd5/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode28 Implement strStr()"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10028.leetcode28%20Implement%20strStr().html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode28 Implement strStr()"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10028.leetcode28%20Implement%20strStr().html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode28 Implement strStr()"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10028.leetcode28%20Implement%20strStr().html",relativePath:"01.算法/24.leetcode/10028.leetcode28 Implement strStr().md",key:"v-3ada3421",path:"/p/612dd5/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:531},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:538},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:259},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:573}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 28. 实现 strStr()\n\nEnglish Version\n\n\n# 题目描述\n\n实现 strStr() 函数。\n\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。\n\n \n\n说明：\n\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。\n\n \n\n示例 1：\n\n\n输入：haystack = "hello", needle = "ll"\n输出：2\n\n\n示例 2：\n\n\n输入：haystack = "aaaaa", needle = "bba"\n输出：-1\n\n\n示例 3：\n\n\n输入：haystack = "", needle = ""\n输出：0\n\n\n \n\n提示：\n\n * 0 <= haystack.length, needle.length <= 5 * 104\n * haystack 和 needle 仅由小写英文字符组成\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 28. 实现 strstr()\n\nenglish version\n\n\n# 题目描述\n\n实现 strstr() 函数。\n\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。\n\n \n\n说明：\n\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 c 语言的 strstr() 以及 java 的 indexof() 定义相符。\n\n \n\n示例 1：\n\n\n输入：haystack = "hello", needle = "ll"\n输出：2\n\n\n示例 2：\n\n\n输入：haystack = "aaaaa", needle = "bba"\n输出：-1\n\n\n示例 3：\n\n\n输入：haystack = "", needle = ""\n输出：0\n\n\n \n\n提示：\n\n * 0 <= haystack.length, needle.length <= 5 * 104\n * haystack 和 needle 仅由小写英文字符组成\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode29 Divide Two Integers",frontmatter:{title:"leetcode29 Divide Two Integers",date:"2021-07-20T04:24:14.000Z",permalink:"/p/35bd07/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode29 Divide Two Integers"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10029.leetcode29%20Divide%20Two%20Integers.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode29 Divide Two Integers"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10029.leetcode29%20Divide%20Two%20Integers.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode29 Divide Two Integers"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10029.leetcode29%20Divide%20Two%20Integers.html",relativePath:"01.算法/24.leetcode/10029.leetcode29 Divide Two Integers.md",key:"v-d4112a68",path:"/p/35bd07/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:511},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:518},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:537},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:553}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 29. 两数相除\n\nEnglish Version\n\n\n# 题目描述\n\n给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。\n\n返回被除数 dividend 除以除数 divisor 得到的商。\n\n整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2\n\n \n\n示例 1:\n\n输入: dividend = 10, divisor = 3\n输出: 3\n解释: 10/3 = truncate(3.33333..) = truncate(3) = 3\n\n示例 2:\n\n输入: dividend = 7, divisor = -3\n输出: -2\n解释: 7/-3 = truncate(-2.33333..) = -2\n\n \n\n提示：\n\n * 被除数和除数均为 32 位有符号整数。\n * 除数不为 0。\n * 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 29. 两数相除\n\nenglish version\n\n\n# 题目描述\n\n给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。\n\n返回被除数 dividend 除以除数 divisor 得到的商。\n\n整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2\n\n \n\n示例 1:\n\n输入: dividend = 10, divisor = 3\n输出: 3\n解释: 10/3 = truncate(3.33333..) = truncate(3) = 3\n\n示例 2:\n\n输入: dividend = 7, divisor = -3\n输出: -2\n解释: 7/-3 = truncate(-2.33333..) = -2\n\n \n\n提示：\n\n * 被除数和除数均为 32 位有符号整数。\n * 除数不为 0。\n * 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode30 Substring with Concatenation of All Words",frontmatter:{title:"leetcode30 Substring with Concatenation of All Words",date:"2021-07-20T04:24:14.000Z",permalink:"/p/62136e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode30 Substring with Concatenation of All Words"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10030.leetcode30%20Substring%20with%20Concatenation%20of%20All%20Words.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode30 Substring with Concatenation of All Words"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10030.leetcode30%20Substring%20with%20Concatenation%20of%20All%20Words.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode30 Substring with Concatenation of All Words"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10030.leetcode30%20Substring%20with%20Concatenation%20of%20All%20Words.html",relativePath:"01.算法/24.leetcode/10030.leetcode30 Substring with Concatenation of All Words.md",key:"v-8bdc6966",path:"/p/62136e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:406},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:413},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:432},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:448}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 30. 串联所有单词的子串\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。\n\n注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。\n\n \n\n示例 1：\n\n输入：\n  s = "barfoothefoobarman",\n  words = ["foo","bar"]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n\n\n示例 2：\n\n输入：\n  s = "wordgoodgoodgoodbestword",\n  words = ["word","good","best","word"]\n输出：[]\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 30. 串联所有单词的子串\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。\n\n注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。\n\n \n\n示例 1：\n\n输入：\n  s = "barfoothefoobarman",\n  words = ["foo","bar"]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n\n\n示例 2：\n\n输入：\n  s = "wordgoodgoodgoodbestword",\n  words = ["word","good","best","word"]\n输出：[]\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode31 Next Permutation",frontmatter:{title:"leetcode31 Next Permutation",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d4a741/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode31 Next Permutation"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10031.leetcode31%20Next%20Permutation.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode31 Next Permutation"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10031.leetcode31%20Next%20Permutation.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode31 Next Permutation"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10031.leetcode31%20Next%20Permutation.html",relativePath:"01.算法/24.leetcode/10031.leetcode31 Next Permutation.md",key:"v-28f18332",path:"/p/d4a741/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:359},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:366},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:385},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:401}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 31. 下一个排列\n\nEnglish Version\n\n\n# 题目描述\n\n实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须 原地 修改，只允许使用额外常数空间。\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,3]\n输出：[1,3,2]\n\n\n示例 2：\n\n\n输入：nums = [3,2,1]\n输出：[1,2,3]\n\n\n示例 3：\n\n\n输入：nums = [1,1,5]\n输出：[1,5,1]\n\n\n示例 4：\n\n\n输入：nums = [1]\n输出：[1]\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 31. 下一个排列\n\nenglish version\n\n\n# 题目描述\n\n实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须 原地 修改，只允许使用额外常数空间。\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,3]\n输出：[1,3,2]\n\n\n示例 2：\n\n\n输入：nums = [3,2,1]\n输出：[1,2,3]\n\n\n示例 3：\n\n\n输入：nums = [1,1,5]\n输出：[1,5,1]\n\n\n示例 4：\n\n\n输入：nums = [1]\n输出：[1]\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode32 Longest Valid Parentheses",frontmatter:{title:"leetcode32 Longest Valid Parentheses",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d12644/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode32 Longest Valid Parentheses"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10032.leetcode32%20Longest%20Valid%20Parentheses.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode32 Longest Valid Parentheses"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10032.leetcode32%20Longest%20Valid%20Parentheses.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode32 Longest Valid Parentheses"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10032.leetcode32%20Longest%20Valid%20Parentheses.html",relativePath:"01.算法/24.leetcode/10032.leetcode32 Longest Valid Parentheses.md",key:"v-197875f8",path:"/p/d12644/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:273},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:280},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:299},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:315}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 32. 最长有效括号\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个只包含 \'(\' 和 \')\' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n\n \n\n示例 1：\n\n\n输入：s = "(()"\n输出：2\n解释：最长有效括号子串是 "()"\n\n\n示例 2：\n\n\n输入：s = ")()())"\n输出：4\n解释：最长有效括号子串是 "()()"\n\n\n示例 3：\n\n\n输入：s = ""\n输出：0\n\n\n \n\n提示：\n\n * 0 <= s.length <= 3 * 104\n * s[i] 为 \'(\' 或 \')\'\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 32. 最长有效括号\n\nenglish version\n\n\n# 题目描述\n\n给你一个只包含 \'(\' 和 \')\' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n\n \n\n示例 1：\n\n\n输入：s = "(()"\n输出：2\n解释：最长有效括号子串是 "()"\n\n\n示例 2：\n\n\n输入：s = ")()())"\n输出：4\n解释：最长有效括号子串是 "()()"\n\n\n示例 3：\n\n\n输入：s = ""\n输出：0\n\n\n \n\n提示：\n\n * 0 <= s.length <= 3 * 104\n * s[i] 为 \'(\' 或 \')\'\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode33 Search in Rotated Sorted Array",frontmatter:{title:"leetcode33 Search in Rotated Sorted Array",date:"2021-07-20T04:24:14.000Z",permalink:"/p/584160/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode33 Search in Rotated Sorted Array"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10033.leetcode33%20Search%20in%20Rotated%20Sorted%20Array.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode33 Search in Rotated Sorted Array"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10033.leetcode33%20Search%20in%20Rotated%20Sorted%20Array.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode33 Search in Rotated Sorted Array"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10033.leetcode33%20Search%20in%20Rotated%20Sorted%20Array.html",relativePath:"01.算法/24.leetcode/10033.leetcode33 Search in Rotated Sorted Array.md",key:"v-6a2136f8",path:"/p/584160/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:684},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:698},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1349},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1948},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2557},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:155}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript ...",content:"# 33. 搜索旋转排序数组\n\nEnglish Version\n\n\n# 题目描述\n\n整数数组 nums 按升序排列，数组中的值 互不相同 。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n\n \n\n示例 1：\n\n\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n\n\n示例 2：\n\n\n输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n\n示例 3：\n\n\n输入：nums = [1], target = 0\n输出：-1\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 5000\n * -10^4 <= nums[i] <= 10^4\n * nums 中的每个值都 独一无二\n * 题目数据保证 nums 在预先未知的某个下标上进行了旋转\n * -10^4 <= target <= 10^4\n\n \n\n进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？\n\n\n# 解法\n\n二分查找。\n\n\n# Python3\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) >> 1\n            if nums[mid] == target:\n                return mid\n            if nums[mid] > target:\n                if nums[mid] >= nums[r] and target < nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            else:\n                if nums[mid] <= nums[l] and target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Java\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = (l + r) >>> 1;\n            if (nums[mid] == target) return mid;\n            if (nums[mid] > target) {\n                if (nums[mid] >= nums[r] && target < nums[l]) l = mid + 1;\n                else r = mid - 1;\n            } else {\n                if (nums[mid] <= nums[l] && target > nums[r]) r = mid - 1;\n                else l = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l <= r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] == target) return mid;\n            if (nums[mid] > target) {\n                if (nums[mid] >= nums[r] && target < nums[l]) l = mid + 1;\n                else r = mid - 1;\n            } else {\n                if (nums[mid] <= nums[l] && target > nums[r]) r = mid - 1;\n                else l = mid + 1;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function (nums, target) {\n  let l = 0, r = nums.length - 1;\n  if (l > r) return -1;\n  while (l <= r) {\n    let mid = l + Math.floor((r - l) / 2);\n    if (nums[mid] === target) return mid;\n    else if (nums[mid] <= nums[r] && target <= nums[r] && target >= nums[mid])\n      l = mid + 1;\n    else if (nums[mid] >= nums[l] && target <= nums[mid] && target >= nums[l])\n      r = mid - 1;\n    else if (nums[mid] >= nums[r])\n      l = mid + 1;\n    else if (nums[mid] <= nums[l])\n      r = mid - 1;\n    else return -1;\n  }\n  return -1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 33. 搜索旋转排序数组\n\nenglish version\n\n\n# 题目描述\n\n整数数组 nums 按升序排列，数组中的值 互不相同 。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n\n \n\n示例 1：\n\n\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n\n\n示例 2：\n\n\n输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n\n示例 3：\n\n\n输入：nums = [1], target = 0\n输出：-1\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 5000\n * -10^4 <= nums[i] <= 10^4\n * nums 中的每个值都 独一无二\n * 题目数据保证 nums 在预先未知的某个下标上进行了旋转\n * -10^4 <= target <= 10^4\n\n \n\n进阶：你可以设计一个时间复杂度为 o(log n) 的解决方案吗？\n\n\n# 解法\n\n二分查找。\n\n\n# python3\n\nclass solution:\n    def search(self, nums: list[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) >> 1\n            if nums[mid] == target:\n                return mid\n            if nums[mid] > target:\n                if nums[mid] >= nums[r] and target < nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            else:\n                if nums[mid] <= nums[l] and target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# java\n\nclass solution {\n    public int search(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = (l + r) >>> 1;\n            if (nums[mid] == target) return mid;\n            if (nums[mid] > target) {\n                if (nums[mid] >= nums[r] && target < nums[l]) l = mid + 1;\n                else r = mid - 1;\n            } else {\n                if (nums[mid] <= nums[l] && target > nums[r]) r = mid - 1;\n                else l = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# c++\n\nclass solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l <= r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] == target) return mid;\n            if (nums[mid] > target) {\n                if (nums[mid] >= nums[r] && target < nums[l]) l = mid + 1;\n                else r = mid - 1;\n            } else {\n                if (nums[mid] <= nums[l] && target > nums[r]) r = mid - 1;\n                else l = mid + 1;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function (nums, target) {\n  let l = 0, r = nums.length - 1;\n  if (l > r) return -1;\n  while (l <= r) {\n    let mid = l + math.floor((r - l) / 2);\n    if (nums[mid] === target) return mid;\n    else if (nums[mid] <= nums[r] && target <= nums[r] && target >= nums[mid])\n      l = mid + 1;\n    else if (nums[mid] >= nums[l] && target <= nums[mid] && target >= nums[l])\n      r = mid - 1;\n    else if (nums[mid] >= nums[r])\n      l = mid + 1;\n    else if (nums[mid] <= nums[l])\n      r = mid - 1;\n    else return -1;\n  }\n  return -1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode34 Find First and Last Position of Element in Sorted Array",frontmatter:{title:"leetcode34 Find First and Last Position of Element in Sorted Array",date:"2021-07-20T04:24:14.000Z",permalink:"/p/f47e3f/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode34 Find First and Last Position of Element in Sorted Array"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10034.leetcode34%20Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode34 Find First and Last Position of Element in Sorted Array"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10034.leetcode34%20Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode34 Find First and Last Position of Element in Sorted Array"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10034.leetcode34%20Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array.html",relativePath:"01.算法/24.leetcode/10034.leetcode34 Find First and Last Position of Element in Sorted Array.md",key:"v-fc4d86a6",path:"/p/f47e3f/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:49},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:458},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:492},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1229},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2219},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:3155},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:4019},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4602}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go ...",content:"# 34. 在排序数组中查找元素的第一个和最后一个位置\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 target，返回 [-1, -1]。\n\n进阶：\n\n * 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？\n\n \n\n示例 1：\n\n\n输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]\n\n示例 2：\n\n\n输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]\n\n示例 3：\n\n\n输入：nums = [], target = 0\n输出：[-1,-1]\n\n \n\n提示：\n\n * 0 <= nums.length <= 105\n * -109 <= nums[i] <= 109\n * nums 是一个非递减数组\n * -109 <= target <= 109\n\n\n# 解法\n\n二分查找。\n\n两遍二分，分别查找出左边界和右边界。\n\n\n# Python3\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        if len(nums) == 0:\n            return [-1, -1]\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        if nums[left] != target:\n            return [-1, -1]\n        l, right = left, len(nums) - 1\n        while left < right:\n            mid = (left + right + 1) >> 1\n            if nums[mid] <= target:\n                left = mid\n            else:\n                right = mid - 1\n        return [l, left]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Java\n\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        if (nums.length == 0) {\n            return new int[]{-1, -1};\n        }\n        // find first position\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int mid = (left + right) >>> 1;\n            if (nums[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        if (nums[left] != target) {\n            return new int[]{-1, -1};\n        }\n        int l = left;\n\n        // find last position\n        right = nums.length - 1;\n        while (left < right) {\n            int mid = (left + right + 1) >>> 1;\n            if (nums[mid] <= target) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return new int[]{l, left};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# C++\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        if (nums.size() == 0) {\n            return vector<int>{-1, -1};\n        }\n        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            int mid = left + right >> 1;\n            if (nums[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        if (nums[left] != target) {\n            return vector<int>{-1, -1};\n        }\n        int l = left;\n        right = nums.size() - 1;\n        while (left < right) {\n            int mid = left + right + 1 >> 1;\n            if (nums[mid] <= target) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return vector<int>{l, left};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar searchRange = function(nums, target) {\n    if (nums.length == 0) {\n        return [-1, -1];\n    }\n    let left = 0;\n    let right = nums.length - 1;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        if (nums[mid] >= target) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    if (nums[left] != target) {\n        return [-1, -1];\n    }\n    let l = left;\n    right = nums.length - 1;\n    while (left < right) {\n        const mid = (left + right + 1) >> 1;\n        if (nums[mid] <= target) {\n            left = mid;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return [l, left];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# Go\n\nfunc searchRange(nums []int, target int) []int {\n\tif len(nums) == 0 {\n\t\treturn []int{-1, -1}\n\t}\n\tleft, right := 0, len(nums)-1\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tif nums[mid] >= target {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\tif nums[left] != target {\n\t\treturn []int{-1, -1}\n\t}\n\tl := left\n\tright = len(nums) - 1\n\tfor left < right {\n\t\tmid := (left + right + 1) >> 1\n\t\tif nums[mid] <= target {\n\t\t\tleft = mid\n\t\t} else {\n\t\t\tright = mid - 1\n\t\t}\n\t}\n\treturn []int{l, left}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 34. 在排序数组中查找元素的第一个和最后一个位置\n\nenglish version\n\n\n# 题目描述\n\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 target，返回 [-1, -1]。\n\n进阶：\n\n * 你可以设计并实现时间复杂度为 o(log n) 的算法解决此问题吗？\n\n \n\n示例 1：\n\n\n输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]\n\n示例 2：\n\n\n输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]\n\n示例 3：\n\n\n输入：nums = [], target = 0\n输出：[-1,-1]\n\n \n\n提示：\n\n * 0 <= nums.length <= 105\n * -109 <= nums[i] <= 109\n * nums 是一个非递减数组\n * -109 <= target <= 109\n\n\n# 解法\n\n二分查找。\n\n两遍二分，分别查找出左边界和右边界。\n\n\n# python3\n\nclass solution:\n    def searchrange(self, nums: list[int], target: int) -> list[int]:\n        if len(nums) == 0:\n            return [-1, -1]\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        if nums[left] != target:\n            return [-1, -1]\n        l, right = left, len(nums) - 1\n        while left < right:\n            mid = (left + right + 1) >> 1\n            if nums[mid] <= target:\n                left = mid\n            else:\n                right = mid - 1\n        return [l, left]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# java\n\nclass solution {\n    public int[] searchrange(int[] nums, int target) {\n        if (nums.length == 0) {\n            return new int[]{-1, -1};\n        }\n        // find first position\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int mid = (left + right) >>> 1;\n            if (nums[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        if (nums[left] != target) {\n            return new int[]{-1, -1};\n        }\n        int l = left;\n\n        // find last position\n        right = nums.length - 1;\n        while (left < right) {\n            int mid = (left + right + 1) >>> 1;\n            if (nums[mid] <= target) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return new int[]{l, left};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# c++\n\nclass solution {\npublic:\n    vector<int> searchrange(vector<int>& nums, int target) {\n        if (nums.size() == 0) {\n            return vector<int>{-1, -1};\n        }\n        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            int mid = left + right >> 1;\n            if (nums[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        if (nums[left] != target) {\n            return vector<int>{-1, -1};\n        }\n        int l = left;\n        right = nums.size() - 1;\n        while (left < right) {\n            int mid = left + right + 1 >> 1;\n            if (nums[mid] <= target) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return vector<int>{l, left};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar searchrange = function(nums, target) {\n    if (nums.length == 0) {\n        return [-1, -1];\n    }\n    let left = 0;\n    let right = nums.length - 1;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        if (nums[mid] >= target) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    if (nums[left] != target) {\n        return [-1, -1];\n    }\n    let l = left;\n    right = nums.length - 1;\n    while (left < right) {\n        const mid = (left + right + 1) >> 1;\n        if (nums[mid] <= target) {\n            left = mid;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return [l, left];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# go\n\nfunc searchrange(nums []int, target int) []int {\n\tif len(nums) == 0 {\n\t\treturn []int{-1, -1}\n\t}\n\tleft, right := 0, len(nums)-1\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tif nums[mid] >= target {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\tif nums[left] != target {\n\t\treturn []int{-1, -1}\n\t}\n\tl := left\n\tright = len(nums) - 1\n\tfor left < right {\n\t\tmid := (left + right + 1) >> 1\n\t\tif nums[mid] <= target {\n\t\t\tleft = mid\n\t\t} else {\n\t\t\tright = mid - 1\n\t\t}\n\t}\n\treturn []int{l, left}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode35 Search Insert Position",frontmatter:{title:"leetcode35 Search Insert Position",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b5f6ea/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode35 Search Insert Position"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10035.leetcode35%20Search%20Insert%20Position.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode35 Search Insert Position"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10035.leetcode35%20Search%20Insert%20Position.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode35 Search Insert Position"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10035.leetcode35%20Search%20Insert%20Position.html",relativePath:"01.算法/24.leetcode/10035.leetcode35 Search Insert Position.md",key:"v-0f2635e4",path:"/p/b5f6ea/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:249},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:263},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:615},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1024},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1441},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1698},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2142}],headersStr:"题目描述 解法 Python3 Java C++ Go JavaScript ...",content:"# 35. 搜索插入位置\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n\n\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n\n\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n\n\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n\n\n# 解法\n\n二分查找。\n\n\n# Python3\n\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Java\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0, right = nums.length;\n        while (left < right) {\n            int mid = (left + right) >>> 1;\n            if (nums[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0, right = nums.size();\n        while (left < right) {\n            int mid = left + right >> 1;\n            if (nums[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Go\n\nfunc searchInsert(nums []int, target int) int {\n\tleft, right := 0, len(nums)\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tif nums[mid] >= target {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\treturn left\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let left = 0;\n    let right = nums.length;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        if (nums[mid] >= target) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 35. 搜索插入位置\n\nenglish version\n\n\n# 题目描述\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n\n\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n\n\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n\n\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n\n\n# 解法\n\n二分查找。\n\n\n# python3\n\nclass solution:\n    def searchinsert(self, nums: list[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# java\n\nclass solution {\n    public int searchinsert(int[] nums, int target) {\n        int left = 0, right = nums.length;\n        while (left < right) {\n            int mid = (left + right) >>> 1;\n            if (nums[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# c++\n\nclass solution {\npublic:\n    int searchinsert(vector<int>& nums, int target) {\n        int left = 0, right = nums.size();\n        while (left < right) {\n            int mid = left + right >> 1;\n            if (nums[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# go\n\nfunc searchinsert(nums []int, target int) int {\n\tleft, right := 0, len(nums)\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tif nums[mid] >= target {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\treturn left\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchinsert = function(nums, target) {\n    let left = 0;\n    let right = nums.length;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        if (nums[mid] >= target) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode36 有效的数独【中等难度】|极客学长",frontmatter:{title:"leetcode36 有效的数独【中等难度】|极客学长",date:"2021-07-17T23:32:48.000Z",permalink:"/leetcode36/",categories:["leetcode","学习笔记","算法"],tags:["leetcode"],description:"         &nbsp; ● &nbsp;难度:     中等",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/sudu0.png"},{name:"twitter:title",content:"leetcode36 有效的数独【中等难度】|极客学长"},{name:"twitter:description",content:"         &nbsp; ● &nbsp;难度:     中等"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/sudu0.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10036.leetcode36%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%5B%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%5D.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode36 有效的数独【中等难度】|极客学长"},{property:"og:description",content:"         &nbsp; ● &nbsp;难度:     中等"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/sudu0.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10036.leetcode36%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%5B%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%5D.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-17T23:32:48.000Z"},{property:"article:tag",content:"leetcode"},{itemprop:"name",content:"leetcode36 有效的数独【中等难度】|极客学长"},{itemprop:"description",content:"         &nbsp; ● &nbsp;难度:     中等"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/sudu0.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10036.leetcode36%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%5B%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%5D.html",relativePath:"01.算法/24.leetcode/10036.leetcode36 有效的数独[中等难度].md",key:"v-0152edd7",path:"/leetcode36/",headers:[{level:3,title:"36. 有效的数独",slug:"_36-有效的数独",normalizedTitle:"36. 有效的数独",charIndex:2},{level:3,title:"英文题目: Valid sudoku",slug:"英文题目-valid-sudoku",normalizedTitle:"英文题目: valid sudoku",charIndex:16},{level:2,title:"分析",slug:"分析",normalizedTitle:"分析",charIndex:1270},{level:3,title:"方法1、蛮力直接法",slug:"方法1、蛮力直接法",normalizedTitle:"方法1、蛮力直接法",charIndex:1277},{level:3,title:"方法2：set插入方法 - 改进",slug:"方法2-set插入方法-改进",normalizedTitle:"方法2：set插入方法 - 改进",charIndex:3696},{level:3,title:"方法3：使用位操作",slug:"方法3-使用位操作",normalizedTitle:"方法3：使用位操作",charIndex:5107}],headersStr:"36. 有效的数独 英文题目: Valid sudoku 分析 方法1、蛮力直接法 方法2：set插入方法 - 改进 方法3：使用位操作",content:'# 36. 有效的数独\n\n\n# 英文题目: Valid sudoku\n\n  ●  难度:   中等   \n\n请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。\n\n 1. 数字 1-9 在每一行只能出现一次。\n 2. 数字 1-9 在每一列只能出现一次。\n 3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\n\n数独部分空格内已填入了数字，空白格用 \'.\' 表示。\n\n注意：\n\n * 一个有效的数独（部分已被填充）不一定是可解的。\n * 只需要根据以上规则，验证已经填入的数字是否有效即可。\n\n示例 1：\n\n\n\n输入：board = \n[["5","3",".",".","7",".",".",".","."]\n,["6",".",".","1","9","5",".",".","."]\n,[".","9","8",".",".",".",".","6","."]\n,["8",".",".",".","6",".",".",".","3"]\n,["4",".",".","8",".","3",".",".","1"]\n,["7",".",".",".","2",".",".",".","6"]\n,[".","6",".",".",".",".","2","8","."]\n,[".",".",".","4","1","9",".",".","5"]\n,[".",".",".",".","8",".",".","7","9"]]\n输出：true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n示例 2：\n\n输入：board = \n[["8","3",".",".","7",".",".",".","."]\n,["6",".",".","1","9","5",".",".","."]\n,[".","9","8",".",".",".",".","6","."]\n,["8",".",".",".","6",".",".",".","3"]\n,["4",".",".","8",".","3",".",".","1"]\n,["7",".",".",".","2",".",".",".","6"]\n,[".","6",".",".",".",".","2","8","."]\n,[".",".",".","4","1","9",".",".","5"]\n,[".",".",".",".","8",".",".","7","9"]]\n输出：false\n解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n提示：\n\n * board.length == 9\n * board[i].length == 9\n * board[i][j] 是一位数字或者 \'.\'\n\n\n\n# 分析\n\n\n# 方法1、蛮力直接法\n\n使用set， 对于行遍历: 每一行中, isValid: unique的数字数量+\'.\'的数量 = 9, 对于列遍历：每一列中, isValid: unique的数字数量+\'.\'的数量 = 9, 对于box遍历：每个3行3列九宫格中，isValid: unique的数字数量+\'.\'的数量 = 9。\n\n\n已AC代码:\n\nclass Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>> &board)\n    {\n        bool isValid = true;\n\n        // 遍历行\n        for (int i = 0; i < 9; i++)\n        {\n            set<char> st;\n            vector<char> rowVec = board[i];\n            int dotCount = 0;\n            for (int k = 0; k < 9; k++)\n            {\n                if (rowVec[k] == \'.\')\n                {\n                    dotCount++;\n                }\n                else\n                    st.insert(rowVec[k]);\n            }\n            int uniqueCharCount = st.size();\n            if (uniqueCharCount + dotCount != 9)\n            {\n                isValid = false;\n            }\n        }\n\n        // 遍历列\n        for (int i = 0; i < 9; i++)\n        {\n            set<char> st;            \n            int dotCount = 0;\n            for (int k = 0; k < 9; k++)\n            {\n                if (board[k][i] == \'.\')\n                {\n                    dotCount++;\n                }\n                else\n                    st.insert(board[k][i]);\n            }\n            int uniqueCharCount = st.size();\n            if (uniqueCharCount + dotCount != 9)\n            {\n                isValid = false;\n            }\n        }\n\n        // 遍历小grid: 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n        for (int si = 0; si <= 6; si += 3)                 \n            for (int sj = 0; sj <= 6; sj += 3)\n            {\n                set<char> st; \n                int dotCount = 0;\n                for (int i = si; i < si + 3; i++)\n                {\n                    for (int j = sj; j < sj + 3; j++)\n                    {\n                        if (board[i][j] == \'.\')\n                            dotCount += 1;\n                        else\n                            st.insert(board[i][j]);\n                    }\n                }\n                if (st.size() + dotCount != 9)\n                    isValid = false;\n            }\n        return isValid;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n跟国外的小伙伴想到一块去了。 https://leetcode.com/problems/valid-sudoku/discuss/869625/easy-C%2B%2B-with-set\n\n\n\n# 方法2：set插入方法 - 改进\n\n坐标中任意一点(i,j)，可以map到对应的的第几行第几列的方块(box)中，box的坐标为(i/3, j/3)。\n\n于是把一个小的九宫格中的数全压缩到一个box中，比如：\n\n\n\n\n以最中间那个九宫格为例，使用int型的/3可以得到:\n\n\n\n对于任意一个值不为\'.\'的字符，进行如下操作:\n\n1.把所在row的信息插入到大九宫格中;\n\n2.把所在column的信息插入到大九宫格中;\n\n3.把所在的小方块(box)的信息插入到大九宫格中。\n\n插入如果失败说明出现了重复。\n\n# 已AC的C++代码:\n\nclass Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        set<string> st;\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                char ch = board[i][j];\n                // 使用i / 3 + "," + j / 3 得到对应第几行第几列的方块(box)\n                if (ch != \'.\'){\n                    string val;\n                    val.push_back(ch);\n                    /* 对于任意一个值不为\'.\'的字符\n                       1.把所在row的信息插入到大九宫格中;\n                       2.把所在column的信息插入到大九宫格中;\n                       3.把所在的小方块(box)的信息插入到大九宫格中。\n                       插入如果失败说明出现了重复。 */\n                    if (!st.insert(val + " in row " + to_string(i)).second ||\n                        !st.insert(val + " in column " + to_string(j)).second ||\n                        !st.insert(val + " in box " + to_string(i / 3) + "," + to_string(j / 3)).second)\n                        return false;  /* set插入失败时，表示出现了重复 */\n                }\n            }\n        }\n        return true;        \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nJava的HashSet有同样的写法，Java中插入失败，会出现 set.Add() == false。\n\n\n# 方法3：使用位操作\n\n此题，使用位操作，是几种解法中速度最快的算法了。\n\n具体做法是：\n\n\n\n将大数独棋盘分成9个小棋盘，编号0~8。\n\n窗口中的每个小方格若有数字，必为 1 ~ 9 (记作k)，该方法适用于 遍历行/遍历列/遍历box。\n\n然后把 二进制数 1 左移 k 位，得到偏移量shift，后续使用按位或|来判断是否存在。\n\n# 已AC的C++代码:\n\nclass Solution {\npublic:\n\tbool isValidSudoku(vector<vector<char>>& board) {\n\t\tvector<int> row(9); // row[j]表示第j 行的9个数字各自的存在情况，同理于col, boxes\n\t\tvector<int> col(9);\n\t\tvector<int> boxes(9);\n\n\t\tint shiftInt = 0;\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 9; j++)\n\t\t\t{\n\t\t\t\tif (board[i][j] == \'.\')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tshiftInt = 1 << (board[i][j] - \'0\');  // 转为二进制，移位结束后目标位为1，其他位均为0\n\t\t\t\t/* 每个格子若有数字，必为 1 ~ 9，该方法适用于 遍历行/遍历列/遍历box  */\n\t\t\t\tint boxPos = (i / 3) * 3 + j / 3; //将大数独棋盘分成9个小棋盘，编号0~8\n\n\t\t\t\t// 如果当前数字shiftInt在row[j] 或col[i] 或 boxes中已经存在，&运算后不为0，\n\t\t\t\t// 只有当前数字没出现过，&运算后为0\n\t\t\t\tif ((col[i] & shiftInt) != 0 || (row[j] & shiftInt) != 0 || (boxes[boxPos] & shiftInt) != 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t//第 n 位代表 n 这个数字是否存在(1→存在， 0→不存在)，同理于col[i]  boxes[boxPos]\n\t\t\t\trow[j] |= shiftInt;\n\t\t\t\tcol[i] |= shiftInt;\n\t\t\t\tboxes[boxPos] |= shiftInt;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n后两种方法，参考:\n\nhttps://leetcode-cn.com/problems/valid-sudoku/solution/wei-yun-suan-qiu-jie-you-xiao-shu-du-c-b-sac7/\n\nhttps://www.youtube.com/watch?v=ceOLAY4XUOw&ab_channel=JacobHuang',normalizedContent:'# 36. 有效的数独\n\n\n# 英文题目: valid sudoku\n\n  ●  难度:   中等   \n\n请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。\n\n 1. 数字 1-9 在每一行只能出现一次。\n 2. 数字 1-9 在每一列只能出现一次。\n 3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\n\n数独部分空格内已填入了数字，空白格用 \'.\' 表示。\n\n注意：\n\n * 一个有效的数独（部分已被填充）不一定是可解的。\n * 只需要根据以上规则，验证已经填入的数字是否有效即可。\n\n示例 1：\n\n\n\n输入：board = \n[["5","3",".",".","7",".",".",".","."]\n,["6",".",".","1","9","5",".",".","."]\n,[".","9","8",".",".",".",".","6","."]\n,["8",".",".",".","6",".",".",".","3"]\n,["4",".",".","8",".","3",".",".","1"]\n,["7",".",".",".","2",".",".",".","6"]\n,[".","6",".",".",".",".","2","8","."]\n,[".",".",".","4","1","9",".",".","5"]\n,[".",".",".",".","8",".",".","7","9"]]\n输出：true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n示例 2：\n\n输入：board = \n[["8","3",".",".","7",".",".",".","."]\n,["6",".",".","1","9","5",".",".","."]\n,[".","9","8",".",".",".",".","6","."]\n,["8",".",".",".","6",".",".",".","3"]\n,["4",".",".","8",".","3",".",".","1"]\n,["7",".",".",".","2",".",".",".","6"]\n,[".","6",".",".",".",".","2","8","."]\n,[".",".",".","4","1","9",".",".","5"]\n,[".",".",".",".","8",".",".","7","9"]]\n输出：false\n解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n提示：\n\n * board.length == 9\n * board[i].length == 9\n * board[i][j] 是一位数字或者 \'.\'\n\n\n\n# 分析\n\n\n# 方法1、蛮力直接法\n\n使用set， 对于行遍历: 每一行中, isvalid: unique的数字数量+\'.\'的数量 = 9, 对于列遍历：每一列中, isvalid: unique的数字数量+\'.\'的数量 = 9, 对于box遍历：每个3行3列九宫格中，isvalid: unique的数字数量+\'.\'的数量 = 9。\n\n\n已ac代码:\n\nclass solution {\npublic:\n    bool isvalidsudoku(vector<vector<char>> &board)\n    {\n        bool isvalid = true;\n\n        // 遍历行\n        for (int i = 0; i < 9; i++)\n        {\n            set<char> st;\n            vector<char> rowvec = board[i];\n            int dotcount = 0;\n            for (int k = 0; k < 9; k++)\n            {\n                if (rowvec[k] == \'.\')\n                {\n                    dotcount++;\n                }\n                else\n                    st.insert(rowvec[k]);\n            }\n            int uniquecharcount = st.size();\n            if (uniquecharcount + dotcount != 9)\n            {\n                isvalid = false;\n            }\n        }\n\n        // 遍历列\n        for (int i = 0; i < 9; i++)\n        {\n            set<char> st;            \n            int dotcount = 0;\n            for (int k = 0; k < 9; k++)\n            {\n                if (board[k][i] == \'.\')\n                {\n                    dotcount++;\n                }\n                else\n                    st.insert(board[k][i]);\n            }\n            int uniquecharcount = st.size();\n            if (uniquecharcount + dotcount != 9)\n            {\n                isvalid = false;\n            }\n        }\n\n        // 遍历小grid: 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n        for (int si = 0; si <= 6; si += 3)                 \n            for (int sj = 0; sj <= 6; sj += 3)\n            {\n                set<char> st; \n                int dotcount = 0;\n                for (int i = si; i < si + 3; i++)\n                {\n                    for (int j = sj; j < sj + 3; j++)\n                    {\n                        if (board[i][j] == \'.\')\n                            dotcount += 1;\n                        else\n                            st.insert(board[i][j]);\n                    }\n                }\n                if (st.size() + dotcount != 9)\n                    isvalid = false;\n            }\n        return isvalid;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n跟国外的小伙伴想到一块去了。 https://leetcode.com/problems/valid-sudoku/discuss/869625/easy-c%2b%2b-with-set\n\n\n\n# 方法2：set插入方法 - 改进\n\n坐标中任意一点(i,j)，可以map到对应的的第几行第几列的方块(box)中，box的坐标为(i/3, j/3)。\n\n于是把一个小的九宫格中的数全压缩到一个box中，比如：\n\n\n\n\n以最中间那个九宫格为例，使用int型的/3可以得到:\n\n\n\n对于任意一个值不为\'.\'的字符，进行如下操作:\n\n1.把所在row的信息插入到大九宫格中;\n\n2.把所在column的信息插入到大九宫格中;\n\n3.把所在的小方块(box)的信息插入到大九宫格中。\n\n插入如果失败说明出现了重复。\n\n# 已ac的c++代码:\n\nclass solution {\npublic:\n    bool isvalidsudoku(vector<vector<char>>& board) {\n        set<string> st;\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                char ch = board[i][j];\n                // 使用i / 3 + "," + j / 3 得到对应第几行第几列的方块(box)\n                if (ch != \'.\'){\n                    string val;\n                    val.push_back(ch);\n                    /* 对于任意一个值不为\'.\'的字符\n                       1.把所在row的信息插入到大九宫格中;\n                       2.把所在column的信息插入到大九宫格中;\n                       3.把所在的小方块(box)的信息插入到大九宫格中。\n                       插入如果失败说明出现了重复。 */\n                    if (!st.insert(val + " in row " + to_string(i)).second ||\n                        !st.insert(val + " in column " + to_string(j)).second ||\n                        !st.insert(val + " in box " + to_string(i / 3) + "," + to_string(j / 3)).second)\n                        return false;  /* set插入失败时，表示出现了重复 */\n                }\n            }\n        }\n        return true;        \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\njava的hashset有同样的写法，java中插入失败，会出现 set.add() == false。\n\n\n# 方法3：使用位操作\n\n此题，使用位操作，是几种解法中速度最快的算法了。\n\n具体做法是：\n\n\n\n将大数独棋盘分成9个小棋盘，编号0~8。\n\n窗口中的每个小方格若有数字，必为 1 ~ 9 (记作k)，该方法适用于 遍历行/遍历列/遍历box。\n\n然后把 二进制数 1 左移 k 位，得到偏移量shift，后续使用按位或|来判断是否存在。\n\n# 已ac的c++代码:\n\nclass solution {\npublic:\n\tbool isvalidsudoku(vector<vector<char>>& board) {\n\t\tvector<int> row(9); // row[j]表示第j 行的9个数字各自的存在情况，同理于col, boxes\n\t\tvector<int> col(9);\n\t\tvector<int> boxes(9);\n\n\t\tint shiftint = 0;\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 9; j++)\n\t\t\t{\n\t\t\t\tif (board[i][j] == \'.\')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tshiftint = 1 << (board[i][j] - \'0\');  // 转为二进制，移位结束后目标位为1，其他位均为0\n\t\t\t\t/* 每个格子若有数字，必为 1 ~ 9，该方法适用于 遍历行/遍历列/遍历box  */\n\t\t\t\tint boxpos = (i / 3) * 3 + j / 3; //将大数独棋盘分成9个小棋盘，编号0~8\n\n\t\t\t\t// 如果当前数字shiftint在row[j] 或col[i] 或 boxes中已经存在，&运算后不为0，\n\t\t\t\t// 只有当前数字没出现过，&运算后为0\n\t\t\t\tif ((col[i] & shiftint) != 0 || (row[j] & shiftint) != 0 || (boxes[boxpos] & shiftint) != 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t//第 n 位代表 n 这个数字是否存在(1→存在， 0→不存在)，同理于col[i]  boxes[boxpos]\n\t\t\t\trow[j] |= shiftint;\n\t\t\t\tcol[i] |= shiftint;\n\t\t\t\tboxes[boxpos] |= shiftint;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n后两种方法，参考:\n\nhttps://leetcode-cn.com/problems/valid-sudoku/solution/wei-yun-suan-qiu-jie-you-xiao-shu-du-c-b-sac7/\n\nhttps://www.youtube.com/watch?v=ceolay4xuow&ab_channel=jacobhuang',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode37 Sudoku Solver",frontmatter:{title:"leetcode37 Sudoku Solver",date:"2021-07-20T04:24:14.000Z",permalink:"/p/1a4005/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0037.Sudoku%20Solver/images/250px-sudoku-by-l2g-20050714svg.png"},{name:"twitter:title",content:"leetcode37 Sudoku Solver"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0037.Sudoku%20Solver/images/250px-sudoku-by-l2g-20050714svg.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10037.leetcode37%20Sudoku%20Solver.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode37 Sudoku Solver"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0037.Sudoku%20Solver/images/250px-sudoku-by-l2g-20050714svg.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10037.leetcode37%20Sudoku%20Solver.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode37 Sudoku Solver"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0037.Sudoku%20Solver/images/250px-sudoku-by-l2g-20050714svg.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10037.leetcode37%20Sudoku%20Solver.html",relativePath:"01.算法/24.leetcode/10037.leetcode37 Sudoku Solver.md",key:"v-6f0ca157",path:"/p/1a4005/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:31},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:63},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1051},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1070},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1086}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 37. 解数独\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个程序，通过填充空格来解决数独问题。\n\n数独的解法需 遵循如下规则：\n\n 1. 数字 1-9 在每一行只能出现一次。\n 2. 数字 1-9 在每一列只能出现一次。\n 3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\n\n数独部分空格内已填入了数字，空白格用 \'.\' 表示。\n\n \n\n示例：\n\n\n输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]\n输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]\n解释：输入的数独如上图所示，唯一有效的解决方案如下所示：\n\n\n\n \n\n提示：\n\n * board.length == 9\n * board[i].length == 9\n * board[i][j] 是一位数字或者 \'.\'\n * 题目数据 保证 输入数独仅有一个解\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 37. 解数独\n\nenglish version\n\n\n# 题目描述\n\n编写一个程序，通过填充空格来解决数独问题。\n\n数独的解法需 遵循如下规则：\n\n 1. 数字 1-9 在每一行只能出现一次。\n 2. 数字 1-9 在每一列只能出现一次。\n 3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\n\n数独部分空格内已填入了数字，空白格用 \'.\' 表示。\n\n \n\n示例：\n\n\n输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]\n输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]\n解释：输入的数独如上图所示，唯一有效的解决方案如下所示：\n\n\n\n \n\n提示：\n\n * board.length == 9\n * board[i].length == 9\n * board[i][j] 是一位数字或者 \'.\'\n * 题目数据 保证 输入数独仅有一个解\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode38 外观数列(报数)【中等难度】",frontmatter:{title:"leetcode38 外观数列(报数)【中等难度】",date:"2021-07-18T11:10:20.000Z",permalink:"/leetcode38/",categories:["leetcode","学习笔记","算法"],tags:["leetcode"],description:"         &nbsp; ● &nbsp;难度:     中等",meta:[{name:"image",content:"https://pic.rmb.bdstatic.com/bjh/8514fdc080a7eb404f6edb5807428395.png"},{name:"twitter:title",content:"leetcode38 外观数列(报数)【中等难度】"},{name:"twitter:description",content:"         &nbsp; ● &nbsp;难度:     中等"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://pic.rmb.bdstatic.com/bjh/8514fdc080a7eb404f6edb5807428395.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10038.leetcode38%20%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97(%E6%8A%A5%E6%95%B0)%E3%80%90%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E3%80%91.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode38 外观数列(报数)【中等难度】"},{property:"og:description",content:"         &nbsp; ● &nbsp;难度:     中等"},{property:"og:image",content:"https://pic.rmb.bdstatic.com/bjh/8514fdc080a7eb404f6edb5807428395.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10038.leetcode38%20%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97(%E6%8A%A5%E6%95%B0)%E3%80%90%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E3%80%91.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-18T11:10:20.000Z"},{property:"article:tag",content:"leetcode"},{itemprop:"name",content:"leetcode38 外观数列(报数)【中等难度】"},{itemprop:"description",content:"         &nbsp; ● &nbsp;难度:     中等"},{itemprop:"image",content:"https://pic.rmb.bdstatic.com/bjh/8514fdc080a7eb404f6edb5807428395.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10038.leetcode38%20%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97(%E6%8A%A5%E6%95%B0)%E3%80%90%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E3%80%91.html",relativePath:"01.算法/24.leetcode/10038.leetcode38 外观数列(报数)【中等难度】.md",key:"v-e038dfdc",path:"/leetcode38/",headers:[{level:3,title:"38. 外观数列 (报数)",slug:"_38-外观数列-报数",normalizedTitle:"38. 外观数列 (报数)",charIndex:2},{level:3,title:"英文题目: Count and Say",slug:"英文题目-count-and-say",normalizedTitle:"英文题目: count and say",charIndex:20},{level:2,title:"分析:",slug:"分析",normalizedTitle:"分析:",charIndex:939},{level:3,title:"方法1",slug:"方法1",normalizedTitle:"方法1",charIndex:1066},{level:3,title:"方法2",slug:"方法2",normalizedTitle:"方法2",charIndex:2564},{level:3,title:"方法3",slug:"方法3",normalizedTitle:"方法3",charIndex:3674}],headersStr:"38. 外观数列 (报数) 英文题目: Count and Say 分析: 方法1 方法2 方法3",content:'# 38. 外观数列 (报数)\n\n\n# 英文题目: Count and Say\n\n  ●  难度:   中等   \n\n给定一个正整数 n ，输出外观数列的第 n 项。\n\n「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。\n\n你可以将其视作是由递归公式定义的数字字符串序列：\n\n * countAndSay(1) = "1"\n * countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。\n\n前五项如下：\n\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n第一项是数字 1 \n描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"\n描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"\n描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"\n描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。\n\n例如，数字字符串 "3322251" 的描述如下图：\n\n\n\n示例 1：\n\n输入：n = 1\n输出："1"\n解释：这是一个基本样例。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：n = 4\n输出："1211"\n解释：\ncountAndSay(1) = "1"\ncountAndSay(2) = 读 "1" = 一 个 1 = "11"\ncountAndSay(3) = 读 "11" = 二 个 1 = "21"\ncountAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示：\n\n * 1 <= n <= 30\n\n\n# 分析:\n\n本题可使用递归或迭代来解决，下面的几种方法都使用了迭代。\n\n\n主体思路: 以已知a4=1211, 来求a5为例来说明如何用迭代法实现。 首先将不同字符间(用虚线)划开进行分片，即 1|2|11，分别统计各个分片中连续相同的字符数即可。\n\n\n# 方法1\n\n本题从f(1)到f(n)需要迭代 n-1 次来解决，每次迭代以上一次的迭代结果作为起点，将该迭代结果res中不同字符间(用虚线)划开进行分片，即 1|2|11。\n\n当循环变量从0 -> n-1 且没到末尾的分片时, 每出现新的字符时，把已处理的连续相同字符的信息插入到结果字符串中。而到末尾分片时，需要单独把末尾连续相同字符的信息插入到结果字符串中，因为对末尾一段字符来说，不会再有新的字符了，该数据也需要写入。\n\n# 已AC的C++代码\n\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if(n == 1)\n            return "1";    // f(1) = 1\n        \n        string res = "1";  // f(1) = 1, 作为迭代的初始值放入到结果中\n        for(int i=0; i<n-1; i++)\n        {\n            string currentCombinedStr = "";\n            char curFirstChar = res[0];    // 存放当前分片的第一个字符\n            int currentCharCount = 0;            \n            for(char ch : res)             // 将当前的字符与当前分片的第一个字符比较\n            {\n                if(ch == curFirstChar)\n                    currentCharCount += 1;\n                else {         \n                    // 出现新的字符时，把已处理的连续相同字符的信息插入到结果字符串中\n                    currentCombinedStr.append(to_string(currentCharCount));\n                    currentCombinedStr.push_back(curFirstChar);\n\n                    curFirstChar = ch;\n                    currentCharCount = 1;\n                }\n            }\n\n            // 把末尾连续相同字符的信息插入到结果字符串中(对末尾一段字符来说，不会再有新的字符了)\n            currentCombinedStr.append(to_string(currentCharCount));\n            currentCombinedStr.push_back(curFirstChar);            \n            res = currentCombinedStr; // 将结果用作下一轮循环的初始值\n        }\n\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 方法2\n\n思路与方法1类似，只是将 字符串中第一个连续相等数的数量的功能封装成单独的函数，以便后面使用。\n\n# 已AC的C++代码\n\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        string res = "1";  // f(1) = 1\n        \n        while (n > 1) {\n            string curStr = "";\n            for (int i = 0; i < res.size(); i++) {\n                int count = getRepeatCount(res.substr(i));  // 截取从当前字符到末尾的子串\n                curStr += to_string(count);\n                curStr.push_back(res[i]);\n\n                // 跳过重复的字符, 共处理一次即可\n                i = i + count - 1;\n            }\n            n--;  // 总共需要迭代 n-1 次\n\n            res = curStr;  // 将结果用作下一轮循环的初始值\n        }\n        return res;\n    }\n\n    /* 得到字符串 str 中第一个分片中连续相等数的重复个数，例如: "111221" 返回 3, "2" 返回 1 */\n    int getRepeatCount(string str) {\n        int count = 1;\n        char same = str[0];\n        for (int i = 1; i < str.size(); i++) {\n            if (same == str[i]) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        return count;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 方法3\n\n懂了方法1 或 方法2后，也可以用下面的方式完成。\n\n# 已AC的C++代码\n\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n <= 0) return "";\n\n        string res = "1";\n        while (--n) {\n            string curStr = "";\n            for (int i = 0; i < res.size(); ++i) {\n                int count = 1; // 出现第一个新字符, count置为1\n                while (i + 1 < res.size() && res[i] == res[i + 1]) {  /* 这里与上1层循环用的是同一个i, 且区间是上层循环的子区间, 故时间复杂度是O(n^2) */\n                    count++;\n                    i++;\n                }\n                curStr += to_string(count) + res[i];\n            }\n            res = curStr;  // 将结果用作下一轮循环的初始值\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n以上3种方法都是迭代法的实现，本题还可以使用递归来做，有兴趣的小伙伴可以试试~\n\n----------------------------------------\n\n本人公众号 大白技术控, 2万读者。\n\n知乎 Bravo Yeung, 4.5万读者。\n\nB站 极客学长呀, 后续会用视频的形式来带大家刷LeetCode题，欢迎点个关注，敬请期待~\n\n\n更多清晰易懂的代码 (C++/Java/C#/Python/Go) 的 LeetCode 题解，会在我的 github 仓库 https://github.com/yanglr/AlgoSolutions中持续更新, 欢迎小伙伴们 star/fork，如果有不错的解法也欢迎提PR。\n\n\nps: 仓库的代码中可以直接拿来本地调试喔，框架已搭好，根据自己的需求调整 test case即可~',normalizedContent:'# 38. 外观数列 (报数)\n\n\n# 英文题目: count and say\n\n  ●  难度:   中等   \n\n给定一个正整数 n ，输出外观数列的第 n 项。\n\n「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。\n\n你可以将其视作是由递归公式定义的数字字符串序列：\n\n * countandsay(1) = "1"\n * countandsay(n) 是对 countandsay(n-1) 的描述，然后转换成另一个数字字符串。\n\n前五项如下：\n\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n第一项是数字 1 \n描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"\n描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"\n描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"\n描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。\n\n例如，数字字符串 "3322251" 的描述如下图：\n\n\n\n示例 1：\n\n输入：n = 1\n输出："1"\n解释：这是一个基本样例。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：n = 4\n输出："1211"\n解释：\ncountandsay(1) = "1"\ncountandsay(2) = 读 "1" = 一 个 1 = "11"\ncountandsay(3) = 读 "11" = 二 个 1 = "21"\ncountandsay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示：\n\n * 1 <= n <= 30\n\n\n# 分析:\n\n本题可使用递归或迭代来解决，下面的几种方法都使用了迭代。\n\n\n主体思路: 以已知a4=1211, 来求a5为例来说明如何用迭代法实现。 首先将不同字符间(用虚线)划开进行分片，即 1|2|11，分别统计各个分片中连续相同的字符数即可。\n\n\n# 方法1\n\n本题从f(1)到f(n)需要迭代 n-1 次来解决，每次迭代以上一次的迭代结果作为起点，将该迭代结果res中不同字符间(用虚线)划开进行分片，即 1|2|11。\n\n当循环变量从0 -> n-1 且没到末尾的分片时, 每出现新的字符时，把已处理的连续相同字符的信息插入到结果字符串中。而到末尾分片时，需要单独把末尾连续相同字符的信息插入到结果字符串中，因为对末尾一段字符来说，不会再有新的字符了，该数据也需要写入。\n\n# 已ac的c++代码\n\nclass solution {\npublic:\n    string countandsay(int n) {\n        if(n == 1)\n            return "1";    // f(1) = 1\n        \n        string res = "1";  // f(1) = 1, 作为迭代的初始值放入到结果中\n        for(int i=0; i<n-1; i++)\n        {\n            string currentcombinedstr = "";\n            char curfirstchar = res[0];    // 存放当前分片的第一个字符\n            int currentcharcount = 0;            \n            for(char ch : res)             // 将当前的字符与当前分片的第一个字符比较\n            {\n                if(ch == curfirstchar)\n                    currentcharcount += 1;\n                else {         \n                    // 出现新的字符时，把已处理的连续相同字符的信息插入到结果字符串中\n                    currentcombinedstr.append(to_string(currentcharcount));\n                    currentcombinedstr.push_back(curfirstchar);\n\n                    curfirstchar = ch;\n                    currentcharcount = 1;\n                }\n            }\n\n            // 把末尾连续相同字符的信息插入到结果字符串中(对末尾一段字符来说，不会再有新的字符了)\n            currentcombinedstr.append(to_string(currentcharcount));\n            currentcombinedstr.push_back(curfirstchar);            \n            res = currentcombinedstr; // 将结果用作下一轮循环的初始值\n        }\n\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 方法2\n\n思路与方法1类似，只是将 字符串中第一个连续相等数的数量的功能封装成单独的函数，以便后面使用。\n\n# 已ac的c++代码\n\nclass solution {\npublic:\n    string countandsay(int n) {\n        string res = "1";  // f(1) = 1\n        \n        while (n > 1) {\n            string curstr = "";\n            for (int i = 0; i < res.size(); i++) {\n                int count = getrepeatcount(res.substr(i));  // 截取从当前字符到末尾的子串\n                curstr += to_string(count);\n                curstr.push_back(res[i]);\n\n                // 跳过重复的字符, 共处理一次即可\n                i = i + count - 1;\n            }\n            n--;  // 总共需要迭代 n-1 次\n\n            res = curstr;  // 将结果用作下一轮循环的初始值\n        }\n        return res;\n    }\n\n    /* 得到字符串 str 中第一个分片中连续相等数的重复个数，例如: "111221" 返回 3, "2" 返回 1 */\n    int getrepeatcount(string str) {\n        int count = 1;\n        char same = str[0];\n        for (int i = 1; i < str.size(); i++) {\n            if (same == str[i]) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        return count;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 方法3\n\n懂了方法1 或 方法2后，也可以用下面的方式完成。\n\n# 已ac的c++代码\n\nclass solution {\npublic:\n    string countandsay(int n) {\n        if (n <= 0) return "";\n\n        string res = "1";\n        while (--n) {\n            string curstr = "";\n            for (int i = 0; i < res.size(); ++i) {\n                int count = 1; // 出现第一个新字符, count置为1\n                while (i + 1 < res.size() && res[i] == res[i + 1]) {  /* 这里与上1层循环用的是同一个i, 且区间是上层循环的子区间, 故时间复杂度是o(n^2) */\n                    count++;\n                    i++;\n                }\n                curstr += to_string(count) + res[i];\n            }\n            res = curstr;  // 将结果用作下一轮循环的初始值\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n以上3种方法都是迭代法的实现，本题还可以使用递归来做，有兴趣的小伙伴可以试试~\n\n----------------------------------------\n\n本人公众号 大白技术控, 2万读者。\n\n知乎 bravo yeung, 4.5万读者。\n\nb站 极客学长呀, 后续会用视频的形式来带大家刷leetcode题，欢迎点个关注，敬请期待~\n\n\n更多清晰易懂的代码 (c++/java/c#/python/go) 的 leetcode 题解，会在我的 github 仓库 https://github.com/yanglr/algosolutions中持续更新, 欢迎小伙伴们 star/fork，如果有不错的解法也欢迎提pr。\n\n\nps: 仓库的代码中可以直接拿来本地调试喔，框架已搭好，根据自己的需求调整 test case即可~',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode39 Combination Sum",frontmatter:{title:"leetcode39 Combination Sum",date:"2021-07-20T04:24:14.000Z",permalink:"/p/ca29a3/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode39 Combination Sum"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10039.leetcode39%20Combination%20Sum.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode39 Combination Sum"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10039.leetcode39%20Combination%20Sum.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode39 Combination Sum"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10039.leetcode39%20Combination%20Sum.html",relativePath:"01.算法/24.leetcode/10039.leetcode39 Combination Sum.md",key:"v-f821d6fe",path:"/p/ca29a3/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:478},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:485},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:504},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:520}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 39. 组合总和\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n * 所有数字（包括 target）都是正整数。\n * 解集不能包含重复的组合。 \n\n示例 1：\n\n输入：candidates = [2,3,6,7], target = 7,\n所求解集为：\n[\n  [7],\n  [2,2,3]\n]\n\n\n示例 2：\n\n输入：candidates = [2,3,5], target = 8,\n所求解集为：\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n\n \n\n提示：\n\n * 1 <= candidates.length <= 30\n * 1 <= candidates[i] <= 200\n * candidate 中的每个元素都是独一无二的。\n * 1 <= target <= 500\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 39. 组合总和\n\nenglish version\n\n\n# 题目描述\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n * 所有数字（包括 target）都是正整数。\n * 解集不能包含重复的组合。 \n\n示例 1：\n\n输入：candidates = [2,3,6,7], target = 7,\n所求解集为：\n[\n  [7],\n  [2,2,3]\n]\n\n\n示例 2：\n\n输入：candidates = [2,3,5], target = 8,\n所求解集为：\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n\n \n\n提示：\n\n * 1 <= candidates.length <= 30\n * 1 <= candidates[i] <= 200\n * candidate 中的每个元素都是独一无二的。\n * 1 <= target <= 500\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode40 Combination Sum II",frontmatter:{title:"leetcode40 Combination Sum II",date:"2021-07-20T04:24:14.000Z",permalink:"/p/3104b4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode40 Combination Sum II"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10040.leetcode40%20Combination%20Sum%20II.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode40 Combination Sum II"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10040.leetcode40%20Combination%20Sum%20II.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode40 Combination Sum II"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10040.leetcode40%20Combination%20Sum%20II.html",relativePath:"01.算法/24.leetcode/10040.leetcode40 Combination Sum II.md",key:"v-47723afe",path:"/p/3104b4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:381},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:388},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:407},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:423}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 40. 组合总和 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用一次。\n\n说明：\n\n * 所有数字（包括目标数）都是正整数。\n * 解集不能包含重复的组合。 \n\n示例 1:\n\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n所求解集为:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n\n\n示例 2:\n\n输入: candidates = [2,5,2,1,2], target = 5,\n所求解集为:\n[\n  [1,2,2],\n  [5]\n]\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 40. 组合总和 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用一次。\n\n说明：\n\n * 所有数字（包括目标数）都是正整数。\n * 解集不能包含重复的组合。 \n\n示例 1:\n\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n所求解集为:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n\n\n示例 2:\n\n输入: candidates = [2,5,2,1,2], target = 5,\n所求解集为:\n[\n  [1,2,2],\n  [5]\n]\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode41 First Missing Positive-zh",frontmatter:{title:"leetcode41 First Missing Positive-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/56c9c9/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode41 First Missing Positive-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10041.leetcode41%20First%20Missing%20Positive-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode41 First Missing Positive-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10041.leetcode41%20First%20Missing%20Positive-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode41 First Missing Positive-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10041.leetcode41%20First%20Missing%20Positive-zh.html",relativePath:"01.算法/24.leetcode/10041.leetcode41 First Missing Positive-zh.md",key:"v-0acd08c8",path:"/p/56c9c9/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:306},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:313},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:332},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:348}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 41. 缺失的第一个正数\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n\n \n\n进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,0]\n输出：3\n\n\n示例 2：\n\n\n输入：nums = [3,4,-1,1]\n输出：2\n\n\n示例 3：\n\n\n输入：nums = [7,8,9,11,12]\n输出：1\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 300\n * -231 <= nums[i] <= 231 - 1\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 41. 缺失的第一个正数\n\nenglish version\n\n\n# 题目描述\n\n给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n\n \n\n进阶：你可以实现时间复杂度为 o(n) 并且只使用常数级别额外空间的解决方案吗？\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,0]\n输出：3\n\n\n示例 2：\n\n\n输入：nums = [3,4,-1,1]\n输出：2\n\n\n示例 3：\n\n\n输入：nums = [7,8,9,11,12]\n输出：1\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 300\n * -231 <= nums[i] <= 231 - 1\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode42 Trapping Rain Water-zh",frontmatter:{title:"leetcode42 Trapping Rain Water-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/41be27/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0042.Trapping%20Rain%20Water/images/rainwatertrap.png"},{name:"twitter:title",content:"leetcode42 Trapping Rain Water-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0042.Trapping%20Rain%20Water/images/rainwatertrap.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10042.leetcode42%20Trapping%20Rain%20Water-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode42 Trapping Rain Water-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0042.Trapping%20Rain%20Water/images/rainwatertrap.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10042.leetcode42%20Trapping%20Rain%20Water-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode42 Trapping Rain Water-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0042.Trapping%20Rain%20Water/images/rainwatertrap.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10042.leetcode42%20Trapping%20Rain%20Water-zh.html",relativePath:"01.算法/24.leetcode/10042.leetcode42 Trapping Rain Water-zh.md",key:"v-1eb400c4",path:"/p/41be27/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:31},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:342},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:445},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:943},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:1617},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2396},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:3014},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3609}],headersStr:"题目描述 解法 Python3 Java TypeScript C++ Go ...",content:"# 42. 接雨水\n\nEnglish Version\n\n\n# 题目描述\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n \n\n示例 1：\n\n\n\n\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n\n示例 2：\n\n\n输入：height = [4,2,0,3,2,5]\n输出：9\n\n\n \n\n提示：\n\n * n == height.length\n * 0 <= n <= 3 * 104\n * 0 <= height[i] <= 105\n\n\n# 解法\n\n动态规划法。\n\n对于下标 i，水能达到的最大高度等于下标 i 左右两侧的最大高度的最小值，再减去 height[i] 就能得到当前柱子所能存的水量。\n\n同面试题 17.21. 直方图的水量\n\n\n# Python3\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        if n < 3:\n            return 0\n\n        lmx, rmx = [height[0]] * n, [height[n - 1]] * n\n        for i in range(1, n):\n            lmx[i] = max(lmx[i - 1], height[i])\n            rmx[n - 1 - i] = max(rmx[n - i], height[n - 1 - i])\n        \n        res = 0\n        for i in range(n):\n            res += min(lmx[i], rmx[i]) - height[i]\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java\n\nclass Solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        if (n < 3) {\n            return 0;\n        }\n\n        int[] lmx = new int[n];\n        int[] rmx = new int[n];\n        lmx[0] = height[0];\n        rmx[n - 1] = height[n - 1];\n        for (int i = 1; i < n; ++i) {\n            lmx[i] = Math.max(lmx[i - 1], height[i]);\n            rmx[n - 1 - i] = Math.max(rmx[n - i], height[n - i - 1]);\n        }\n        \n        int res = 0;\n        for (int i = 0; i < n; ++i) {\n            res += Math.min(lmx[i], rmx[i]) - height[i];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# TypeScript\n\nfunction trap(height: number[]): number {\n    let ans = 0;\n    let left = 0, right = height.length - 1;\n    let maxLeft = 0, maxRight = 0;\n    while (left < right) {\n        if (height[left] < height[right]) {\n            // move left\n            if (height[left] >= maxLeft) {\n                maxLeft = height[left];\n            } else {\n                ans += (maxLeft - height[left]);\n            }\n            ++left;\n        } else {\n            // move right\n            if (height[right] >= maxRight) {\n                maxRight = height[right];\n            } else {\n                ans += (maxRight - height[right]);\n            }\n            --right;\n        }\n    }\n    return ans;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        if (n < 3) {\n            return 0;\n        }\n\n        vector<int> lmx(n, height[0]);\n        vector<int> rmx(n, height[n - 1]);\n        for (int i = 1; i < n; ++i) {\n            lmx[i] = max(lmx[i - 1], height[i]);\n            rmx[n - 1 - i] = max(rmx[n - i], height[n - 1 - i]);\n        }\n        \n        int res = 0;\n        for (int i = 0; i < n; ++i) {\n            res += min(lmx[i], rmx[i]) - height[i];\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Go\n\nfunc trap(height []int) int {\n\tn := len(height)\n\tif n < 3 {\n\t\treturn 0\n\t}\n\n\tlmx, rmx := make([]int, n), make([]int, n)\n\tlmx[0], rmx[n-1] = height[0], height[n-1]\n\tfor i := 1; i < n; i++ {\n\t\tlmx[i] = max(lmx[i-1], height[i])\n\t\trmx[n-1-i] = max(rmx[n-i], height[n-1-i])\n\t}\n\n\tres := 0\n\tfor i := 0; i < n; i++ {\n\t\tres += min(lmx[i], rmx[i]) - height[i]\n\t}\n\treturn res\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 42. 接雨水\n\nenglish version\n\n\n# 题目描述\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n \n\n示例 1：\n\n\n\n\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n\n示例 2：\n\n\n输入：height = [4,2,0,3,2,5]\n输出：9\n\n\n \n\n提示：\n\n * n == height.length\n * 0 <= n <= 3 * 104\n * 0 <= height[i] <= 105\n\n\n# 解法\n\n动态规划法。\n\n对于下标 i，水能达到的最大高度等于下标 i 左右两侧的最大高度的最小值，再减去 height[i] 就能得到当前柱子所能存的水量。\n\n同面试题 17.21. 直方图的水量\n\n\n# python3\n\nclass solution:\n    def trap(self, height: list[int]) -> int:\n        n = len(height)\n        if n < 3:\n            return 0\n\n        lmx, rmx = [height[0]] * n, [height[n - 1]] * n\n        for i in range(1, n):\n            lmx[i] = max(lmx[i - 1], height[i])\n            rmx[n - 1 - i] = max(rmx[n - i], height[n - 1 - i])\n        \n        res = 0\n        for i in range(n):\n            res += min(lmx[i], rmx[i]) - height[i]\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java\n\nclass solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        if (n < 3) {\n            return 0;\n        }\n\n        int[] lmx = new int[n];\n        int[] rmx = new int[n];\n        lmx[0] = height[0];\n        rmx[n - 1] = height[n - 1];\n        for (int i = 1; i < n; ++i) {\n            lmx[i] = math.max(lmx[i - 1], height[i]);\n            rmx[n - 1 - i] = math.max(rmx[n - i], height[n - i - 1]);\n        }\n        \n        int res = 0;\n        for (int i = 0; i < n; ++i) {\n            res += math.min(lmx[i], rmx[i]) - height[i];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# typescript\n\nfunction trap(height: number[]): number {\n    let ans = 0;\n    let left = 0, right = height.length - 1;\n    let maxleft = 0, maxright = 0;\n    while (left < right) {\n        if (height[left] < height[right]) {\n            // move left\n            if (height[left] >= maxleft) {\n                maxleft = height[left];\n            } else {\n                ans += (maxleft - height[left]);\n            }\n            ++left;\n        } else {\n            // move right\n            if (height[right] >= maxright) {\n                maxright = height[right];\n            } else {\n                ans += (maxright - height[right]);\n            }\n            --right;\n        }\n    }\n    return ans;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# c++\n\nclass solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        if (n < 3) {\n            return 0;\n        }\n\n        vector<int> lmx(n, height[0]);\n        vector<int> rmx(n, height[n - 1]);\n        for (int i = 1; i < n; ++i) {\n            lmx[i] = max(lmx[i - 1], height[i]);\n            rmx[n - 1 - i] = max(rmx[n - i], height[n - 1 - i]);\n        }\n        \n        int res = 0;\n        for (int i = 0; i < n; ++i) {\n            res += min(lmx[i], rmx[i]) - height[i];\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# go\n\nfunc trap(height []int) int {\n\tn := len(height)\n\tif n < 3 {\n\t\treturn 0\n\t}\n\n\tlmx, rmx := make([]int, n), make([]int, n)\n\tlmx[0], rmx[n-1] = height[0], height[n-1]\n\tfor i := 1; i < n; i++ {\n\t\tlmx[i] = max(lmx[i-1], height[i])\n\t\trmx[n-1-i] = max(rmx[n-i], height[n-1-i])\n\t}\n\n\tres := 0\n\tfor i := 0; i < n; i++ {\n\t\tres += min(lmx[i], rmx[i]) - height[i]\n\t}\n\treturn res\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode43 Multiply Strings-zh",frontmatter:{title:"leetcode43 Multiply Strings-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b5dd5b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode43 Multiply Strings-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10043.leetcode43%20Multiply%20Strings-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode43 Multiply Strings-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10043.leetcode43%20Multiply%20Strings-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode43 Multiply Strings-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10043.leetcode43%20Multiply%20Strings-zh.html",relativePath:"01.算法/24.leetcode/10043.leetcode43 Multiply Strings-zh.md",key:"v-3b8af4e5",path:"/p/b5dd5b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:345},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:352},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:371},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:387}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 43. 字符串相乘\n\nEnglish Version\n\n\n# 题目描述\n\n给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n\n示例 1:\n\n输入: num1 = "2", num2 = "3"\n输出: "6"\n\n示例 2:\n\n输入: num1 = "123", num2 = "456"\n输出: "56088"\n\n说明：\n\n 1. num1 和 num2 的长度小于110。\n 2. num1 和 num2 只包含数字 0-9。\n 3. num1 和 num2 均不以零开头，除非是数字 0 本身。\n 4. 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 43. 字符串相乘\n\nenglish version\n\n\n# 题目描述\n\n给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n\n示例 1:\n\n输入: num1 = "2", num2 = "3"\n输出: "6"\n\n示例 2:\n\n输入: num1 = "123", num2 = "456"\n输出: "56088"\n\n说明：\n\n 1. num1 和 num2 的长度小于110。\n 2. num1 和 num2 只包含数字 0-9。\n 3. num1 和 num2 均不以零开头，除非是数字 0 本身。\n 4. 不能使用任何标准库的大数类型（比如 biginteger）或直接将输入转换为整数来处理。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode44 Wildcard Matching-zh",frontmatter:{title:"leetcode44 Wildcard Matching-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/6a9e78/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode44 Wildcard Matching-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10044.leetcode44%20Wildcard%20Matching-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode44 Wildcard Matching-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10044.leetcode44%20Wildcard%20Matching-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode44 Wildcard Matching-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10044.leetcode44%20Wildcard%20Matching-zh.html",relativePath:"01.算法/24.leetcode/10044.leetcode44 Wildcard Matching-zh.md",key:"v-69cddf07",path:"/p/6a9e78/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:559},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:566},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:585},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:601}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 44. 通配符匹配\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 \'?\' 和 \'*\' 的通配符匹配。\n\n\'?\' 可以匹配任何单个字符。\n\'*\' 可以匹配任意字符串（包括空字符串）。\n\n\n两个字符串完全匹配才算匹配成功。\n\n说明:\n\n * s 可能为空，且只包含从 a-z 的小写字母。\n * p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。\n\n示例 1:\n\n输入:\ns = "aa"\np = "a"\n输出: false\n解释: "a" 无法匹配 "aa" 整个字符串。\n\n示例 2:\n\n输入:\ns = "aa"\np = "*"\n输出: true\n解释: \'*\' 可以匹配任意字符串。\n\n\n示例 3:\n\n输入:\ns = "cb"\np = "?a"\n输出: false\n解释: \'?\' 可以匹配 \'c\', 但第二个 \'a\' 无法匹配 \'b\'。\n\n\n示例 4:\n\n输入:\ns = "adceb"\np = "*a*b"\n输出: true\n解释: 第一个 \'*\' 可以匹配空字符串, 第二个 \'*\' 可以匹配字符串 "dce".\n\n\n示例 5:\n\n输入:\ns = "acdcb"\np = "a*c?b"\n输出: false\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 44. 通配符匹配\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 \'?\' 和 \'*\' 的通配符匹配。\n\n\'?\' 可以匹配任何单个字符。\n\'*\' 可以匹配任意字符串（包括空字符串）。\n\n\n两个字符串完全匹配才算匹配成功。\n\n说明:\n\n * s 可能为空，且只包含从 a-z 的小写字母。\n * p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。\n\n示例 1:\n\n输入:\ns = "aa"\np = "a"\n输出: false\n解释: "a" 无法匹配 "aa" 整个字符串。\n\n示例 2:\n\n输入:\ns = "aa"\np = "*"\n输出: true\n解释: \'*\' 可以匹配任意字符串。\n\n\n示例 3:\n\n输入:\ns = "cb"\np = "?a"\n输出: false\n解释: \'?\' 可以匹配 \'c\', 但第二个 \'a\' 无法匹配 \'b\'。\n\n\n示例 4:\n\n输入:\ns = "adceb"\np = "*a*b"\n输出: true\n解释: 第一个 \'*\' 可以匹配空字符串, 第二个 \'*\' 可以匹配字符串 "dce".\n\n\n示例 5:\n\n输入:\ns = "acdcb"\np = "a*c?b"\n输出: false\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode45 Jump Game II-zh",frontmatter:{title:"leetcode45 Jump Game II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fce74b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode45 Jump Game II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10045.leetcode45%20Jump%20Game%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode45 Jump Game II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10045.leetcode45%20Jump%20Game%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode45 Jump Game II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10045.leetcode45%20Jump%20Game%20II-zh.html",relativePath:"01.算法/24.leetcode/10045.leetcode45 Jump Game II-zh.md",key:"v-23a69c14",path:"/p/fce74b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:254},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:266},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:565},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:958},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1327},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:1626},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2050}],headersStr:"题目描述 解法 Python3 Java C++ Go C# ...",content:"# 45. 跳跃游戏 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n\n示例:\n\n输入: [2,3,1,1,4]\n输出: 2\n解释: 跳到最后一个位置的最小跳跃数是 2。\n     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n\n\n说明:\n\n假设你总是可以到达数组的最后一个位置。\n\n\n# 解法\n\n贪心。\n\n\n# Python3\n\nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        end = mx = steps = 0\n        for i, num in enumerate(nums[:-1]):\n            mx = max(mx, i + num)\n            if i == end:\n                end = mx\n                steps += 1\n        return steps\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Java\n\nclass Solution {\n    public int jump(int[] nums) {\n        int end = 0;\n        int mx = 0;\n        int steps = 0;\n        for (int i = 0; i < nums.length - 1; ++i) {\n            mx = Math.max(mx, i + nums[i]);\n            if (i == end) {\n                end = mx;\n                ++steps;\n            }\n        }\n        return steps;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int mx = 0, steps = 0, end = 0;\n        for (int i = 0; i < nums.size() - 1; ++i) {\n            mx = max(mx, i + nums[i]);\n            if (i == end) {\n                end = mx;\n                ++steps;\n            }\n        }\n        return steps;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Go\n\nfunc jump(nums []int) int {\n\tmx, steps, end := 0, 0, 0\n\tfor i := 0; i < len(nums)-1; i++ {\n\t\tmx = max(mx, i+nums[i])\n\t\tif i == end {\n\t\t\tend = mx\n\t\t\tsteps++\n\t\t}\n\t}\n\treturn steps\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# C#\n\npublic class Solution {\n    public int Jump(int[] nums) {\n        int end = 0;\n        int mx = 0;\n        int steps = 0;\n        for (int i = 0; i < nums.Length - 1; ++i)\n        {\n            mx = Math.Max(mx, i + nums[i]);\n            if (i == end)\n            {\n                end = mx;\n                ++steps;\n            }\n        }\n        return steps;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 45. 跳跃游戏 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n\n示例:\n\n输入: [2,3,1,1,4]\n输出: 2\n解释: 跳到最后一个位置的最小跳跃数是 2。\n     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n\n\n说明:\n\n假设你总是可以到达数组的最后一个位置。\n\n\n# 解法\n\n贪心。\n\n\n# python3\n\nclass solution:\n    def jump(self, nums: list[int]) -> int:\n        end = mx = steps = 0\n        for i, num in enumerate(nums[:-1]):\n            mx = max(mx, i + num)\n            if i == end:\n                end = mx\n                steps += 1\n        return steps\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# java\n\nclass solution {\n    public int jump(int[] nums) {\n        int end = 0;\n        int mx = 0;\n        int steps = 0;\n        for (int i = 0; i < nums.length - 1; ++i) {\n            mx = math.max(mx, i + nums[i]);\n            if (i == end) {\n                end = mx;\n                ++steps;\n            }\n        }\n        return steps;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# c++\n\nclass solution {\npublic:\n    int jump(vector<int>& nums) {\n        int mx = 0, steps = 0, end = 0;\n        for (int i = 0; i < nums.size() - 1; ++i) {\n            mx = max(mx, i + nums[i]);\n            if (i == end) {\n                end = mx;\n                ++steps;\n            }\n        }\n        return steps;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# go\n\nfunc jump(nums []int) int {\n\tmx, steps, end := 0, 0, 0\n\tfor i := 0; i < len(nums)-1; i++ {\n\t\tmx = max(mx, i+nums[i])\n\t\tif i == end {\n\t\t\tend = mx\n\t\t\tsteps++\n\t\t}\n\t}\n\treturn steps\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# c#\n\npublic class solution {\n    public int jump(int[] nums) {\n        int end = 0;\n        int mx = 0;\n        int steps = 0;\n        for (int i = 0; i < nums.length - 1; ++i)\n        {\n            mx = math.max(mx, i + nums[i]);\n            if (i == end)\n            {\n                end = mx;\n                ++steps;\n            }\n        }\n        return steps;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode46 Permutations-zh",frontmatter:{title:"leetcode46 Permutations-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/64e1ed/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode46 Permutations-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10046.leetcode46%20Permutations-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode46 Permutations-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10046.leetcode46%20Permutations-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode46 Permutations-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10046.leetcode46%20Permutations-zh.html",relativePath:"01.算法/24.leetcode/10046.leetcode46 Permutations-zh.md",key:"v-34822816",path:"/p/64e1ed/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:31},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:161},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:168},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1200},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2955},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3702}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 46. 全排列\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n\n示例:\n\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n\n# 解法\n\n\n# Python3\n\n回溯法：\n\nclass Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        def dfs(nums, i, res, path, used):\n            if i == len(nums):\n                res.append(copy.deepcopy(path))\n                return\n            for j in range(len(nums)):\n                if not used[j]:\n                    path.append(nums[j])\n                    used[j] = True\n                    dfs(nums, i + 1, res, path, used)\n                    used[j] = False\n                    path.pop()\n\n        res, path = [], []\n        used = [False] * len(nums)\n        dfs(nums, 0, res, path, used)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n切分数组：\n\nclass Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        if len(nums) <= 1:\n            return [nums]\n        res = []\n        for i, num in enumerate(nums):\n            n = nums[:i] + nums[i + 1:]\n            for item in self.permute(n):\n                res.append([num] + item)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Java\n\n回溯法：\n\nclass Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> path = new ArrayList<>();\n        boolean[] used = new boolean[nums.length];\n        dfs(nums, 0, res, path, used);\n        return res;\n    }\n\n    private void dfs(int[] nums, int i, List<List<Integer>> res, List<Integer> path, boolean[] used) {\n        if (i == nums.length) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int j = 0; j < nums.length; ++j) {\n            if (!used[j]) {\n                path.add(nums[j]);\n                used[j] = true;\n                dfs(nums, i + 1, res, path, used);\n                used[j] = false;\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 递归：\n\nclass Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        permute(res, nums, 0);\n        return res;\n    }\n\n    private void permute(List<List<Integer>> res, int[] nums, int start) {\n        if (start == nums.length) {\n            List<Integer> t = new ArrayList<>();\n            for (int e : nums) {\n                t.add(e);\n            }\n            res.add(t);\n            return;\n        }\n        for (int i = start; i < nums.length; ++i) {\n            swap(nums, i, start);\n            permute(res, nums, start + 1);\n            swap(nums, i, start);\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int t = nums[i];\n        nums[i] = nums[j];\n        nums[j] = t;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n    let res = [];\n    let solution = [];\n    let record = new Array(nums.length).fill(false);\n    dfs(nums, 0, record, solution, res);\n    return res;\n};\n\nfunction dfs (nums, depth, record, solution, res) {\n    if (depth == nums.length) {\n        res.push(solution.slice());\n        return;\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (!record[i]) {\n            solution.push(nums[i]);\n            record[i] = true;\n            dfs(nums, depth + 1, record, solution, res);\n            solution.pop();\n            record[i] = false;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 46. 全排列\n\nenglish version\n\n\n# 题目描述\n\n给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n\n示例:\n\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n\n# 解法\n\n\n# python3\n\n回溯法：\n\nclass solution:\n    def permute(self, nums: list[int]) -> list[list[int]]:\n        def dfs(nums, i, res, path, used):\n            if i == len(nums):\n                res.append(copy.deepcopy(path))\n                return\n            for j in range(len(nums)):\n                if not used[j]:\n                    path.append(nums[j])\n                    used[j] = true\n                    dfs(nums, i + 1, res, path, used)\n                    used[j] = false\n                    path.pop()\n\n        res, path = [], []\n        used = [false] * len(nums)\n        dfs(nums, 0, res, path, used)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n切分数组：\n\nclass solution:\n    def permute(self, nums: list[int]) -> list[list[int]]:\n        if len(nums) <= 1:\n            return [nums]\n        res = []\n        for i, num in enumerate(nums):\n            n = nums[:i] + nums[i + 1:]\n            for item in self.permute(n):\n                res.append([num] + item)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# java\n\n回溯法：\n\nclass solution {\n    public list<list<integer>> permute(int[] nums) {\n        list<list<integer>> res = new arraylist<>();\n        list<integer> path = new arraylist<>();\n        boolean[] used = new boolean[nums.length];\n        dfs(nums, 0, res, path, used);\n        return res;\n    }\n\n    private void dfs(int[] nums, int i, list<list<integer>> res, list<integer> path, boolean[] used) {\n        if (i == nums.length) {\n            res.add(new arraylist<>(path));\n            return;\n        }\n        for (int j = 0; j < nums.length; ++j) {\n            if (!used[j]) {\n                path.add(nums[j]);\n                used[j] = true;\n                dfs(nums, i + 1, res, path, used);\n                used[j] = false;\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 递归：\n\nclass solution {\n    public list<list<integer>> permute(int[] nums) {\n        list<list<integer>> res = new arraylist<>();\n        permute(res, nums, 0);\n        return res;\n    }\n\n    private void permute(list<list<integer>> res, int[] nums, int start) {\n        if (start == nums.length) {\n            list<integer> t = new arraylist<>();\n            for (int e : nums) {\n                t.add(e);\n            }\n            res.add(t);\n            return;\n        }\n        for (int i = start; i < nums.length; ++i) {\n            swap(nums, i, start);\n            permute(res, nums, start + 1);\n            swap(nums, i, start);\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int t = nums[i];\n        nums[i] = nums[j];\n        nums[j] = t;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n    let res = [];\n    let solution = [];\n    let record = new array(nums.length).fill(false);\n    dfs(nums, 0, record, solution, res);\n    return res;\n};\n\nfunction dfs (nums, depth, record, solution, res) {\n    if (depth == nums.length) {\n        res.push(solution.slice());\n        return;\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (!record[i]) {\n            solution.push(nums[i]);\n            record[i] = true;\n            dfs(nums, depth + 1, record, solution, res);\n            solution.pop();\n            record[i] = false;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode47 Permutations II-zh",frontmatter:{title:"leetcode47 Permutations II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/8e858c/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode47 Permutations II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10047.leetcode47%20Permutations%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode47 Permutations II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10047.leetcode47%20Permutations%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode47 Permutations II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10047.leetcode47%20Permutations%20II-zh.html",relativePath:"01.算法/24.leetcode/10047.leetcode47 Permutations II-zh.md",key:"v-14075572",path:"/p/8e858c/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:288},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:295},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:314},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:330}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 47. 全排列 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n\n \n\n示例 1：\n\n\n输入：nums = [1,1,2]\n输出：\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\n示例 2：\n\n\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 47. 全排列 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n\n \n\n示例 1：\n\n\n输入：nums = [1,1,2]\n输出：\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\n示例 2：\n\n\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode48 Rotate Image-zh",frontmatter:{title:"leetcode48 Rotate Image-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/deb8c7/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0048.Rotate%20Image/images/mat1.jpg"},{name:"twitter:title",content:"leetcode48 Rotate Image-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0048.Rotate%20Image/images/mat1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10048.leetcode48%20Rotate%20Image-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode48 Rotate Image-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0048.Rotate%20Image/images/mat1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10048.leetcode48%20Rotate%20Image-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode48 Rotate Image-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0048.Rotate%20Image/images/mat1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10048.leetcode48%20Rotate%20Image-zh.html",relativePath:"01.算法/24.leetcode/10048.leetcode48 Rotate Image-zh.md",key:"v-3f1c5b45",path:"/p/deb8c7/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:539},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:546},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1124},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1664}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 48. 旋转图像\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[[7,4,1],[8,5,2],[9,6,3]]\n\n\n示例 2：\n\n\n输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n示例 3：\n\n\n输入：matrix = [[1]]\n输出：[[1]]\n\n\n示例 4：\n\n\n输入：matrix = [[1,2],[3,4]]\n输出：[[3,1],[4,2]]\n\n\n \n\n提示：\n\n * matrix.length == n\n * matrix[i].length == n\n * 1 <= n <= 20\n * -1000 <= matrix[i][j] <= 1000\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        """\n        Do not return anything, modify matrix in-place instead.\n        """\n        s, n = 0, len(matrix)\n        while s < (n >> 1):\n            e = n - s - 1\n            for i in range(s, e):\n                t = matrix[i][e]\n                matrix[i][e] = matrix[s][i]\n                matrix[s][i] = matrix[n - i - 1][s]\n                matrix[n - i - 1][s] = matrix[e][n - i - 1]\n                matrix[e][n - i - 1] = t\n            s += 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java\n\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int s = 0, n = matrix.length;\n        while (s < (n >> 1)) {\n            int e = n - s - 1;\n            for (int i = s; i < e; ++i) {\n                int t = matrix[i][e];\n                matrix[i][e] = matrix[s][i];\n                matrix[s][i] = matrix[n - i - 1][s];\n                matrix[n - i - 1][s] = matrix[e][n - i - 1];\n                matrix[e][n - i - 1] = t;\n            }\n            ++s;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 48. 旋转图像\n\nenglish version\n\n\n# 题目描述\n\n给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[[7,4,1],[8,5,2],[9,6,3]]\n\n\n示例 2：\n\n\n输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n示例 3：\n\n\n输入：matrix = [[1]]\n输出：[[1]]\n\n\n示例 4：\n\n\n输入：matrix = [[1,2],[3,4]]\n输出：[[3,1],[4,2]]\n\n\n \n\n提示：\n\n * matrix.length == n\n * matrix[i].length == n\n * 1 <= n <= 20\n * -1000 <= matrix[i][j] <= 1000\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def rotate(self, matrix: list[list[int]]) -> none:\n        """\n        do not return anything, modify matrix in-place instead.\n        """\n        s, n = 0, len(matrix)\n        while s < (n >> 1):\n            e = n - s - 1\n            for i in range(s, e):\n                t = matrix[i][e]\n                matrix[i][e] = matrix[s][i]\n                matrix[s][i] = matrix[n - i - 1][s]\n                matrix[n - i - 1][s] = matrix[e][n - i - 1]\n                matrix[e][n - i - 1] = t\n            s += 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java\n\nclass solution {\n    public void rotate(int[][] matrix) {\n        int s = 0, n = matrix.length;\n        while (s < (n >> 1)) {\n            int e = n - s - 1;\n            for (int i = s; i < e; ++i) {\n                int t = matrix[i][e];\n                matrix[i][e] = matrix[s][i];\n                matrix[s][i] = matrix[n - i - 1][s];\n                matrix[n - i - 1][s] = matrix[e][n - i - 1];\n                matrix[e][n - i - 1] = t;\n            }\n            ++s;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode49 Group Anagrams-zh",frontmatter:{title:"leetcode49 Group Anagrams-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/15206f/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode49 Group Anagrams-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10049.leetcode49%20Group%20Anagrams-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode49 Group Anagrams-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10049.leetcode49%20Group%20Anagrams-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode49 Group Anagrams-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10049.leetcode49%20Group%20Anagrams-zh.html",relativePath:"01.算法/24.leetcode/10049.leetcode49 Group Anagrams-zh.md",key:"v-3d9e1e51",path:"/p/15206f/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:236},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:243},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:262},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:278}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 49. 字母异位词分组\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n示例:\n\n输入: ["eat", "tea", "tan", "ate", "nat", "bat"]\n输出:\n[\n  ["ate","eat","tea"],\n  ["nat","tan"],\n  ["bat"]\n]\n\n说明：\n\n * 所有输入均为小写字母。\n * 不考虑答案输出的顺序。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 49. 字母异位词分组\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n示例:\n\n输入: ["eat", "tea", "tan", "ate", "nat", "bat"]\n输出:\n[\n  ["ate","eat","tea"],\n  ["nat","tan"],\n  ["bat"]\n]\n\n说明：\n\n * 所有输入均为小写字母。\n * 不考虑答案输出的顺序。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode50 Pow(x, n)-zh",frontmatter:{title:"leetcode50 Pow(x, n)-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/f37caf/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode50 Pow(x, n)-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10050.leetcode50%20Pow(x,%20n)-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode50 Pow(x, n)-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10050.leetcode50%20Pow(x,%20n)-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode50 Pow(x, n)-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10050.leetcode50%20Pow(x,%20n)-zh.html",relativePath:"01.算法/24.leetcode/10050.leetcode50 Pow(x, n)-zh.md",key:"v-63be4647",path:"/p/f37caf/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:321},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:328},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:609},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:986},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1314}],headersStr:"题目描述 解法 Python3 Java TypeScript ...",content:"# 50. Pow(x, n)\n\nEnglish Version\n\n\n# 题目描述\n\n实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。\n\n \n\n示例 1：\n\n\n输入：x = 2.00000, n = 10\n输出：1024.00000\n\n\n示例 2：\n\n\n输入：x = 2.10000, n = 3\n输出：9.26100\n\n\n示例 3：\n\n\n输入：x = 2.00000, n = -2\n输出：0.25000\n解释：2-2 = 1/22 = 1/4 = 0.25\n\n\n \n\n提示：\n\n * -100.0 < x < 100.0\n * -231 <= n <= 231-1\n * -104 <= xn <= 104\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if n < 0:\n            return 1 / self.myPow(x, -n)\n        y = self.myPow(x, n >> 1)\n        return y * y if (n & 1) == 0 else y * y * x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Java\n\nclass Solution {\n    public double myPow(double x, int n) {\n        long N = n;\n        return N >= 0 ? pow(x, N) : 1.0 / pow(x, -N);\n    }\n\n    public double pow(double x, long N) {\n        if (N == 0) {\n            return 1.0;\n        }\n        double y = pow(x, N >> 1);\n        return (N & 1) == 0 ? y * y : y * y * x;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# TypeScript\n\nfunction myPow(x: number, n: number): number {\n    let res = 1;\n    if (n < 0) {\n        n = -n;\n        x = 1 / x;\n    }\n    for (let i = n; i != 0; i = Math.floor(i / 2)) {\n        if ((i & 1) == 1) {\n            res *= x;\n        }\n        x *= x;\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 50. pow(x, n)\n\nenglish version\n\n\n# 题目描述\n\n实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。\n\n \n\n示例 1：\n\n\n输入：x = 2.00000, n = 10\n输出：1024.00000\n\n\n示例 2：\n\n\n输入：x = 2.10000, n = 3\n输出：9.26100\n\n\n示例 3：\n\n\n输入：x = 2.00000, n = -2\n输出：0.25000\n解释：2-2 = 1/22 = 1/4 = 0.25\n\n\n \n\n提示：\n\n * -100.0 < x < 100.0\n * -231 <= n <= 231-1\n * -104 <= xn <= 104\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def mypow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if n < 0:\n            return 1 / self.mypow(x, -n)\n        y = self.mypow(x, n >> 1)\n        return y * y if (n & 1) == 0 else y * y * x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# java\n\nclass solution {\n    public double mypow(double x, int n) {\n        long n = n;\n        return n >= 0 ? pow(x, n) : 1.0 / pow(x, -n);\n    }\n\n    public double pow(double x, long n) {\n        if (n == 0) {\n            return 1.0;\n        }\n        double y = pow(x, n >> 1);\n        return (n & 1) == 0 ? y * y : y * y * x;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# typescript\n\nfunction mypow(x: number, n: number): number {\n    let res = 1;\n    if (n < 0) {\n        n = -n;\n        x = 1 / x;\n    }\n    for (let i = n; i != 0; i = math.floor(i / 2)) {\n        if ((i & 1) == 1) {\n            res *= x;\n        }\n        x *= x;\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode51 N-Queens-zh",frontmatter:{title:"leetcode51 N-Queens-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/890db5/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0051.N-Queens/images/queens.jpg"},{name:"twitter:title",content:"leetcode51 N-Queens-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0051.N-Queens/images/queens.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10051.leetcode51%20N-Queens-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode51 N-Queens-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0051.N-Queens/images/queens.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10051.leetcode51%20N-Queens-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode51 N-Queens-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0051.N-Queens/images/queens.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10051.leetcode51%20N-Queens-zh.html",relativePath:"01.算法/24.leetcode/10051.leetcode51 N-Queens-zh.md",key:"v-d6e0aee8",path:"/p/890db5/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:125},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:399},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:418},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:211}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 51. N 皇后\n\nEnglish Version\n\n\n# 题目描述\n\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 \'Q\' 和 \'.\' 分别代表了皇后和空位。\n\n \n\n示例 1：\n\n\n输入：n = 4\n输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]\n解释：如上图所示，4 皇后问题存在两个不同的解法。\n\n\n示例 2：\n\n\n输入：n = 1\n输出：[["Q"]]\n\n\n \n\n提示：\n\n * 1 <= n <= 9\n * 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 51. n 皇后\n\nenglish version\n\n\n# 题目描述\n\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 \'q\' 和 \'.\' 分别代表了皇后和空位。\n\n \n\n示例 1：\n\n\n输入：n = 4\n输出：[[".q..","...q","q...","..q."],["..q.","q...","...q",".q.."]]\n解释：如上图所示，4 皇后问题存在两个不同的解法。\n\n\n示例 2：\n\n\n输入：n = 1\n输出：[["q"]]\n\n\n \n\n提示：\n\n * 1 <= n <= 9\n * 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode52 N-Queens II-zh",frontmatter:{title:"leetcode52 N-Queens II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/06718e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0052.N-Queens%20II/images/queens.jpg"},{name:"twitter:title",content:"leetcode52 N-Queens II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0052.N-Queens%20II/images/queens.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10052.leetcode52%20N-Queens%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode52 N-Queens II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0052.N-Queens%20II/images/queens.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10052.leetcode52%20N-Queens%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode52 N-Queens II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0052.N-Queens%20II/images/queens.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10052.leetcode52%20N-Queens%20II-zh.html",relativePath:"01.算法/24.leetcode/10052.leetcode52 N-Queens II-zh.md",key:"v-42571427",path:"/p/06718e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:171},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:279},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:298},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:314}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 52. N皇后 II\n\nEnglish Version\n\n\n# 题目描述\n\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。\n\n \n\n示例 1：\n\n\n输入：n = 4\n输出：2\n解释：如上图所示，4 皇后问题存在两个不同的解法。\n\n\n示例 2：\n\n\n输入：n = 1\n输出：1\n\n\n \n\n提示：\n\n * 1 <= n <= 9\n * 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 52. n皇后 ii\n\nenglish version\n\n\n# 题目描述\n\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。\n\n \n\n示例 1：\n\n\n输入：n = 4\n输出：2\n解释：如上图所示，4 皇后问题存在两个不同的解法。\n\n\n示例 2：\n\n\n输入：n = 1\n输出：1\n\n\n \n\n提示：\n\n * 1 <= n <= 9\n * 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode53 Maximum Subarray-zh",frontmatter:{title:"leetcode53 Maximum Subarray-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/827961/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode53 Maximum Subarray-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10053.leetcode53%20Maximum%20Subarray-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode53 Maximum Subarray-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10053.leetcode53%20Maximum%20Subarray-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode53 Maximum Subarray-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10053.leetcode53%20Maximum%20Subarray-zh.html",relativePath:"01.算法/24.leetcode/10053.leetcode53 Maximum Subarray-zh.md",key:"v-c57e491e",path:"/p/827961/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:395},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:555},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:788},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1091},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1388},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1690},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:2006},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2318}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go C# ...",content:"# 53. 最大子序和\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n \n\n示例 1：\n\n\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n\n示例 2：\n\n\n输入：nums = [1]\n输出：1\n\n\n示例 3：\n\n\n输入：nums = [0]\n输出：0\n\n\n示例 4：\n\n\n输入：nums = [-1]\n输出：-1\n\n\n示例 5：\n\n\n输入：nums = [-100000]\n输出：-100000\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 3 * 104\n * -105 <= nums[i] <= 105\n\n \n\n进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\n\n\n# 解法\n\n设 dp[i] 表示 [0..i] 中，以 nums[i] 结尾的最大子数组和，状态转移方程 dp[i] = nums[i] + max(dp[i - 1], 0)。\n\n由于 dp[i] 只与子问题 dp[i-1] 有关，故可以用一个变量 f 来表示。\n\n\n# Python3\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        res = f = nums[0]\n        for num in nums[1:]:\n            f = num + max(f, 0)\n            res = max(res, f)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Java\n\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int f = nums[0], res = nums[0];\n        for (int i = 1, n = nums.length; i < n; ++i) {\n            f = nums[i] + Math.max(f, 0);\n            res = Math.max(res, f);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int f = nums[0], res = nums[0];\n        for (int i = 1; i < nums.size(); ++i) {\n            f = nums[i] + max(f, 0);\n            res = max(res, f);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function (nums) {\n  let f = nums[0],\n    res = nums[0];\n  for (let i = 1; i < nums.length; ++i) {\n    f = nums[i] + Math.max(f, 0);\n    res = Math.max(res, f);\n  }\n  return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Go\n\nfunc maxSubArray(nums []int) int {\n    f, res := nums[0], nums[0]\n    for i := 1; i < len(nums); i++ {\n        if f > 0 {\n            f += nums[i]\n        } else {\n            f = nums[i]\n        }\n        if f > res {\n            res = f\n        }\n    }\n    return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# C#\n\npublic class Solution {\n    public int MaxSubArray(int[] nums) {\n        int res = nums[0], f = nums[0];\n        for (int i = 1; i < nums.Length; ++i)\n        {\n            f = nums[i] + Math.Max(f, 0);\n            res = Math.Max(res, f);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 53. 最大子序和\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n \n\n示例 1：\n\n\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n\n示例 2：\n\n\n输入：nums = [1]\n输出：1\n\n\n示例 3：\n\n\n输入：nums = [0]\n输出：0\n\n\n示例 4：\n\n\n输入：nums = [-1]\n输出：-1\n\n\n示例 5：\n\n\n输入：nums = [-100000]\n输出：-100000\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 3 * 104\n * -105 <= nums[i] <= 105\n\n \n\n进阶：如果你已经实现复杂度为 o(n) 的解法，尝试使用更为精妙的 分治法 求解。\n\n\n# 解法\n\n设 dp[i] 表示 [0..i] 中，以 nums[i] 结尾的最大子数组和，状态转移方程 dp[i] = nums[i] + max(dp[i - 1], 0)。\n\n由于 dp[i] 只与子问题 dp[i-1] 有关，故可以用一个变量 f 来表示。\n\n\n# python3\n\nclass solution:\n    def maxsubarray(self, nums: list[int]) -> int:\n        res = f = nums[0]\n        for num in nums[1:]:\n            f = num + max(f, 0)\n            res = max(res, f)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# java\n\nclass solution {\n    public int maxsubarray(int[] nums) {\n        int f = nums[0], res = nums[0];\n        for (int i = 1, n = nums.length; i < n; ++i) {\n            f = nums[i] + math.max(f, 0);\n            res = math.max(res, f);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# c++\n\nclass solution {\npublic:\n    int maxsubarray(vector<int>& nums) {\n        int f = nums[0], res = nums[0];\n        for (int i = 1; i < nums.size(); ++i) {\n            f = nums[i] + max(f, 0);\n            res = max(res, f);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxsubarray = function (nums) {\n  let f = nums[0],\n    res = nums[0];\n  for (let i = 1; i < nums.length; ++i) {\n    f = nums[i] + math.max(f, 0);\n    res = math.max(res, f);\n  }\n  return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# go\n\nfunc maxsubarray(nums []int) int {\n    f, res := nums[0], nums[0]\n    for i := 1; i < len(nums); i++ {\n        if f > 0 {\n            f += nums[i]\n        } else {\n            f = nums[i]\n        }\n        if f > res {\n            res = f\n        }\n    }\n    return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# c#\n\npublic class solution {\n    public int maxsubarray(int[] nums) {\n        int res = nums[0], f = nums[0];\n        for (int i = 1; i < nums.length; ++i)\n        {\n            f = nums[i] + math.max(f, 0);\n            res = math.max(res, f);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode54 Spiral Matrix-zh",frontmatter:{title:"leetcode54 Spiral Matrix-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b4f91b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0054.Spiral%20Matrix/images/spiral1.jpg"},{name:"twitter:title",content:"leetcode54 Spiral Matrix-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0054.Spiral%20Matrix/images/spiral1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10054.leetcode54%20Spiral%20Matrix-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode54 Spiral Matrix-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0054.Spiral%20Matrix/images/spiral1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10054.leetcode54%20Spiral%20Matrix-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode54 Spiral Matrix-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0054.Spiral%20Matrix/images/spiral1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10054.leetcode54%20Spiral%20Matrix-zh.html",relativePath:"01.算法/24.leetcode/10054.leetcode54 Spiral Matrix-zh.md",key:"v-42d939e7",path:"/p/b4f91b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:360},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:389},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1185},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2420},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3366}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 54. 螺旋矩阵\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n\n\n示例 2：\n\n\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n \n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 10\n * -100 <= matrix[i][j] <= 100\n\n\n# 解法\n\n从外往里一圈一圈遍历并存储矩阵元素即可。\n\n\n# Python3\n\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        def add(i1, j1, i2, j2):\n            if i1 == i2:\n                return [matrix[i1][j] for j in range(j1, j2 + 1)]\n            if j1 == j2:\n                return [matrix[i][j1] for i in range(i1, i2 + 1)]\n            return [matrix[i1][j] for j in range(j1, j2)] + [matrix[i][j2] for i in range(i1, i2)] + [matrix[i2][j] for j in range(j2, j1, -1)] + [matrix[i][j1] for i in range(i2, i1, -1)]\n        m, n = len(matrix), len(matrix[0])\n        i1, j1, i2, j2 = 0, 0, m - 1, n - 1\n        res = []\n        while i1 <= i2 and j1 <= j2:\n            res += add(i1, j1, i2, j2)\n            i1, j1, i2, j2 = i1 + 1, j1 + 1, i2 - 1, j2 - 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java\n\nclass Solution {\n    private List<Integer> res;\n\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        res = new ArrayList<>();\n        int i1 = 0, i2 = m - 1;\n        int j1 = 0, j2 = n - 1;\n        while (i1 <= i2 && j1 <= j2) {\n            add(matrix, i1++, j1++, i2--, j2--);\n        }\n        return res;\n    }\n\n    private void add(int[][] matrix, int i1, int j1, int i2, int j2) {\n        if (i1 == i2) {\n            for (int j = j1; j <= j2; ++j) {\n                res.add(matrix[i1][j]);\n            }\n            return;\n        }\n        if (j1 == j2) {\n            for (int i = i1; i <= i2; ++i) {\n                res.add(matrix[i][j1]);\n            }\n            return;\n        }\n        for (int j = j1; j < j2; ++j) {\n            res.add(matrix[i1][j]);\n        }\n        for (int i = i1; i < i2; ++i) {\n            res.add(matrix[i][j2]);\n        }\n        for (int j = j2; j > j1; --j) {\n            res.add(matrix[i2][j]);\n        }\n        for (int i = i2; i > i1; --i) {\n            res.add(matrix[i][j1]);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# JavaScript\n\n/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralOrder = function (matrix) {\n    let m = matrix.length;\n    if (m === 0) return [];\n    let res = [];\n    let top = 0, bottom = m - 1, left = 0, right = matrix[0].length - 1;\n    while (left < right && bottom > top) {\n        for (let i = left; i < right; i++) res.push(matrix[top][i]);\n        for (let i = top; i < bottom; i++) res.push(matrix[i][right]);\n        for (let i = right; i > left; i--) res.push(matrix[bottom][i]);\n        for (let i = bottom; i > top; i--) res.push(matrix[i][left]);\n        top++;\n        bottom--;\n        left++;\n        right--;\n    }\n    if (left === right) {\n        for (i = top; i <= bottom; i++) res.push(matrix[i][left]);\n    } else if (top === bottom) {\n        for (i = left; i <= right; i++) res.push(matrix[top][i]);\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 54. 螺旋矩阵\n\nenglish version\n\n\n# 题目描述\n\n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n\n\n示例 2：\n\n\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n \n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 10\n * -100 <= matrix[i][j] <= 100\n\n\n# 解法\n\n从外往里一圈一圈遍历并存储矩阵元素即可。\n\n\n# python3\n\nclass solution:\n    def spiralorder(self, matrix: list[list[int]]) -> list[int]:\n        def add(i1, j1, i2, j2):\n            if i1 == i2:\n                return [matrix[i1][j] for j in range(j1, j2 + 1)]\n            if j1 == j2:\n                return [matrix[i][j1] for i in range(i1, i2 + 1)]\n            return [matrix[i1][j] for j in range(j1, j2)] + [matrix[i][j2] for i in range(i1, i2)] + [matrix[i2][j] for j in range(j2, j1, -1)] + [matrix[i][j1] for i in range(i2, i1, -1)]\n        m, n = len(matrix), len(matrix[0])\n        i1, j1, i2, j2 = 0, 0, m - 1, n - 1\n        res = []\n        while i1 <= i2 and j1 <= j2:\n            res += add(i1, j1, i2, j2)\n            i1, j1, i2, j2 = i1 + 1, j1 + 1, i2 - 1, j2 - 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java\n\nclass solution {\n    private list<integer> res;\n\n    public list<integer> spiralorder(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        res = new arraylist<>();\n        int i1 = 0, i2 = m - 1;\n        int j1 = 0, j2 = n - 1;\n        while (i1 <= i2 && j1 <= j2) {\n            add(matrix, i1++, j1++, i2--, j2--);\n        }\n        return res;\n    }\n\n    private void add(int[][] matrix, int i1, int j1, int i2, int j2) {\n        if (i1 == i2) {\n            for (int j = j1; j <= j2; ++j) {\n                res.add(matrix[i1][j]);\n            }\n            return;\n        }\n        if (j1 == j2) {\n            for (int i = i1; i <= i2; ++i) {\n                res.add(matrix[i][j1]);\n            }\n            return;\n        }\n        for (int j = j1; j < j2; ++j) {\n            res.add(matrix[i1][j]);\n        }\n        for (int i = i1; i < i2; ++i) {\n            res.add(matrix[i][j2]);\n        }\n        for (int j = j2; j > j1; --j) {\n            res.add(matrix[i2][j]);\n        }\n        for (int i = i2; i > i1; --i) {\n            res.add(matrix[i][j1]);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# javascript\n\n/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralorder = function (matrix) {\n    let m = matrix.length;\n    if (m === 0) return [];\n    let res = [];\n    let top = 0, bottom = m - 1, left = 0, right = matrix[0].length - 1;\n    while (left < right && bottom > top) {\n        for (let i = left; i < right; i++) res.push(matrix[top][i]);\n        for (let i = top; i < bottom; i++) res.push(matrix[i][right]);\n        for (let i = right; i > left; i--) res.push(matrix[bottom][i]);\n        for (let i = bottom; i > top; i--) res.push(matrix[i][left]);\n        top++;\n        bottom--;\n        left++;\n        right--;\n    }\n    if (left === right) {\n        for (i = top; i <= bottom; i++) res.push(matrix[i][left]);\n    } else if (top === bottom) {\n        for (i = left; i <= right; i++) res.push(matrix[top][i]);\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode55 Jump Game-zh",frontmatter:{title:"leetcode55 Jump Game-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/30906e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode55 Jump Game-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10055.leetcode55%20Jump%20Game-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode55 Jump Game-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10055.leetcode55%20Jump%20Game-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode55 Jump Game-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10055.leetcode55%20Jump%20Game-zh.html",relativePath:"01.算法/24.leetcode/10055.leetcode55 Jump Game-zh.md",key:"v-7bfc9367",path:"/p/30906e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:374},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:386},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:642},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:961},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1283},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:1543},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1890}],headersStr:"题目描述 解法 Python3 Java C++ Go C# ...",content:"# 55. 跳跃游戏\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标。\n\n \n\n示例 1：\n\n\n输入：nums = [2,3,1,1,4]\n输出：true\n解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n\n示例 2：\n\n\n输入：nums = [3,2,1,0,4]\n输出：false\n解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 3 * 104\n * 0 <= nums[i] <= 105\n\n\n# 解法\n\n贪心。\n\n\n# Python3\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        mx = 0\n        for i, num in enumerate(nums):\n            if i > mx:\n                return False\n            mx = max(mx, i + num)\n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Java\n\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int mx = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            if (i > mx) {\n                return false;\n            }\n            mx = Math.max(mx, i + nums[i]);\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# C++\n\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int mx = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (i > mx) {\n                return false;\n            }\n            mx = max(mx, i + nums[i]);\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Go\n\nfunc canJump(nums []int) bool {\n\tmx := 0\n\tfor i, num := range nums {\n\t\tif i > mx {\n\t\t\treturn false\n\t\t}\n\t\tmx = max(mx, i+num)\n\t}\n\treturn true\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# C#\n\npublic class Solution {\n    public bool CanJump(int[] nums) {\n        int mx = 0;\n        for (int i = 0; i < nums.Length; ++i)\n        {\n            if (i > mx)\n            {\n                return false;\n            }\n            mx = Math.Max(mx, i + nums[i]);\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 55. 跳跃游戏\n\nenglish version\n\n\n# 题目描述\n\n给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标。\n\n \n\n示例 1：\n\n\n输入：nums = [2,3,1,1,4]\n输出：true\n解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n\n示例 2：\n\n\n输入：nums = [3,2,1,0,4]\n输出：false\n解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 3 * 104\n * 0 <= nums[i] <= 105\n\n\n# 解法\n\n贪心。\n\n\n# python3\n\nclass solution:\n    def canjump(self, nums: list[int]) -> bool:\n        mx = 0\n        for i, num in enumerate(nums):\n            if i > mx:\n                return false\n            mx = max(mx, i + num)\n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# java\n\nclass solution {\n    public boolean canjump(int[] nums) {\n        int mx = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            if (i > mx) {\n                return false;\n            }\n            mx = math.max(mx, i + nums[i]);\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# c++\n\nclass solution {\npublic:\n    bool canjump(vector<int>& nums) {\n        int mx = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (i > mx) {\n                return false;\n            }\n            mx = max(mx, i + nums[i]);\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# go\n\nfunc canjump(nums []int) bool {\n\tmx := 0\n\tfor i, num := range nums {\n\t\tif i > mx {\n\t\t\treturn false\n\t\t}\n\t\tmx = max(mx, i+num)\n\t}\n\treturn true\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# c#\n\npublic class solution {\n    public bool canjump(int[] nums) {\n        int mx = 0;\n        for (int i = 0; i < nums.length; ++i)\n        {\n            if (i > mx)\n            {\n                return false;\n            }\n            mx = math.max(mx, i + nums[i]);\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode56 Merge Intervals-zh",frontmatter:{title:"leetcode56 Merge Intervals-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/f65cda/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode56 Merge Intervals-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10056.leetcode56%20Merge%20Intervals-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode56 Merge Intervals-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10056.leetcode56%20Merge%20Intervals-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode56 Merge Intervals-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10056.leetcode56%20Merge%20Intervals-zh.html",relativePath:"01.算法/24.leetcode/10056.leetcode56 Merge Intervals-zh.md",key:"v-53742b01",path:"/p/f65cda/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:449},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:456},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:475},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:491}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 56. 合并区间\n\nEnglish Version\n\n\n# 题目描述\n\n以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。\n\n \n\n示例 1：\n\n\n输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]]\n解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n\n\n示例 2：\n\n\n输入：intervals = [[1,4],[4,5]]\n输出：[[1,5]]\n解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n\n \n\n提示：\n\n * 1 <= intervals.length <= 104\n * intervals[i].length == 2\n * 0 <= starti <= endi <= 104\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 56. 合并区间\n\nenglish version\n\n\n# 题目描述\n\n以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。\n\n \n\n示例 1：\n\n\n输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]]\n解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n\n\n示例 2：\n\n\n输入：intervals = [[1,4],[4,5]]\n输出：[[1,5]]\n解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n\n \n\n提示：\n\n * 1 <= intervals.length <= 104\n * intervals[i].length == 2\n * 0 <= starti <= endi <= 104\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode57 Insert Interval-zh",frontmatter:{title:"leetcode57 Insert Interval-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/93b3a2/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode57 Insert Interval-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10057.leetcode57%20Insert%20Interval-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode57 Insert Interval-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10057.leetcode57%20Insert%20Interval-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode57 Insert Interval-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10057.leetcode57%20Insert%20Interval-zh.html",relativePath:"01.算法/24.leetcode/10057.leetcode57 Insert Interval-zh.md",key:"v-18e98ab2",path:"/p/93b3a2/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:774},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:781},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:800},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:816}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 57. 插入区间\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个 无重叠的 ，按照区间起始端点排序的区间列表。\n\n在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。\n\n \n\n示例 1：\n\n\n输入：intervals = [[1,3],[6,9]], newInterval = [2,5]\n输出：[[1,5],[6,9]]\n\n\n示例 2：\n\n\n输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n输出：[[1,2],[3,10],[12,16]]\n解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。\n\n示例 3：\n\n\n输入：intervals = [], newInterval = [5,7]\n输出：[[5,7]]\n\n\n示例 4：\n\n\n输入：intervals = [[1,5]], newInterval = [2,3]\n输出：[[1,5]]\n\n\n示例 5：\n\n\n输入：intervals = [[1,5]], newInterval = [2,7]\n输出：[[1,7]]\n\n\n \n\n提示：\n\n * 0 <= intervals.length <= 104\n * intervals[i].length == 2\n * 0 <= intervals[i][0] <= intervals[i][1] <= 105\n * intervals 根据 intervals[i][0] 按 升序 排列\n * newInterval.length == 2\n * 0 <= newInterval[0] <= newInterval[1] <= 105\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 57. 插入区间\n\nenglish version\n\n\n# 题目描述\n\n给你一个 无重叠的 ，按照区间起始端点排序的区间列表。\n\n在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。\n\n \n\n示例 1：\n\n\n输入：intervals = [[1,3],[6,9]], newinterval = [2,5]\n输出：[[1,5],[6,9]]\n\n\n示例 2：\n\n\n输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newinterval = [4,8]\n输出：[[1,2],[3,10],[12,16]]\n解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。\n\n示例 3：\n\n\n输入：intervals = [], newinterval = [5,7]\n输出：[[5,7]]\n\n\n示例 4：\n\n\n输入：intervals = [[1,5]], newinterval = [2,3]\n输出：[[1,5]]\n\n\n示例 5：\n\n\n输入：intervals = [[1,5]], newinterval = [2,7]\n输出：[[1,7]]\n\n\n \n\n提示：\n\n * 0 <= intervals.length <= 104\n * intervals[i].length == 2\n * 0 <= intervals[i][0] <= intervals[i][1] <= 105\n * intervals 根据 intervals[i][0] 按 升序 排列\n * newinterval.length == 2\n * 0 <= newinterval[0] <= newinterval[1] <= 105\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode59 Spiral Matrix II-zh",frontmatter:{title:"leetcode59 Spiral Matrix II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/1f8940/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0059.Spiral%20Matrix%20II/images/spiraln.jpg"},{name:"twitter:title",content:"leetcode59 Spiral Matrix II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0059.Spiral%20Matrix%20II/images/spiraln.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10059.leetcode59%20Spiral%20Matrix%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode59 Spiral Matrix II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0059.Spiral%20Matrix%20II/images/spiraln.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10059.leetcode59%20Spiral%20Matrix%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode59 Spiral Matrix II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0059.Spiral%20Matrix%20II/images/spiraln.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10059.leetcode59%20Spiral%20Matrix%20II-zh.html",relativePath:"01.算法/24.leetcode/10059.leetcode59 Spiral Matrix II-zh.md",key:"v-a7ccf908",path:"/p/1f8940/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:215},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:222},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:972},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1752},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2562}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 59. 螺旋矩阵 II\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n\n \n\n示例 1：\n\n\n输入：n = 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]\n\n\n示例 2：\n\n\n输入：n = 1\n输出：[[1]]\n\n\n \n\n提示：\n\n * 1 <= n <= 20\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        res = [[0] * n for _ in range(n)]\n        num = 1\n        m1, m2 = 0, n - 1\n        while m1 < m2:\n            for j in range(m1, m2):\n                res[m1][j] = num\n                num += 1\n            for i in range(m1, m2):\n                res[i][m2] = num\n                num += 1\n            for j in range(m2, m1, -1):\n                res[m2][j] = num\n                num += 1\n            for i in range(m2, m1, -1):\n                res[i][m1] = num\n                num += 1\n            m1 += 1\n            m2 -= 1\n        if m1 == m2:\n            res[m1][m1] = num\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Java\n\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] res = new int[n][n];\n        int num = 1;\n        int m1 = 0, m2 = n - 1;\n        while (m1 < m2) {\n            for (int j = m1; j < m2; ++j) {\n                res[m1][j] = num++;\n            }\n            for (int i = m1; i < m2; ++i) {\n                res[i][m2] = num++;\n            }\n            for (int j = m2; j > m1; --j) {\n                res[m2][j] = num++;\n            }\n            for (int i = m2; i > m1; --i) {\n                res[i][m1] = num++;\n            }\n            ++m1;\n            --m2;\n        }\n        if (m1 == m2) {\n            res[m1][m1] = num;\n        }\n\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# C++\n\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> res(n, vector<int>(n, 0));\n        int num = 1;\n        int m1 = 0, m2 = n - 1;\n        while (m1 < m2) {\n            for (int j = m1; j < m2; ++j) {\n                res[m1][j] = num++;\n            }\n            for (int i = m1; i < m2; ++i) {\n                res[i][m2] = num++;\n            }\n            for (int j = m2; j > m1; --j) {\n                res[m2][j] = num++;\n            }\n            for (int i = m2; i > m1; --i) {\n                res[i][m1] = num++;\n            }\n            ++m1;\n            --m2;\n        }\n        if (m1 == m2) {\n            res[m1][m1] = num;\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 59. 螺旋矩阵 ii\n\nenglish version\n\n\n# 题目描述\n\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n\n \n\n示例 1：\n\n\n输入：n = 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]\n\n\n示例 2：\n\n\n输入：n = 1\n输出：[[1]]\n\n\n \n\n提示：\n\n * 1 <= n <= 20\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def generatematrix(self, n: int) -> list[list[int]]:\n        res = [[0] * n for _ in range(n)]\n        num = 1\n        m1, m2 = 0, n - 1\n        while m1 < m2:\n            for j in range(m1, m2):\n                res[m1][j] = num\n                num += 1\n            for i in range(m1, m2):\n                res[i][m2] = num\n                num += 1\n            for j in range(m2, m1, -1):\n                res[m2][j] = num\n                num += 1\n            for i in range(m2, m1, -1):\n                res[i][m1] = num\n                num += 1\n            m1 += 1\n            m2 -= 1\n        if m1 == m2:\n            res[m1][m1] = num\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# java\n\nclass solution {\n    public int[][] generatematrix(int n) {\n        int[][] res = new int[n][n];\n        int num = 1;\n        int m1 = 0, m2 = n - 1;\n        while (m1 < m2) {\n            for (int j = m1; j < m2; ++j) {\n                res[m1][j] = num++;\n            }\n            for (int i = m1; i < m2; ++i) {\n                res[i][m2] = num++;\n            }\n            for (int j = m2; j > m1; --j) {\n                res[m2][j] = num++;\n            }\n            for (int i = m2; i > m1; --i) {\n                res[i][m1] = num++;\n            }\n            ++m1;\n            --m2;\n        }\n        if (m1 == m2) {\n            res[m1][m1] = num;\n        }\n\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# c++\n\nclass solution {\npublic:\n    vector<vector<int>> generatematrix(int n) {\n        vector<vector<int>> res(n, vector<int>(n, 0));\n        int num = 1;\n        int m1 = 0, m2 = n - 1;\n        while (m1 < m2) {\n            for (int j = m1; j < m2; ++j) {\n                res[m1][j] = num++;\n            }\n            for (int i = m1; i < m2; ++i) {\n                res[i][m2] = num++;\n            }\n            for (int j = m2; j > m1; --j) {\n                res[m2][j] = num++;\n            }\n            for (int i = m2; i > m1; --i) {\n                res[i][m1] = num++;\n            }\n            ++m1;\n            --m2;\n        }\n        if (m1 == m2) {\n            res[m1][m1] = num;\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode58 Length of Last Word-zh",frontmatter:{title:"leetcode58 Length of Last Word-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/3d955e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode58 Length of Last Word-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10058.leetcode58%20Length%20of%20Last%20Word-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode58 Length of Last Word-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10058.leetcode58%20Length%20of%20Last%20Word-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode58 Length of Last Word-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10058.leetcode58%20Length%20of%20Last%20Word-zh.html",relativePath:"01.算法/24.leetcode/10058.leetcode58 Length of Last Word-zh.md",key:"v-6ae185b2",path:"/p/3d955e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:262},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:269},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:693},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1211}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 58. 最后一个单词的长度\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。\n\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n\n \n\n示例 1：\n\n\n输入：s = \"Hello World\"\n输出：5\n\n\n示例 2：\n\n\n输入：s = \" \"\n输出：0\n\n\n \n\n提示：\n\n * 1 <= s.length <= 104\n * s 仅有英文字母和空格 ' ' 组成\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        last_word_length = 0\n        meet_word = False\n        for i in range(len(s) - 1, -1, -1):\n            ch = ord(s[i])\n            if ch >= 65 and ch <= 122:\n                meet_word = True\n                last_word_length += 1\n            elif meet_word:\n                break\n        return last_word_length\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        int n = s.length();\n        int lastWordLength = 0;\n        boolean meetWord = false;\n        for (int i = n - 1; i >= 0; --i) {\n            char ch = s.charAt(i);\n            if (ch >= 'A' && ch <= 'z') {\n                meetWord = true;\n                ++lastWordLength;\n            } else if (meetWord) {\n                break;\n            }\n        }\n        return lastWordLength;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 58. 最后一个单词的长度\n\nenglish version\n\n\n# 题目描述\n\n给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。\n\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n\n \n\n示例 1：\n\n\n输入：s = \"hello world\"\n输出：5\n\n\n示例 2：\n\n\n输入：s = \" \"\n输出：0\n\n\n \n\n提示：\n\n * 1 <= s.length <= 104\n * s 仅有英文字母和空格 ' ' 组成\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def lengthoflastword(self, s: str) -> int:\n        last_word_length = 0\n        meet_word = false\n        for i in range(len(s) - 1, -1, -1):\n            ch = ord(s[i])\n            if ch >= 65 and ch <= 122:\n                meet_word = true\n                last_word_length += 1\n            elif meet_word:\n                break\n        return last_word_length\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public int lengthoflastword(string s) {\n        int n = s.length();\n        int lastwordlength = 0;\n        boolean meetword = false;\n        for (int i = n - 1; i >= 0; --i) {\n            char ch = s.charat(i);\n            if (ch >= 'a' && ch <= 'z') {\n                meetword = true;\n                ++lastwordlength;\n            } else if (meetword) {\n                break;\n            }\n        }\n        return lastwordlength;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode60 Permutation Sequence-zh",frontmatter:{title:"leetcode60 Permutation Sequence-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a46975/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode60 Permutation Sequence-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10060.leetcode60%20Permutation%20Sequence-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode60 Permutation Sequence-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10060.leetcode60%20Permutation%20Sequence-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode60 Permutation Sequence-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10060.leetcode60%20Permutation%20Sequence-zh.html",relativePath:"01.算法/24.leetcode/10060.leetcode60 Permutation Sequence-zh.md",key:"v-1e7a2316",path:"/p/a46975/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:348},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:355},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:374},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:50}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 60. 排列序列\n\nEnglish Version\n\n\n# 题目描述\n\n给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。\n\n按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：\n\n 1. "123"\n 2. "132"\n 3. "213"\n 4. "231"\n 5. "312"\n 6. "321"\n\n给定 n 和 k，返回第 k 个排列。\n\n \n\n示例 1：\n\n\n输入：n = 3, k = 3\n输出："213"\n\n\n示例 2：\n\n\n输入：n = 4, k = 9\n输出："2314"\n\n\n示例 3：\n\n\n输入：n = 3, k = 1\n输出："123"\n\n\n \n\n提示：\n\n * 1 <= n <= 9\n * 1 <= k <= n!\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 60. 排列序列\n\nenglish version\n\n\n# 题目描述\n\n给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。\n\n按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：\n\n 1. "123"\n 2. "132"\n 3. "213"\n 4. "231"\n 5. "312"\n 6. "321"\n\n给定 n 和 k，返回第 k 个排列。\n\n \n\n示例 1：\n\n\n输入：n = 3, k = 3\n输出："213"\n\n\n示例 2：\n\n\n输入：n = 4, k = 9\n输出："2314"\n\n\n示例 3：\n\n\n输入：n = 3, k = 1\n输出："123"\n\n\n \n\n提示：\n\n * 1 <= n <= 9\n * 1 <= k <= n!\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode61 Rotate List-zh",frontmatter:{title:"leetcode61 Rotate List-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fe1724/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0061.Rotate%20List/images/rotate1.jpg"},{name:"twitter:title",content:"leetcode61 Rotate List-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0061.Rotate%20List/images/rotate1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10061.leetcode61%20Rotate%20List-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode61 Rotate List-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0061.Rotate%20List/images/rotate1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10061.leetcode61%20Rotate%20List-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode61 Rotate List-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0061.Rotate%20List/images/rotate1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10061.leetcode61%20Rotate%20List-zh.html",relativePath:"01.算法/24.leetcode/10061.leetcode61 Rotate List-zh.md",key:"v-bfdfb6f2",path:"/p/fe1724/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:269},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:330},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1133},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:2196},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:3189},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:4256},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:5373}],headersStr:"题目描述 解法 Python3 Java TypeScript C++ C# ...",content:"# 61. 旋转链表\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n \n\n示例 1：\n\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n\n \n\n提示：\n\n * 链表中节点的数目在范围 [0, 500] 内\n * -100 <= Node.val <= 100\n * 0 <= k <= 2 * 109\n\n\n# 解法\n\n将链表右半部分的 k 的节点拼接到 head 即可。\n\n注：k 对链表长度 n 取余，即 k %= n。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or head is None or head.next is None:\n            return head\n        n, cur = 0, head\n        while cur:\n            n, cur = n + 1, cur.next\n        k %= n\n        if k == 0:\n            return head\n        \n        slow = fast = head\n        for _ in range(k):\n            fast = fast.next\n        while fast.next:\n            slow, fast = slow.next, fast.next\n        \n        start = slow.next\n        slow.next = None\n        fast.next = head\n        return start\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 0;\n        for (ListNode cur = head; cur != null; cur = cur.next) {\n            ++n;\n        }\n        k %= n;\n        if (k == 0) {\n            return head;\n        }\n        ListNode slow = head, fast = head;\n        while (k-- > 0) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n\n        ListNode start = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return start;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# TypeScript\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    if (k == 0  || head == null || head.next == null) return head;\n    // mod n\n    let n = 0;\n    let p = head;\n    while (p != null) {\n        ++n;\n        p = p.next;\n    }\n    k %= n;\n    if (k == 0) return head;\n    \n    let fast = head, slow = head;\n    for (let i = 0; i < k; ++i) {\n        fast = fast.next;\n    }\n    while (fast.next != null) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    let start = slow.next;\n    slow.next = null;\n    fast.next = head;\n    return start;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || !head || !head->next) {\n            return head;\n        }\n        int n = 0;\n        for (ListNode *cur = head; !!cur; cur = cur->next) {\n            ++n;\n        }\n        k %= n;\n        if (k == 0) {\n            return head;\n        }\n        ListNode *slow = head, *fast = head;\n        while (k-- > 0) {\n            fast = fast->next;\n        }\n        while (fast->next) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n\n        ListNode *start = slow->next;\n        slow->next = nullptr;\n        fast->next = head;\n        return start;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# C#\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null)\n        {\n            return head;\n        }\n        var n = 0;\n        for (ListNode cur = head; cur != null; cur = cur.next)\n        {\n            ++n;\n        }\n        k %= n;\n        if (k == 0)\n        {\n            return head;\n        }\n        ListNode slow = head, fast = head;\n        while (k-- > 0)\n        {\n            fast = fast.next;\n        }\n        while (fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next;\n        }\n\n        ListNode start = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return start;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 61. 旋转链表\n\nenglish version\n\n\n# 题目描述\n\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n \n\n示例 1：\n\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n\n \n\n提示：\n\n * 链表中节点的数目在范围 [0, 500] 内\n * -100 <= node.val <= 100\n * 0 <= k <= 2 * 109\n\n\n# 解法\n\n将链表右半部分的 k 的节点拼接到 head 即可。\n\n注：k 对链表长度 n 取余，即 k %= n。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def rotateright(self, head: listnode, k: int) -> listnode:\n        if k == 0 or head is none or head.next is none:\n            return head\n        n, cur = 0, head\n        while cur:\n            n, cur = n + 1, cur.next\n        k %= n\n        if k == 0:\n            return head\n        \n        slow = fast = head\n        for _ in range(k):\n            fast = fast.next\n        while fast.next:\n            slow, fast = slow.next, fast.next\n        \n        start = slow.next\n        slow.next = none\n        fast.next = head\n        return start\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode rotateright(listnode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 0;\n        for (listnode cur = head; cur != null; cur = cur.next) {\n            ++n;\n        }\n        k %= n;\n        if (k == 0) {\n            return head;\n        }\n        listnode slow = head, fast = head;\n        while (k-- > 0) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n\n        listnode start = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return start;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# typescript\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     val: number\n *     next: listnode | null\n *     constructor(val?: number, next?: listnode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction rotateright(head: listnode | null, k: number): listnode | null {\n    if (k == 0  || head == null || head.next == null) return head;\n    // mod n\n    let n = 0;\n    let p = head;\n    while (p != null) {\n        ++n;\n        p = p.next;\n    }\n    k %= n;\n    if (k == 0) return head;\n    \n    let fast = head, slow = head;\n    for (let i = 0; i < k; ++i) {\n        fast = fast.next;\n    }\n    while (fast.next != null) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    let start = slow.next;\n    slow.next = null;\n    fast.next = head;\n    return start;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* rotateright(listnode* head, int k) {\n        if (k == 0 || !head || !head->next) {\n            return head;\n        }\n        int n = 0;\n        for (listnode *cur = head; !!cur; cur = cur->next) {\n            ++n;\n        }\n        k %= n;\n        if (k == 0) {\n            return head;\n        }\n        listnode *slow = head, *fast = head;\n        while (k-- > 0) {\n            fast = fast->next;\n        }\n        while (fast->next) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n\n        listnode *start = slow->next;\n        slow->next = nullptr;\n        fast->next = head;\n        return start;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# c#\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     public int val;\n *     public listnode next;\n *     public listnode(int val=0, listnode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class solution {\n    public listnode rotateright(listnode head, int k) {\n        if (k == 0 || head == null || head.next == null)\n        {\n            return head;\n        }\n        var n = 0;\n        for (listnode cur = head; cur != null; cur = cur.next)\n        {\n            ++n;\n        }\n        k %= n;\n        if (k == 0)\n        {\n            return head;\n        }\n        listnode slow = head, fast = head;\n        while (k-- > 0)\n        {\n            fast = fast.next;\n        }\n        while (fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next;\n        }\n\n        listnode start = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return start;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode62 Unique Paths-zh",frontmatter:{title:"leetcode62 Unique Paths-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/665af6/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0062.Unique%20Paths/images/robot_maze.png"},{name:"twitter:title",content:"leetcode62 Unique Paths-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0062.Unique%20Paths/images/robot_maze.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10062.leetcode62%20Unique%20Paths-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode62 Unique Paths-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0062.Unique%20Paths/images/robot_maze.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10062.leetcode62%20Unique%20Paths-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode62 Unique Paths-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0062.Unique%20Paths/images/robot_maze.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10062.leetcode62%20Unique%20Paths-zh.html",relativePath:"01.算法/24.leetcode/10062.leetcode62 Unique Paths-zh.md",key:"v-cec914d2",path:"/p/665af6/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:419},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:506},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:788},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1214},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1570},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1916}],headersStr:"题目描述 解法 Python3 Java C++ Go ...",content:"# 62. 不同路径\n\nEnglish Version\n\n\n# 题目描述\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n \n\n示例 1：\n\n\n输入：m = 3, n = 7\n输出：28\n\n示例 2：\n\n\n输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向下\n\n\n示例 3：\n\n\n输入：m = 7, n = 3\n输出：28\n\n\n示例 4：\n\n\n输入：m = 3, n = 3\n输出：6\n\n \n\n提示：\n\n * 1 <= m, n <= 100\n * 题目数据保证答案小于等于 2 * 109\n\n\n# 解法\n\n动态规划。\n\n假设 dp[i][j] 表示到达网格 (i,j) 的路径数，则 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]。\n\n\n# Python3\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1] * n for _ in range(m)]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Java\n\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            Arrays.fill(dp[i], 1);\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 1));\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Go\n\nfunc uniquePaths(m int, n int) int {\n\tdp := make([][]int, m)\n\tfor i := 0; i < m; i++ {\n\t\tdp[i] = make([]int, n)\n\t}\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif i == 0 || j == 0 {\n\t\t\t\tdp[i][j] = 1\n\t\t\t} else {\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1]\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[m-1][n-1]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 62. 不同路径\n\nenglish version\n\n\n# 题目描述\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “finish” ）。\n\n问总共有多少条不同的路径？\n\n \n\n示例 1：\n\n\n输入：m = 3, n = 7\n输出：28\n\n示例 2：\n\n\n输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向下\n\n\n示例 3：\n\n\n输入：m = 7, n = 3\n输出：28\n\n\n示例 4：\n\n\n输入：m = 3, n = 3\n输出：6\n\n \n\n提示：\n\n * 1 <= m, n <= 100\n * 题目数据保证答案小于等于 2 * 109\n\n\n# 解法\n\n动态规划。\n\n假设 dp[i][j] 表示到达网格 (i,j) 的路径数，则 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]。\n\n\n# python3\n\nclass solution:\n    def uniquepaths(self, m: int, n: int) -> int:\n        dp = [[1] * n for _ in range(m)]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# java\n\nclass solution {\n    public int uniquepaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            arrays.fill(dp[i], 1);\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# c++\n\nclass solution {\npublic:\n    int uniquepaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 1));\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# go\n\nfunc uniquepaths(m int, n int) int {\n\tdp := make([][]int, m)\n\tfor i := 0; i < m; i++ {\n\t\tdp[i] = make([]int, n)\n\t}\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif i == 0 || j == 0 {\n\t\t\t\tdp[i][j] = 1\n\t\t\t} else {\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1]\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[m-1][n-1]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode63 Unique Paths II-zh",frontmatter:{title:"leetcode63 Unique Paths II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/641106/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0063.Unique%20Paths%20II/images/robot_maze.png"},{name:"twitter:title",content:"leetcode63 Unique Paths II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0063.Unique%20Paths%20II/images/robot_maze.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10063.leetcode63%20Unique%20Paths%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode63 Unique Paths II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0063.Unique%20Paths%20II/images/robot_maze.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10063.leetcode63%20Unique%20Paths%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode63 Unique Paths II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0063.Unique%20Paths%20II/images/robot_maze.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10063.leetcode63%20Unique%20Paths%20II-zh.html",relativePath:"01.算法/24.leetcode/10063.leetcode63 Unique Paths II-zh.md",key:"v-65770dca",path:"/p/641106/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:525},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:747},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1416},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2134},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2884},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3435}],headersStr:"题目描述 解法 Python3 Java C++ Go ...",content:"# 63. 不同路径 II\n\nEnglish Version\n\n\n# 题目描述\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n\n\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n\n \n\n示例 1：\n\n\n输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n输出：2\n解释：\n3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -> 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右 -> 向右\n\n\n示例 2：\n\n\n输入：obstacleGrid = [[0,1],[0,0]]\n输出：1\n\n\n \n\n提示：\n\n * m == obstacleGrid.length\n * n == obstacleGrid[i].length\n * 1 <= m, n <= 100\n * obstacleGrid[i][j] 为 0 或 1\n\n\n# 解法\n\n动态规划。\n\n假设 dp[i][j] 表示到达网格 (i,j) 的路径数，先初始化 dp 第一列和第一行的所有值，然后判断。\n\n * 若 obstacleGrid[i][j] == 1，说明路径数为 0，dp[i][j] = 0；\n * 若 obstacleGrid[i][j] == 0，则 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]。\n\n最后返回 dp[m - 1][n - 1] 即可。\n\n\n# Python3\n\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            if obstacleGrid[i][0] == 1:\n                break\n            dp[i][0] = 1\n        for j in range(n):\n            if obstacleGrid[0][j] == 1:\n                break\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Java\n\nclass Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length, n = obstacleGrid[0].length;\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < m && obstacleGrid[i][0] == 0; ++i) {\n            dp[i][0] = 1;\n        }\n        for (int j = 0; j < n && obstacleGrid[0][j] == 0; ++j) {\n            dp[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (obstacleGrid[i][j] == 0) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n));\n        for (int i = 0; i < m && obstacleGrid[i][0] == 0; ++i) {\n            dp[i][0] = 1;\n        }\n        for (int j = 0; j < n && obstacleGrid[0][j] == 0; ++j) {\n            dp[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (obstacleGrid[i][j] == 0) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Go\n\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\n\tm, n := len(obstacleGrid), len(obstacleGrid[0])\n\tdp := make([][]int, m)\n\tfor i := 0; i < m; i++ {\n\t\tdp[i] = make([]int, n)\n\t}\n\tfor i := 0; i < m && obstacleGrid[i][0] == 0; i++ {\n\t\tdp[i][0] = 1\n\t}\n\tfor j := 0; j < n && obstacleGrid[0][j] == 0; j++ {\n\t\tdp[0][j] = 1\n\t}\n\tfor i := 1; i < m; i++ {\n\t\tfor j := 1; j < n; j++ {\n\t\t\tif obstacleGrid[i][j] == 0 {\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1]\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[m-1][n-1]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 63. 不同路径 ii\n\nenglish version\n\n\n# 题目描述\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n\n\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n\n \n\n示例 1：\n\n\n输入：obstaclegrid = [[0,0,0],[0,1,0],[0,0,0]]\n输出：2\n解释：\n3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -> 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右 -> 向右\n\n\n示例 2：\n\n\n输入：obstaclegrid = [[0,1],[0,0]]\n输出：1\n\n\n \n\n提示：\n\n * m == obstaclegrid.length\n * n == obstaclegrid[i].length\n * 1 <= m, n <= 100\n * obstaclegrid[i][j] 为 0 或 1\n\n\n# 解法\n\n动态规划。\n\n假设 dp[i][j] 表示到达网格 (i,j) 的路径数，先初始化 dp 第一列和第一行的所有值，然后判断。\n\n * 若 obstaclegrid[i][j] == 1，说明路径数为 0，dp[i][j] = 0；\n * 若 obstaclegrid[i][j] == 0，则 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]。\n\n最后返回 dp[m - 1][n - 1] 即可。\n\n\n# python3\n\nclass solution:\n    def uniquepathswithobstacles(self, obstaclegrid: list[list[int]]) -> int:\n        m, n = len(obstaclegrid), len(obstaclegrid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            if obstaclegrid[i][0] == 1:\n                break\n            dp[i][0] = 1\n        for j in range(n):\n            if obstaclegrid[0][j] == 1:\n                break\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstaclegrid[i][j] == 0:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# java\n\nclass solution {\n    public int uniquepathswithobstacles(int[][] obstaclegrid) {\n        int m = obstaclegrid.length, n = obstaclegrid[0].length;\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < m && obstaclegrid[i][0] == 0; ++i) {\n            dp[i][0] = 1;\n        }\n        for (int j = 0; j < n && obstaclegrid[0][j] == 0; ++j) {\n            dp[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (obstaclegrid[i][j] == 0) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# c++\n\nclass solution {\npublic:\n    int uniquepathswithobstacles(vector<vector<int>>& obstaclegrid) {\n        int m = obstaclegrid.size(), n = obstaclegrid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n));\n        for (int i = 0; i < m && obstaclegrid[i][0] == 0; ++i) {\n            dp[i][0] = 1;\n        }\n        for (int j = 0; j < n && obstaclegrid[0][j] == 0; ++j) {\n            dp[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (obstaclegrid[i][j] == 0) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# go\n\nfunc uniquepathswithobstacles(obstaclegrid [][]int) int {\n\tm, n := len(obstaclegrid), len(obstaclegrid[0])\n\tdp := make([][]int, m)\n\tfor i := 0; i < m; i++ {\n\t\tdp[i] = make([]int, n)\n\t}\n\tfor i := 0; i < m && obstaclegrid[i][0] == 0; i++ {\n\t\tdp[i][0] = 1\n\t}\n\tfor j := 0; j < n && obstaclegrid[0][j] == 0; j++ {\n\t\tdp[0][j] = 1\n\t}\n\tfor i := 1; i < m; i++ {\n\t\tfor j := 1; j < n; j++ {\n\t\t\tif obstaclegrid[i][j] == 0 {\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1]\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[m-1][n-1]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode64 Minimum Path Sum-zh",frontmatter:{title:"leetcode64 Minimum Path Sum-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/3cbab8/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0064.Minimum%20Path%20Sum/images/minpath.jpg"},{name:"twitter:title",content:"leetcode64 Minimum Path Sum-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0064.Minimum%20Path%20Sum/images/minpath.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10064.leetcode64%20Minimum%20Path%20Sum-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode64 Minimum Path Sum-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0064.Minimum%20Path%20Sum/images/minpath.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10064.leetcode64%20Minimum%20Path%20Sum-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode64 Minimum Path Sum-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0064.Minimum%20Path%20Sum/images/minpath.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10064.leetcode64%20Minimum%20Path%20Sum-zh.html",relativePath:"01.算法/24.leetcode/10064.leetcode64 Minimum Path Sum-zh.md",key:"v-d33c36c0",path:"/p/3cbab8/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:343},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:506},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1029},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1684},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2344},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2931}],headersStr:"题目描述 解法 Python3 Java C++ Go ...",content:"# 64. 最小路径和\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n \n\n示例 1：\n\n\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n\n\n示例 2：\n\n\n输入：grid = [[1,2,3],[4,5,6]]\n输出：12\n\n\n \n\n提示：\n\n * m == grid.length\n * n == grid[i].length\n * 1 <= m, n <= 200\n * 0 <= grid[i][j] <= 100\n\n\n# 解法\n\n动态规划。假设 dp[i][j] 表示到达网格 (i,j) 的最小数字和，先初始化 dp 第一列和第一行的所有值，然后利用递推公式：dp[i][j] = min(dp[i -1][j], dp[i][j - 1]) + grid[i][j] 求得 dp。\n\n最后返回 dp[m - 1][n - 1] 即可。\n\n\n# Python3\n\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[grid[0][0]] * n for _ in range(m)]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i -1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[-1][-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][] dp = new int[m][n];\n        dp[0][0] = grid[0][0];\n        for (int i = 1; i < m; ++i) {\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; ++j) {\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n, grid[0][0]));\n        for (int i = 1; i < m; ++i) {\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; ++j) {\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Go\n\nfunc minPathSum(grid [][]int) int {\n\tm, n := len(grid), len(grid[0])\n\tdp := make([][]int, m)\n\tfor i := 0; i < m; i++ {\n\t\tdp[i] = make([]int, n)\n\t}\n\tdp[0][0] = grid[0][0]\n\tfor i := 1; i < m; i++ {\n\t\tdp[i][0] = dp[i-1][0] + grid[i][0]\n\t}\n\tfor j := 1; j < n; j++ {\n\t\tdp[0][j] = dp[0][j-1] + grid[0][j]\n\t}\n\tfor i := 1; i < m; i++ {\n\t\tfor j := 1; j < n; j++ {\n\t\t\tdp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\t\t}\n\t}\n\treturn dp[m-1][n-1]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 64. 最小路径和\n\nenglish version\n\n\n# 题目描述\n\n给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n \n\n示例 1：\n\n\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n\n\n示例 2：\n\n\n输入：grid = [[1,2,3],[4,5,6]]\n输出：12\n\n\n \n\n提示：\n\n * m == grid.length\n * n == grid[i].length\n * 1 <= m, n <= 200\n * 0 <= grid[i][j] <= 100\n\n\n# 解法\n\n动态规划。假设 dp[i][j] 表示到达网格 (i,j) 的最小数字和，先初始化 dp 第一列和第一行的所有值，然后利用递推公式：dp[i][j] = min(dp[i -1][j], dp[i][j - 1]) + grid[i][j] 求得 dp。\n\n最后返回 dp[m - 1][n - 1] 即可。\n\n\n# python3\n\nclass solution:\n    def minpathsum(self, grid: list[list[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[grid[0][0]] * n for _ in range(m)]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i -1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[-1][-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public int minpathsum(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][] dp = new int[m][n];\n        dp[0][0] = grid[0][0];\n        for (int i = 1; i < m; ++i) {\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; ++j) {\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                dp[i][j] = math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# c++\n\nclass solution {\npublic:\n    int minpathsum(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n, grid[0][0]));\n        for (int i = 1; i < m; ++i) {\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; ++j) {\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# go\n\nfunc minpathsum(grid [][]int) int {\n\tm, n := len(grid), len(grid[0])\n\tdp := make([][]int, m)\n\tfor i := 0; i < m; i++ {\n\t\tdp[i] = make([]int, n)\n\t}\n\tdp[0][0] = grid[0][0]\n\tfor i := 1; i < m; i++ {\n\t\tdp[i][0] = dp[i-1][0] + grid[i][0]\n\t}\n\tfor j := 1; j < n; j++ {\n\t\tdp[0][j] = dp[0][j-1] + grid[0][j]\n\t}\n\tfor i := 1; i < m; i++ {\n\t\tfor j := 1; j < n; j++ {\n\t\t\tdp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\t\t}\n\t}\n\treturn dp[m-1][n-1]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode65 Valid Number-zh",frontmatter:{title:"leetcode65 Valid Number-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d84d4d/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode65 Valid Number-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10065.leetcode65%20Valid%20Number-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode65 Valid Number-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10065.leetcode65%20Valid%20Number-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode65 Valid Number-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10065.leetcode65%20Valid%20Number-zh.html",relativePath:"01.算法/24.leetcode/10065.leetcode65 Valid Number-zh.md",key:"v-3b7ceb99",path:"/p/d84d4d/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:767},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:774},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:793},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:809}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 65. 有效数字\n\nEnglish Version\n\n\n# 题目描述\n\n有效数字（按顺序）可以分成以下几个部分：\n\n 1. 一个 小数 或者 整数\n 2. （可选）一个 \'e\' 或 \'E\' ，后面跟着一个 整数\n\n小数（按顺序）可以分成以下几个部分：\n\n 1. （可选）一个符号字符（\'+\' 或 \'-\'）\n 2. 下述格式之一：\n    1. 至少一位数字，后面跟着一个点 \'.\'\n    2. 至少一位数字，后面跟着一个点 \'.\' ，后面再跟着至少一位数字\n    3. 一个点 \'.\' ，后面跟着至少一位数字\n\n整数（按顺序）可以分成以下几个部分：\n\n 1. （可选）一个符号字符（\'+\' 或 \'-\'）\n 2. 至少一位数字\n\n部分有效数字列举如下：\n\n * ["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]\n\n部分无效数字列举如下：\n\n * ["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]\n\n给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。\n\n \n\n示例 1：\n\n\n输入：s = "0"\n输出：true\n\n\n示例 2：\n\n\n输入：s = "e"\n输出：false\n\n\n示例 3：\n\n\n输入：s = "."\n输出：false\n\n\n示例 4：\n\n\n输入：s = ".1"\n输出：true\n\n\n \n\n提示：\n\n * 1 <= s.length <= 20\n * s 仅含英文字母（大写和小写），数字（0-9），加号 \'+\' ，减号 \'-\' ，或者点 \'.\' 。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 65. 有效数字\n\nenglish version\n\n\n# 题目描述\n\n有效数字（按顺序）可以分成以下几个部分：\n\n 1. 一个 小数 或者 整数\n 2. （可选）一个 \'e\' 或 \'e\' ，后面跟着一个 整数\n\n小数（按顺序）可以分成以下几个部分：\n\n 1. （可选）一个符号字符（\'+\' 或 \'-\'）\n 2. 下述格式之一：\n    1. 至少一位数字，后面跟着一个点 \'.\'\n    2. 至少一位数字，后面跟着一个点 \'.\' ，后面再跟着至少一位数字\n    3. 一个点 \'.\' ，后面跟着至少一位数字\n\n整数（按顺序）可以分成以下几个部分：\n\n 1. （可选）一个符号字符（\'+\' 或 \'-\'）\n 2. 至少一位数字\n\n部分有效数字列举如下：\n\n * ["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90e3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]\n\n部分无效数字列举如下：\n\n * ["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]\n\n给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。\n\n \n\n示例 1：\n\n\n输入：s = "0"\n输出：true\n\n\n示例 2：\n\n\n输入：s = "e"\n输出：false\n\n\n示例 3：\n\n\n输入：s = "."\n输出：false\n\n\n示例 4：\n\n\n输入：s = ".1"\n输出：true\n\n\n \n\n提示：\n\n * 1 <= s.length <= 20\n * s 仅含英文字母（大写和小写），数字（0-9），加号 \'+\' ，减号 \'-\' ，或者点 \'.\' 。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode66 Plus One-zh",frontmatter:{title:"leetcode66 Plus One-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a9a5e7/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode66 Plus One-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10066.leetcode66%20Plus%20One-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode66 Plus One-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10066.leetcode66%20Plus%20One-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode66 Plus One-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10066.leetcode66%20Plus%20One-zh.html",relativePath:"01.算法/24.leetcode/10066.leetcode66 Plus One-zh.md",key:"v-09f55659",path:"/p/a9a5e7/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:30},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:356},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:363},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:382},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:398}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 66. 加一\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n \n\n示例 1：\n\n\n输入：digits = [1,2,3]\n输出：[1,2,4]\n解释：输入数组表示数字 123。\n\n\n示例 2：\n\n\n输入：digits = [4,3,2,1]\n输出：[4,3,2,2]\n解释：输入数组表示数字 4321。\n\n\n示例 3：\n\n\n输入：digits = [0]\n输出：[1]\n\n\n \n\n提示：\n\n * 1 <= digits.length <= 100\n * 0 <= digits[i] <= 9\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 66. 加一\n\nenglish version\n\n\n# 题目描述\n\n给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n \n\n示例 1：\n\n\n输入：digits = [1,2,3]\n输出：[1,2,4]\n解释：输入数组表示数字 123。\n\n\n示例 2：\n\n\n输入：digits = [4,3,2,1]\n输出：[4,3,2,2]\n解释：输入数组表示数字 4321。\n\n\n示例 3：\n\n\n输入：digits = [0]\n输出：[1]\n\n\n \n\n提示：\n\n * 1 <= digits.length <= 100\n * 0 <= digits[i] <= 9\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode67 Add Binary-zh",frontmatter:{title:"leetcode67 Add Binary-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/7ca8bd/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode67 Add Binary-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10067.leetcode67%20Add%20Binary-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode67 Add Binary-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10067.leetcode67%20Add%20Binary-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode67 Add Binary-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10067.leetcode67%20Add%20Binary-zh.html",relativePath:"01.算法/24.leetcode/10067.leetcode67 Add Binary-zh.md",key:"v-76d0f302",path:"/p/7ca8bd/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:281},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:288},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:420},{level:3,title:"C#",slug:"c",normalizedTitle:"c#",charIndex:939},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1771},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2216}],headersStr:"题目描述 解法 Python3 Java C# Go ...",content:'# 67. 二进制求和\n\nEnglish Version\n\n\n# 题目描述\n\n给你两个二进制字符串，返回它们的和（用二进制表示）。\n\n输入为 非空 字符串且只包含数字 1 和 0。\n\n \n\n示例 1:\n\n输入: a = "11", b = "1"\n输出: "100"\n\n示例 2:\n\n输入: a = "1010", b = "1011"\n输出: "10101"\n\n \n\n提示：\n\n * 每个字符串仅由字符 \'0\' 或 \'1\' 组成。\n * 1 <= a.length, b.length <= 10^4\n * 字符串如果不是 "0" ，就都不含前导零。\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        return bin(int(a, 2) + int(b, 2))[2:]\n\n\n1\n2\n3\n\n\n\n# Java\n\nclass Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder sb = new StringBuilder();\n        int i = a.length() - 1, j = b.length() - 1, carry = 0;\n        while (i >= 0 || j >= 0 || carry != 0) {\n            int s = carry + (i >= 0 ? a.charAt(i) - \'0\' : 0) + (j >= 0 ? b.charAt(j) - \'0\' : 0);\n            sb.append(s % 2);\n            carry = s / 2;\n            --i;\n            --j;\n        }\n        return sb.reverse().toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# C#\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    public string AddBinary(string a, string b) {\n        var list = new List<char>(Math.Max(a.Length, b.Length) + 1);\n        var i = a.Length - 1;\n        var j = b.Length - 1;\n        var carry = 0;\n        while (i >= 0 || j >= 0)\n        {\n            if (i >= 0)\n            {\n                carry += a[i] - \'0\';\n            }\n            if (j >= 0)\n            {\n                carry += b[j] - \'0\';\n            }\n            list.Add((char)((carry % 2) + \'0\'));\n            carry /= 2;\n            --i;\n            --j;\n        }\n        if (carry > 0) list.Add((char) (carry + \'0\'));\n        list.Reverse();\n        return new string(list.ToArray());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# Go\n\nfunc addBinary(a string, b string) string {\n\tfor len(a) > len(b) {\n\t\tb = "0" + b\n\t}\n\tfor len(a) < len(b) {\n\t\ta = "0" + a\n\t}\n\tzero := []byte("0")[0]\n\tret := make([]byte, len(a))\n\tfor right := len(a) - 1; right > 0; right-- {\n\t\tt := ret[right] + a[right] + b[right] - zero*2\n\t\tret[right] = t%2 + zero\n\t\tif t >= 2 {\n\t\t\tret[right-1] = 1\n\t\t}\n\t}\n\tt := ret[0] + a[0] + b[0] - zero*2\n\tret[0] = t%2 + zero\n\tif t >= 2 {\n\t\tret = append([]byte("1"), ret...)\n\t}\n\n\treturn string(ret)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 67. 二进制求和\n\nenglish version\n\n\n# 题目描述\n\n给你两个二进制字符串，返回它们的和（用二进制表示）。\n\n输入为 非空 字符串且只包含数字 1 和 0。\n\n \n\n示例 1:\n\n输入: a = "11", b = "1"\n输出: "100"\n\n示例 2:\n\n输入: a = "1010", b = "1011"\n输出: "10101"\n\n \n\n提示：\n\n * 每个字符串仅由字符 \'0\' 或 \'1\' 组成。\n * 1 <= a.length, b.length <= 10^4\n * 字符串如果不是 "0" ，就都不含前导零。\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def addbinary(self, a: str, b: str) -> str:\n        return bin(int(a, 2) + int(b, 2))[2:]\n\n\n1\n2\n3\n\n\n\n# java\n\nclass solution {\n    public string addbinary(string a, string b) {\n        stringbuilder sb = new stringbuilder();\n        int i = a.length() - 1, j = b.length() - 1, carry = 0;\n        while (i >= 0 || j >= 0 || carry != 0) {\n            int s = carry + (i >= 0 ? a.charat(i) - \'0\' : 0) + (j >= 0 ? b.charat(j) - \'0\' : 0);\n            sb.append(s % 2);\n            carry = s / 2;\n            --i;\n            --j;\n        }\n        return sb.reverse().tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# c#\n\nusing system;\nusing system.collections.generic;\n\npublic class solution {\n    public string addbinary(string a, string b) {\n        var list = new list<char>(math.max(a.length, b.length) + 1);\n        var i = a.length - 1;\n        var j = b.length - 1;\n        var carry = 0;\n        while (i >= 0 || j >= 0)\n        {\n            if (i >= 0)\n            {\n                carry += a[i] - \'0\';\n            }\n            if (j >= 0)\n            {\n                carry += b[j] - \'0\';\n            }\n            list.add((char)((carry % 2) + \'0\'));\n            carry /= 2;\n            --i;\n            --j;\n        }\n        if (carry > 0) list.add((char) (carry + \'0\'));\n        list.reverse();\n        return new string(list.toarray());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# go\n\nfunc addbinary(a string, b string) string {\n\tfor len(a) > len(b) {\n\t\tb = "0" + b\n\t}\n\tfor len(a) < len(b) {\n\t\ta = "0" + a\n\t}\n\tzero := []byte("0")[0]\n\tret := make([]byte, len(a))\n\tfor right := len(a) - 1; right > 0; right-- {\n\t\tt := ret[right] + a[right] + b[right] - zero*2\n\t\tret[right] = t%2 + zero\n\t\tif t >= 2 {\n\t\t\tret[right-1] = 1\n\t\t}\n\t}\n\tt := ret[0] + a[0] + b[0] - zero*2\n\tret[0] = t%2 + zero\n\tif t >= 2 {\n\t\tret = append([]byte("1"), ret...)\n\t}\n\n\treturn string(ret)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode68 Text Justification-zh",frontmatter:{title:"leetcode68 Text Justification-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d7cf8a/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode68 Text Justification-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10068.leetcode68%20Text%20Justification-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode68 Text Justification-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10068.leetcode68%20Text%20Justification-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode68 Text Justification-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10068.leetcode68%20Text%20Justification-zh.html",relativePath:"01.算法/24.leetcode/10068.leetcode68 Text Justification-zh.md",key:"v-734fa6d2",path:"/p/d7cf8a/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1147},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1154},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1173},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1189}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 68. 文本左右对齐\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。\n\n你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 \' \' 填充，使得每行恰好有 maxWidth 个字符。\n\n要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。\n\n文本的最后一行应为左对齐，且单词之间不插入额外的空格。\n\n说明:\n\n * 单词是指由非空格字符组成的字符序列。\n * 每个单词的长度大于 0，小于等于 maxWidth。\n * 输入单词数组 words 至少包含一个单词。\n\n示例:\n\n输入:\nwords = ["This", "is", "an", "example", "of", "text", "justification."]\nmaxWidth = 16\n输出:\n[\n   "This    is    an",\n   "example  of text",\n   "justification.  "\n]\n\n\n示例 2:\n\n输入:\nwords = ["What","must","be","acknowledgment","shall","be"]\nmaxWidth = 16\n输出:\n[\n  "What   must   be",\n  "acknowledgment  ",\n  "shall be        "\n]\n解释: 注意最后一行的格式应为 "shall be    " 而不是 "shall     be",\n     因为最后一行应为左对齐，而不是左右两端对齐。       \n     第二行同样为左对齐，这是因为这行只包含一个单词。\n\n\n示例 3:\n\n输入:\nwords = ["Science","is","what","we","understand","well","enough","to","explain",\n         "to","a","computer.","Art","is","everything","else","we","do"]\nmaxWidth = 20\n输出:\n[\n  "Science  is  what we",\n  "understand      well",\n  "enough to explain to",\n  "a  computer.  Art is",\n  "everything  else  we",\n  "do                  "\n]\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 68. 文本左右对齐\n\nenglish version\n\n\n# 题目描述\n\n给定一个单词数组和一个长度 maxwidth，重新排版单词，使其成为每行恰好有 maxwidth 个字符，且左右两端对齐的文本。\n\n你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 \' \' 填充，使得每行恰好有 maxwidth 个字符。\n\n要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。\n\n文本的最后一行应为左对齐，且单词之间不插入额外的空格。\n\n说明:\n\n * 单词是指由非空格字符组成的字符序列。\n * 每个单词的长度大于 0，小于等于 maxwidth。\n * 输入单词数组 words 至少包含一个单词。\n\n示例:\n\n输入:\nwords = ["this", "is", "an", "example", "of", "text", "justification."]\nmaxwidth = 16\n输出:\n[\n   "this    is    an",\n   "example  of text",\n   "justification.  "\n]\n\n\n示例 2:\n\n输入:\nwords = ["what","must","be","acknowledgment","shall","be"]\nmaxwidth = 16\n输出:\n[\n  "what   must   be",\n  "acknowledgment  ",\n  "shall be        "\n]\n解释: 注意最后一行的格式应为 "shall be    " 而不是 "shall     be",\n     因为最后一行应为左对齐，而不是左右两端对齐。       \n     第二行同样为左对齐，这是因为这行只包含一个单词。\n\n\n示例 3:\n\n输入:\nwords = ["science","is","what","we","understand","well","enough","to","explain",\n         "to","a","computer.","art","is","everything","else","we","do"]\nmaxwidth = 20\n输出:\n[\n  "science  is  what we",\n  "understand      well",\n  "enough to explain to",\n  "a  computer.  art is",\n  "everything  else  we",\n  "do                  "\n]\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode69 Sqrt(x)-zh",frontmatter:{title:"leetcode69 Sqrt(x)-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/565a77/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode69 Sqrt(x)-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10069.leetcode69%20Sqrt(x)-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode69 Sqrt(x)-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10069.leetcode69%20Sqrt(x)-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode69 Sqrt(x)-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10069.leetcode69%20Sqrt(x)-zh.html",relativePath:"01.算法/24.leetcode/10069.leetcode69 Sqrt(x)-zh.md",key:"v-19a97cc4",path:"/p/565a77/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:217},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:224},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:616},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1089},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1539},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1973},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:2233},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:181}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go C# ...",content:"# 69. x 的平方根\n\nEnglish Version\n\n\n# 题目描述\n\n实现 int sqrt(int x) 函数。\n\n计算并返回 x 的平方根，其中 x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n示例 1:\n\n输入: 4\n输出: 2\n\n\n示例 2:\n\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n     由于返回类型是整数，小数部分将被舍去。\n\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0:\n            return 0\n        left, right = 1, x\n        while left < right:\n            mid = (left + right + 1) >> 1\n            # mid*mid <= x\n            if x // mid >= mid:\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\nclass Solution {\n    public int mySqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        int left = 1, right = x;\n        while (left < right) {\n            int mid = (left + right + 1) >>> 1;\n            if (x / mid >= mid) {\n                // mid*mid <= x\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        int left = 1, right = x;\n        while (left < right) {\n            int mid = left + ((right - left + 1) >> 1);\n            if (x / mid >= mid) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# JavaScript\n\n/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    if (x == 0) {\n        return 0;\n    }\n    let left = 1;\n    let right = x;\n    while (left < right) {\n        const mid = (left + right + 1) >>> 1;\n        if (x / mid >= mid) {\n            left = mid;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return left;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Go\n\nfunc mySqrt(x int) int {\n\tif x == 0 {\n\t\treturn 0\n\t}\n\tleft, right := 1, x\n\tfor left < right {\n\t\tmid := left + (right-left+1)>>1\n\t\tif x/mid >= mid {\n\t\t\tleft = mid\n\t\t} else {\n\t\t\tright = mid - 1\n\t\t}\n\t}\n\treturn left\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# C#\n\npublic class Solution {\n    public int MySqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        int left = 1, right = x;\n        while (left < right)\n        {\n            int mid = left + right + 1 >> 1;\n            if (x / mid >= mid)\n            {\n                left = mid;\n            } \n            else \n            {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 69. x 的平方根\n\nenglish version\n\n\n# 题目描述\n\n实现 int sqrt(int x) 函数。\n\n计算并返回 x 的平方根，其中 x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n示例 1:\n\n输入: 4\n输出: 2\n\n\n示例 2:\n\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n     由于返回类型是整数，小数部分将被舍去。\n\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def mysqrt(self, x: int) -> int:\n        if x == 0:\n            return 0\n        left, right = 1, x\n        while left < right:\n            mid = (left + right + 1) >> 1\n            # mid*mid <= x\n            if x // mid >= mid:\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\nclass solution {\n    public int mysqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        int left = 1, right = x;\n        while (left < right) {\n            int mid = (left + right + 1) >>> 1;\n            if (x / mid >= mid) {\n                // mid*mid <= x\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# c++\n\nclass solution {\npublic:\n    int mysqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        int left = 1, right = x;\n        while (left < right) {\n            int mid = left + ((right - left + 1) >> 1);\n            if (x / mid >= mid) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# javascript\n\n/**\n * @param {number} x\n * @return {number}\n */\nvar mysqrt = function(x) {\n    if (x == 0) {\n        return 0;\n    }\n    let left = 1;\n    let right = x;\n    while (left < right) {\n        const mid = (left + right + 1) >>> 1;\n        if (x / mid >= mid) {\n            left = mid;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return left;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# go\n\nfunc mysqrt(x int) int {\n\tif x == 0 {\n\t\treturn 0\n\t}\n\tleft, right := 1, x\n\tfor left < right {\n\t\tmid := left + (right-left+1)>>1\n\t\tif x/mid >= mid {\n\t\t\tleft = mid\n\t\t} else {\n\t\t\tright = mid - 1\n\t\t}\n\t}\n\treturn left\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# c#\n\npublic class solution {\n    public int mysqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        int left = 1, right = x;\n        while (left < right)\n        {\n            int mid = left + right + 1 >> 1;\n            if (x / mid >= mid)\n            {\n                left = mid;\n            } \n            else \n            {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode70 Climbing Stairs-zh",frontmatter:{title:"leetcode70 Climbing Stairs-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fa8040/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode70 Climbing Stairs-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10070.leetcode70%20Climbing%20Stairs-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode70 Climbing Stairs-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10070.leetcode70%20Climbing%20Stairs-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode70 Climbing Stairs-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10070.leetcode70%20Climbing%20Stairs-zh.html",relativePath:"01.算法/24.leetcode/10070.leetcode70 Climbing Stairs-zh.md",key:"v-273a5ff2",path:"/p/fa8040/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:31},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:264},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:350},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:528},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:783},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1042},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1294},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1440}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go ...",content:"# 70. 爬楼梯\n\nEnglish Version\n\n\n# 题目描述\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n\n\n\n# 解法\n\n想上第 n 级台阶，可从第 n-1 级台阶爬一级上去，也可从第 n-2 级台阶爬两级上去，即：f(n) = f(n-1) + f(n-2)。递推求解即可。\n\n\n# Python3\n\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return b\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Java\n\nclass Solution {\n    public int climbStairs(int n) {\n        int a = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int a = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# JavaScript\n\n/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function (n) {\n  let a = 0,\n    b = 1;\n  for (let i = 0; i < n; ++i) {\n    const c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Go\n\nfunc climbStairs(n int) int {\n    a, b := 0, 1\n    for i := 0; i < n; i++ {\n        a, b = b, a + b\n    }\n    return b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 70. 爬楼梯\n\nenglish version\n\n\n# 题目描述\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n\n\n\n# 解法\n\n想上第 n 级台阶，可从第 n-1 级台阶爬一级上去，也可从第 n-2 级台阶爬两级上去，即：f(n) = f(n-1) + f(n-2)。递推求解即可。\n\n\n# python3\n\nclass solution:\n    def climbstairs(self, n: int) -> int:\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return b\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# java\n\nclass solution {\n    public int climbstairs(int n) {\n        int a = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# c++\n\nclass solution {\npublic:\n    int climbstairs(int n) {\n        int a = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# javascript\n\n/**\n * @param {number} n\n * @return {number}\n */\nvar climbstairs = function (n) {\n  let a = 0,\n    b = 1;\n  for (let i = 0; i < n; ++i) {\n    const c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# go\n\nfunc climbstairs(n int) int {\n    a, b := 0, 1\n    for i := 0; i < n; i++ {\n        a, b = b, a + b\n    }\n    return b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode71 Simplify Path-zh",frontmatter:{title:"leetcode71 Simplify Path-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/ba0add/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode71 Simplify Path-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10071.leetcode71%20Simplify%20Path-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode71 Simplify Path-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10071.leetcode71%20Simplify%20Path-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode71 Simplify Path-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10071.leetcode71%20Simplify%20Path-zh.html",relativePath:"01.算法/24.leetcode/10071.leetcode71 Simplify Path-zh.md",key:"v-7c3b4127",path:"/p/ba0add/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:777},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:784},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:803},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:239}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 71. 简化路径\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。\n\n在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。\n\n请注意，返回的 规范路径 必须遵循下述格式：\n\n * 始终以斜杠 '/' 开头。\n * 两个目录名之间必须只有一个斜杠 '/' 。\n * 最后一个目录名（如果存在）不能 以 '/' 结尾。\n * 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。\n\n返回简化后得到的 规范路径 。\n\n \n\n示例 1：\n\n\n输入：path = \"/home/\"\n输出：\"/home\"\n解释：注意，最后一个目录名后面没有斜杠。 \n\n示例 2：\n\n\n输入：path = \"/../\"\n输出：\"/\"\n解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n\n\n示例 3：\n\n\n输入：path = \"/home//foo/\"\n输出：\"/home/foo\"\n解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。\n\n\n示例 4：\n\n\n输入：path = \"/a/./b/../../c/\"\n输出：\"/c\"\n\n\n \n\n提示：\n\n * 1 <= path.length <= 3000\n * path 由英文字母，数字，'.'，'/' 或 '_' 组成。\n * path 是一个有效的 Unix 风格绝对路径。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 71. 简化路径\n\nenglish version\n\n\n# 题目描述\n\n给你一个字符串 path ，表示指向某一文件或目录的 unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。\n\n在 unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。\n\n请注意，返回的 规范路径 必须遵循下述格式：\n\n * 始终以斜杠 '/' 开头。\n * 两个目录名之间必须只有一个斜杠 '/' 。\n * 最后一个目录名（如果存在）不能 以 '/' 结尾。\n * 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。\n\n返回简化后得到的 规范路径 。\n\n \n\n示例 1：\n\n\n输入：path = \"/home/\"\n输出：\"/home\"\n解释：注意，最后一个目录名后面没有斜杠。 \n\n示例 2：\n\n\n输入：path = \"/../\"\n输出：\"/\"\n解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n\n\n示例 3：\n\n\n输入：path = \"/home//foo/\"\n输出：\"/home/foo\"\n解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。\n\n\n示例 4：\n\n\n输入：path = \"/a/./b/../../c/\"\n输出：\"/c\"\n\n\n \n\n提示：\n\n * 1 <= path.length <= 3000\n * path 由英文字母，数字，'.'，'/' 或 '_' 组成。\n * path 是一个有效的 unix 风格绝对路径。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode72 Edit Distance-zh",frontmatter:{title:"leetcode72 Edit Distance-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/143034/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode72 Edit Distance-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10072.leetcode72%20Edit%20Distance-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode72 Edit Distance-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10072.leetcode72%20Edit%20Distance-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode72 Edit Distance-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10072.leetcode72%20Edit%20Distance-zh.html",relativePath:"01.算法/24.leetcode/10072.leetcode72 Edit Distance-zh.md",key:"v-5b069c87",path:"/p/143034/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:593},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:600},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:619},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:635}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 72. 编辑距离\n\nEnglish Version\n\n\n# 题目描述\n\n给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n * 插入一个字符\n * 删除一个字符\n * 替换一个字符\n\n \n\n示例 1：\n\n\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n\n\n示例 2：\n\n\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n\n\n \n\n提示：\n\n * 0 <= word1.length, word2.length <= 500\n * word1 和 word2 由小写英文字母组成\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 72. 编辑距离\n\nenglish version\n\n\n# 题目描述\n\n给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n * 插入一个字符\n * 删除一个字符\n * 替换一个字符\n\n \n\n示例 1：\n\n\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n\n\n示例 2：\n\n\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n\n\n \n\n提示：\n\n * 0 <= word1.length, word2.length <= 500\n * word1 和 word2 由小写英文字母组成\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode73 Set Matrix Zeroes-zh",frontmatter:{title:"leetcode73 Set Matrix Zeroes-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/1a45c9/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0073.Set%20Matrix%20Zeroes/images/mat1.jpg"},{name:"twitter:title",content:"leetcode73 Set Matrix Zeroes-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0073.Set%20Matrix%20Zeroes/images/mat1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10073.leetcode73%20Set%20Matrix%20Zeroes-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode73 Set Matrix Zeroes-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0073.Set%20Matrix%20Zeroes/images/mat1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10073.leetcode73%20Set%20Matrix%20Zeroes-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode73 Set Matrix Zeroes-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0073.Set%20Matrix%20Zeroes/images/mat1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10073.leetcode73%20Set%20Matrix%20Zeroes-zh.html",relativePath:"01.算法/24.leetcode/10073.leetcode73 Set Matrix Zeroes-zh.md",key:"v-bdfb2438",path:"/p/1a45c9/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:499},{level:3,title:"方法一：使用两个标记数组",slug:"方法一-使用两个标记数组",normalizedTitle:"方法一：使用两个标记数组",charIndex:506},{level:3,title:"方法二：使用两个标记变量",slug:"方法二-使用两个标记变量",normalizedTitle:"方法二：使用两个标记变量",charIndex:608},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:739},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2296},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:4395},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:5072}],headersStr:"题目描述 解法 方法一：使用两个标记数组 方法二：使用两个标记变量 Python3 Java C++ ...",content:'# 73. 矩阵置零\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。\n\n进阶：\n\n * 一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。\n * 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。\n * 你能想出一个仅使用常量空间的解决方案吗？\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]\n输出：[[1,0,1],[0,0,0],[1,0,1]]\n\n\n示例 2：\n\n\n输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n\n \n\n提示：\n\n * m == matrix.length\n * n == matrix[0].length\n * 1 <= m, n <= 200\n * -231 <= matrix[i][j] <= 231 - 1\n\n\n# 解法\n\n\n# 方法一：使用两个标记数组\n\n用两个数组标记每一行、每一列是否出现零。\n\n遍历原数组，若元素为 0，将元素所在的行、列所对应的标记数组的位置为 true。\n\n最后遍历原数组，用标记数组更新原数组。\n\n\n# 方法二：使用两个标记变量\n\n用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1) 的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。\n\n\n# Python3\n\n方法一：\n\nclass Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        """\n        Do not return anything, modify matrix in-place instead.\n        """\n        m, n = len(matrix), len(matrix[0])\n        zero_rows = [False] * m\n        zero_cols = [False] * n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    zero_rows[i] = zero_cols[j] = True\n        for i in range(m):\n            for j in range(n):\n                if zero_rows[i] or zero_cols[j]:\n                    matrix[i][j] = 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n方法二：\n\nclass Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        """\n        Do not return anything, modify matrix in-place instead.\n        """\n        m, n = len(matrix), len(matrix[0])\n        first_row_has_zero = any(matrix[0][j] == 0 for j in range(n))\n        first_col_has_zero = any(matrix[i][0] == 0 for i in range(m))\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = matrix[0][j] = 0\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        if first_row_has_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n\n        if first_col_has_zero:\n            for i in range(m):\n                matrix[i][0] = 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java\n\n方法一：\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        boolean[] zeroRows = new boolean[m];\n        boolean[] zeroCols = new boolean[n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == 0) {\n                    zeroRows[i] = zeroCols[j] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (zeroRows[i] || zeroCols[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n方法二：\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        boolean firstRowHasZero = false;\n        boolean firstColHasZero = false;\n        for (int j = 0; j < n; ++j) {\n            if (matrix[0][j] == 0) {\n                firstRowHasZero = true;\n                break;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            if (matrix[i][0] == 0) {\n                firstColHasZero = true;\n                break;\n            }\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                // 更新标记数组\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if (firstRowHasZero) {\n            for (int j = 0; j < n; ++j) {\n                matrix[0][j] = 0;\n            }\n        }\n        if (firstColHasZero) {\n            for (int i = 0; i < m; ++i) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# C++\n\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<bool> zeroRows(m), zeroCols(n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    zeroRows[i] = zeroCols[j] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (zeroRows[i] || zeroCols[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 73. 矩阵置零\n\nenglish version\n\n\n# 题目描述\n\n给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。\n\n进阶：\n\n * 一个直观的解决方案是使用  o(mn) 的额外空间，但这并不是一个好的解决方案。\n * 一个简单的改进方案是使用 o(m + n) 的额外空间，但这仍然不是最好的解决方案。\n * 你能想出一个仅使用常量空间的解决方案吗？\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]\n输出：[[1,0,1],[0,0,0],[1,0,1]]\n\n\n示例 2：\n\n\n输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n\n \n\n提示：\n\n * m == matrix.length\n * n == matrix[0].length\n * 1 <= m, n <= 200\n * -231 <= matrix[i][j] <= 231 - 1\n\n\n# 解法\n\n\n# 方法一：使用两个标记数组\n\n用两个数组标记每一行、每一列是否出现零。\n\n遍历原数组，若元素为 0，将元素所在的行、列所对应的标记数组的位置为 true。\n\n最后遍历原数组，用标记数组更新原数组。\n\n\n# 方法二：使用两个标记变量\n\n用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 o(1) 的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。\n\n\n# python3\n\n方法一：\n\nclass solution:\n    def setzeroes(self, matrix: list[list[int]]) -> none:\n        """\n        do not return anything, modify matrix in-place instead.\n        """\n        m, n = len(matrix), len(matrix[0])\n        zero_rows = [false] * m\n        zero_cols = [false] * n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    zero_rows[i] = zero_cols[j] = true\n        for i in range(m):\n            for j in range(n):\n                if zero_rows[i] or zero_cols[j]:\n                    matrix[i][j] = 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n方法二：\n\nclass solution:\n    def setzeroes(self, matrix: list[list[int]]) -> none:\n        """\n        do not return anything, modify matrix in-place instead.\n        """\n        m, n = len(matrix), len(matrix[0])\n        first_row_has_zero = any(matrix[0][j] == 0 for j in range(n))\n        first_col_has_zero = any(matrix[i][0] == 0 for i in range(m))\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = matrix[0][j] = 0\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        if first_row_has_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n\n        if first_col_has_zero:\n            for i in range(m):\n                matrix[i][0] = 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java\n\n方法一：\n\nclass solution {\n    public void setzeroes(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        boolean[] zerorows = new boolean[m];\n        boolean[] zerocols = new boolean[n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == 0) {\n                    zerorows[i] = zerocols[j] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (zerorows[i] || zerocols[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n方法二：\n\nclass solution {\n    public void setzeroes(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        boolean firstrowhaszero = false;\n        boolean firstcolhaszero = false;\n        for (int j = 0; j < n; ++j) {\n            if (matrix[0][j] == 0) {\n                firstrowhaszero = true;\n                break;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            if (matrix[i][0] == 0) {\n                firstcolhaszero = true;\n                break;\n            }\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                // 更新标记数组\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if (firstrowhaszero) {\n            for (int j = 0; j < n; ++j) {\n                matrix[0][j] = 0;\n            }\n        }\n        if (firstcolhaszero) {\n            for (int i = 0; i < m; ++i) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# c++\n\nclass solution {\npublic:\n    void setzeroes(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<bool> zerorows(m), zerocols(n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    zerorows[i] = zerocols[j] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (zerorows[i] || zerocols[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode74 Search a 2D Matrix-zh",frontmatter:{title:"leetcode74 Search a 2D Matrix-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/8b2390/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0074.Search%20a%202D%20Matrix/images/mat.jpg"},{name:"twitter:title",content:"leetcode74 Search a 2D Matrix-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0074.Search%20a%202D%20Matrix/images/mat.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10074.leetcode74%20Search%20a%202D%20Matrix-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode74 Search a 2D Matrix-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0074.Search%20a%202D%20Matrix/images/mat.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10074.leetcode74%20Search%20a%202D%20Matrix-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode74 Search a 2D Matrix-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0074.Search%20a%202D%20Matrix/images/mat.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10074.leetcode74%20Search%20a%202D%20Matrix-zh.html",relativePath:"01.算法/24.leetcode/10074.leetcode74 Search a 2D Matrix-zh.md",key:"v-a2bdfe2e",path:"/p/8b2390/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:418},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:446},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:926},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1476},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2038},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2673},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3028}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go ...",content:"# 74. 搜索二维矩阵\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：\n\n * 每行中的整数从左到右按升序排列。\n * 每行的第一个整数大于前一行的最后一个整数。\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n输出：true\n\n\n示例 2：\n\n\n输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n输出：false\n\n\n \n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 100\n * -104 <= matrix[i][j], target <= 104\n\n\n# 解法\n\n将二维矩阵逻辑展开，然后二分查找即可。\n\n\n# Python3\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        while left < right:\n            mid = (left + right) >> 1\n            x, y = divmod(mid, n)\n            if matrix[x][y] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return matrix[left // n][left % n] == target\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length, n = matrix[0].length;\n        int left = 0, right = m * n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            int x = mid / n, y = mid % n;\n            if (matrix[x][y] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return matrix[left / n][left % n] == target;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# C++\n\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(), n = matrix[0].size();\n        int left = 0, right = m * n - 1;\n        while (left < right) {\n            int mid = left + right >> 1;\n            int x = mid / n, y = mid % n;\n            if (matrix[x][y] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return matrix[left / n][left % n] == target;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# JavaScript\n\n/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nvar searchMatrix = function(matrix, target) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    let left = 0;\n    let right = m * n - 1;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        const x = Math.floor(mid / n);\n        const y = mid % n;\n        if (matrix[x][y] >= target) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return matrix[Math.floor(left / n)][left % n] == target;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Go\n\nfunc searchMatrix(matrix [][]int, target int) bool {\n\tm, n := len(matrix), len(matrix[0])\n\tleft, right := 0, m*n-1\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tx, y := mid/n, mid%n\n\t\tif matrix[x][y] >= target {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\treturn matrix[left/n][left%n] == target\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 74. 搜索二维矩阵\n\nenglish version\n\n\n# 题目描述\n\n编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：\n\n * 每行中的整数从左到右按升序排列。\n * 每行的第一个整数大于前一行的最后一个整数。\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n输出：true\n\n\n示例 2：\n\n\n输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n输出：false\n\n\n \n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 100\n * -104 <= matrix[i][j], target <= 104\n\n\n# 解法\n\n将二维矩阵逻辑展开，然后二分查找即可。\n\n\n# python3\n\nclass solution:\n    def searchmatrix(self, matrix: list[list[int]], target: int) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        while left < right:\n            mid = (left + right) >> 1\n            x, y = divmod(mid, n)\n            if matrix[x][y] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return matrix[left // n][left % n] == target\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public boolean searchmatrix(int[][] matrix, int target) {\n        int m = matrix.length, n = matrix[0].length;\n        int left = 0, right = m * n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            int x = mid / n, y = mid % n;\n            if (matrix[x][y] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return matrix[left / n][left % n] == target;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# c++\n\nclass solution {\npublic:\n    bool searchmatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(), n = matrix[0].size();\n        int left = 0, right = m * n - 1;\n        while (left < right) {\n            int mid = left + right >> 1;\n            int x = mid / n, y = mid % n;\n            if (matrix[x][y] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return matrix[left / n][left % n] == target;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# javascript\n\n/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nvar searchmatrix = function(matrix, target) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    let left = 0;\n    let right = m * n - 1;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        const x = math.floor(mid / n);\n        const y = mid % n;\n        if (matrix[x][y] >= target) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return matrix[math.floor(left / n)][left % n] == target;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# go\n\nfunc searchmatrix(matrix [][]int, target int) bool {\n\tm, n := len(matrix), len(matrix[0])\n\tleft, right := 0, m*n-1\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tx, y := mid/n, mid%n\n\t\tif matrix[x][y] >= target {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\treturn matrix[left/n][left%n] == target\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode75 Sort Colors-zh",frontmatter:{title:"leetcode75 Sort Colors-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d1d03e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode75 Sort Colors-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10075.leetcode75%20Sort%20Colors-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode75 Sort Colors-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10075.leetcode75%20Sort%20Colors-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode75 Sort Colors-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10075.leetcode75%20Sort%20Colors-zh.html",relativePath:"01.算法/24.leetcode/10075.leetcode75 Sort Colors-zh.md",key:"v-624d6567",path:"/p/d1d03e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:427},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:434},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1003},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1571},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1999},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2311}],headersStr:"题目描述 解法 Python3 Java C++ Go ...",content:'# 75. 颜色分类\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n \n\n示例 1：\n\n\n输入：nums = [2,0,2,1,1,0]\n输出：[0,0,1,1,2,2]\n\n\n示例 2：\n\n\n输入：nums = [2,0,1]\n输出：[0,1,2]\n\n\n示例 3：\n\n\n输入：nums = [0]\n输出：[0]\n\n\n示例 4：\n\n\n输入：nums = [1]\n输出：[1]\n\n\n \n\n提示：\n\n * n == nums.length\n * 1 <= n <= 300\n * nums[i] 为 0、1 或 2\n\n \n\n进阶：\n\n * 你可以不使用代码库中的排序函数来解决这道题吗？\n * 你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        """\n        Do not return anything, modify nums in-place instead.\n        """\n        i, j = -1, len(nums)\n        cur = 0\n        while cur < j:\n            if nums[cur] == 0:\n                i += 1\n                nums[cur], nums[i] = nums[i], nums[cur]\n                cur += 1\n            elif nums[cur] == 1:\n                cur += 1\n            else:\n                j -= 1\n                nums[cur], nums[j] = nums[j], nums[cur]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Java\n\nclass Solution {\n    public void sortColors(int[] nums) {\n        int i = -1, j = nums.length;\n        int cur = 0;\n        while (cur < j) {\n            if (nums[cur] == 0) {\n                swap(nums, cur++, ++i);\n            } else if (nums[cur] == 1) {\n                ++cur;\n            } else {\n                swap(nums, cur, --j);\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int t = nums[i];\n        nums[i] = nums[j];\n        nums[j] = t;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# C++\n\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int i = -1, j = nums.size(), cur = 0;\n        while (cur < j) {\n            if (nums[cur] == 0) {\n                swap(nums[++i], nums[cur++]);\n            } else if (nums[cur] == 1) {\n                ++cur;\n            } else {\n                swap(nums[cur], nums[--j]);\n            }\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Go\n\nfunc sortColors(nums []int) {\n\ti, j, cur := -1, len(nums), 0\n\tfor cur < j {\n\t\tif nums[cur] == 0 {\n\t\t\ti++\n\t\t\tnums[cur], nums[i] = nums[i], nums[cur]\n\t\t\tcur++\n\t\t} else if nums[cur] == 1 {\n\t\t\tcur++\n\t\t} else {\n\t\t\tj--\n\t\t\tnums[cur], nums[j] = nums[j], nums[cur]\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 75. 颜色分类\n\nenglish version\n\n\n# 题目描述\n\n给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n \n\n示例 1：\n\n\n输入：nums = [2,0,2,1,1,0]\n输出：[0,0,1,1,2,2]\n\n\n示例 2：\n\n\n输入：nums = [2,0,1]\n输出：[0,1,2]\n\n\n示例 3：\n\n\n输入：nums = [0]\n输出：[0]\n\n\n示例 4：\n\n\n输入：nums = [1]\n输出：[1]\n\n\n \n\n提示：\n\n * n == nums.length\n * 1 <= n <= 300\n * nums[i] 为 0、1 或 2\n\n \n\n进阶：\n\n * 你可以不使用代码库中的排序函数来解决这道题吗？\n * 你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def sortcolors(self, nums: list[int]) -> none:\n        """\n        do not return anything, modify nums in-place instead.\n        """\n        i, j = -1, len(nums)\n        cur = 0\n        while cur < j:\n            if nums[cur] == 0:\n                i += 1\n                nums[cur], nums[i] = nums[i], nums[cur]\n                cur += 1\n            elif nums[cur] == 1:\n                cur += 1\n            else:\n                j -= 1\n                nums[cur], nums[j] = nums[j], nums[cur]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# java\n\nclass solution {\n    public void sortcolors(int[] nums) {\n        int i = -1, j = nums.length;\n        int cur = 0;\n        while (cur < j) {\n            if (nums[cur] == 0) {\n                swap(nums, cur++, ++i);\n            } else if (nums[cur] == 1) {\n                ++cur;\n            } else {\n                swap(nums, cur, --j);\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int t = nums[i];\n        nums[i] = nums[j];\n        nums[j] = t;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# c++\n\nclass solution {\npublic:\n    void sortcolors(vector<int>& nums) {\n        int i = -1, j = nums.size(), cur = 0;\n        while (cur < j) {\n            if (nums[cur] == 0) {\n                swap(nums[++i], nums[cur++]);\n            } else if (nums[cur] == 1) {\n                ++cur;\n            } else {\n                swap(nums[cur], nums[--j]);\n            }\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# go\n\nfunc sortcolors(nums []int) {\n\ti, j, cur := -1, len(nums), 0\n\tfor cur < j {\n\t\tif nums[cur] == 0 {\n\t\t\ti++\n\t\t\tnums[cur], nums[i] = nums[i], nums[cur]\n\t\t\tcur++\n\t\t} else if nums[cur] == 1 {\n\t\t\tcur++\n\t\t} else {\n\t\t\tj--\n\t\t\tnums[cur], nums[j] = nums[j], nums[cur]\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode76 Minimum Window Substring-zh",frontmatter:{title:"leetcode76 Minimum Window Substring-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/8151b3/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode76 Minimum Window Substring-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10076.leetcode76%20Minimum%20Window%20Substring-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode76 Minimum Window Substring-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10076.leetcode76%20Minimum%20Window%20Substring-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode76 Minimum Window Substring-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10076.leetcode76%20Minimum%20Window%20Substring-zh.html",relativePath:"01.算法/24.leetcode/10076.leetcode76 Minimum Window Substring-zh.md",key:"v-2a6aeffc",path:"/p/8151b3/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:339},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:352},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:371},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:387},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1448}],headersStr:"题目描述 解法 Python3 Java TypeScript ...",content:'# 76. 最小覆盖子串\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。\n\n注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。\n\n \n\n示例 1：\n\n\n输入：s = "ADOBECODEBANC", t = "ABC"\n输出："BANC"\n\n\n示例 2：\n\n\n输入：s = "a", t = "a"\n输出："a"\n\n\n \n\n提示：\n\n * 1 <= s.length, t.length <= 105\n * s 和 t 由英文字母组成\n\n \n\n进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？\n\n\n# 解法\n\n滑动窗口\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# TypeScript\n\nfunction minWindow(s: string, t: string): string {\n    let n1 = s.length, n2 = t.length;\n    if (n1 < n2) return \'\';\n    let need = new Array(128).fill(0);\n    let window = new Array(128).fill(0);\n    for (let i = 0; i < n2; ++i) {\n        ++need[t.charCodeAt(i)];\n    }\n\n    let left = 0, right = 0;\n    let res = \'\';\n    let count = 0;\n    let min = n1 + 1;\n    while (right < n1) {\n        let cur = s.charCodeAt(right);\n        ++window[cur];\n        if (need[cur] > 0 && need[cur] >= window[cur]) {\n            ++count;\n        }\n        while (count == n2) {\n            cur = s.charCodeAt(left);\n            if (need[cur] > 0 && need[cur] >= window[cur]) {\n                --count;\n            }\n            if (right - left + 1 < min) {\n                min = right - left + 1;\n                res = s.slice(left, right + 1);\n            }\n            --window[cur];\n            ++left;\n        }\n        ++right;\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 76. 最小覆盖子串\n\nenglish version\n\n\n# 题目描述\n\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。\n\n注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。\n\n \n\n示例 1：\n\n\n输入：s = "adobecodebanc", t = "abc"\n输出："banc"\n\n\n示例 2：\n\n\n输入：s = "a", t = "a"\n输出："a"\n\n\n \n\n提示：\n\n * 1 <= s.length, t.length <= 105\n * s 和 t 由英文字母组成\n\n \n\n进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？\n\n\n# 解法\n\n滑动窗口\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# typescript\n\nfunction minwindow(s: string, t: string): string {\n    let n1 = s.length, n2 = t.length;\n    if (n1 < n2) return \'\';\n    let need = new array(128).fill(0);\n    let window = new array(128).fill(0);\n    for (let i = 0; i < n2; ++i) {\n        ++need[t.charcodeat(i)];\n    }\n\n    let left = 0, right = 0;\n    let res = \'\';\n    let count = 0;\n    let min = n1 + 1;\n    while (right < n1) {\n        let cur = s.charcodeat(right);\n        ++window[cur];\n        if (need[cur] > 0 && need[cur] >= window[cur]) {\n            ++count;\n        }\n        while (count == n2) {\n            cur = s.charcodeat(left);\n            if (need[cur] > 0 && need[cur] >= window[cur]) {\n                --count;\n            }\n            if (right - left + 1 < min) {\n                min = right - left + 1;\n                res = s.slice(left, right + 1);\n            }\n            --window[cur];\n            ++left;\n        }\n        ++right;\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode77 Combinations-zh",frontmatter:{title:"leetcode77 Combinations-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/c30f65/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode77 Combinations-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10077.leetcode77%20Combinations-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode77 Combinations-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10077.leetcode77%20Combinations-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode77 Combinations-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10077.leetcode77%20Combinations-zh.html",relativePath:"01.算法/24.leetcode/10077.leetcode77 Combinations-zh.md",key:"v-4ed47a78",path:"/p/c30f65/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:30},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:165},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:172},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:191},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:54}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 77. 组合\n\nEnglish Version\n\n\n# 题目描述\n\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n示例:\n\n输入: n = 4, k = 2\n输出:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 77. 组合\n\nenglish version\n\n\n# 题目描述\n\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n示例:\n\n输入: n = 4, k = 2\n输出:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode78 Subsets-zh",frontmatter:{title:"leetcode78 Subsets-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/be20e0/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode78 Subsets-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10078.leetcode78%20Subsets-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode78 Subsets-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10078.leetcode78%20Subsets-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode78 Subsets-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10078.leetcode78%20Subsets-zh.html",relativePath:"01.算法/24.leetcode/10078.leetcode78 Subsets-zh.md",key:"v-350b55c4",path:"/p/be20e0/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:30},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:309},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:637},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1078},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1677}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 78. 子集\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,3]\n输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n\n示例 2：\n\n\n输入：nums = [0]\n输出：[[],[0]]\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 10\n * -10 <= nums[i] <= 10\n * nums 中的所有元素 互不相同\n\n\n# 解法\n\n回溯法的基本模板：\n\nres = []\npath = []\n\ndef backtrack(未探索区域, res, path):\n    if path 满足条件:\n        res.add(path) # 深度拷贝\n        # return  # 如果不用继续搜索需要 return\n    for 选择 in 未探索区域当前可能的选择:\n        if 当前选择符合要求:\n            path.add(当前选择)\n            backtrack(新的未探索区域, res, path)\n            path.pop()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Python3\n\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        def dfs(nums, i, res, path):\n            res.append(copy.deepcopy(path))\n            while i < len(nums):\n                path.append(nums[i])\n                dfs(nums, i + 1, res, path)\n                path.pop()\n                i += 1\n        res, path = [], []\n        dfs(nums, 0, res, path)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<Integer> path = new ArrayList<>();\n        List<List<Integer>> res = new ArrayList<>();\n        dfs(nums, 0, res, path);\n        return res;\n    }\n\n    private void dfs(int[] nums, int i, List<List<Integer>> res, List<Integer> path) {\n        res.add(new ArrayList<>(path));\n        while (i < nums.length) {\n            path.add(nums[i]);\n            dfs(nums, i + 1, res, path);\n            path.remove(path.size() - 1);\n            ++i;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 78. 子集\n\nenglish version\n\n\n# 题目描述\n\n给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,3]\n输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n\n示例 2：\n\n\n输入：nums = [0]\n输出：[[],[0]]\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 10\n * -10 <= nums[i] <= 10\n * nums 中的所有元素 互不相同\n\n\n# 解法\n\n回溯法的基本模板：\n\nres = []\npath = []\n\ndef backtrack(未探索区域, res, path):\n    if path 满足条件:\n        res.add(path) # 深度拷贝\n        # return  # 如果不用继续搜索需要 return\n    for 选择 in 未探索区域当前可能的选择:\n        if 当前选择符合要求:\n            path.add(当前选择)\n            backtrack(新的未探索区域, res, path)\n            path.pop()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# python3\n\nclass solution:\n    def subsets(self, nums: list[int]) -> list[list[int]]:\n        def dfs(nums, i, res, path):\n            res.append(copy.deepcopy(path))\n            while i < len(nums):\n                path.append(nums[i])\n                dfs(nums, i + 1, res, path)\n                path.pop()\n                i += 1\n        res, path = [], []\n        dfs(nums, 0, res, path)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public list<list<integer>> subsets(int[] nums) {\n        list<integer> path = new arraylist<>();\n        list<list<integer>> res = new arraylist<>();\n        dfs(nums, 0, res, path);\n        return res;\n    }\n\n    private void dfs(int[] nums, int i, list<list<integer>> res, list<integer> path) {\n        res.add(new arraylist<>(path));\n        while (i < nums.length) {\n            path.add(nums[i]);\n            dfs(nums, i + 1, res, path);\n            path.remove(path.size() - 1);\n            ++i;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode79 Word Search-zh",frontmatter:{title:"leetcode79 Word Search-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/832da5/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0079.Word%20Search/images/word2.jpg"},{name:"twitter:title",content:"leetcode79 Word Search-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0079.Word%20Search/images/word2.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10079.leetcode79%20Word%20Search-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode79 Word Search-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0079.Word%20Search/images/word2.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10079.leetcode79%20Word%20Search-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode79 Word Search-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0079.Word%20Search/images/word2.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10079.leetcode79%20Word%20Search-zh.html",relativePath:"01.算法/24.leetcode/10079.leetcode79 Word Search-zh.md",key:"v-859a1432",path:"/p/832da5/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:675},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:702},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1562},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:2738},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3914}],headersStr:"题目描述 解法 Python3 Java TypeScript ...",content:'# 79. 单词搜索\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n \n\n示例 1：\n\n\n输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"\n输出：true\n\n\n示例 2：\n\n\n输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"\n输出：true\n\n\n示例 3：\n\n\n输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"\n输出：false\n\n\n \n\n提示：\n\n * m == board.length\n * n = board[i].length\n * 1 <= m, n <= 6\n * 1 <= word.length <= 15\n * board 和 word 仅由大小写英文字母组成\n\n \n\n进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？\n\n\n# 解法\n\n回溯（深度优先搜索 DFS ）实现。\n\n\n# Python3\n\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        def dfs(i, j, cur):\n            if cur == len(word):\n                return True\n            if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or word[cur] != board[i][j]:\n                return False\n            visited[i][j] = True\n            next = cur + 1\n            res = dfs(i + 1, j, next) or dfs(i - 1, j, next) or dfs(i, j + 1, next) or dfs(i, j - 1, next)\n            visited[i][j] = False\n            return res\n        m, n = len(board), len(board[0])\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                res = dfs(i, j, 0)\n                if res:\n                    return True\n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java\n\nclass Solution {\n    private boolean[][] visited;\n\n    public boolean exist(char[][] board, String word) {\n        int m = board.length, n = board[0].length;\n        visited = new boolean[m][n];\n        char[] chars = word.toCharArray();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                boolean res = dfs(board, i, j, chars, 0);\n                if (res) return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(char[][] board, int i, int j, char[] chars, int cur) {\n        if (cur == chars.length) return true;\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) return false;\n        if (visited[i][j] || board[i][j] != chars[cur]) return false;\n        visited[i][j] = true;\n        int next = cur + 1;\n        boolean res = dfs(board, i + 1, j, chars, next)\n                || dfs(board, i - 1, j, chars, next)\n                || dfs(board, i, j + 1, chars, next)\n                || dfs(board, i, j - 1, chars, next);\n        visited[i][j] = false;\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# TypeScript\n\nfunction exist(board: string[][], word: string): boolean {\n    let m = board.length, n = board[0].length;\n    let visited = Array.from({ length: m }, v => new Array(n).fill(false));\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (dfs(board, word, i, j, 0, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\nfunction dfs(board: string[][], word: string, i: number, j: number, depth: number, visited: boolean[][]): boolean {\n    let m = board.length, n = board[0].length;\n    if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || visited[i][j]) {\n        return false;\n    }\n    if (board[i][j] != word.charAt(depth)) {\n        return false;\n    }\n\n    if (depth == word.length - 1) {\n        return true;\n    }\n\n    visited[i][j] = true;\n    ++depth;\n    let res = false;\n    for (let [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\n        let x = i + dx, y = j + dy;\n        res = res || dfs(board, word, x, y, depth, visited);\n    }\n    visited[i][j] = false;\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 79. 单词搜索\n\nenglish version\n\n\n# 题目描述\n\n给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n \n\n示例 1：\n\n\n输入：board = [["a","b","c","e"],["s","f","c","s"],["a","d","e","e"]], word = "abcced"\n输出：true\n\n\n示例 2：\n\n\n输入：board = [["a","b","c","e"],["s","f","c","s"],["a","d","e","e"]], word = "see"\n输出：true\n\n\n示例 3：\n\n\n输入：board = [["a","b","c","e"],["s","f","c","s"],["a","d","e","e"]], word = "abcb"\n输出：false\n\n\n \n\n提示：\n\n * m == board.length\n * n = board[i].length\n * 1 <= m, n <= 6\n * 1 <= word.length <= 15\n * board 和 word 仅由大小写英文字母组成\n\n \n\n进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？\n\n\n# 解法\n\n回溯（深度优先搜索 dfs ）实现。\n\n\n# python3\n\nclass solution:\n    def exist(self, board: list[list[str]], word: str) -> bool:\n        def dfs(i, j, cur):\n            if cur == len(word):\n                return true\n            if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or word[cur] != board[i][j]:\n                return false\n            visited[i][j] = true\n            next = cur + 1\n            res = dfs(i + 1, j, next) or dfs(i - 1, j, next) or dfs(i, j + 1, next) or dfs(i, j - 1, next)\n            visited[i][j] = false\n            return res\n        m, n = len(board), len(board[0])\n        visited = [[false for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                res = dfs(i, j, 0)\n                if res:\n                    return true\n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java\n\nclass solution {\n    private boolean[][] visited;\n\n    public boolean exist(char[][] board, string word) {\n        int m = board.length, n = board[0].length;\n        visited = new boolean[m][n];\n        char[] chars = word.tochararray();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                boolean res = dfs(board, i, j, chars, 0);\n                if (res) return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(char[][] board, int i, int j, char[] chars, int cur) {\n        if (cur == chars.length) return true;\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) return false;\n        if (visited[i][j] || board[i][j] != chars[cur]) return false;\n        visited[i][j] = true;\n        int next = cur + 1;\n        boolean res = dfs(board, i + 1, j, chars, next)\n                || dfs(board, i - 1, j, chars, next)\n                || dfs(board, i, j + 1, chars, next)\n                || dfs(board, i, j - 1, chars, next);\n        visited[i][j] = false;\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# typescript\n\nfunction exist(board: string[][], word: string): boolean {\n    let m = board.length, n = board[0].length;\n    let visited = array.from({ length: m }, v => new array(n).fill(false));\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (dfs(board, word, i, j, 0, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\nfunction dfs(board: string[][], word: string, i: number, j: number, depth: number, visited: boolean[][]): boolean {\n    let m = board.length, n = board[0].length;\n    if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || visited[i][j]) {\n        return false;\n    }\n    if (board[i][j] != word.charat(depth)) {\n        return false;\n    }\n\n    if (depth == word.length - 1) {\n        return true;\n    }\n\n    visited[i][j] = true;\n    ++depth;\n    let res = false;\n    for (let [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\n        let x = i + dx, y = j + dy;\n        res = res || dfs(board, word, x, y, depth, visited);\n    }\n    visited[i][j] = false;\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode80 Remove Duplicates from Sorted Array II-zh",frontmatter:{title:"leetcode80 Remove Duplicates from Sorted Array II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/2f5116/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode80 Remove Duplicates from Sorted Array II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10080.leetcode80%20Remove%20Duplicates%20from%20Sorted%20Array%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode80 Remove Duplicates from Sorted Array II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10080.leetcode80%20Remove%20Duplicates%20from%20Sorted%20Array%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode80 Remove Duplicates from Sorted Array II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10080.leetcode80%20Remove%20Duplicates%20from%20Sorted%20Array%20II-zh.html",relativePath:"01.算法/24.leetcode/10080.leetcode80 Remove Duplicates from Sorted Array II-zh.md",key:"v-f862e242",path:"/p/2f5116/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:42},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:812},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1038},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1442},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1779},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:2149},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2502},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2944}],headersStr:"题目描述 解法 Python3 Java C++ C# JavaScript ...",content:"# 80. 删除有序数组中的重复项 II\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n \n\n说明：\n\n为什么返回数值是整数，但输出的答案是数组呢？\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n\n \n\n示例 1：\n\n\n输入：nums = [1,1,1,2,2,3]\n输出：5, nums = [1,1,2,2,3]\n解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。\n\n\n示例 2：\n\n\n输入：nums = [0,0,1,1,1,1,2,3,3]\n输出：7, nums = [0,0,1,1,2,3,3]\n解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 3 * 104\n * -104 <= nums[i] <= 104\n * nums 已按升序排列\n\n\n# 解法\n\n从数组下标 1 开始遍历数组。\n\n用计数器 cnt 记录当前数字重复出现的次数，cnt 的最小计数为 0；用 cur 记录新数组下个待覆盖的元素位置。\n\n遍历时，若当前元素 nums[i] 与上个元素 nums[i-1] 相同，则计数器 +1，否则计数器重置为 0。如果计数器小于 2，说明当前元素 nums[i] 可以添加到新数组中，即：nums[cur] = nums[i]，同时 cur++。\n\n遍历结果，返回 cur 值即可。\n\n\n# Python3\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = len(nums)\n        cnt, cur = 0, 1\n        for i in range(1, n):\n            if nums[i] == nums[i - 1]:\n                cnt += 1\n            else:\n                cnt = 0\n            if cnt < 2:\n                nums[cur] = nums[i]\n                cur += 1\n        return cur\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int cnt = 0, cur = 1;\n        for (int i = 1; i < nums.length; ++i) {\n            if (nums[i] == nums[i - 1]) ++cnt;\n            else cnt = 0;\n            if (cnt < 2) nums[cur++] = nums[i];\n        }\n        return cur;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        int cnt = 0, cur = 1;\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] == nums[i - 1]) ++cnt;\n            else cnt = 0;\n            if (cnt < 2) nums[cur++] = nums[i];\n        }\n        return cur;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# C#\n\npublic class Solution {\n    public int RemoveDuplicates(int[] nums) {\n        int cnt = 0, cur = 1;\n        for (int i = 1; i < nums.Length; ++i)\n        {\n            if (nums[i] == nums[i - 1]) ++cnt;\n            else cnt = 0;\n            if (cnt < 2) nums[cur++] = nums[i];\n        }\n        return cur;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n    if (nums.length == 0) return 0;\n    let len = nums.length;\n    let j = 0;\n    for (let i = 0; i < nums.length - 1; i++) {\n        if (nums[i] != nums[i - 1] || nums[i] != nums[i + 1]) {\n            nums[j++] = nums[i];\n        }\n    }\n    nums[j] = nums[len - 1];\n    return j + 1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 80. 删除有序数组中的重复项 ii\n\nenglish version\n\n\n# 题目描述\n\n给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 o(1) 额外空间的条件下完成。\n\n \n\n说明：\n\n为什么返回数值是整数，但输出的答案是数组呢？\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeduplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n\n \n\n示例 1：\n\n\n输入：nums = [1,1,1,2,2,3]\n输出：5, nums = [1,1,2,2,3]\n解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。\n\n\n示例 2：\n\n\n输入：nums = [0,0,1,1,1,1,2,3,3]\n输出：7, nums = [0,0,1,1,2,3,3]\n解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 3 * 104\n * -104 <= nums[i] <= 104\n * nums 已按升序排列\n\n\n# 解法\n\n从数组下标 1 开始遍历数组。\n\n用计数器 cnt 记录当前数字重复出现的次数，cnt 的最小计数为 0；用 cur 记录新数组下个待覆盖的元素位置。\n\n遍历时，若当前元素 nums[i] 与上个元素 nums[i-1] 相同，则计数器 +1，否则计数器重置为 0。如果计数器小于 2，说明当前元素 nums[i] 可以添加到新数组中，即：nums[cur] = nums[i]，同时 cur++。\n\n遍历结果，返回 cur 值即可。\n\n\n# python3\n\nclass solution:\n    def removeduplicates(self, nums: list[int]) -> int:\n        n = len(nums)\n        cnt, cur = 0, 1\n        for i in range(1, n):\n            if nums[i] == nums[i - 1]:\n                cnt += 1\n            else:\n                cnt = 0\n            if cnt < 2:\n                nums[cur] = nums[i]\n                cur += 1\n        return cur\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\nclass solution {\n    public int removeduplicates(int[] nums) {\n        int cnt = 0, cur = 1;\n        for (int i = 1; i < nums.length; ++i) {\n            if (nums[i] == nums[i - 1]) ++cnt;\n            else cnt = 0;\n            if (cnt < 2) nums[cur++] = nums[i];\n        }\n        return cur;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# c++\n\nclass solution {\npublic:\n    int removeduplicates(vector<int>& nums) {\n        int n = nums.size();\n        int cnt = 0, cur = 1;\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] == nums[i - 1]) ++cnt;\n            else cnt = 0;\n            if (cnt < 2) nums[cur++] = nums[i];\n        }\n        return cur;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# c#\n\npublic class solution {\n    public int removeduplicates(int[] nums) {\n        int cnt = 0, cur = 1;\n        for (int i = 1; i < nums.length; ++i)\n        {\n            if (nums[i] == nums[i - 1]) ++cnt;\n            else cnt = 0;\n            if (cnt < 2) nums[cur++] = nums[i];\n        }\n        return cur;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeduplicates = function (nums) {\n    if (nums.length == 0) return 0;\n    let len = nums.length;\n    let j = 0;\n    for (let i = 0; i < nums.length - 1; i++) {\n        if (nums[i] != nums[i - 1] || nums[i] != nums[i + 1]) {\n            nums[j++] = nums[i];\n        }\n    }\n    nums[j] = nums[len - 1];\n    return j + 1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode81 Search in Rotated Sorted Array II-zh",frontmatter:{title:"leetcode81 Search in Rotated Sorted Array II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d72c14/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode81 Search in Rotated Sorted Array II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10081.leetcode81%20Search%20in%20Rotated%20Sorted%20Array%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode81 Search in Rotated Sorted Array II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10081.leetcode81%20Search%20in%20Rotated%20Sorted%20Array%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode81 Search in Rotated Sorted Array II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10081.leetcode81%20Search%20in%20Rotated%20Sorted%20Array%20II-zh.html",relativePath:"01.算法/24.leetcode/10081.leetcode81 Search in Rotated Sorted Array II-zh.md",key:"v-911a4cb2",path:"/p/d72c14/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:723},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:737},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1505},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2192},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:167}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 81. 搜索旋转排序数组 II\n\nEnglish Version\n\n\n# 题目描述\n\n已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。\n\n \n\n示例 1：\n\n\n输入：nums = [2,5,6,0,0,1,2], target = 0\n输出：true\n\n\n示例 2：\n\n\n输入：nums = [2,5,6,0,0,1,2], target = 3\n输出：false\n\n \n\n提示：\n\n * 1 <= nums.length <= 5000\n * -104 <= nums[i] <= 104\n * 题目数据保证 nums 在预先未知的某个下标上进行了旋转\n * -104 <= target <= 104\n\n \n\n进阶：\n\n * 这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。\n * 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？\n\n\n# 解法\n\n二分查找。\n\n\n# Python3\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) >> 1\n            if nums[mid] == target:\n                return True\n            if nums[mid] < nums[r] or nums[mid] < nums[l]:\n                if target > nums[mid] and target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            elif nums[mid] > nums[l] or nums[mid] > nums[r]:\n                if target < nums[mid] and target >= nums[l]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                r -= 1\n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java\n\nclass Solution {\n    public boolean search(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = (l + r) >>> 1;\n            if (nums[mid] == target) return true;\n            if (nums[mid] < nums[r] || nums[mid] < nums[l]) {\n                if (target > nums[mid] && target <= nums[r]) l = mid + 1;\n                else r = mid - 1;\n            } else if (nums[mid] > nums[l] || nums[mid] > nums[r]) {\n                if (target < nums[mid] && target >= nums[l]) r = mid - 1;\n                else l = mid + 1;\n            } else r--;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# C++\n\nclass Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l <= r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] == target) return true;\n            if (nums[mid] < nums[r] || nums[mid] < nums[l]) {\n                if (target > nums[mid] && target <= nums[r]) l = mid + 1;\n                else r = mid - 1;\n            } else if (nums[mid] > nums[l] || nums[mid] > nums[r]) {\n                if (target < nums[mid] && target >= nums[l]) r = mid - 1;\n                else l = mid + 1;\n            } else r--;\n        }\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 81. 搜索旋转排序数组 ii\n\nenglish version\n\n\n# 题目描述\n\n已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。\n\n \n\n示例 1：\n\n\n输入：nums = [2,5,6,0,0,1,2], target = 0\n输出：true\n\n\n示例 2：\n\n\n输入：nums = [2,5,6,0,0,1,2], target = 3\n输出：false\n\n \n\n提示：\n\n * 1 <= nums.length <= 5000\n * -104 <= nums[i] <= 104\n * 题目数据保证 nums 在预先未知的某个下标上进行了旋转\n * -104 <= target <= 104\n\n \n\n进阶：\n\n * 这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。\n * 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？\n\n\n# 解法\n\n二分查找。\n\n\n# python3\n\nclass solution:\n    def search(self, nums: list[int], target: int) -> bool:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) >> 1\n            if nums[mid] == target:\n                return true\n            if nums[mid] < nums[r] or nums[mid] < nums[l]:\n                if target > nums[mid] and target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            elif nums[mid] > nums[l] or nums[mid] > nums[r]:\n                if target < nums[mid] and target >= nums[l]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                r -= 1\n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java\n\nclass solution {\n    public boolean search(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = (l + r) >>> 1;\n            if (nums[mid] == target) return true;\n            if (nums[mid] < nums[r] || nums[mid] < nums[l]) {\n                if (target > nums[mid] && target <= nums[r]) l = mid + 1;\n                else r = mid - 1;\n            } else if (nums[mid] > nums[l] || nums[mid] > nums[r]) {\n                if (target < nums[mid] && target >= nums[l]) r = mid - 1;\n                else l = mid + 1;\n            } else r--;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# c++\n\nclass solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l <= r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] == target) return true;\n            if (nums[mid] < nums[r] || nums[mid] < nums[l]) {\n                if (target > nums[mid] && target <= nums[r]) l = mid + 1;\n                else r = mid - 1;\n            } else if (nums[mid] > nums[l] || nums[mid] > nums[r]) {\n                if (target < nums[mid] && target >= nums[l]) r = mid - 1;\n                else l = mid + 1;\n            } else r--;\n        }\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode82 Remove Duplicates from Sorted List II-zh",frontmatter:{title:"leetcode82 Remove Duplicates from Sorted List II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/3f819f/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0082.Remove%20Duplicates%20from%20Sorted%20List%20II/images/linkedlist1.jpg"},{name:"twitter:title",content:"leetcode82 Remove Duplicates from Sorted List II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0082.Remove%20Duplicates%20from%20Sorted%20List%20II/images/linkedlist1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10082.leetcode82%20Remove%20Duplicates%20from%20Sorted%20List%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode82 Remove Duplicates from Sorted List II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0082.Remove%20Duplicates%20from%20Sorted%20List%20II/images/linkedlist1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10082.leetcode82%20Remove%20Duplicates%20from%20Sorted%20List%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode82 Remove Duplicates from Sorted List II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0082.Remove%20Duplicates%20from%20Sorted%20List%20II/images/linkedlist1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10082.leetcode82%20Remove%20Duplicates%20from%20Sorted%20List%20II-zh.html",relativePath:"01.算法/24.leetcode/10082.leetcode82 Remove Duplicates from Sorted List II-zh.md",key:"v-949ed272",path:"/p/3f819f/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:43},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:313},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:320},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:963},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1853},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2788}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 82. 删除排序链表中的重复元素 II\n\nEnglish Version\n\n\n# 题目描述\n\n存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。\n\n返回同样按升序排列的结果链表。\n\n \n\n示例 1：\n\n\n输入：head = [1,2,3,3,4,4,5]\n输出：[1,2,5]\n\n\n示例 2：\n\n\n输入：head = [1,1,1,2,3]\n输出：[2,3]\n\n\n \n\n提示：\n\n * 链表中节点数目在范围 [0, 300] 内\n * -100 <= Node.val <= 100\n * 题目数据保证链表已经按升序排列\n\n\n# 解法\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        dummy = ListNode(-1, head)\n        cur = dummy\n        while cur.next and cur.next.next:\n            if cur.next.val == cur.next.next.val:\n                val = cur.next.val\n                while cur.next and cur.next.val == val:\n                    cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode dummy = new ListNode(-1, head);\n        ListNode cur = dummy;\n        while (cur.next != null && cur.next.next != null) {\n            if (cur.next.val == cur.next.next.val) {\n                int val = cur.next.val;\n                while (cur.next != null && cur.next.val == val) {\n                    cur.next = cur.next.next;\n                }\n            } else {\n                cur = cur.next;\n            }\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* dummy = new ListNode(-1, head);\n        ListNode* cur = dummy;\n        while (cur->next != nullptr && cur->next->next != nullptr) {\n            if (cur->next->val == cur->next->next->val) {\n                int val = cur->next->val;\n                while (cur->next != nullptr && cur->next->val == val) {\n                    cur->next = cur->next->next;\n                }\n            } else {\n                cur = cur->next;\n            }\n        }\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 82. 删除排序链表中的重复元素 ii\n\nenglish version\n\n\n# 题目描述\n\n存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。\n\n返回同样按升序排列的结果链表。\n\n \n\n示例 1：\n\n\n输入：head = [1,2,3,3,4,4,5]\n输出：[1,2,5]\n\n\n示例 2：\n\n\n输入：head = [1,1,1,2,3]\n输出：[2,3]\n\n\n \n\n提示：\n\n * 链表中节点数目在范围 [0, 300] 内\n * -100 <= node.val <= 100\n * 题目数据保证链表已经按升序排列\n\n\n# 解法\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def deleteduplicates(self, head: listnode) -> listnode:\n        dummy = listnode(-1, head)\n        cur = dummy\n        while cur.next and cur.next.next:\n            if cur.next.val == cur.next.next.val:\n                val = cur.next.val\n                while cur.next and cur.next.val == val:\n                    cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode deleteduplicates(listnode head) {\n        listnode dummy = new listnode(-1, head);\n        listnode cur = dummy;\n        while (cur.next != null && cur.next.next != null) {\n            if (cur.next.val == cur.next.next.val) {\n                int val = cur.next.val;\n                while (cur.next != null && cur.next.val == val) {\n                    cur.next = cur.next.next;\n                }\n            } else {\n                cur = cur.next;\n            }\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* deleteduplicates(listnode* head) {\n        listnode* dummy = new listnode(-1, head);\n        listnode* cur = dummy;\n        while (cur->next != nullptr && cur->next->next != nullptr) {\n            if (cur->next->val == cur->next->next->val) {\n                int val = cur->next->val;\n                while (cur->next != nullptr && cur->next->val == val) {\n                    cur->next = cur->next->next;\n                }\n            } else {\n                cur = cur->next;\n            }\n        }\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode83 Remove Duplicates from Sorted List-zh",frontmatter:{title:"leetcode83 Remove Duplicates from Sorted List-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/54a9ff/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0083.Remove%20Duplicates%20from%20Sorted%20List/images/list1.jpg"},{name:"twitter:title",content:"leetcode83 Remove Duplicates from Sorted List-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0083.Remove%20Duplicates%20from%20Sorted%20List/images/list1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10083.leetcode83%20Remove%20Duplicates%20from%20Sorted%20List-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode83 Remove Duplicates from Sorted List-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0083.Remove%20Duplicates%20from%20Sorted%20List/images/list1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10083.leetcode83%20Remove%20Duplicates%20from%20Sorted%20List-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode83 Remove Duplicates from Sorted List-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0083.Remove%20Duplicates%20from%20Sorted%20List/images/list1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10083.leetcode83%20Remove%20Duplicates%20from%20Sorted%20List-zh.html",relativePath:"01.算法/24.leetcode/10083.leetcode83 Remove Duplicates from Sorted List-zh.md",key:"v-2687274a",path:"/p/54a9ff/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:40},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:286},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:293},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:770},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1444},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2149},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2430}],headersStr:"题目描述 解法 Python3 Java C++ Go ...",content:"# 83. 删除排序链表中的重复元素\n\nEnglish Version\n\n\n# 题目描述\n\n存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。\n\n返回同样按升序排列的结果链表。\n\n \n\n示例 1：\n\n\n输入：head = [1,1,2]\n输出：[1,2]\n\n\n示例 2：\n\n\n输入：head = [1,1,2,3,3]\n输出：[1,2,3]\n\n\n \n\n提示：\n\n * 链表中节点数目在范围 [0, 300] 内\n * -100 <= Node.val <= 100\n * 题目数据保证链表已经按升序排列\n\n\n# 解法\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        cur = head\n        while cur and cur.next:\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode cur = head;\n        while (cur != null && cur.next != null) {\n            if (cur.val == cur.next.val) {\n                cur.next = cur.next.next;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* cur = head;\n        while (cur != nullptr && cur->next != nullptr) {\n            if (cur->val == cur->next->val) {\n                cur->next = cur->next->next;\n            } else {\n                cur = cur->next;\n            }\n        }\n        return head;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Go\n\nfunc deleteDuplicates(head *ListNode) *ListNode {\n\tcurrent := head\n\tfor current != nil && current.Next != nil {\n\t\tif current.Val == current.Next.Val {\n\t\t\tcurrent.Next = current.Next.Next\n\t\t} else {\n\t\t\tcurrent = current.Next\n\t\t}\n\t}\n\treturn head\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 83. 删除排序链表中的重复元素\n\nenglish version\n\n\n# 题目描述\n\n存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。\n\n返回同样按升序排列的结果链表。\n\n \n\n示例 1：\n\n\n输入：head = [1,1,2]\n输出：[1,2]\n\n\n示例 2：\n\n\n输入：head = [1,1,2,3,3]\n输出：[1,2,3]\n\n\n \n\n提示：\n\n * 链表中节点数目在范围 [0, 300] 内\n * -100 <= node.val <= 100\n * 题目数据保证链表已经按升序排列\n\n\n# 解法\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def deleteduplicates(self, head: listnode) -> listnode:\n        cur = head\n        while cur and cur.next:\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode deleteduplicates(listnode head) {\n        listnode cur = head;\n        while (cur != null && cur.next != null) {\n            if (cur.val == cur.next.val) {\n                cur.next = cur.next.next;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* deleteduplicates(listnode* head) {\n        listnode* cur = head;\n        while (cur != nullptr && cur->next != nullptr) {\n            if (cur->val == cur->next->val) {\n                cur->next = cur->next->next;\n            } else {\n                cur = cur->next;\n            }\n        }\n        return head;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# go\n\nfunc deleteduplicates(head *listnode) *listnode {\n\tcurrent := head\n\tfor current != nil && current.next != nil {\n\t\tif current.val == current.next.val {\n\t\t\tcurrent.next = current.next.next\n\t\t} else {\n\t\t\tcurrent = current.next\n\t\t}\n\t}\n\treturn head\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode84 Largest Rectangle in Histogram-zh",frontmatter:{title:"leetcode84 Largest Rectangle in Histogram-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/61c799/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0084.Largest%20Rectangle%20in%20Histogram/images/histogram.png"},{name:"twitter:title",content:"leetcode84 Largest Rectangle in Histogram-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0084.Largest%20Rectangle%20in%20Histogram/images/histogram.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10084.leetcode84%20Largest%20Rectangle%20in%20Histogram-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode84 Largest Rectangle in Histogram-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0084.Largest%20Rectangle%20in%20Histogram/images/histogram.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10084.leetcode84%20Largest%20Rectangle%20in%20Histogram-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode84 Largest Rectangle in Histogram-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0084.Largest%20Rectangle%20in%20Histogram/images/histogram.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10084.leetcode84%20Largest%20Rectangle%20in%20Histogram-zh.html",relativePath:"01.算法/24.leetcode/10084.leetcode84 Largest Rectangle in Histogram-zh.md",key:"v-eb81604a",path:"/p/61c799/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:241},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:248},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:267},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:283}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 84. 柱状图中最大的矩形\n\nEnglish Version\n\n\n# 题目描述\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n \n\n\n\n以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。\n\n \n\n\n\n图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。\n\n \n\n示例:\n\n输入: [2,1,5,6,2,3]\n输出: 10\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 84. 柱状图中最大的矩形\n\nenglish version\n\n\n# 题目描述\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n \n\n\n\n以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。\n\n \n\n\n\n图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。\n\n \n\n示例:\n\n输入: [2,1,5,6,2,3]\n输出: 10\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode85 Maximal Rectangle-zh",frontmatter:{title:"leetcode85 Maximal Rectangle-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/54fa5d/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0085.Maximal%20Rectangle/images/maximal.jpg"},{name:"twitter:title",content:"leetcode85 Maximal Rectangle-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0085.Maximal%20Rectangle/images/maximal.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10085.leetcode85%20Maximal%20Rectangle-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode85 Maximal Rectangle-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0085.Maximal%20Rectangle/images/maximal.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10085.leetcode85%20Maximal%20Rectangle-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode85 Maximal Rectangle-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0085.Maximal%20Rectangle/images/maximal.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10085.leetcode85%20Maximal%20Rectangle-zh.html",relativePath:"01.算法/24.leetcode/10085.leetcode85 Maximal Rectangle-zh.md",key:"v-3b2ed841",path:"/p/54fa5d/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:492},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:499},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:518},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:534}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 85. 最大矩形\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n\n \n\n示例 1：\n\n\n输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]\n输出：6\n解释：最大矩形如上图所示。\n\n\n示例 2：\n\n\n输入：matrix = []\n输出：0\n\n\n示例 3：\n\n\n输入：matrix = [["0"]]\n输出：0\n\n\n示例 4：\n\n\n输入：matrix = [["1"]]\n输出：1\n\n\n示例 5：\n\n\n输入：matrix = [["0","0"]]\n输出：0\n\n\n \n\n提示：\n\n * rows == matrix.length\n * cols == matrix[0].length\n * 0 <= row, cols <= 200\n * matrix[i][j] 为 \'0\' 或 \'1\'\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 85. 最大矩形\n\nenglish version\n\n\n# 题目描述\n\n给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n\n \n\n示例 1：\n\n\n输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]\n输出：6\n解释：最大矩形如上图所示。\n\n\n示例 2：\n\n\n输入：matrix = []\n输出：0\n\n\n示例 3：\n\n\n输入：matrix = [["0"]]\n输出：0\n\n\n示例 4：\n\n\n输入：matrix = [["1"]]\n输出：1\n\n\n示例 5：\n\n\n输入：matrix = [["0","0"]]\n输出：0\n\n\n \n\n提示：\n\n * rows == matrix.length\n * cols == matrix[0].length\n * 0 <= row, cols <= 200\n * matrix[i][j] 为 \'0\' 或 \'1\'\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode86 Partition List-zh",frontmatter:{title:"leetcode86 Partition List-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/4b39e8/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0086.Partition%20List/images/partition.jpg"},{name:"twitter:title",content:"leetcode86 Partition List-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0086.Partition%20List/images/partition.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10086.leetcode86%20Partition%20List-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode86 Partition List-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0086.Partition%20List/images/partition.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10086.leetcode86%20Partition%20List-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode86 Partition List-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0086.Partition%20List/images/partition.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10086.leetcode86%20Partition%20List-zh.html",relativePath:"01.算法/24.leetcode/10086.leetcode86 Partition List-zh.md",key:"v-1b79f9b2",path:"/p/4b39e8/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:322},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:376},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1043},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1946},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2903}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 86. 分隔链表\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。\n\n你应当 保留 两个分区中每个节点的初始相对位置。\n\n \n\n示例 1：\n\n\n输入：head = [1,4,3,2,5,2], x = 3\n输出：[1,2,2,4,3,5]\n\n\n示例 2：\n\n\n输入：head = [2,1], x = 2\n输出：[1,2]\n\n\n \n\n提示：\n\n * 链表中节点的数目在范围 [0, 200] 内\n * -100 <= Node.val <= 100\n * -200 <= x <= 200\n\n\n# 解法\n\n创建两个链表，一个存放小于 x 的节点，另一个存放大于等于 x 的节点，之后进行拼接即可。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: ListNode, x: int) -> ListNode:\n        l1, l2 = ListNode(), ListNode()\n        cur1, cur2 = l1, l2\n        while head:\n            if head.val < x:\n                cur1.next = head\n                cur1 = cur1.next\n            else:\n                cur2.next = head\n                cur2 = cur2.next\n            head = head.next\n        cur1.next = l2.next\n        cur2.next = None\n        return l1.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode l1 = new ListNode(0);\n        ListNode l2 = new ListNode(0);\n        ListNode cur1 = l1, cur2 = l2;\n        while (head != null) {\n            if (head.val < x) {\n                cur1.next = head;\n                cur1 = cur1.next;\n            } else {\n                cur2.next = head;\n                cur2 = cur2.next;\n            }\n            head = head.next;\n        }\n        cur1.next = l2.next;\n        cur2.next = null;\n        return l1.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode* l1 = new ListNode();\n        ListNode* l2 = new ListNode();\n        ListNode* cur1 = l1;\n        ListNode* cur2 = l2;\n        while (head != nullptr) {\n            if (head->val < x) {\n                cur1->next = head;\n                cur1 = cur1->next;\n            } else {\n                cur2->next = head;\n                cur2 = cur2->next;\n            }\n            head = head->next;\n        }\n        cur1->next = l2->next;\n        cur2->next = nullptr;\n        return l1->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 86. 分隔链表\n\nenglish version\n\n\n# 题目描述\n\n给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。\n\n你应当 保留 两个分区中每个节点的初始相对位置。\n\n \n\n示例 1：\n\n\n输入：head = [1,4,3,2,5,2], x = 3\n输出：[1,2,2,4,3,5]\n\n\n示例 2：\n\n\n输入：head = [2,1], x = 2\n输出：[1,2]\n\n\n \n\n提示：\n\n * 链表中节点的数目在范围 [0, 200] 内\n * -100 <= node.val <= 100\n * -200 <= x <= 200\n\n\n# 解法\n\n创建两个链表，一个存放小于 x 的节点，另一个存放大于等于 x 的节点，之后进行拼接即可。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def partition(self, head: listnode, x: int) -> listnode:\n        l1, l2 = listnode(), listnode()\n        cur1, cur2 = l1, l2\n        while head:\n            if head.val < x:\n                cur1.next = head\n                cur1 = cur1.next\n            else:\n                cur2.next = head\n                cur2 = cur2.next\n            head = head.next\n        cur1.next = l2.next\n        cur2.next = none\n        return l1.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode partition(listnode head, int x) {\n        listnode l1 = new listnode(0);\n        listnode l2 = new listnode(0);\n        listnode cur1 = l1, cur2 = l2;\n        while (head != null) {\n            if (head.val < x) {\n                cur1.next = head;\n                cur1 = cur1.next;\n            } else {\n                cur2.next = head;\n                cur2 = cur2.next;\n            }\n            head = head.next;\n        }\n        cur1.next = l2.next;\n        cur2.next = null;\n        return l1.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* partition(listnode* head, int x) {\n        listnode* l1 = new listnode();\n        listnode* l2 = new listnode();\n        listnode* cur1 = l1;\n        listnode* cur2 = l2;\n        while (head != nullptr) {\n            if (head->val < x) {\n                cur1->next = head;\n                cur1 = cur1->next;\n            } else {\n                cur2->next = head;\n                cur2 = cur2->next;\n            }\n            head = head->next;\n        }\n        cur1->next = l2->next;\n        cur2->next = nullptr;\n        return l1->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode87 Scramble String-zh",frontmatter:{title:"leetcode87 Scramble String-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/9b9658/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/leetcode87-demo.png"},{name:"twitter:title",content:"leetcode87 Scramble String-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/leetcode87-demo.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10087.leetcode87%20Scramble%20String-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode87 Scramble String-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/leetcode87-demo.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10087.leetcode87%20Scramble%20String-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode87 Scramble String-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/leetcode87-demo.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10087.leetcode87%20Scramble%20String-zh.html",relativePath:"01.算法/24.leetcode/10087.leetcode87 Scramble String-zh.md",key:"v-91a43932",path:"/p/9b9658/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1068},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1412},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2353},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3659}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 87. 扰乱字符串\n\nEnglish Version\n\n\n# 题目描述\n\n使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：\n\n 1. 如果字符串的长度为 1 ，算法停止\n 2. 如果字符串的长度 > 1 ，执行下述步骤：\n    * 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。\n    * 随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。\n    * 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。\n\n\n\n给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。\n\n \n\n示例 1：\n\n\n输入：s1 = "great", s2 = "rgeat"\n输出：true\n解释：s1 上可能发生的一种情形是：\n"great" --\x3e "gr/eat" // 在一个随机下标处分割得到两个子字符串\n"gr/eat" --\x3e "gr/eat" // 随机决定：「保持这两个子字符串的顺序不变」\n"gr/eat" --\x3e "g/r / e/at" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割\n"g/r / e/at" --\x3e "r/g / e/at" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」\n"r/g / e/at" --\x3e "r/g / e/ a/t" // 继续递归执行此算法，将 "at" 分割得到 "a/t"\n"r/g / e/ a/t" --\x3e "r/g / e/ a/t" // 随机决定：「保持这两个子字符串的顺序不变」\n算法终止，结果字符串和 s2 相同，都是 "rgeat"\n这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true\n\n\n示例 2：\n\n\n输入：s1 = "abcde", s2 = "caebd"\n输出：false\n\n\n示例 3：\n\n\n输入：s1 = "a", s2 = "a"\n输出：true\n\n\n \n\n提示：\n\n * s1.length == s2.length\n * 1 <= s1.length <= 30\n * s1 和 s2 由小写英文字母组成\n\n\n# 解法\n\n动态规划法。\n\n假设 dp[i][j][len] 表示从字符串 S 中 i 开始长度为 len 的字符串是否能变换为从字符串 T 中 j 开始长度为 len 的字符串。题目可转变为求 dp[0][0][n]。\n\n在 len 为 1 的情况下，只需要判断 S[i] 是否等于 T[j]。所以可以对 dp 进行初始化：dp[i][j][1] = S[i] == T[j]，其中，i,j ∈ [0, n)。\n\n在 len 大于 1 的情况下，枚举 S 的长度 i ∈ [1, len-1]，dp[i1][i2][i] 表示 S1 能变成 T1，dp[i1 + i][i2 + i][len - i] 表示 S2 能变成 T2；或者 S1 能变成 T2，S2 能变成 T1。\n\n\n\n\n# Python3\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n = len(s1)\n        dp = [[[False] * (n + 1) for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                dp[i][j][1] = s1[i] == s2[j]\n        # 枚举长度区间[2, n]\n        for l in range(2, n + 1):\n            # 枚举s1的起始位置\n            for i1 in range(n - l + 1):\n                # 枚举s2的起始位置\n                for i2 in range(n - l + 1):\n                    # 枚举分割的位置\n                    for i in range(1, l):\n                        if dp[i1][i2][i] and dp[i1 + i][i2 + i][l - i]:\n                            dp[i1][i2][l] = True\n                            break\n                        if dp[i1][i2 + l - i][i] and dp[i1 + i][i2][l - i]:\n                            dp[i1][i2][l] = True\n                            break\n        return dp[0][0][n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java\n\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        // 题目已说明 s1.length == s2.length，无须再判断长度是否相等\n        int n = s1.length();\n        boolean[][][] dp = new boolean[n][n][n + 1];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                // 长度为1时，两字符必须相等\n                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\n            }\n        }\n        // 枚举长度区间[2, n]\n        for (int len = 2; len <= n; ++len) {\n            // 枚举s1的起始位置\n            for (int i1 = 0; i1 <= n - len; ++i1) {\n                // 枚举s2的起始位置\n                for (int i2 = 0; i2 <= n - len; ++i2) {\n                    // 枚举分割的位置\n                    for (int i = 1; i < len; ++i) {\n                        if (dp[i1][i2][i] && dp[i1 + i][i2 + i][len - i]) {\n                            dp[i1][i2][len] = true;\n                            break;\n                        }\n                        if (dp[i1][i2 + len - i][i] && dp[i1 + i][i2][len - i]) {\n                            dp[i1][i2][len] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 87. 扰乱字符串\n\nenglish version\n\n\n# 题目描述\n\n使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：\n\n 1. 如果字符串的长度为 1 ，算法停止\n 2. 如果字符串的长度 > 1 ，执行下述步骤：\n    * 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。\n    * 随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。\n    * 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。\n\n\n\n给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。\n\n \n\n示例 1：\n\n\n输入：s1 = "great", s2 = "rgeat"\n输出：true\n解释：s1 上可能发生的一种情形是：\n"great" --\x3e "gr/eat" // 在一个随机下标处分割得到两个子字符串\n"gr/eat" --\x3e "gr/eat" // 随机决定：「保持这两个子字符串的顺序不变」\n"gr/eat" --\x3e "g/r / e/at" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割\n"g/r / e/at" --\x3e "r/g / e/at" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」\n"r/g / e/at" --\x3e "r/g / e/ a/t" // 继续递归执行此算法，将 "at" 分割得到 "a/t"\n"r/g / e/ a/t" --\x3e "r/g / e/ a/t" // 随机决定：「保持这两个子字符串的顺序不变」\n算法终止，结果字符串和 s2 相同，都是 "rgeat"\n这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true\n\n\n示例 2：\n\n\n输入：s1 = "abcde", s2 = "caebd"\n输出：false\n\n\n示例 3：\n\n\n输入：s1 = "a", s2 = "a"\n输出：true\n\n\n \n\n提示：\n\n * s1.length == s2.length\n * 1 <= s1.length <= 30\n * s1 和 s2 由小写英文字母组成\n\n\n# 解法\n\n动态规划法。\n\n假设 dp[i][j][len] 表示从字符串 s 中 i 开始长度为 len 的字符串是否能变换为从字符串 t 中 j 开始长度为 len 的字符串。题目可转变为求 dp[0][0][n]。\n\n在 len 为 1 的情况下，只需要判断 s[i] 是否等于 t[j]。所以可以对 dp 进行初始化：dp[i][j][1] = s[i] == t[j]，其中，i,j ∈ [0, n)。\n\n在 len 大于 1 的情况下，枚举 s 的长度 i ∈ [1, len-1]，dp[i1][i2][i] 表示 s1 能变成 t1，dp[i1 + i][i2 + i][len - i] 表示 s2 能变成 t2；或者 s1 能变成 t2，s2 能变成 t1。\n\n\n\n\n# python3\n\nclass solution:\n    def isscramble(self, s1: str, s2: str) -> bool:\n        n = len(s1)\n        dp = [[[false] * (n + 1) for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                dp[i][j][1] = s1[i] == s2[j]\n        # 枚举长度区间[2, n]\n        for l in range(2, n + 1):\n            # 枚举s1的起始位置\n            for i1 in range(n - l + 1):\n                # 枚举s2的起始位置\n                for i2 in range(n - l + 1):\n                    # 枚举分割的位置\n                    for i in range(1, l):\n                        if dp[i1][i2][i] and dp[i1 + i][i2 + i][l - i]:\n                            dp[i1][i2][l] = true\n                            break\n                        if dp[i1][i2 + l - i][i] and dp[i1 + i][i2][l - i]:\n                            dp[i1][i2][l] = true\n                            break\n        return dp[0][0][n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java\n\nclass solution {\n    public boolean isscramble(string s1, string s2) {\n        // 题目已说明 s1.length == s2.length，无须再判断长度是否相等\n        int n = s1.length();\n        boolean[][][] dp = new boolean[n][n][n + 1];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                // 长度为1时，两字符必须相等\n                dp[i][j][1] = s1.charat(i) == s2.charat(j);\n            }\n        }\n        // 枚举长度区间[2, n]\n        for (int len = 2; len <= n; ++len) {\n            // 枚举s1的起始位置\n            for (int i1 = 0; i1 <= n - len; ++i1) {\n                // 枚举s2的起始位置\n                for (int i2 = 0; i2 <= n - len; ++i2) {\n                    // 枚举分割的位置\n                    for (int i = 1; i < len; ++i) {\n                        if (dp[i1][i2][i] && dp[i1 + i][i2 + i][len - i]) {\n                            dp[i1][i2][len] = true;\n                            break;\n                        }\n                        if (dp[i1][i2 + len - i][i] && dp[i1 + i][i2][len - i]) {\n                            dp[i1][i2][len] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode88 Merge Sorted Array-zh",frontmatter:{title:"leetcode88 Merge Sorted Array-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/9ab86e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode88 Merge Sorted Array-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10088.leetcode88%20Merge%20Sorted%20Array-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode88 Merge Sorted Array-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10088.leetcode88%20Merge%20Sorted%20Array-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode88 Merge Sorted Array-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10088.leetcode88%20Merge%20Sorted%20Array-zh.html",relativePath:"01.算法/24.leetcode/10088.leetcode88 Merge Sorted Array-zh.md",key:"v-5b7e22d8",path:"/p/9ab86e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:475},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:490},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:989},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1368},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1705},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2192}],headersStr:"题目描述 解法 Python3 Java Go JavaScript ...",content:'# 88. 合并两个有序数组\n\nEnglish Version\n\n\n# 题目描述\n\n给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。\n\n初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。\n\n \n\n示例 1：\n\n\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n\n\n示例 2：\n\n\n输入：nums1 = [1], m = 1, nums2 = [], n = 0\n输出：[1]\n\n\n \n\n提示：\n\n * nums1.length == m + n\n * nums2.length == n\n * 0 <= m, n <= 200\n * 1 <= m + n <= 200\n * -109 <= nums1[i], nums2[i] <= 109\n\n\n# 解法\n\n双指针解决。\n\n\n# Python3\n\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        """\n        Do not return anything, modify nums1 in-place instead.\n        """\n        i, j, k = m - 1, n - 1, m + n - 1\n        while j >= 0:\n            if i >= 0 and nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Java\n\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m - 1, j = n - 1, k = m + n - 1;\n        while (j >= 0) {\n            if (i >= 0 && nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Go\n\nfunc merge(nums1 []int, m int, nums2 []int, n int)  {\n    i, j, k := m - 1, n - 1, m + n - 1\n    for j >= 0 {\n        if i >= 0 && nums1[i] > nums2[j] {\n            nums1[k] = nums1[i]\n            i--\n        } else {\n            nums1[k] = nums2[j]\n            j--\n        }\n        k--\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function (nums1, m, nums2, n) {\n  let i = m - 1,\n    j = n - 1,\n    k = m + n - 1;\n  while (j >= 0) {\n    if (i >= 0 && nums1[i] > nums2[j]) {\n      nums1[k--] = nums1[i--];\n    } else {\n      nums1[k--] = nums2[j--];\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 88. 合并两个有序数组\n\nenglish version\n\n\n# 题目描述\n\n给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。\n\n初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。\n\n \n\n示例 1：\n\n\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n\n\n示例 2：\n\n\n输入：nums1 = [1], m = 1, nums2 = [], n = 0\n输出：[1]\n\n\n \n\n提示：\n\n * nums1.length == m + n\n * nums2.length == n\n * 0 <= m, n <= 200\n * 1 <= m + n <= 200\n * -109 <= nums1[i], nums2[i] <= 109\n\n\n# 解法\n\n双指针解决。\n\n\n# python3\n\nclass solution:\n    def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> none:\n        """\n        do not return anything, modify nums1 in-place instead.\n        """\n        i, j, k = m - 1, n - 1, m + n - 1\n        while j >= 0:\n            if i >= 0 and nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# java\n\nclass solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m - 1, j = n - 1, k = m + n - 1;\n        while (j >= 0) {\n            if (i >= 0 && nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# go\n\nfunc merge(nums1 []int, m int, nums2 []int, n int)  {\n    i, j, k := m - 1, n - 1, m + n - 1\n    for j >= 0 {\n        if i >= 0 && nums1[i] > nums2[j] {\n            nums1[k] = nums1[i]\n            i--\n        } else {\n            nums1[k] = nums2[j]\n            j--\n        }\n        k--\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} do not return anything, modify nums1 in-place instead.\n */\nvar merge = function (nums1, m, nums2, n) {\n  let i = m - 1,\n    j = n - 1,\n    k = m + n - 1;\n  while (j >= 0) {\n    if (i >= 0 && nums1[i] > nums2[j]) {\n      nums1[k--] = nums1[i--];\n    } else {\n      nums1[k--] = nums2[j--];\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode89 Gray Code-zh",frontmatter:{title:"leetcode89 Gray Code-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/dc9180/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode89 Gray Code-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10089.leetcode89%20Gray%20Code-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode89 Gray Code-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10089.leetcode89%20Gray%20Code-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode89 Gray Code-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10089.leetcode89%20Gray%20Code-zh.html",relativePath:"01.算法/24.leetcode/10089.leetcode89 Gray Code-zh.md",key:"v-5c9209e7",path:"/p/dc9180/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:426},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:433},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:452},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:468}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 89. 格雷编码\n\nEnglish Version\n\n\n# 题目描述\n\n格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。\n\n给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。\n\n格雷编码序列必须以 0 开头。\n\n \n\n示例 1:\n\n输入: 2\n输出: [0,1,3,2]\n解释:\n00 - 0\n01 - 1\n11 - 3\n10 - 2\n\n对于给定的 n，其格雷编码序列并不唯一。\n例如，[0,2,3,1] 也是一个有效的格雷编码序列。\n\n00 - 0\n10 - 2\n11 - 3\n01 - 1\n\n示例 2:\n\n输入: 0\n输出: [0]\n解释: 我们定义格雷编码序列必须以 0 开头。\n     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。\n     因此，当 n = 0 时，其格雷编码序列为 [0]。\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 89. 格雷编码\n\nenglish version\n\n\n# 题目描述\n\n格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。\n\n给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。\n\n格雷编码序列必须以 0 开头。\n\n \n\n示例 1:\n\n输入: 2\n输出: [0,1,3,2]\n解释:\n00 - 0\n01 - 1\n11 - 3\n10 - 2\n\n对于给定的 n，其格雷编码序列并不唯一。\n例如，[0,2,3,1] 也是一个有效的格雷编码序列。\n\n00 - 0\n10 - 2\n11 - 3\n01 - 1\n\n示例 2:\n\n输入: 0\n输出: [0]\n解释: 我们定义格雷编码序列必须以 0 开头。\n     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。\n     因此，当 n = 0 时，其格雷编码序列为 [0]。\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode90 Subsets II-zh",frontmatter:{title:"leetcode90 Subsets II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/8df0f5/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode90 Subsets II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10090.leetcode90%20Subsets%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode90 Subsets II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10090.leetcode90%20Subsets%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode90 Subsets II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10090.leetcode90%20Subsets%20II-zh.html",relativePath:"01.算法/24.leetcode/10090.leetcode90 Subsets II-zh.md",key:"v-069718c6",path:"/p/8df0f5/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:288},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:295},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:838},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1569}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 90. 子集 II\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n\n解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,2]\n输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n\n\n示例 2：\n\n\n输入：nums = [0]\n输出：[[],[0]]\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 10\n * -10 <= nums[i] <= 10\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        def dfs(nums, i, res, path):\n            res.append(copy.deepcopy(path))\n            for j in range(i, len(nums)):\n                if j != i and nums[j] == nums[j - 1]:\n                    continue\n                path.append(nums[j])\n                dfs(nums, j + 1, res, path)\n                path.pop()\n        res, path = [], []\n        nums.sort()\n        dfs(nums, 0, res, path)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Java\n\nclass Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        List<Integer> path = new ArrayList<>();\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        dfs(nums, 0, res, path);\n        return res;\n    }\n\n    private void dfs(int[] nums, int i, List<List<Integer>> res, List<Integer> path) {\n        res.add(new ArrayList<>(path));\n        for (int j = i; j < nums.length; ++j) {\n            if (j != i && nums[j] == nums[j - 1]) {\n                continue;\n            }\n            path.add(nums[j]);\n            dfs(nums, i + 1, res, path);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 90. 子集 ii\n\nenglish version\n\n\n# 题目描述\n\n给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n\n解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,2]\n输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n\n\n示例 2：\n\n\n输入：nums = [0]\n输出：[[],[0]]\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 10\n * -10 <= nums[i] <= 10\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def subsetswithdup(self, nums: list[int]) -> list[list[int]]:\n        def dfs(nums, i, res, path):\n            res.append(copy.deepcopy(path))\n            for j in range(i, len(nums)):\n                if j != i and nums[j] == nums[j - 1]:\n                    continue\n                path.append(nums[j])\n                dfs(nums, j + 1, res, path)\n                path.pop()\n        res, path = [], []\n        nums.sort()\n        dfs(nums, 0, res, path)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# java\n\nclass solution {\n    public list<list<integer>> subsetswithdup(int[] nums) {\n        list<integer> path = new arraylist<>();\n        list<list<integer>> res = new arraylist<>();\n        arrays.sort(nums);\n        dfs(nums, 0, res, path);\n        return res;\n    }\n\n    private void dfs(int[] nums, int i, list<list<integer>> res, list<integer> path) {\n        res.add(new arraylist<>(path));\n        for (int j = i; j < nums.length; ++j) {\n            if (j != i && nums[j] == nums[j - 1]) {\n                continue;\n            }\n            path.add(nums[j]);\n            dfs(nums, i + 1, res, path);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode91 Decode Ways-zh",frontmatter:{title:"leetcode91 Decode Ways-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/04a12e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode91 Decode Ways-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10091.leetcode91%20Decode%20Ways-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode91 Decode Ways-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10091.leetcode91%20Decode%20Ways-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode91 Decode Ways-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10091.leetcode91%20Decode%20Ways-zh.html",relativePath:"01.算法/24.leetcode/10091.leetcode91 Decode Ways-zh.md",key:"v-5a548ea7",path:"/p/04a12e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:761},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1256},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2067},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:3133},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:3676},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:4002},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:87}],headersStr:"题目描述 解法 Python3 Java C++ Go C# ...",content:"# 91. 解码方法\n\nEnglish Version\n\n\n# 题目描述\n\n一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：\n\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n\n\n要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，\"11106\" 可以映射为：\n\n * \"AAJF\" ，将消息分组为 (1 1 10 6)\n * \"KJF\" ，将消息分组为 (11 10 6)\n\n注意，消息不能分组为  (1 11 06) ，因为 \"06\" 不能映射为 \"F\" ，这是由于 \"6\" 和 \"06\" 在映射中并不等价。\n\n给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。\n\n题目数据保证答案肯定是一个 32 位 的整数。\n\n \n\n示例 1：\n\n\n输入：s = \"12\"\n输出：2\n解释：它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n\n\n示例 2：\n\n\n输入：s = \"226\"\n输出：3\n解释：它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n\n\n示例 3：\n\n\n输入：s = \"0\"\n输出：0\n解释：没有字符映射到以 0 开头的数字。\n含有 0 的有效映射是 'J' -> \"10\" 和 'T'-> \"20\" 。\n由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。\n\n\n示例 4：\n\n\n输入：s = \"06\"\n输出：0\n解释：\"06\" 不能映射到 \"F\" ，因为字符串含有前导 0（\"6\" 和 \"06\" 在映射中并不等价）。\n\n \n\n提示：\n\n * 1 <= s.length <= 100\n * s 只包含数字，并且可能包含前导零。\n\n\n# 解法\n\n动态规划法。\n\n假设 dp[i] 表示字符串 s 的前 i 个字符 s[1..i] 的解码方法数。\n\n考虑最后一次解码中使用了 s 中的哪些字符：\n\n * 第一种情况是我们使用了一个字符，即 s[i] 进行解码，那么只要 s[i]≠0，它就可以被解码成 A∼I 中的某个字母。由于剩余的前 i-1 个字符的解码方法数为 dp[i-1]，所以 dp[i] = dp[i-1]。\n * 第二种情况是我们使用了两个字符，即 s[i-1] 和 s[i] 进行编码。与第一种情况类似，s[i-1] 不能等于 0，并且 s[i-1] 和 s[i] 组成的整数必须小于等于 26，这样它们就可以被解码成 J∼Z 中的某个字母。由于剩余的前 i-2 个字符的解码方法数为 dp[i-2]，所以 dp[i] = dp[i-2]。\n\n将上面的两种状态转移方程在对应的条件满足时进行累加，即可得到 dp[i]的值。在动态规划完成后，最终的答案即为 dp[n]。\n\n由于 dp[i] 的值仅与 dp[i-1] 和 dp[i-2] 有关，因此可以不定义 dp 数组，可以仅使用三个变量进行状态转移。\n\n\n# Python3\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if i > 1 and s[i - 2] != '0' and (int(s[i - 2]) * 10 + int(s[i - 1]) <= 26):\n                dp[i] += dp[i - 2]\n        return dp[n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n优化空间：\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        a, b, c = 0, 1, 0\n        for i in range(1, n + 1):\n            c = 0\n            if s[i - 1] != '0':\n                c += b\n            if i > 1 and s[i - 2] != '0' and (int(s[i - 2]) * 10 + int(s[i - 1]) <= 26):\n                c += a\n            a, b = b, c\n        return c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public int numDecodings(String s) {\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            if (s.charAt(i - 1) != '0') {\n                dp[i] += dp[i - 1];\n            }\n            if (i > 1 && s.charAt(i - 2) != '0' && ((s.charAt(i - 2) - '0') * 10 + s.charAt(i - 1) - '0') <= 26) {\n                dp[i] += dp[i - 2];\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n优化空间：\n\nclass Solution {\n    public int numDecodings(String s) {\n        int n = s.length();\n        int a = 0, b = 1, c = 0;\n        for (int i = 1; i <= n; ++i) {\n            c = 0;\n            if (s.charAt(i - 1) != '0') {\n                c += b;\n            }\n            if (i > 1 && s.charAt(i - 2) != '0' && ((s.charAt(i - 2) - '0') * 10 + s.charAt(i - 1) - '0') <= 26) {\n                c += a;\n            }\n            a = b;\n            b = c;\n        }\n        return c;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        int n = s.size();\n        vector<int> dp(n + 1);\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            if (s[i - 1] != '0') {\n                dp[i] += dp[i - 1];\n            }\n            if (i > 1 && s[i - 2] != '0') {\n                if ((s[i - 2] - '0') * 10 + s[i - 1] - '0' <= 26) {\n                    dp[i] += dp[i - 2];\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Go\n\nfunc numDecodings(s string) int {\n\tn := len(s)\n\tdp := make([]int, n+1)\n\tdp[0] = 1\n\tfor i := 1; i <= n; i++ {\n\t\tif s[i-1] != '0' {\n\t\t\tdp[i] += dp[i-1]\n\t\t}\n\t\tif i > 1 && s[i-2] != '0' {\n\t\t\tif (s[i-2]-'0')*10+(s[i-1]-'0') <= 26 {\n\t\t\t\tdp[i] += dp[i-2]\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# C#\n\npublic class Solution {\n    public int NumDecodings(string s) {\n        if (s.Length == 0) return 0;\n        \n        var f0 = 1;\n        var f1 = 1;\n        var f2 = 1;\n        for (var i = 0; i < s.Length; ++i)\n        {\n            f0 = f1;\n            f1 = f2;\n            f2 = 0;\n            var two = i > 0 ? int.Parse(string.Format(\"{0}{1}\", s[i - 1], s[i])) : 0;\n            if (two >= 10 && two <= 26)\n            {\n               f2 += f0;  \n            }\n            if (s[i] != '0')\n            {\n                f2 += f1;\n            }\n        }\n        return f2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 91. 解码方法\n\nenglish version\n\n\n# 题目描述\n\n一条包含字母 a-z 的消息通过以下映射进行了 编码 ：\n\n\n'a' -> 1\n'b' -> 2\n...\n'z' -> 26\n\n\n要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，\"11106\" 可以映射为：\n\n * \"aajf\" ，将消息分组为 (1 1 10 6)\n * \"kjf\" ，将消息分组为 (11 10 6)\n\n注意，消息不能分组为  (1 11 06) ，因为 \"06\" 不能映射为 \"f\" ，这是由于 \"6\" 和 \"06\" 在映射中并不等价。\n\n给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。\n\n题目数据保证答案肯定是一个 32 位 的整数。\n\n \n\n示例 1：\n\n\n输入：s = \"12\"\n输出：2\n解释：它可以解码为 \"ab\"（1 2）或者 \"l\"（12）。\n\n\n示例 2：\n\n\n输入：s = \"226\"\n输出：3\n解释：它可以解码为 \"bz\" (2 26), \"vf\" (22 6), 或者 \"bbf\" (2 2 6) 。\n\n\n示例 3：\n\n\n输入：s = \"0\"\n输出：0\n解释：没有字符映射到以 0 开头的数字。\n含有 0 的有效映射是 'j' -> \"10\" 和 't'-> \"20\" 。\n由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。\n\n\n示例 4：\n\n\n输入：s = \"06\"\n输出：0\n解释：\"06\" 不能映射到 \"f\" ，因为字符串含有前导 0（\"6\" 和 \"06\" 在映射中并不等价）。\n\n \n\n提示：\n\n * 1 <= s.length <= 100\n * s 只包含数字，并且可能包含前导零。\n\n\n# 解法\n\n动态规划法。\n\n假设 dp[i] 表示字符串 s 的前 i 个字符 s[1..i] 的解码方法数。\n\n考虑最后一次解码中使用了 s 中的哪些字符：\n\n * 第一种情况是我们使用了一个字符，即 s[i] 进行解码，那么只要 s[i]=0，它就可以被解码成 a∼i 中的某个字母。由于剩余的前 i-1 个字符的解码方法数为 dp[i-1]，所以 dp[i] = dp[i-1]。\n * 第二种情况是我们使用了两个字符，即 s[i-1] 和 s[i] 进行编码。与第一种情况类似，s[i-1] 不能等于 0，并且 s[i-1] 和 s[i] 组成的整数必须小于等于 26，这样它们就可以被解码成 j∼z 中的某个字母。由于剩余的前 i-2 个字符的解码方法数为 dp[i-2]，所以 dp[i] = dp[i-2]。\n\n将上面的两种状态转移方程在对应的条件满足时进行累加，即可得到 dp[i]的值。在动态规划完成后，最终的答案即为 dp[n]。\n\n由于 dp[i] 的值仅与 dp[i-1] 和 dp[i-2] 有关，因此可以不定义 dp 数组，可以仅使用三个变量进行状态转移。\n\n\n# python3\n\nclass solution:\n    def numdecodings(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if i > 1 and s[i - 2] != '0' and (int(s[i - 2]) * 10 + int(s[i - 1]) <= 26):\n                dp[i] += dp[i - 2]\n        return dp[n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n优化空间：\n\nclass solution:\n    def numdecodings(self, s: str) -> int:\n        n = len(s)\n        a, b, c = 0, 1, 0\n        for i in range(1, n + 1):\n            c = 0\n            if s[i - 1] != '0':\n                c += b\n            if i > 1 and s[i - 2] != '0' and (int(s[i - 2]) * 10 + int(s[i - 1]) <= 26):\n                c += a\n            a, b = b, c\n        return c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public int numdecodings(string s) {\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            if (s.charat(i - 1) != '0') {\n                dp[i] += dp[i - 1];\n            }\n            if (i > 1 && s.charat(i - 2) != '0' && ((s.charat(i - 2) - '0') * 10 + s.charat(i - 1) - '0') <= 26) {\n                dp[i] += dp[i - 2];\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n优化空间：\n\nclass solution {\n    public int numdecodings(string s) {\n        int n = s.length();\n        int a = 0, b = 1, c = 0;\n        for (int i = 1; i <= n; ++i) {\n            c = 0;\n            if (s.charat(i - 1) != '0') {\n                c += b;\n            }\n            if (i > 1 && s.charat(i - 2) != '0' && ((s.charat(i - 2) - '0') * 10 + s.charat(i - 1) - '0') <= 26) {\n                c += a;\n            }\n            a = b;\n            b = c;\n        }\n        return c;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# c++\n\nclass solution {\npublic:\n    int numdecodings(string s) {\n        int n = s.size();\n        vector<int> dp(n + 1);\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            if (s[i - 1] != '0') {\n                dp[i] += dp[i - 1];\n            }\n            if (i > 1 && s[i - 2] != '0') {\n                if ((s[i - 2] - '0') * 10 + s[i - 1] - '0' <= 26) {\n                    dp[i] += dp[i - 2];\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# go\n\nfunc numdecodings(s string) int {\n\tn := len(s)\n\tdp := make([]int, n+1)\n\tdp[0] = 1\n\tfor i := 1; i <= n; i++ {\n\t\tif s[i-1] != '0' {\n\t\t\tdp[i] += dp[i-1]\n\t\t}\n\t\tif i > 1 && s[i-2] != '0' {\n\t\t\tif (s[i-2]-'0')*10+(s[i-1]-'0') <= 26 {\n\t\t\t\tdp[i] += dp[i-2]\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# c#\n\npublic class solution {\n    public int numdecodings(string s) {\n        if (s.length == 0) return 0;\n        \n        var f0 = 1;\n        var f1 = 1;\n        var f2 = 1;\n        for (var i = 0; i < s.length; ++i)\n        {\n            f0 = f1;\n            f1 = f2;\n            f2 = 0;\n            var two = i > 0 ? int.parse(string.format(\"{0}{1}\", s[i - 1], s[i])) : 0;\n            if (two >= 10 && two <= 26)\n            {\n               f2 += f0;  \n            }\n            if (s[i] != '0')\n            {\n                f2 += f1;\n            }\n        }\n        return f2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode92 Reverse Linked List II-zh",frontmatter:{title:"leetcode92 Reverse Linked List II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/4999f0/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0092.Reverse%20Linked%20List%20II/images/rev2ex2.jpg"},{name:"twitter:title",content:"leetcode92 Reverse Linked List II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0092.Reverse%20Linked%20List%20II/images/rev2ex2.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10092.leetcode92%20Reverse%20Linked%20List%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode92 Reverse Linked List II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0092.Reverse%20Linked%20List%20II/images/rev2ex2.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10092.leetcode92%20Reverse%20Linked%20List%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode92 Reverse Linked List II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0092.Reverse%20Linked%20List%20II/images/rev2ex2.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10092.leetcode92%20Reverse%20Linked%20List%20II-zh.html",relativePath:"01.算法/24.leetcode/10092.leetcode92 Reverse Linked List II-zh.md",key:"v-275d0591",path:"/p/4999f0/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:382},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:389},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1149},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2199},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:3126},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:4192},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:5274}],headersStr:"题目描述 解法 Python3 Java JavaScript C++ C# ...",content:"# 92. 反转链表 II\n\nEnglish Version\n\n\n# 题目描述\n\n给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。\n\n \n\n\n\n示例 1：\n\n\n输入：head = [1,2,3,4,5], left = 2, right = 4\n输出：[1,4,3,2,5]\n\n\n示例 2：\n\n\n输入：head = [5], left = 1, right = 1\n输出：[5]\n\n\n \n\n提示：\n\n * 链表中节点数目为 n\n * 1 <= n <= 500\n * -500 <= Node.val <= 500\n * 1 <= left <= right <= n\n\n \n\n进阶： 你可以使用一趟扫描完成反转吗？\n\n\n# 解法\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\n        if head is None or head.next is None or left == right:\n            return head\n        dummy = ListNode(0, head)\n        pre = dummy\n        for _ in range(left - 1):\n            pre = pre.next\n        p, q = pre, pre.next\n        cur = q\n        for _ in range(right - left + 1):\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        p.next = pre\n        q.next = cur\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if (head == null || head.next == null || left == right) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy;\n        for (int i = 0; i < left - 1; ++i) {\n            pre = pre.next;\n        }\n        ListNode p = pre;\n        ListNode q = pre.next;\n        ListNode cur = q;\n        for (int i = 0; i < right - left + 1; ++i) {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        p.next = pre;\n        q.next = cur;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nvar reverseBetween = function(head, left, right) {\n    if (!head || !head.next || left == right) {\n        return head;\n    }\n    const dummy = new ListNode(0, head);\n    let pre = dummy;\n    for (let i = 0; i < left - 1; ++i) {\n        pre = pre.next;\n    }\n    const p = pre;\n    const q = pre.next;\n    let cur = q;\n    for (let i = 0; i < right - left + 1; ++i) {\n        const t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    p.next = pre;\n    q.next = cur;\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        if (head == nullptr || head->next == nullptr || left == right) {\n            return head;\n        }\n        ListNode *dummy = new ListNode(0, head);\n        ListNode *pre = dummy;\n        for (int i = 0; i < left - 1; ++i) {\n            pre = pre->next;\n        }\n        ListNode *p = pre, *q = pre->next;\n        ListNode *cur = q;\n        for (int i = 0; i < right - left + 1; ++i) {\n            ListNode *t = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = t;\n        }\n        p->next = pre;\n        q->next = cur;\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# C#\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ReverseBetween(ListNode head, int left, int right) {\n        if (head == null || head.next == null || left == right)\n        {\n            return head;\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy;\n        for (int i = 0; i < left - 1; ++i)\n        {\n            pre = pre.next;\n        }\n        ListNode p = pre;\n        ListNode q = pre.next;\n        ListNode cur = q;\n        for (int i = 0; i < right - left + 1; ++i)\n        {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        p.next = pre;\n        q.next = cur;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 92. 反转链表 ii\n\nenglish version\n\n\n# 题目描述\n\n给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。\n\n \n\n\n\n示例 1：\n\n\n输入：head = [1,2,3,4,5], left = 2, right = 4\n输出：[1,4,3,2,5]\n\n\n示例 2：\n\n\n输入：head = [5], left = 1, right = 1\n输出：[5]\n\n\n \n\n提示：\n\n * 链表中节点数目为 n\n * 1 <= n <= 500\n * -500 <= node.val <= 500\n * 1 <= left <= right <= n\n\n \n\n进阶： 你可以使用一趟扫描完成反转吗？\n\n\n# 解法\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def reversebetween(self, head: listnode, left: int, right: int) -> listnode:\n        if head is none or head.next is none or left == right:\n            return head\n        dummy = listnode(0, head)\n        pre = dummy\n        for _ in range(left - 1):\n            pre = pre.next\n        p, q = pre, pre.next\n        cur = q\n        for _ in range(right - left + 1):\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        p.next = pre\n        q.next = cur\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode reversebetween(listnode head, int left, int right) {\n        if (head == null || head.next == null || left == right) {\n            return head;\n        }\n        listnode dummy = new listnode(0, head);\n        listnode pre = dummy;\n        for (int i = 0; i < left - 1; ++i) {\n            pre = pre.next;\n        }\n        listnode p = pre;\n        listnode q = pre.next;\n        listnode cur = q;\n        for (int i = 0; i < right - left + 1; ++i) {\n            listnode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        p.next = pre;\n        q.next = cur;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @param {number} left\n * @param {number} right\n * @return {listnode}\n */\nvar reversebetween = function(head, left, right) {\n    if (!head || !head.next || left == right) {\n        return head;\n    }\n    const dummy = new listnode(0, head);\n    let pre = dummy;\n    for (let i = 0; i < left - 1; ++i) {\n        pre = pre.next;\n    }\n    const p = pre;\n    const q = pre.next;\n    let cur = q;\n    for (let i = 0; i < right - left + 1; ++i) {\n        const t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    p.next = pre;\n    q.next = cur;\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* reversebetween(listnode* head, int left, int right) {\n        if (head == nullptr || head->next == nullptr || left == right) {\n            return head;\n        }\n        listnode *dummy = new listnode(0, head);\n        listnode *pre = dummy;\n        for (int i = 0; i < left - 1; ++i) {\n            pre = pre->next;\n        }\n        listnode *p = pre, *q = pre->next;\n        listnode *cur = q;\n        for (int i = 0; i < right - left + 1; ++i) {\n            listnode *t = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = t;\n        }\n        p->next = pre;\n        q->next = cur;\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# c#\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     public int val;\n *     public listnode next;\n *     public listnode(int val=0, listnode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class solution {\n    public listnode reversebetween(listnode head, int left, int right) {\n        if (head == null || head.next == null || left == right)\n        {\n            return head;\n        }\n        listnode dummy = new listnode(0, head);\n        listnode pre = dummy;\n        for (int i = 0; i < left - 1; ++i)\n        {\n            pre = pre.next;\n        }\n        listnode p = pre;\n        listnode q = pre.next;\n        listnode cur = q;\n        for (int i = 0; i < right - left + 1; ++i)\n        {\n            listnode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        p.next = pre;\n        q.next = cur;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode93 Restore IP Addresses-zh",frontmatter:{title:"leetcode93 Restore IP Addresses-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/81aad5/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode93 Restore IP Addresses-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10093.leetcode93%20Restore%20IP%20Addresses-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode93 Restore IP Addresses-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10093.leetcode93%20Restore%20IP%20Addresses-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode93 Restore IP Addresses-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10093.leetcode93%20Restore%20IP%20Addresses-zh.html",relativePath:"01.算法/24.leetcode/10093.leetcode93 Restore IP Addresses-zh.md",key:"v-6b8e495c",path:"/p/81aad5/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:623},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:630},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:649},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:665}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 93. 复原 IP 地址\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。\n\n有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 \'.\' 分隔。\n\n例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。\n\n \n\n示例 1：\n\n\n输入：s = "25525511135"\n输出：["255.255.11.135","255.255.111.35"]\n\n\n示例 2：\n\n\n输入：s = "0000"\n输出：["0.0.0.0"]\n\n\n示例 3：\n\n\n输入：s = "1111"\n输出：["1.1.1.1"]\n\n\n示例 4：\n\n\n输入：s = "010010"\n输出：["0.10.0.10","0.100.1.0"]\n\n\n示例 5：\n\n\n输入：s = "101023"\n输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]\n\n\n \n\n提示：\n\n * 0 <= s.length <= 3000\n * s 仅由数字组成\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 93. 复原 ip 地址\n\nenglish version\n\n\n# 题目描述\n\n给定一个只包含数字的字符串，用以表示一个 ip 地址，返回所有可能从 s 获得的 有效 ip 地址 。你可以按任何顺序返回答案。\n\n有效 ip 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 \'.\' 分隔。\n\n例如："0.1.2.201" 和 "192.168.1.1" 是 有效 ip 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 ip 地址。\n\n \n\n示例 1：\n\n\n输入：s = "25525511135"\n输出：["255.255.11.135","255.255.111.35"]\n\n\n示例 2：\n\n\n输入：s = "0000"\n输出：["0.0.0.0"]\n\n\n示例 3：\n\n\n输入：s = "1111"\n输出：["1.1.1.1"]\n\n\n示例 4：\n\n\n输入：s = "010010"\n输出：["0.10.0.10","0.100.1.0"]\n\n\n示例 5：\n\n\n输入：s = "101023"\n输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]\n\n\n \n\n提示：\n\n * 0 <= s.length <= 3000\n * s 仅由数字组成\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode94 Binary Tree Inorder Traversal-zh",frontmatter:{title:"leetcode94 Binary Tree Inorder Traversal-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/6844b9/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0094.Binary%20Tree%20Inorder%20Traversal/images/inorder_1.jpg"},{name:"twitter:title",content:"leetcode94 Binary Tree Inorder Traversal-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0094.Binary%20Tree%20Inorder%20Traversal/images/inorder_1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10094.leetcode94%20Binary%20Tree%20Inorder%20Traversal-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode94 Binary Tree Inorder Traversal-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0094.Binary%20Tree%20Inorder%20Traversal/images/inorder_1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10094.leetcode94%20Binary%20Tree%20Inorder%20Traversal-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode94 Binary Tree Inorder Traversal-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0094.Binary%20Tree%20Inorder%20Traversal/images/inorder_1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10094.leetcode94%20Binary%20Tree%20Inorder%20Traversal-zh.html",relativePath:"01.算法/24.leetcode/10094.leetcode94 Binary Tree Inorder Traversal-zh.md",key:"v-9aa612be",path:"/p/6844b9/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:348},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:446},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1597},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:3476},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4138}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 94. 二叉树的中序遍历\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n\n \n\n示例 1：\n\n\n输入：root = [1,null,2,3]\n输出：[1,3,2]\n\n\n示例 2：\n\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [1]\n输出：[1]\n\n\n示例 4：\n\n\n输入：root = [1,2]\n输出：[2,1]\n\n\n示例 5：\n\n\n输入：root = [1,null,2]\n输出：[1,2]\n\n\n \n\n提示：\n\n * 树中节点数目在范围 [0, 100] 内\n * -100 <= Node.val <= 100\n\n \n\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n\n\n# 解法\n\n递归遍历或利用栈实现非递归遍历。\n\n非递归的思路如下：\n\n 1. 定义一个栈\n 2. 将树的左节点依次入栈\n 3. 左节点为空时，弹出栈顶元素并处理\n 4. 重复 2-3 的操作\n\n\n# Python3\n\n递归：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        def inorder(root):\n            if root:\n                inorder(root.left)\n                res.append(root.val)\n                inorder(root.right)\n        res = []\n        inorder(root)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n非递归：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        s = []\n        res = []\n        while root or s:\n            if root:\n                s.append(root)\n                root = root.left\n            else:\n                root = s.pop()\n                res.append(root.val)\n                root = root.right\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Java\n\n递归：\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    private List<Integer> res;\n\n    public List<Integer> inorderTraversal(TreeNode root) {\n        res = new ArrayList<>();\n        inorder(root);\n        return res;\n    }\n\n    private void inorder(TreeNode root) {\n        if (root != null) {\n            inorder(root.left);\n            res.add(root.val);\n            inorder(root.right);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n非递归：\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        List<Integer> res = new ArrayList<>();\n        Deque<TreeNode> s = new ArrayDeque<>();\n        while (root != null || !s.isEmpty()) {\n            if (root != null) {\n                s.push(root);\n                root = root.left;\n            } else {\n                root = s.pop();\n                res.add(root.val);\n                root = root.right;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# JavaScript\n\n递归：\n\nvar inorderTraversal = function(root) {\n    let res = [];\n    function inorder(root){\n        if(root){\n        inorder(root.left);\n        res.push(root.val);\n        inorder(root.right);\n        }\n    }\n    inorder(root);\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n非递归：\n\nvar inorderTraversal = function (root) {\n    let res = [], stk = [];\n    let cur = root;\n    while (cur || stk.length !== 0) {\n        while (cur) {\n            stk.push(cur);\n            cur = cur.left;\n        } \n        let top = stk.pop();\n        res.push(top.val);\n        cur = top.right;\n\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 94. 二叉树的中序遍历\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n\n \n\n示例 1：\n\n\n输入：root = [1,null,2,3]\n输出：[1,3,2]\n\n\n示例 2：\n\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [1]\n输出：[1]\n\n\n示例 4：\n\n\n输入：root = [1,2]\n输出：[2,1]\n\n\n示例 5：\n\n\n输入：root = [1,null,2]\n输出：[1,2]\n\n\n \n\n提示：\n\n * 树中节点数目在范围 [0, 100] 内\n * -100 <= node.val <= 100\n\n \n\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n\n\n# 解法\n\n递归遍历或利用栈实现非递归遍历。\n\n非递归的思路如下：\n\n 1. 定义一个栈\n 2. 将树的左节点依次入栈\n 3. 左节点为空时，弹出栈顶元素并处理\n 4. 重复 2-3 的操作\n\n\n# python3\n\n递归：\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def inordertraversal(self, root: treenode) -> list[int]:\n        def inorder(root):\n            if root:\n                inorder(root.left)\n                res.append(root.val)\n                inorder(root.right)\n        res = []\n        inorder(root)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n非递归：\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def inordertraversal(self, root: treenode) -> list[int]:\n        s = []\n        res = []\n        while root or s:\n            if root:\n                s.append(root)\n                root = root.left\n            else:\n                root = s.pop()\n                res.append(root.val)\n                root = root.right\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# java\n\n递归：\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n\n    private list<integer> res;\n\n    public list<integer> inordertraversal(treenode root) {\n        res = new arraylist<>();\n        inorder(root);\n        return res;\n    }\n\n    private void inorder(treenode root) {\n        if (root != null) {\n            inorder(root.left);\n            res.add(root.val);\n            inorder(root.right);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n非递归：\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public list<integer> inordertraversal(treenode root) {\n        if (root == null) {\n            return collections.emptylist();\n        }\n        list<integer> res = new arraylist<>();\n        deque<treenode> s = new arraydeque<>();\n        while (root != null || !s.isempty()) {\n            if (root != null) {\n                s.push(root);\n                root = root.left;\n            } else {\n                root = s.pop();\n                res.add(root.val);\n                root = root.right;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# javascript\n\n递归：\n\nvar inordertraversal = function(root) {\n    let res = [];\n    function inorder(root){\n        if(root){\n        inorder(root.left);\n        res.push(root.val);\n        inorder(root.right);\n        }\n    }\n    inorder(root);\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n非递归：\n\nvar inordertraversal = function (root) {\n    let res = [], stk = [];\n    let cur = root;\n    while (cur || stk.length !== 0) {\n        while (cur) {\n            stk.push(cur);\n            cur = cur.left;\n        } \n        let top = stk.pop();\n        res.push(top.val);\n        cur = top.right;\n\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode95 Unique Binary Search Trees II-zh",frontmatter:{title:"leetcode95 Unique Binary Search Trees II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/65b61c/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode95 Unique Binary Search Trees II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10095.leetcode95%20Unique%20Binary%20Search%20Trees%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode95 Unique Binary Search Trees II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10095.leetcode95%20Unique%20Binary%20Search%20Trees%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode95 Unique Binary Search Trees II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10095.leetcode95%20Unique%20Binary%20Search%20Trees%20II-zh.html",relativePath:"01.算法/24.leetcode/10095.leetcode95 Unique Binary Search Trees II-zh.md",key:"v-7907a92c",path:"/p/65b61c/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:434},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:441},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:460},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:62}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 95. 不同的二叉搜索树 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n \n\n示例：\n\n输入：3\n输出：\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n解释：\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n\n \n\n提示：\n\n * 0 <= n <= 8\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 95. 不同的二叉搜索树 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n \n\n示例：\n\n输入：3\n输出：\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n解释：\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n\n \n\n提示：\n\n * 0 <= n <= 8\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode96 Unique Binary Search Trees-zh",frontmatter:{title:"leetcode96 Unique Binary Search Trees-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b6afec/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode96 Unique Binary Search Trees-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10096.leetcode96%20Unique%20Binary%20Search%20Trees-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode96 Unique Binary Search Trees-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10096.leetcode96%20Unique%20Binary%20Search%20Trees-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode96 Unique Binary Search Trees-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10096.leetcode96%20Unique%20Binary%20Search%20Trees-zh.html",relativePath:"01.算法/24.leetcode/10096.leetcode96 Unique Binary Search Trees-zh.md",key:"v-24153e5a",path:"/p/b6afec/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:320},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:512},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:778},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1105},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1432},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:56}],headersStr:"题目描述 解法 Python3 Java C++ Go ...",content:"# 96. 不同的二叉搜索树\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n示例:\n\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n\n# 解法\n\n假设 n 个节点存在二叉搜索树的个数是 G(n)，1 为根节点，2 为根节点，...，n 为根节点，当 1 为根节点时，其左子树节点个数为 0，右子树节点个数为 n-1，同理当 2 为根节点时，其左子树节点个数为 1，右子树节点为 n-2，所以可得 G(n) = G(0) * G(n-1) + G(1) * (n-2) + ... + G(n-1) * G(0)。\n\n\n# Python3\n\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        return dp[-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Java\n\nclass Solution {\n    public int numTrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1);\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Go\n\nfunc numTrees(n int) int {\n\tdp := make([]int, n+1)\n\tdp[0] = 1\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i-j-1]\n\t\t}\n\t}\n\treturn dp[n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 96. 不同的二叉搜索树\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n示例:\n\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n\n# 解法\n\n假设 n 个节点存在二叉搜索树的个数是 g(n)，1 为根节点，2 为根节点，...，n 为根节点，当 1 为根节点时，其左子树节点个数为 0，右子树节点个数为 n-1，同理当 2 为根节点时，其左子树节点个数为 1，右子树节点为 n-2，所以可得 g(n) = g(0) * g(n-1) + g(1) * (n-2) + ... + g(n-1) * g(0)。\n\n\n# python3\n\nclass solution:\n    def numtrees(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        return dp[-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# java\n\nclass solution {\n    public int numtrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# c++\n\nclass solution {\npublic:\n    int numtrees(int n) {\n        vector<int> dp(n + 1);\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# go\n\nfunc numtrees(n int) int {\n\tdp := make([]int, n+1)\n\tdp[0] = 1\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i-j-1]\n\t\t}\n\t}\n\treturn dp[n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode97 Interleaving String-zh",frontmatter:{title:"leetcode97 Interleaving String-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/53d753/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0097.Interleaving%20String/images/interleave.jpg"},{name:"twitter:title",content:"leetcode97 Interleaving String-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0097.Interleaving%20String/images/interleave.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10097.leetcode97%20Interleaving%20String-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode97 Interleaving String-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0097.Interleaving%20String/images/interleave.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10097.leetcode97%20Interleaving%20String-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode97 Interleaving String-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0097.Interleaving%20String/images/interleave.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10097.leetcode97%20Interleaving%20String-zh.html",relativePath:"01.算法/24.leetcode/10097.leetcode97 Interleaving String-zh.md",key:"v-d9351e72",path:"/p/53d753/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:596},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:603},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:622},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:155}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 97. 交错字符串\n\nEnglish Version\n\n\n# 题目描述\n\n给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。\n\n两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：\n\n * s = s1 + s2 + ... + sn\n * t = t1 + t2 + ... + tm\n * |n - m| <= 1\n * 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...\n\n提示：a + b 意味着字符串 a 和 b 连接。\n\n \n\n示例 1：\n\n\n输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"\n输出：true\n\n\n示例 2：\n\n\n输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"\n输出：false\n\n\n示例 3：\n\n\n输入：s1 = "", s2 = "", s3 = ""\n输出：true\n\n\n \n\n提示：\n\n * 0 <= s1.length, s2.length <= 100\n * 0 <= s3.length <= 200\n * s1、s2、和 s3 都由小写英文字母组成\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 97. 交错字符串\n\nenglish version\n\n\n# 题目描述\n\n给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。\n\n两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：\n\n * s = s1 + s2 + ... + sn\n * t = t1 + t2 + ... + tm\n * |n - m| <= 1\n * 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...\n\n提示：a + b 意味着字符串 a 和 b 连接。\n\n \n\n示例 1：\n\n\n输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"\n输出：true\n\n\n示例 2：\n\n\n输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"\n输出：false\n\n\n示例 3：\n\n\n输入：s1 = "", s2 = "", s3 = ""\n输出：true\n\n\n \n\n提示：\n\n * 0 <= s1.length, s2.length <= 100\n * 0 <= s3.length <= 200\n * s1、s2、和 s3 都由小写英文字母组成\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode98 Validate Binary Search Tree-zh",frontmatter:{title:"leetcode98 Validate Binary Search Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/64d24d/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode98 Validate Binary Search Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10098.leetcode98%20Validate%20Binary%20Search%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode98 Validate Binary Search Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10098.leetcode98%20Validate%20Binary%20Search%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode98 Validate Binary Search Tree-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10098.leetcode98%20Validate%20Binary%20Search%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10098.leetcode98 Validate Binary Search Tree-zh.md",key:"v-12d6d9a7",path:"/p/64d24d/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:326},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:398},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1048},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1836}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 98. 验证二叉搜索树\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n * 节点的左子树只包含小于当前节点的数。\n * 节点的右子树只包含大于当前节点的数。\n * 所有左子树和右子树自身必须也是二叉搜索树。\n\n示例 1:\n\n输入:\n    2\n   / \\\n  1   3\n输出: true\n\n\n示例 2:\n\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n\n\n\n# 解法\n\n中序遍历，若是一个有效的二叉搜索树，那么遍历到的序列应该是单调递增的。所以只要比较判断遍历到的当前数是否 >= 上一个数即可。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    pre = None\n    def isValidBST(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        if not self.isValidBST(root.left):\n            return False\n        if self.pre is not None and self.pre >= root.val:\n            return False\n        self.pre = root.val\n        if not self.isValidBST(root.right):\n            return False\n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private Integer pre = null;\n    public boolean isValidBST(TreeNode root) {\n        if (root == null) return true;\n        if (!isValidBST(root.left)) return false;\n        if (pre != null && pre >= root.val) return false;\n        pre = root.val;\n        if (!isValidBST(root.right)) return false;\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 98. 验证二叉搜索树\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n * 节点的左子树只包含小于当前节点的数。\n * 节点的右子树只包含大于当前节点的数。\n * 所有左子树和右子树自身必须也是二叉搜索树。\n\n示例 1:\n\n输入:\n    2\n   / \\\n  1   3\n输出: true\n\n\n示例 2:\n\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n\n\n\n# 解法\n\n中序遍历，若是一个有效的二叉搜索树，那么遍历到的序列应该是单调递增的。所以只要比较判断遍历到的当前数是否 >= 上一个数即可。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    pre = none\n    def isvalidbst(self, root: treenode) -> bool:\n        if not root:\n            return true\n        if not self.isvalidbst(root.left):\n            return false\n        if self.pre is not none and self.pre >= root.val:\n            return false\n        self.pre = root.val\n        if not self.isvalidbst(root.right):\n            return false\n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    private integer pre = null;\n    public boolean isvalidbst(treenode root) {\n        if (root == null) return true;\n        if (!isvalidbst(root.left)) return false;\n        if (pre != null && pre >= root.val) return false;\n        pre = root.val;\n        if (!isvalidbst(root.right)) return false;\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode99 Recover Binary Search Tree-zh",frontmatter:{title:"leetcode99 Recover Binary Search Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/4c13f1/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0099.Recover%20Binary%20Search%20Tree/images/recover1.jpg"},{name:"twitter:title",content:"leetcode99 Recover Binary Search Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0099.Recover%20Binary%20Search%20Tree/images/recover1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10099.leetcode99%20Recover%20Binary%20Search%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode99 Recover Binary Search Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0099.Recover%20Binary%20Search%20Tree/images/recover1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10099.leetcode99%20Recover%20Binary%20Search%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode99 Recover Binary Search Tree-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0099.Recover%20Binary%20Search%20Tree/images/recover1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10099.leetcode99%20Recover%20Binary%20Search%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10099.leetcode99 Recover Binary Search Tree-zh.md",key:"v-67b93205",path:"/p/4c13f1/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:112},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:432},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1326},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1342}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 99. 恢复二叉搜索树\n\nEnglish Version\n\n\n# 题目描述\n\n给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。\n\n进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？\n\n \n\n示例 1：\n\n\n输入：root = [1,3,null,null,2]\n输出：[3,1,null,null,2]\n解释：3 不能是 1 左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。\n\n\n示例 2：\n\n\n输入：root = [3,1,4,null,null,2]\n输出：[2,1,4,null,null,3]\n解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。\n\n \n\n提示：\n\n * 树上节点的数目在范围 [2, 1000] 内\n * -231 <= Node.val <= 231 - 1\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    first = None\n    second = None\n    prev = None\n    def recoverTree(self, root: TreeNode) -> None:\n        """\n        Do not return anything, modify root in-place instead.\n        """\n        def dfs(root):\n            if root:\n                dfs(root.left)\n                if self.prev and root.val < self.prev.val:\n                    if not self.first:\n                        self.first = self.prev\n                    self.second = root\n                self.prev = root\n                dfs(root.right)\n        dfs(root)\n        self.first.val, self.second.val = self.second.val, self.first.val\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 99. 恢复二叉搜索树\n\nenglish version\n\n\n# 题目描述\n\n给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。\n\n进阶：使用 o(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？\n\n \n\n示例 1：\n\n\n输入：root = [1,3,null,null,2]\n输出：[3,1,null,null,2]\n解释：3 不能是 1 左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。\n\n\n示例 2：\n\n\n输入：root = [3,1,4,null,null,2]\n输出：[2,1,4,null,null,3]\n解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。\n\n \n\n提示：\n\n * 树上节点的数目在范围 [2, 1000] 内\n * -231 <= node.val <= 231 - 1\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    first = none\n    second = none\n    prev = none\n    def recovertree(self, root: treenode) -> none:\n        """\n        do not return anything, modify root in-place instead.\n        """\n        def dfs(root):\n            if root:\n                dfs(root.left)\n                if self.prev and root.val < self.prev.val:\n                    if not self.first:\n                        self.first = self.prev\n                    self.second = root\n                self.prev = root\n                dfs(root.right)\n        dfs(root)\n        self.first.val, self.second.val = self.second.val, self.first.val\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode101 Symmetric Tree-zh",frontmatter:{title:"leetcode101 Symmetric Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/f654ba/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode101 Symmetric Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10101.leetcode101%20Symmetric%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode101 Symmetric Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10101.leetcode101%20Symmetric%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode101 Symmetric Tree-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10101.leetcode101%20Symmetric%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10101.leetcode101 Symmetric Tree-zh.md",key:"v-6b98a4ad",path:"/p/f654ba/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:257},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:264},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:995},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1701},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2200}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript",content:"# 101. 对称二叉树\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\n \n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n\n \n\n进阶：\n\n你可以运用递归和迭代两种方法解决这个问题吗？\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if root is None:\n            return True\n        return self.is_symmetric(root.left, root.right)\n\n    def is_symmetric(self, left: TreeNode, right: TreeNode) -> bool:\n        if left is None and right is None:\n            return True\n        if left is None or right is None or left.val != right.val:\n            return False\n        return self.is_symmetric(left.left, right.right) and self.is_symmetric(left.right, right.left)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) return true;\n        return isSymmetric(root.left, root.right);\n    }\n\n    private boolean isSymmetric(TreeNode left, TreeNode right) {\n        if (left == null && right == null) return true;\n        if (left == null || right == null || left.val != right.val) return false;\n        return isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# C++\n\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (!root) return true;\n        return isSymmetric(root->left, root->right);\n    }\n\nprivate:\n    bool isSymmetric(TreeNode* left, TreeNode* right) {\n        if (!left && !right) return true;\n        if (!left && right || left && !right || left->val != right->val) return false;\n        return isSymmetric(left->left, right->right) && isSymmetric(left->right, right->left);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# JavaScript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n  let result = [];\n  if (!root) return result;\n\n  let queue = [];\n  queue.push(root);\n  while (queue.length) {\n    let size = queue.length;\n    let levelItems = [];\n    while (size--) {\n      let node = queue.shift();\n      levelItems.push(node.val);\n      if (node.left) {\n        queue.push(node.left);\n      }\n      if (node.right) {\n        queue.push(node.right);\n      }\n    }\n    result.push(levelItems);\n  }\n  return result;\n};\n\n### **...**\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n\x3c!-- tabs:end --\x3e\n\n\n1\n2\n",normalizedContent:"# 101. 对称二叉树\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\n \n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n\n \n\n进阶：\n\n你可以运用递归和迭代两种方法解决这个问题吗？\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def issymmetric(self, root: treenode) -> bool:\n        if root is none:\n            return true\n        return self.is_symmetric(root.left, root.right)\n\n    def is_symmetric(self, left: treenode, right: treenode) -> bool:\n        if left is none and right is none:\n            return true\n        if left is none or right is none or left.val != right.val:\n            return false\n        return self.is_symmetric(left.left, right.right) and self.is_symmetric(left.right, right.left)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean issymmetric(treenode root) {\n        if (root == null) return true;\n        return issymmetric(root.left, root.right);\n    }\n\n    private boolean issymmetric(treenode left, treenode right) {\n        if (left == null && right == null) return true;\n        if (left == null || right == null || left.val != right.val) return false;\n        return issymmetric(left.left, right.right) && issymmetric(left.right, right.left);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# c++\n\nclass solution {\npublic:\n    bool issymmetric(treenode* root) {\n        if (!root) return true;\n        return issymmetric(root->left, root->right);\n    }\n\nprivate:\n    bool issymmetric(treenode* left, treenode* right) {\n        if (!left && !right) return true;\n        if (!left && right || left && !right || left->val != right->val) return false;\n        return issymmetric(left->left, right->right) && issymmetric(left->right, right->left);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# javascript\n\n/**\n * definition for a binary tree node.\n * function treenode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {treenode} root\n * @return {number[][]}\n */\nvar levelorder = function (root) {\n  let result = [];\n  if (!root) return result;\n\n  let queue = [];\n  queue.push(root);\n  while (queue.length) {\n    let size = queue.length;\n    let levelitems = [];\n    while (size--) {\n      let node = queue.shift();\n      levelitems.push(node.val);\n      if (node.left) {\n        queue.push(node.left);\n      }\n      if (node.right) {\n        queue.push(node.right);\n      }\n    }\n    result.push(levelitems);\n  }\n  return result;\n};\n\n### **...**\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n\x3c!-- tabs:end --\x3e\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode100 Same Tree-zh",frontmatter:{title:"leetcode100 Same Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/7662fd/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0100.Same%20Tree/images/ex1.jpg"},{name:"twitter:title",content:"leetcode100 Same Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0100.Same%20Tree/images/ex1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10100.leetcode100%20Same%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode100 Same Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0100.Same%20Tree/images/ex1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10100.leetcode100%20Same%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode100 Same Tree-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0100.Same%20Tree/images/ex1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10100.leetcode100%20Same%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10100.leetcode100 Same Tree-zh.md",key:"v-1c0a88ad",path:"/p/7662fd/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:324},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:331},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:851},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1537},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2204},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2632},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3228}],headersStr:"题目描述 解法 Python3 Java C++ Go JavaScript ...",content:"# 100. 相同的树\n\nEnglish Version\n\n\n# 题目描述\n\n给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n \n\n示例 1：\n\n\n输入：p = [1,2,3], q = [1,2,3]\n输出：true\n\n\n示例 2：\n\n\n输入：p = [1,2], q = [1,null,2]\n输出：false\n\n\n示例 3：\n\n\n输入：p = [1,2,1], q = [1,1,2]\n输出：false\n\n\n \n\n提示：\n\n * 两棵树上的节点数目都在范围 [0, 100] 内\n * -104 <= Node.val <= 104\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if p == q:\n            return True\n        if p is None or q is None or p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == q) return true;\n        if (p == null || q == null || p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# C++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == q) return true;\n        if (!p || !q || p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Go\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    if p == q {\n        return true\n    }\n    if p == nil || q == nil || p.Val != q.Val {\n        return false\n    }\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# JavaScript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n    if (!p && !q) return true;\n    if (p && q) {\n        return (p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right))\n    }\n    return false;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 100. 相同的树\n\nenglish version\n\n\n# 题目描述\n\n给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n \n\n示例 1：\n\n\n输入：p = [1,2,3], q = [1,2,3]\n输出：true\n\n\n示例 2：\n\n\n输入：p = [1,2], q = [1,null,2]\n输出：false\n\n\n示例 3：\n\n\n输入：p = [1,2,1], q = [1,1,2]\n输出：false\n\n\n \n\n提示：\n\n * 两棵树上的节点数目都在范围 [0, 100] 内\n * -104 <= node.val <= 104\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def issametree(self, p: treenode, q: treenode) -> bool:\n        if p == q:\n            return true\n        if p is none or q is none or p.val != q.val:\n            return false\n        return self.issametree(p.left, q.left) and self.issametree(p.right, q.right)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public boolean issametree(treenode p, treenode q) {\n        if (p == q) return true;\n        if (p == null || q == null || p.val != q.val) return false;\n        return issametree(p.left, q.left) && issametree(p.right, q.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# c++\n\n/**\n * definition for a binary tree node.\n * struct treenode {\n *     int val;\n *     treenode *left;\n *     treenode *right;\n *     treenode() : val(0), left(nullptr), right(nullptr) {}\n *     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass solution {\npublic:\n    bool issametree(treenode* p, treenode* q) {\n        if (p == q) return true;\n        if (!p || !q || p->val != q->val) return false;\n        return issametree(p->left, q->left) && issametree(p->right, q->right);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# go\n\n/**\n * definition for a binary tree node.\n * type treenode struct {\n *     val int\n *     left *treenode\n *     right *treenode\n * }\n */\nfunc issametree(p *treenode, q *treenode) bool {\n    if p == q {\n        return true\n    }\n    if p == nil || q == nil || p.val != q.val {\n        return false\n    }\n    return issametree(p.left, q.left) && issametree(p.right, q.right)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# javascript\n\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} p\n * @param {treenode} q\n * @return {boolean}\n */\nvar issametree = function (p, q) {\n    if (!p && !q) return true;\n    if (p && q) {\n        return (p.val === q.val && issametree(p.left, q.left) && issametree(p.right, q.right))\n    }\n    return false;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode102 Binary Tree Level Order Traversal-zh",frontmatter:{title:"leetcode102 Binary Tree Level Order Traversal-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/74e9b3/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode102 Binary Tree Level Order Traversal-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10102.leetcode102%20Binary%20Tree%20Level%20Order%20Traversal-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode102 Binary Tree Level Order Traversal-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10102.leetcode102%20Binary%20Tree%20Level%20Order%20Traversal-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode102 Binary Tree Level Order Traversal-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10102.leetcode102%20Binary%20Tree%20Level%20Order%20Traversal-zh.html",relativePath:"01.算法/24.leetcode/10102.leetcode102 Binary Tree Level Order Traversal-zh.md",key:"v-6b5017b6",path:"/p/74e9b3/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:219},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:233},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1034},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1975},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2844}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 102. 二叉树的层序遍历\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n \n\n示例：\n二叉树：[3,9,20,null,null,15,7],\n\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回其层序遍历结果：\n\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n\n\n# 解法\n\n队列实现。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        if root is None:\n            return []\n        res = []\n        q = []\n        q.append(root)\n        while q:\n            size = len(q)\n            t = []\n            for _ in range(size):\n                node = q.pop(0)\n                if node.left is not None:\n                    q.append(node.left)\n                if node.right is not None:\n                    q.append(node.right)\n                t.append(node.val)\n            res.append(t)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        if (root == null) return Collections.emptyList();\n        Deque<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        List<List<Integer>> res = new ArrayList<>();\n        while (!q.isEmpty()) {\n            int size = q.size();\n            List<Integer> t = new ArrayList<>();\n            while (size-- > 0) {\n                TreeNode node = q.poll();\n                t.add(node.val);\n                if (node.left != null) q.offer(node.left);\n                if (node.right != null) q.offer(node.right);\n            }\n            res.add(t);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# C++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if (!root) return {};\n        vector<vector<int>> res;\n        queue<TreeNode*> q{{root}};\n        while (!q.empty()) {\n            vector<int> oneLevel;\n            for (int i = q.size(); i > 0; --i) {\n                TreeNode* t = q.front();\n                q.pop();\n                oneLevel.push_back(t->val);\n                if (t->left) q.push(t->left);\n                if (t->right) q.push(t->right);\n            }\n            res.push_back(oneLevel);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 102. 二叉树的层序遍历\n\nenglish version\n\n\n# 题目描述\n\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n \n\n示例：\n二叉树：[3,9,20,null,null,15,7],\n\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回其层序遍历结果：\n\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n\n\n# 解法\n\n队列实现。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def levelorder(self, root: treenode) -> list[list[int]]:\n        if root is none:\n            return []\n        res = []\n        q = []\n        q.append(root)\n        while q:\n            size = len(q)\n            t = []\n            for _ in range(size):\n                node = q.pop(0)\n                if node.left is not none:\n                    q.append(node.left)\n                if node.right is not none:\n                    q.append(node.right)\n                t.append(node.val)\n            res.append(t)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<list<integer>> levelorder(treenode root) {\n        if (root == null) return collections.emptylist();\n        deque<treenode> q = new arraydeque<>();\n        q.offer(root);\n        list<list<integer>> res = new arraylist<>();\n        while (!q.isempty()) {\n            int size = q.size();\n            list<integer> t = new arraylist<>();\n            while (size-- > 0) {\n                treenode node = q.poll();\n                t.add(node.val);\n                if (node.left != null) q.offer(node.left);\n                if (node.right != null) q.offer(node.right);\n            }\n            res.add(t);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# c++\n\n/**\n * definition for a binary tree node.\n * struct treenode {\n *     int val;\n *     treenode *left;\n *     treenode *right;\n *     treenode(int x) : val(x), left(null), right(null) {}\n * };\n */\nclass solution {\npublic:\n    vector<vector<int>> levelorder(treenode* root) {\n        if (!root) return {};\n        vector<vector<int>> res;\n        queue<treenode*> q{{root}};\n        while (!q.empty()) {\n            vector<int> onelevel;\n            for (int i = q.size(); i > 0; --i) {\n                treenode* t = q.front();\n                q.pop();\n                onelevel.push_back(t->val);\n                if (t->left) q.push(t->left);\n                if (t->right) q.push(t->right);\n            }\n            res.push_back(onelevel);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode106 Construct Binary Tree from Inorder and Postorder Traversal-zh",frontmatter:{title:"leetcode106 Construct Binary Tree from Inorder and Postorder Traversal-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/bb567d/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode106 Construct Binary Tree from Inorder and Postorder Traversal-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10106.leetcode106%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode106 Construct Binary Tree from Inorder and Postorder Traversal-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10106.leetcode106%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode106 Construct Binary Tree from Inorder and Postorder Traversal-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10106.leetcode106%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal-zh.html",relativePath:"01.算法/24.leetcode/10106.leetcode106 Construct Binary Tree from Inorder and Postorder Traversal-zh.md",key:"v-722c7ae1",path:"/p/bb567d/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:44},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:218},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:235},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1217},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2342},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3195}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 106. 从中序与后序遍历序列构造二叉树\n\nEnglish Version\n\n\n# 题目描述\n\n根据一棵树的中序遍历与后序遍历构造二叉树。\n\n注意:\n你可以假设树中没有重复的元素。\n\n例如，给出\n\n中序遍历 inorder = [9,3,15,20,7]\n后序遍历 postorder = [9,15,7,20,3]\n\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n\n# 解法\n\n思路同 105。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    indexes = {}\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        def build(inorder, postorder, i1, i2, p1, p2):\n            if i1 > i2 or p1 > p2:\n                return None\n            root_val = postorder[p2]\n            pos = self.indexes[root_val]\n            root = TreeNode(root_val)\n            root.left = None if pos == i1 else build(inorder, postorder, i1, pos - 1, p1, p1 - i1 + pos - 1)\n            root.right = None if pos == i2 else build(inorder, postorder, pos + 1, i2, p1 - i1 + pos, p2 - 1)\n            return root\n        n = len(inorder)\n        for i in range(n):\n            self.indexes[inorder[i]] = i\n        return build(inorder, postorder, 0, n - 1, 0, n - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private Map<Integer, Integer> indexes = new HashMap<>();\n\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        int n = inorder.length;\n        for (int i = 0; i < n; ++i) {\n            indexes.put(inorder[i], i);\n        }\n        return build(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);\n    }\n\n    private TreeNode build(int[] inorder, int[] postorder, int i1, int i2, int p1, int p2) {\n        if (i1 > i2 || p1 > p2) return null;\n        int rootVal = postorder[p2];\n        int pos = indexes.get(rootVal);\n        TreeNode root = new TreeNode(rootVal);\n        root.left = pos == i1 ? null : build(inorder, postorder, i1, pos - 1, p1, p1 - i1 + pos - 1);\n        root.right = pos == i2 ? null : build(inorder, postorder, pos + 1, i2, p1 - i1 + pos, p2 - 1);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# C++\n\nclass Solution {\npublic:\n    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\n        return buildTree(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);\n    }\n    TreeNode *buildTree(vector<int> &inorder, int iLeft, int iRight, vector<int> &postorder, int pLeft, int pRight) {\n        if (iLeft > iRight || pLeft > pRight) return NULL;\n        TreeNode *cur = new TreeNode(postorder[pRight]);\n        int i = 0;\n        for (i = iLeft; i < inorder.size(); ++i) {\n            if (inorder[i] == cur->val)\n                break;\n        }\n        cur->left = buildTree(inorder, iLeft, i - 1, postorder, pLeft, pLeft + i - iLeft - 1);\n        cur->right = buildTree(inorder, i + 1, iRight, postorder, pLeft + i - iLeft, pRight - 1);\n        return cur;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 106. 从中序与后序遍历序列构造二叉树\n\nenglish version\n\n\n# 题目描述\n\n根据一棵树的中序遍历与后序遍历构造二叉树。\n\n注意:\n你可以假设树中没有重复的元素。\n\n例如，给出\n\n中序遍历 inorder = [9,3,15,20,7]\n后序遍历 postorder = [9,15,7,20,3]\n\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n\n# 解法\n\n思路同 105。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    indexes = {}\n    def buildtree(self, inorder: list[int], postorder: list[int]) -> treenode:\n        def build(inorder, postorder, i1, i2, p1, p2):\n            if i1 > i2 or p1 > p2:\n                return none\n            root_val = postorder[p2]\n            pos = self.indexes[root_val]\n            root = treenode(root_val)\n            root.left = none if pos == i1 else build(inorder, postorder, i1, pos - 1, p1, p1 - i1 + pos - 1)\n            root.right = none if pos == i2 else build(inorder, postorder, pos + 1, i2, p1 - i1 + pos, p2 - 1)\n            return root\n        n = len(inorder)\n        for i in range(n):\n            self.indexes[inorder[i]] = i\n        return build(inorder, postorder, 0, n - 1, 0, n - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    private map<integer, integer> indexes = new hashmap<>();\n\n    public treenode buildtree(int[] inorder, int[] postorder) {\n        int n = inorder.length;\n        for (int i = 0; i < n; ++i) {\n            indexes.put(inorder[i], i);\n        }\n        return build(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);\n    }\n\n    private treenode build(int[] inorder, int[] postorder, int i1, int i2, int p1, int p2) {\n        if (i1 > i2 || p1 > p2) return null;\n        int rootval = postorder[p2];\n        int pos = indexes.get(rootval);\n        treenode root = new treenode(rootval);\n        root.left = pos == i1 ? null : build(inorder, postorder, i1, pos - 1, p1, p1 - i1 + pos - 1);\n        root.right = pos == i2 ? null : build(inorder, postorder, pos + 1, i2, p1 - i1 + pos, p2 - 1);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# c++\n\nclass solution {\npublic:\n    treenode *buildtree(vector<int> &inorder, vector<int> &postorder) {\n        return buildtree(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);\n    }\n    treenode *buildtree(vector<int> &inorder, int ileft, int iright, vector<int> &postorder, int pleft, int pright) {\n        if (ileft > iright || pleft > pright) return null;\n        treenode *cur = new treenode(postorder[pright]);\n        int i = 0;\n        for (i = ileft; i < inorder.size(); ++i) {\n            if (inorder[i] == cur->val)\n                break;\n        }\n        cur->left = buildtree(inorder, ileft, i - 1, postorder, pleft, pleft + i - ileft - 1);\n        cur->right = buildtree(inorder, i + 1, iright, postorder, pleft + i - ileft, pright - 1);\n        return cur;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode107 Binary Tree Level Order Traversal II-zh",frontmatter:{title:"leetcode107 Binary Tree Level Order Traversal II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/cdb832/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode107 Binary Tree Level Order Traversal II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10107.leetcode107%20Binary%20Tree%20Level%20Order%20Traversal%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode107 Binary Tree Level Order Traversal II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10107.leetcode107%20Binary%20Tree%20Level%20Order%20Traversal%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode107 Binary Tree Level Order Traversal II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10107.leetcode107%20Binary%20Tree%20Level%20Order%20Traversal%20II-zh.html",relativePath:"01.算法/24.leetcode/10107.leetcode107 Binary Tree Level Order Traversal II-zh.md",key:"v-c7d4dc5a",path:"/p/cdb832/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:40},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:233},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:259},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1050},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2e3},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3038}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 107. 二叉树的层序遍历 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n例如：\n给定二叉树 [3,9,20,null,null,15,7],\n\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回其自底向上的层序遍历为：\n\n\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n\n\n\n# 解法\n\n同 102，最后反转一下结果即可。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:\n        if root is None:\n            return []\n        q = [root]\n        res = []\n        while q:\n            size = len(q)\n            t = []\n            for _ in range(size):\n                node = q.pop(0)\n                t.append(node.val)\n                if node.left is not None:\n                    q.append(node.left)\n                if node.right is not None:\n                    q.append(node.right)\n            res.append(t)\n        return res[::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        if (root == null) return Collections.emptyList();\n        Deque<TreeNode> q = new ArrayDeque<>();\n        List<List<Integer>> res = new ArrayList<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            List<Integer> t = new ArrayList<>();\n            while (size-- > 0) {\n                TreeNode node = q.poll();\n                t.add(node.val);\n                if (node.left != null) q.offer(node.left);\n                if (node.right != null) q.offer(node.right);\n            }\n            res.add(0, t);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# JavaScript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrderBottom = function (root) {\n    if (!root) {\n        return [];\n    }\n    let q = [], output = [], levelOutput = [];\n    q.push(root);\n    q.push(null);\n    while (q.length) {\n        let cur = q.shift();\n        levelOutput.push(cur.val);\n        if (cur.left) {\n            q.push(cur.left);\n        }\n        if (cur.right) {\n            q.push(cur.right);\n        }\n        if (!q[0]) {\n            q.shift();\n            output.unshift(levelOutput);\n            levelOutput = [];\n            if (q.length) {\n                q.push(null);\n            }\n        }\n    }\n    return output;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 107. 二叉树的层序遍历 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n例如：\n给定二叉树 [3,9,20,null,null,15,7],\n\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回其自底向上的层序遍历为：\n\n\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n\n\n\n# 解法\n\n同 102，最后反转一下结果即可。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def levelorderbottom(self, root: treenode) -> list[list[int]]:\n        if root is none:\n            return []\n        q = [root]\n        res = []\n        while q:\n            size = len(q)\n            t = []\n            for _ in range(size):\n                node = q.pop(0)\n                t.append(node.val)\n                if node.left is not none:\n                    q.append(node.left)\n                if node.right is not none:\n                    q.append(node.right)\n            res.append(t)\n        return res[::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<list<integer>> levelorderbottom(treenode root) {\n        if (root == null) return collections.emptylist();\n        deque<treenode> q = new arraydeque<>();\n        list<list<integer>> res = new arraylist<>();\n        q.offer(root);\n        while (!q.isempty()) {\n            int size = q.size();\n            list<integer> t = new arraylist<>();\n            while (size-- > 0) {\n                treenode node = q.poll();\n                t.add(node.val);\n                if (node.left != null) q.offer(node.left);\n                if (node.right != null) q.offer(node.right);\n            }\n            res.add(0, t);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# javascript\n\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number[][]}\n */\nvar levelorderbottom = function (root) {\n    if (!root) {\n        return [];\n    }\n    let q = [], output = [], leveloutput = [];\n    q.push(root);\n    q.push(null);\n    while (q.length) {\n        let cur = q.shift();\n        leveloutput.push(cur.val);\n        if (cur.left) {\n            q.push(cur.left);\n        }\n        if (cur.right) {\n            q.push(cur.right);\n        }\n        if (!q[0]) {\n            q.shift();\n            output.unshift(leveloutput);\n            leveloutput = [];\n            if (q.length) {\n                q.push(null);\n            }\n        }\n    }\n    return output;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode108 Convert Sorted Array to Binary Search Tree-zh",frontmatter:{title:"leetcode108 Convert Sorted Array to Binary Search Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/ea87fb/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0108.Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/images/btree1.jpg"},{name:"twitter:title",content:"leetcode108 Convert Sorted Array to Binary Search Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0108.Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/images/btree1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10108.leetcode108%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode108 Convert Sorted Array to Binary Search Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0108.Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/images/btree1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10108.leetcode108%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode108 Convert Sorted Array to Binary Search Tree-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0108.Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/images/btree1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10108.leetcode108%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10108.leetcode108 Convert Sorted Array to Binary Search Tree-zh.md",key:"v-edee666c",path:"/p/ea87fb/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:42},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:398},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:405},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1009},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1936},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2878},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3681}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript ...",content:"# 108. 将有序数组转换为二叉搜索树\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。\n\n高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n\n \n\n示例 1：\n\n\n输入：nums = [-10,-3,0,5,9]\n输出：[0,-3,9,-10,null,5]\n解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：\n\n\n\n示例 2：\n\n\n输入：nums = [1,3]\n输出：[3,1]\n解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 104\n * -104 <= nums[i] <= 104\n * nums 按 严格递增 顺序排列\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\n        def buildBST(nums, start, end):\n            if start > end:\n                return None\n            mid = (start + end) >> 1\n            return TreeNode(nums[mid], buildBST(nums, start, mid - 1), buildBST(nums, mid + 1, end))\n\n        return buildBST(nums, 0, len(nums) - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return buildBST(nums, 0, nums.length - 1);\n    }\n\n    private TreeNode buildBST(int[] nums, int start, int end) {\n        if (start > end) {\n            return null;\n        }\n        int mid = (start + end) >> 1;\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = buildBST(nums, start, mid - 1);\n        root.right = buildBST(nums, mid + 1, end);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# C++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        return buildBST(nums, 0, nums.size() - 1);\n    }\n\nprivate:\n    TreeNode* buildBST(vector<int>& nums, int start, int end) {\n        if (start > end) {\n            return nullptr;\n        }\n        int mid = (start + end) / 2;\n        TreeNode *root = new TreeNode(nums[mid]);\n        root->left = buildBST(nums, start, mid - 1);\n        root->right = buildBST(nums, mid + 1, end);\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# JavaScript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar sortedArrayToBST = function(nums) {\n    const buildBST = (nums, start, end) => {\n        if (start > end) {\n            return null;\n        }\n        const mid = (start + end) >> 1;\n        const root = new TreeNode(nums[mid]);\n        root.left = buildBST(nums, start, mid - 1);\n        root.right = buildBST(nums, mid + 1, end);\n        return root;\n    }\n\n    return buildBST(nums, 0, nums.length - 1);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 108. 将有序数组转换为二叉搜索树\n\nenglish version\n\n\n# 题目描述\n\n给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。\n\n高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n\n \n\n示例 1：\n\n\n输入：nums = [-10,-3,0,5,9]\n输出：[0,-3,9,-10,null,5]\n解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：\n\n\n\n示例 2：\n\n\n输入：nums = [1,3]\n输出：[3,1]\n解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 104\n * -104 <= nums[i] <= 104\n * nums 按 严格递增 顺序排列\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def sortedarraytobst(self, nums: list[int]) -> treenode:\n        def buildbst(nums, start, end):\n            if start > end:\n                return none\n            mid = (start + end) >> 1\n            return treenode(nums[mid], buildbst(nums, start, mid - 1), buildbst(nums, mid + 1, end))\n\n        return buildbst(nums, 0, len(nums) - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public treenode sortedarraytobst(int[] nums) {\n        return buildbst(nums, 0, nums.length - 1);\n    }\n\n    private treenode buildbst(int[] nums, int start, int end) {\n        if (start > end) {\n            return null;\n        }\n        int mid = (start + end) >> 1;\n        treenode root = new treenode(nums[mid]);\n        root.left = buildbst(nums, start, mid - 1);\n        root.right = buildbst(nums, mid + 1, end);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# c++\n\n/**\n * definition for a binary tree node.\n * struct treenode {\n *     int val;\n *     treenode *left;\n *     treenode *right;\n *     treenode() : val(0), left(nullptr), right(nullptr) {}\n *     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass solution {\npublic:\n    treenode* sortedarraytobst(vector<int>& nums) {\n        return buildbst(nums, 0, nums.size() - 1);\n    }\n\nprivate:\n    treenode* buildbst(vector<int>& nums, int start, int end) {\n        if (start > end) {\n            return nullptr;\n        }\n        int mid = (start + end) / 2;\n        treenode *root = new treenode(nums[mid]);\n        root->left = buildbst(nums, start, mid - 1);\n        root->right = buildbst(nums, mid + 1, end);\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# javascript\n\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} nums\n * @return {treenode}\n */\nvar sortedarraytobst = function(nums) {\n    const buildbst = (nums, start, end) => {\n        if (start > end) {\n            return null;\n        }\n        const mid = (start + end) >> 1;\n        const root = new treenode(nums[mid]);\n        root.left = buildbst(nums, start, mid - 1);\n        root.right = buildbst(nums, mid + 1, end);\n        return root;\n    }\n\n    return buildbst(nums, 0, nums.length - 1);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode109 Convert Sorted List to Binary Search Tree-zh",frontmatter:{title:"leetcode109 Convert Sorted List to Binary Search Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/bc54a6/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode109 Convert Sorted List to Binary Search Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10109.leetcode109%20Convert%20Sorted%20List%20to%20Binary%20Search%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode109 Convert Sorted List to Binary Search Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10109.leetcode109%20Convert%20Sorted%20List%20to%20Binary%20Search%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode109 Convert Sorted List to Binary Search Tree-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10109.leetcode109%20Convert%20Sorted%20List%20to%20Binary%20Search%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10109.leetcode109 Convert Sorted List to Binary Search Tree-zh.md",key:"v-72dbfc5e",path:"/p/bc54a6/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:40},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:271},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:278},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1167},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2549},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:3927},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:5055}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript ...",content:"# 109. 有序链表转换二叉搜索树\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n示例:\n\n给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n\n\n\n# 解法\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def buildBST(nums, start, end):\n            if start > end:\n                return None\n            mid = (start + end) >> 1\n            return TreeNode(nums[mid], buildBST(nums, start, mid - 1), buildBST(nums, mid + 1, end))\n        \n        nums = []\n        while head:\n            nums.append(head.val)\n            head = head.next\n        return buildBST(nums, 0, len(nums) - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> nums = new ArrayList<>();\n        for (; head != null; head = head.next) {\n            nums.add(head.val);\n        }\n        return buildBST(nums, 0, nums.size() - 1);\n    }\n\n    private TreeNode buildBST(List<Integer> nums, int start, int end) {\n        if (start > end) {\n            return null;\n        }\n        int mid = (start + end) >> 1;\n        TreeNode root = new TreeNode(nums.get(mid));\n        root.left = buildBST(nums, start, mid - 1);\n        root.right = buildBST(nums, mid + 1, end);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector<int> nums;\n        for (; head != nullptr; head = head->next) {\n            nums.push_back(head->val);\n        }\n        return buildBST(nums, 0, nums.size() - 1);\n    }\n\nprivate:\n    TreeNode* buildBST(vector<int>& nums, int start, int end) {\n        if (start > end) {\n            return nullptr;\n        }\n        int mid = (start + end) / 2;\n        TreeNode *root = new TreeNode(nums[mid]);\n        root->left = buildBST(nums, start, mid - 1);\n        root->right = buildBST(nums, mid + 1, end);\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    const buildBST = (nums, start, end) => {\n        if (start > end) {\n            return null;\n        }\n        const mid = (start + end) >> 1;\n        const root = new TreeNode(nums[mid]);\n        root.left = buildBST(nums, start, mid - 1);\n        root.right = buildBST(nums, mid + 1, end);\n        return root;\n    }\n\n    const nums = new Array();\n    for (; head != null; head = head.next) {\n        nums.push(head.val);\n    }\n    return buildBST(nums, 0, nums.length - 1);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 109. 有序链表转换二叉搜索树\n\nenglish version\n\n\n# 题目描述\n\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n示例:\n\n给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n\n\n\n# 解法\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def sortedlisttobst(self, head: listnode) -> treenode:\n        def buildbst(nums, start, end):\n            if start > end:\n                return none\n            mid = (start + end) >> 1\n            return treenode(nums[mid], buildbst(nums, start, mid - 1), buildbst(nums, mid + 1, end))\n        \n        nums = []\n        while head:\n            nums.append(head.val)\n            head = head.next\n        return buildbst(nums, 0, len(nums) - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public treenode sortedlisttobst(listnode head) {\n        list<integer> nums = new arraylist<>();\n        for (; head != null; head = head.next) {\n            nums.add(head.val);\n        }\n        return buildbst(nums, 0, nums.size() - 1);\n    }\n\n    private treenode buildbst(list<integer> nums, int start, int end) {\n        if (start > end) {\n            return null;\n        }\n        int mid = (start + end) >> 1;\n        treenode root = new treenode(nums.get(mid));\n        root.left = buildbst(nums, start, mid - 1);\n        root.right = buildbst(nums, mid + 1, end);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\n/**\n * definition for a binary tree node.\n * struct treenode {\n *     int val;\n *     treenode *left;\n *     treenode *right;\n *     treenode() : val(0), left(nullptr), right(nullptr) {}\n *     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass solution {\npublic:\n    treenode* sortedlisttobst(listnode* head) {\n        vector<int> nums;\n        for (; head != nullptr; head = head->next) {\n            nums.push_back(head->val);\n        }\n        return buildbst(nums, 0, nums.size() - 1);\n    }\n\nprivate:\n    treenode* buildbst(vector<int>& nums, int start, int end) {\n        if (start > end) {\n            return nullptr;\n        }\n        int mid = (start + end) / 2;\n        treenode *root = new treenode(nums[mid]);\n        root->left = buildbst(nums, start, mid - 1);\n        root->right = buildbst(nums, mid + 1, end);\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {listnode} head\n * @return {treenode}\n */\nvar sortedlisttobst = function(head) {\n    const buildbst = (nums, start, end) => {\n        if (start > end) {\n            return null;\n        }\n        const mid = (start + end) >> 1;\n        const root = new treenode(nums[mid]);\n        root.left = buildbst(nums, start, mid - 1);\n        root.right = buildbst(nums, mid + 1, end);\n        return root;\n    }\n\n    const nums = new array();\n    for (; head != null; head = head.next) {\n        nums.push(head.val);\n    }\n    return buildbst(nums, 0, nums.length - 1);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode110 Balanced Binary Tree-zh",frontmatter:{title:"leetcode110 Balanced Binary Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/00d991/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0110.Balanced%20Binary%20Tree/images/balance_1.jpg"},{name:"twitter:title",content:"leetcode110 Balanced Binary Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0110.Balanced%20Binary%20Tree/images/balance_1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10110.leetcode110%20Balanced%20Binary%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode110 Balanced Binary Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0110.Balanced%20Binary%20Tree/images/balance_1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10110.leetcode110%20Balanced%20Binary%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode110 Balanced Binary Tree-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0110.Balanced%20Binary%20Tree/images/balance_1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10110.leetcode110%20Balanced%20Binary%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10110.leetcode110 Balanced Binary Tree-zh.md",key:"v-07325a6c",path:"/p/00d991/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:325},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:332},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1021},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2031},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2753},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3754}],headersStr:"题目描述 解法 Python3 Java JavaScript C++ ...",content:"# 110. 平衡二叉树\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n> 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。\n\n \n\n示例 1：\n\n\n输入：root = [3,9,20,null,null,15,7]\n输出：true\n\n\n示例 2：\n\n\n输入：root = [1,2,2,3,3,null,null,4,4]\n输出：false\n\n\n示例 3：\n\n\n输入：root = []\n输出：true\n\n\n \n\n提示：\n\n * 树中的节点数在范围 [0, 5000] 内\n * -104 <= Node.val <= 104\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def height(root):\n            if not root:\n                return 0\n            return 1 + max(height(root.left), height(root.right))\n        if not root:\n            return True\n        left_height, right_height = height(root.left), height(root.right)\n        return abs(left_height - right_height) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        return Math.abs(leftHeight - rightHeight) <= 1 && isBalanced(root.left) && isBalanced(root.right);\n    }\n\n    private int height(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int l = height(root.left);\n        int r = height(root.right);\n        return 1 + Math.max(l, r);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# JavaScript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\n var isBalanced = function(root) {\n    if (root == null) return true; \n    let left = root.left;\n    let right = root.right;\n    return isBalanced(left) && isBalanced(right) && Math.abs(depth(left) - depth(right)) <= 1;\n};\n\nfunction depth(root) {\n    if (root == null) return 0;\n    return Math.max(depth(root.left), depth(root.right)) + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# C++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        if (root == nullptr) {\n            return true;\n        }\n        int leftHeight = height(root->left);\n        int rightHeight = height(root->right);\n        return abs(leftHeight - rightHeight) <= 1 && isBalanced(root->left) && isBalanced(root->right);\n    }\nprivate:\n    int height(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        int l = height(root->left);\n        int r = height(root->right);\n        return 1 + max(l, r);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 110. 平衡二叉树\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n> 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。\n\n \n\n示例 1：\n\n\n输入：root = [3,9,20,null,null,15,7]\n输出：true\n\n\n示例 2：\n\n\n输入：root = [1,2,2,3,3,null,null,4,4]\n输出：false\n\n\n示例 3：\n\n\n输入：root = []\n输出：true\n\n\n \n\n提示：\n\n * 树中的节点数在范围 [0, 5000] 内\n * -104 <= node.val <= 104\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def isbalanced(self, root: treenode) -> bool:\n        def height(root):\n            if not root:\n                return 0\n            return 1 + max(height(root.left), height(root.right))\n        if not root:\n            return true\n        left_height, right_height = height(root.left), height(root.right)\n        return abs(left_height - right_height) <= 1 and self.isbalanced(root.left) and self.isbalanced(root.right)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public boolean isbalanced(treenode root) {\n        if (root == null) {\n            return true;\n        }\n        int leftheight = height(root.left);\n        int rightheight = height(root.right);\n        return math.abs(leftheight - rightheight) <= 1 && isbalanced(root.left) && isbalanced(root.right);\n    }\n\n    private int height(treenode root) {\n        if (root == null) {\n            return 0;\n        }\n        int l = height(root.left);\n        int r = height(root.right);\n        return 1 + math.max(l, r);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# javascript\n\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {boolean}\n */\n var isbalanced = function(root) {\n    if (root == null) return true; \n    let left = root.left;\n    let right = root.right;\n    return isbalanced(left) && isbalanced(right) && math.abs(depth(left) - depth(right)) <= 1;\n};\n\nfunction depth(root) {\n    if (root == null) return 0;\n    return math.max(depth(root.left), depth(root.right)) + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# c++\n\n/**\n * definition for a binary tree node.\n * struct treenode {\n *     int val;\n *     treenode *left;\n *     treenode *right;\n *     treenode() : val(0), left(nullptr), right(nullptr) {}\n *     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass solution {\npublic:\n    bool isbalanced(treenode* root) {\n        if (root == nullptr) {\n            return true;\n        }\n        int leftheight = height(root->left);\n        int rightheight = height(root->right);\n        return abs(leftheight - rightheight) <= 1 && isbalanced(root->left) && isbalanced(root->right);\n    }\nprivate:\n    int height(treenode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        int l = height(root->left);\n        int r = height(root->right);\n        return 1 + max(l, r);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode111 Minimum Depth of Binary Tree-zh",frontmatter:{title:"leetcode111 Minimum Depth of Binary Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/14281b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0111.Minimum%20Depth%20of%20Binary%20Tree/images/ex_depth.jpg"},{name:"twitter:title",content:"leetcode111 Minimum Depth of Binary Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0111.Minimum%20Depth%20of%20Binary%20Tree/images/ex_depth.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10111.leetcode111%20Minimum%20Depth%20of%20Binary%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode111 Minimum Depth of Binary Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0111.Minimum%20Depth%20of%20Binary%20Tree/images/ex_depth.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10111.leetcode111%20Minimum%20Depth%20of%20Binary%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode111 Minimum Depth of Binary Tree-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0111.Minimum%20Depth%20of%20Binary%20Tree/images/ex_depth.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10111.leetcode111%20Minimum%20Depth%20of%20Binary%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10111.leetcode111 Minimum Depth of Binary Tree-zh.md",key:"v-6e49a090",path:"/p/14281b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:285},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:292},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:961},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1785},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2403},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3228}],headersStr:"题目描述 解法 Python3 Java JavaScript C++ ...",content:"# 111. 二叉树的最小深度\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n说明：叶子节点是指没有子节点的节点。\n\n \n\n示例 1：\n\n\n输入：root = [3,9,20,null,null,15,7]\n输出：2\n\n\n示例 2：\n\n\n输入：root = [2,null,3,null,4,null,5,null,6]\n输出：5\n\n\n \n\n提示：\n\n * 树中节点数的范围在 [0, 105] 内\n * -1000 <= Node.val <= 1000\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        # 如果左子树和右子树其中一个为空，那么需要返回比较大的那个子树的深度+1\n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        # 左右子树都不为空，返回最小深度+1即可\n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        if (root.left == null) {\n            return 1 + minDepth(root.right);\n        }\n        if (root.right == null) {\n            return 1 + minDepth(root.left);\n        }\n        return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# JavaScript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minDepth = function(root) {\n    if (root == null) return 0;\n    if (root.left == null) return minDepth(root.right) + 1;\n    if (root.right == null) return minDepth(root.left) + 1;\n    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# C++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        if (root->left == nullptr) {\n            return 1 + minDepth(root->right);\n        }\n        if (root->right == nullptr) {\n            return 1 + minDepth(root->left);\n        }\n        return 1 + min(minDepth(root->left), minDepth(root->right));\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 111. 二叉树的最小深度\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n说明：叶子节点是指没有子节点的节点。\n\n \n\n示例 1：\n\n\n输入：root = [3,9,20,null,null,15,7]\n输出：2\n\n\n示例 2：\n\n\n输入：root = [2,null,3,null,4,null,5,null,6]\n输出：5\n\n\n \n\n提示：\n\n * 树中节点数的范围在 [0, 105] 内\n * -1000 <= node.val <= 1000\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def mindepth(self, root: treenode) -> int:\n        if root is none:\n            return 0\n        # 如果左子树和右子树其中一个为空，那么需要返回比较大的那个子树的深度+1\n        if root.left is none:\n            return 1 + self.mindepth(root.right)\n        if root.right is none:\n            return 1 + self.mindepth(root.left)\n        # 左右子树都不为空，返回最小深度+1即可\n        return 1 + min(self.mindepth(root.left), self.mindepth(root.right))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public int mindepth(treenode root) {\n        if (root == null) {\n            return 0;\n        }\n        if (root.left == null) {\n            return 1 + mindepth(root.right);\n        }\n        if (root.right == null) {\n            return 1 + mindepth(root.left);\n        }\n        return 1 + math.min(mindepth(root.left), mindepth(root.right));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# javascript\n\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number}\n */\nvar mindepth = function(root) {\n    if (root == null) return 0;\n    if (root.left == null) return mindepth(root.right) + 1;\n    if (root.right == null) return mindepth(root.left) + 1;\n    return math.min(mindepth(root.left), mindepth(root.right)) + 1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# c++\n\n/**\n * definition for a binary tree node.\n * struct treenode {\n *     int val;\n *     treenode *left;\n *     treenode *right;\n *     treenode() : val(0), left(nullptr), right(nullptr) {}\n *     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass solution {\npublic:\n    int mindepth(treenode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        if (root->left == nullptr) {\n            return 1 + mindepth(root->right);\n        }\n        if (root->right == nullptr) {\n            return 1 + mindepth(root->left);\n        }\n        return 1 + min(mindepth(root->left), mindepth(root->right));\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode112 Path Sum-zh",frontmatter:{title:"leetcode112 Path Sum-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a45972/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0112.Path%20Sum/images/pathsum1.jpg"},{name:"twitter:title",content:"leetcode112 Path Sum-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0112.Path%20Sum/images/pathsum1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10112.leetcode112%20Path%20Sum-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode112 Path Sum-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0112.Path%20Sum/images/pathsum1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10112.leetcode112%20Path%20Sum-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode112 Path Sum-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0112.Path%20Sum/images/pathsum1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10112.leetcode112%20Path%20Sum-zh.html",relativePath:"01.算法/24.leetcode/10112.leetcode112 Path Sum-zh.md",key:"v-71470c67",path:"/p/a45972/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:437},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:471},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1071},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1686}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 112. 路径总和\n\nEnglish Version\n\n\n# 题目描述\n\n给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。\n\n叶子节点 是指没有子节点的节点。\n\n \n\n示例 1：\n\n\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n输出：true\n\n\n示例 2：\n\n\n输入：root = [1,2,3], targetSum = 5\n输出：false\n\n\n示例 3：\n\n\n输入：root = [1,2], targetSum = 0\n输出：false\n\n\n \n\n提示：\n\n * 树中节点的数目在范围 [0, 5000] 内\n * -1000 <= Node.val <= 1000\n * -1000 <= targetSum <= 1000\n\n\n# 解法\n\n递归求解，递归地询问它的子节点是否能满足条件即可。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n        def dfs(root, sum):\n            if root is None:\n                return False\n            if root.val == sum and root.left is None and root.right is None:\n                return True\n            return dfs(root.left, sum - root.val) or dfs(root.right, sum - root.val)\n        return dfs(root, sum)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        return dfs(root, sum);\n    }\n\n    private boolean dfs(TreeNode root, int sum) {\n        if (root == null) return false;\n        if (root.val == sum && root.left == null && root.right == null) return true;\n        return dfs(root.left, sum - root.val) || dfs(root.right, sum - root.val);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 112. 路径总和\n\nenglish version\n\n\n# 题目描述\n\n给你二叉树的根节点 root 和一个表示目标和的整数 targetsum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetsum 。\n\n叶子节点 是指没有子节点的节点。\n\n \n\n示例 1：\n\n\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetsum = 22\n输出：true\n\n\n示例 2：\n\n\n输入：root = [1,2,3], targetsum = 5\n输出：false\n\n\n示例 3：\n\n\n输入：root = [1,2], targetsum = 0\n输出：false\n\n\n \n\n提示：\n\n * 树中节点的数目在范围 [0, 5000] 内\n * -1000 <= node.val <= 1000\n * -1000 <= targetsum <= 1000\n\n\n# 解法\n\n递归求解，递归地询问它的子节点是否能满足条件即可。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def haspathsum(self, root: treenode, sum: int) -> bool:\n        def dfs(root, sum):\n            if root is none:\n                return false\n            if root.val == sum and root.left is none and root.right is none:\n                return true\n            return dfs(root.left, sum - root.val) or dfs(root.right, sum - root.val)\n        return dfs(root, sum)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean haspathsum(treenode root, int sum) {\n        return dfs(root, sum);\n    }\n\n    private boolean dfs(treenode root, int sum) {\n        if (root == null) return false;\n        if (root.val == sum && root.left == null && root.right == null) return true;\n        return dfs(root.left, sum - root.val) || dfs(root.right, sum - root.val);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode105 Construct Binary Tree from Preorder and Inorder Traversal-zh",frontmatter:{title:"leetcode105 Construct Binary Tree from Preorder and Inorder Traversal-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/5990ea/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode105 Construct Binary Tree from Preorder and Inorder Traversal-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10105.leetcode105%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode105 Construct Binary Tree from Preorder and Inorder Traversal-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10105.leetcode105%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode105 Construct Binary Tree from Preorder and Inorder Traversal-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10105.leetcode105%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal-zh.html",relativePath:"01.算法/24.leetcode/10105.leetcode105 Construct Binary Tree from Preorder and Inorder Traversal-zh.md",key:"v-5b68280b",path:"/p/5990ea/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:44},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:216},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:456},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1522},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2685}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 105. 从前序与中序遍历序列构造二叉树\n\nEnglish Version\n\n\n# 题目描述\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n注意:\n你可以假设树中没有重复的元素。\n\n例如，给出\n\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n# 解法\n\n先遍历前序节点，对于前序的根节点，在中序节点 [i1, i2] 中找到根节点的位置 pos，就可以将中序节点分成：左子树 [i1, pos - 1]、右子树 [pos + 1, i2]。\n\n通过左右子树的区间，可以计算出左、右子树节点的个数，假设为 m、n。然后在前序节点中，从根节点往后的 m 个节点为左子树，再往后的 n 个节点为右子树。\n\n递归求解即可。\n\n> 前序遍历：先遍历根节点，再遍历左右子树；中序遍历：先遍历左子树，再遍历根节点，最后遍历右子树。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    indexes = {}\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        def build(preorder, inorder, p1, p2, i1, i2) -> TreeNode:\n            if p1 > p2 or i1 > i2:\n                return None\n            root_val = preorder[p1]\n            pos = self.indexes[root_val]\n            root = TreeNode(root_val)\n            # pos==i1，说明只有右子树，左子树为空\n            root.left = None if pos == i1 else build(preorder, inorder, p1 + 1, p1 - i1 + pos, i1, pos - 1)\n            # pos==i2，说明只有左子树，右子树为空\n            root.right = None if pos == i2 else build(preorder, inorder, p1 - i1 + pos + 1, p2, pos + 1, i2)\n            return root\n        n = len(inorder)\n        for i in range(n):\n            self.indexes[inorder[i]] = i\n        return build(preorder, inorder, 0, n - 1, 0, n - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private Map<Integer, Integer> indexes = new HashMap<>();\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int n = inorder.length;\n        for (int i = 0; i < n; ++i) {\n            indexes.put(inorder[i], i);\n        }\n        return build(preorder, inorder, 0, n - 1, 0, n - 1);\n    }\n\n    private TreeNode build(int[] preorder, int[] inorder, int p1, int p2, int i1, int i2) {\n        if (p1 > p2 || i1 > i2) return null;\n        int rootVal = preorder[p1];\n        int pos = indexes.get(rootVal);\n        TreeNode node = new TreeNode(rootVal);\n        // pos==i1，说明只有右子树，左子树为空\n        node.left = pos == i1 ? null : build(preorder, inorder, p1 + 1, pos - i1 + p1, i1, pos - 1);\n        // pos==i2，说明只有左子树，右子树为空\n        node.right = pos == i2 ? null : build(preorder, inorder, pos - i1 + p1 + 1, p2, pos + 1, i2);\n        return node;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 105. 从前序与中序遍历序列构造二叉树\n\nenglish version\n\n\n# 题目描述\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n注意:\n你可以假设树中没有重复的元素。\n\n例如，给出\n\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n# 解法\n\n先遍历前序节点，对于前序的根节点，在中序节点 [i1, i2] 中找到根节点的位置 pos，就可以将中序节点分成：左子树 [i1, pos - 1]、右子树 [pos + 1, i2]。\n\n通过左右子树的区间，可以计算出左、右子树节点的个数，假设为 m、n。然后在前序节点中，从根节点往后的 m 个节点为左子树，再往后的 n 个节点为右子树。\n\n递归求解即可。\n\n> 前序遍历：先遍历根节点，再遍历左右子树；中序遍历：先遍历左子树，再遍历根节点，最后遍历右子树。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    indexes = {}\n    def buildtree(self, preorder: list[int], inorder: list[int]) -> treenode:\n        def build(preorder, inorder, p1, p2, i1, i2) -> treenode:\n            if p1 > p2 or i1 > i2:\n                return none\n            root_val = preorder[p1]\n            pos = self.indexes[root_val]\n            root = treenode(root_val)\n            # pos==i1，说明只有右子树，左子树为空\n            root.left = none if pos == i1 else build(preorder, inorder, p1 + 1, p1 - i1 + pos, i1, pos - 1)\n            # pos==i2，说明只有左子树，右子树为空\n            root.right = none if pos == i2 else build(preorder, inorder, p1 - i1 + pos + 1, p2, pos + 1, i2)\n            return root\n        n = len(inorder)\n        for i in range(n):\n            self.indexes[inorder[i]] = i\n        return build(preorder, inorder, 0, n - 1, 0, n - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    private map<integer, integer> indexes = new hashmap<>();\n\n    public treenode buildtree(int[] preorder, int[] inorder) {\n        int n = inorder.length;\n        for (int i = 0; i < n; ++i) {\n            indexes.put(inorder[i], i);\n        }\n        return build(preorder, inorder, 0, n - 1, 0, n - 1);\n    }\n\n    private treenode build(int[] preorder, int[] inorder, int p1, int p2, int i1, int i2) {\n        if (p1 > p2 || i1 > i2) return null;\n        int rootval = preorder[p1];\n        int pos = indexes.get(rootval);\n        treenode node = new treenode(rootval);\n        // pos==i1，说明只有右子树，左子树为空\n        node.left = pos == i1 ? null : build(preorder, inorder, p1 + 1, pos - i1 + p1, i1, pos - 1);\n        // pos==i2，说明只有左子树，右子树为空\n        node.right = pos == i2 ? null : build(preorder, inorder, pos - i1 + p1 + 1, p2, pos + 1, i2);\n        return node;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode113 Path Sum II-zh",frontmatter:{title:"leetcode113 Path Sum II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/056cf0/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0113.Path%20Sum%20II/images/pathsumii1.jpg"},{name:"twitter:title",content:"leetcode113 Path Sum II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0113.Path%20Sum%20II/images/pathsumii1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10113.leetcode113%20Path%20Sum%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode113 Path Sum II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0113.Path%20Sum%20II/images/pathsumii1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10113.leetcode113%20Path%20Sum%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode113 Path Sum II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0113.Path%20Sum%20II/images/pathsumii1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10113.leetcode113%20Path%20Sum%20II-zh.html",relativePath:"01.算法/24.leetcode/10113.leetcode113 Path Sum II-zh.md",key:"v-278cb130",path:"/p/056cf0/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:423},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:444},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1231},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2198}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 113. 路径总和 II\n\nEnglish Version\n\n\n# 题目描述\n\n给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。\n\n叶子节点 是指没有子节点的节点。\n\n \n\n示例 1：\n\n\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n输出：[[5,4,11,2],[5,8,4,5]]\n\n\n示例 2：\n\n\n输入：root = [1,2,3], targetSum = 5\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [1,2], targetSum = 0\n输出：[]\n\n\n \n\n提示：\n\n * 树中节点总数在范围 [0, 5000] 内\n * -1000 <= Node.val <= 1000\n * -1000 <= targetSum <= 1000\n\n\n# 解法\n\n深度优先搜索+路径记录。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\n        def dfs(root, sum):\n            if root is None:\n                return\n            path.append(root.val)\n            if root.val == sum and root.left is None and root.right is None:\n                res.append(path.copy())\n            dfs(root.left, sum - root.val)\n            dfs(root.right, sum - root.val)\n            path.pop()\n        if not root:\n            return []\n        res = []\n        path = []\n        dfs(root, sum)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private List<List<Integer>> res;\n    private List<Integer> path;\n\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        if (root == null) return Collections.emptyList();\n        res = new ArrayList<>();\n        path = new ArrayList<>();\n        dfs(root, sum);\n        return res;\n    }\n\n    private void dfs(TreeNode root, int sum) {\n        if (root == null) return;\n        path.add(root.val);\n        if (root.val == sum && root.left == null && root.right == null) {\n            res.add(new ArrayList<>(path));\n        }\n        dfs(root.left, sum - root.val);\n        dfs(root.right, sum - root.val);\n        path.remove(path.size() - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 113. 路径总和 ii\n\nenglish version\n\n\n# 题目描述\n\n给你二叉树的根节点 root 和一个整数目标和 targetsum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。\n\n叶子节点 是指没有子节点的节点。\n\n \n\n示例 1：\n\n\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetsum = 22\n输出：[[5,4,11,2],[5,8,4,5]]\n\n\n示例 2：\n\n\n输入：root = [1,2,3], targetsum = 5\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [1,2], targetsum = 0\n输出：[]\n\n\n \n\n提示：\n\n * 树中节点总数在范围 [0, 5000] 内\n * -1000 <= node.val <= 1000\n * -1000 <= targetsum <= 1000\n\n\n# 解法\n\n深度优先搜索+路径记录。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def pathsum(self, root: treenode, sum: int) -> list[list[int]]:\n        def dfs(root, sum):\n            if root is none:\n                return\n            path.append(root.val)\n            if root.val == sum and root.left is none and root.right is none:\n                res.append(path.copy())\n            dfs(root.left, sum - root.val)\n            dfs(root.right, sum - root.val)\n            path.pop()\n        if not root:\n            return []\n        res = []\n        path = []\n        dfs(root, sum)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    private list<list<integer>> res;\n    private list<integer> path;\n\n    public list<list<integer>> pathsum(treenode root, int sum) {\n        if (root == null) return collections.emptylist();\n        res = new arraylist<>();\n        path = new arraylist<>();\n        dfs(root, sum);\n        return res;\n    }\n\n    private void dfs(treenode root, int sum) {\n        if (root == null) return;\n        path.add(root.val);\n        if (root.val == sum && root.left == null && root.right == null) {\n            res.add(new arraylist<>(path));\n        }\n        dfs(root.left, sum - root.val);\n        dfs(root.right, sum - root.val);\n        path.remove(path.size() - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode115 Distinct Subsequences-zh",frontmatter:{title:"leetcode115 Distinct Subsequences-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/32c581/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode115 Distinct Subsequences-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10115.leetcode115%20Distinct%20Subsequences-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode115 Distinct Subsequences-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10115.leetcode115%20Distinct%20Subsequences-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode115 Distinct Subsequences-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10115.leetcode115%20Distinct%20Subsequences-zh.html",relativePath:"01.算法/24.leetcode/10115.leetcode115 Distinct Subsequences-zh.md",key:"v-2413460e",path:"/p/32c581/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:593},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:600},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:619},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:635}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 115. 不同的子序列\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。\n\n字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）\n\n题目数据保证答案符合 32 位带符号整数范围。\n\n \n\n示例 1：\n\n\n输入：s = "rabbbit", t = "rabbit"\n输出：3\n解释：\n如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。\n(上箭头符号 ^ 表示选取的字母)\nrabbbit\n^^^^ ^^\nrabbbit\n^^ ^^^^\nrabbbit\n^^^ ^^^\n\n\n示例 2：\n\n\n输入：s = "babgbag", t = "bag"\n输出：5\n解释：\n如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 \n(上箭头符号 ^ 表示选取的字母)\nbabgbag\n^^ ^\nbabgbag\n^^    ^\nbabgbag\n^    ^^\nbabgbag\n  ^  ^^\nbabgbag\n    ^^^\n\n \n\n提示：\n\n * 0 <= s.length, t.length <= 1000\n * s 和 t 由英文字母组成\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 115. 不同的子序列\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。\n\n字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ace" 是 "abcde" 的一个子序列，而 "aec" 不是）\n\n题目数据保证答案符合 32 位带符号整数范围。\n\n \n\n示例 1：\n\n\n输入：s = "rabbbit", t = "rabbit"\n输出：3\n解释：\n如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。\n(上箭头符号 ^ 表示选取的字母)\nrabbbit\n^^^^ ^^\nrabbbit\n^^ ^^^^\nrabbbit\n^^^ ^^^\n\n\n示例 2：\n\n\n输入：s = "babgbag", t = "bag"\n输出：5\n解释：\n如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 \n(上箭头符号 ^ 表示选取的字母)\nbabgbag\n^^ ^\nbabgbag\n^^    ^\nbabgbag\n^    ^^\nbabgbag\n  ^  ^^\nbabgbag\n    ^^^\n\n \n\n提示：\n\n * 0 <= s.length, t.length <= 1000\n * s 和 t 由英文字母组成\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode114 Flatten Binary Tree to Linked List-zh",frontmatter:{title:"leetcode114 Flatten Binary Tree to Linked List-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/22ae1f/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0114.Flatten%20Binary%20Tree%20to%20Linked%20List/images/flaten.jpg"},{name:"twitter:title",content:"leetcode114 Flatten Binary Tree to Linked List-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0114.Flatten%20Binary%20Tree%20to%20Linked%20List/images/flaten.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10114.leetcode114%20Flatten%20Binary%20Tree%20to%20Linked%20List-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode114 Flatten Binary Tree to Linked List-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0114.Flatten%20Binary%20Tree%20to%20Linked%20List/images/flaten.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10114.leetcode114%20Flatten%20Binary%20Tree%20to%20Linked%20List-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode114 Flatten Binary Tree to Linked List-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0114.Flatten%20Binary%20Tree%20to%20Linked%20List/images/flaten.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10114.leetcode114%20Flatten%20Binary%20Tree%20to%20Linked%20List-zh.html",relativePath:"01.算法/24.leetcode/10114.leetcode114 Flatten Binary Tree to Linked List-zh.md",key:"v-447f30ed",path:"/p/22ae1f/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:411},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:418},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1114},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:2132},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:3082},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3963}],headersStr:"题目描述 解法 Python3 Java TypeScript C++ ...",content:'# 114. 二叉树展开为链表\n\nEnglish Version\n\n\n# 题目描述\n\n给你二叉树的根结点 root ，请你将它展开为一个单链表：\n\n * 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。\n * 展开后的单链表应该与二叉树 先序遍历 顺序相同。\n\n \n\n示例 1：\n\n\n输入：root = [1,2,5,3,4,null,6]\n输出：[1,null,2,null,3,null,4,null,5,null,6]\n\n\n示例 2：\n\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [0]\n输出：[0]\n\n\n \n\n提示：\n\n * 树中结点数在范围 [0, 2000] 内\n * -100 <= Node.val <= 100\n\n \n\n进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flatten(self, root: TreeNode) -> None:\n        """\n        Do not return anything, modify root in-place instead.\n        """\n        while root:\n            if root.left:\n                pre = root.left\n                while pre.right:\n                    pre = pre.right\n                pre.right = root.right\n                root.right = root.left\n                root.left = None\n            root = root.right\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        while (root != null) {\n            if (root.left != null) {\n                // 找到当前节点左子树的最右节点\n                TreeNode pre = root.left;\n                while (pre.right != null) {\n                    pre = pre.right;\n                }\n\n                // 将左子树的最右节点指向原来的右子树\n                pre.right = root.right;\n\n                // 将当前节点指向左子树\n                root.right = root.left;\n                root.left = null;\n            }\n            root = root.right;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# TypeScript\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n Do not return anything, modify root in-place instead.\n */\nfunction flatten(root: TreeNode | null): void {\n    while (root != null) {\n        if (root.left != null) {\n            let pre = root.left;\n            while (pre.right != null) {\n                pre = pre.right;\n            }\n            pre.right = root.right;\n            root.right = root.left;\n            root.left = null;\n        }\n        root = root.right;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# C++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        while (root) {\n            if (root->left) {\n                TreeNode *pre = root->left;\n                while (pre->right) {\n                    pre = pre->right;\n                }\n                pre->right = root->right;\n                root->right = root->left;\n                root->left = nullptr;\n            }\n            root = root->right;\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 114. 二叉树展开为链表\n\nenglish version\n\n\n# 题目描述\n\n给你二叉树的根结点 root ，请你将它展开为一个单链表：\n\n * 展开后的单链表应该同样使用 treenode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。\n * 展开后的单链表应该与二叉树 先序遍历 顺序相同。\n\n \n\n示例 1：\n\n\n输入：root = [1,2,5,3,4,null,6]\n输出：[1,null,2,null,3,null,4,null,5,null,6]\n\n\n示例 2：\n\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [0]\n输出：[0]\n\n\n \n\n提示：\n\n * 树中结点数在范围 [0, 2000] 内\n * -100 <= node.val <= 100\n\n \n\n进阶：你可以使用原地算法（o(1) 额外空间）展开这棵树吗？\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def flatten(self, root: treenode) -> none:\n        """\n        do not return anything, modify root in-place instead.\n        """\n        while root:\n            if root.left:\n                pre = root.left\n                while pre.right:\n                    pre = pre.right\n                pre.right = root.right\n                root.right = root.left\n                root.left = none\n            root = root.right\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public void flatten(treenode root) {\n        while (root != null) {\n            if (root.left != null) {\n                // 找到当前节点左子树的最右节点\n                treenode pre = root.left;\n                while (pre.right != null) {\n                    pre = pre.right;\n                }\n\n                // 将左子树的最右节点指向原来的右子树\n                pre.right = root.right;\n\n                // 将当前节点指向左子树\n                root.right = root.left;\n                root.left = null;\n            }\n            root = root.right;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# typescript\n\n/**\n * definition for a binary tree node.\n * class treenode {\n *     val: number\n *     left: treenode | null\n *     right: treenode | null\n *     constructor(val?: number, left?: treenode | null, right?: treenode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n do not return anything, modify root in-place instead.\n */\nfunction flatten(root: treenode | null): void {\n    while (root != null) {\n        if (root.left != null) {\n            let pre = root.left;\n            while (pre.right != null) {\n                pre = pre.right;\n            }\n            pre.right = root.right;\n            root.right = root.left;\n            root.left = null;\n        }\n        root = root.right;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# c++\n\n/**\n * definition for a binary tree node.\n * struct treenode {\n *     int val;\n *     treenode *left;\n *     treenode *right;\n *     treenode() : val(0), left(nullptr), right(nullptr) {}\n *     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass solution {\npublic:\n    void flatten(treenode* root) {\n        while (root) {\n            if (root->left) {\n                treenode *pre = root->left;\n                while (pre->right) {\n                    pre = pre->right;\n                }\n                pre->right = root->right;\n                root->right = root->left;\n                root->left = nullptr;\n            }\n            root = root->right;\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode116 Populating Next Right Pointers in Each Node-zh",frontmatter:{title:"leetcode116 Populating Next Right Pointers in Each Node-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/f0fba3/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node/images/116_sample.png"},{name:"twitter:title",content:"leetcode116 Populating Next Right Pointers in Each Node-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node/images/116_sample.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10116.leetcode116%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode116 Populating Next Right Pointers in Each Node-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node/images/116_sample.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10116.leetcode116%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode116 Populating Next Right Pointers in Each Node-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node/images/116_sample.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10116.leetcode116%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node-zh.html",relativePath:"01.算法/24.leetcode/10116.leetcode116 Populating Next Right Pointers in Each Node-zh.md",key:"v-3ab1949e",path:"/p/f0fba3/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:45},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:558},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:580},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1468},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2688},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3876}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 116. 填充每个节点的下一个右侧节点指针\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n\n初始状态下，所有 next 指针都被设置为 NULL。\n\n \n\n进阶：\n\n * 你只能使用常量级额外空间。\n * 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n \n\n示例：\n\n\n\n\n输入：root = [1,2,3,4,5,6,7]\n输出：[1,#,2,3,#,4,5,6,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。\n\n\n \n\n提示：\n\n * 树中节点的数量少于 4096\n * -1000 <= node.val <= 1000\n\n\n# 解法\n\n“BFS 层次遍历”实现。\n\n\n# Python3\n\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if root is None or (root.left is None and root.right is None):\n            return root\n        q = collections.deque([root])\n        while q:\n            size = len(q)\n            cur = None\n            for _ in range(size):\n                node = q.popleft()\n                if node.right:\n                    q.append(node.right)\n                if node.left:\n                    q.append(node.left)\n                node.next = cur\n                cur = node\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Java\n\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null || (root.left == null && root.right == null)) {\n            return root;\n        }\n        Deque<Node> q = new ArrayDeque<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            Node cur = null;\n            for (int i = 0, n = q.size(); i < n; ++i) {\n                Node node = q.pollFirst();\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                node.next = cur;\n                cur = node;\n            }\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# C++\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if (!root || (!root->left && !root->right)) {\n            return root;\n        }\n        queue<Node*> q;\n        q.push(root);\n        while (!q.empty()) {\n            Node* cur = nullptr;\n            for (int i = 0, n = q.size(); i < n; ++i) {\n                Node* node = q.front();\n                q.pop();\n                if (node->right) {\n                    q.push(node->right);\n                }\n                if (node->left) {\n                    q.push(node->left);\n                }\n                node->next = cur;\n                cur = node;\n            }\n        }\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 116. 填充每个节点的下一个右侧节点指针\n\nenglish version\n\n\n# 题目描述\n\n给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n\nstruct node {\n  int val;\n  node *left;\n  node *right;\n  node *next;\n}\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 null。\n\n初始状态下，所有 next 指针都被设置为 null。\n\n \n\n进阶：\n\n * 你只能使用常量级额外空间。\n * 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n \n\n示例：\n\n\n\n\n输入：root = [1,2,3,4,5,6,7]\n输出：[1,#,2,3,#,4,5,6,7,#]\n解释：给定二叉树如图 a 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 b 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。\n\n\n \n\n提示：\n\n * 树中节点的数量少于 4096\n * -1000 <= node.val <= 1000\n\n\n# 解法\n\n“bfs 层次遍历”实现。\n\n\n# python3\n\n\"\"\"\n# definition for a node.\nclass node:\n    def __init__(self, val: int = 0, left: 'node' = none, right: 'node' = none, next: 'node' = none):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass solution:\n    def connect(self, root: 'node') -> 'node':\n        if root is none or (root.left is none and root.right is none):\n            return root\n        q = collections.deque([root])\n        while q:\n            size = len(q)\n            cur = none\n            for _ in range(size):\n                node = q.popleft()\n                if node.right:\n                    q.append(node.right)\n                if node.left:\n                    q.append(node.left)\n                node.next = cur\n                cur = node\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# java\n\n/*\n// definition for a node.\nclass node {\n    public int val;\n    public node left;\n    public node right;\n    public node next;\n\n    public node() {}\n\n    public node(int _val) {\n        val = _val;\n    }\n\n    public node(int _val, node _left, node _right, node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass solution {\n    public node connect(node root) {\n        if (root == null || (root.left == null && root.right == null)) {\n            return root;\n        }\n        deque<node> q = new arraydeque<>();\n        q.offer(root);\n        while (!q.isempty()) {\n            node cur = null;\n            for (int i = 0, n = q.size(); i < n; ++i) {\n                node node = q.pollfirst();\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                node.next = cur;\n                cur = node;\n            }\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# c++\n\n/*\n// definition for a node.\nclass node {\npublic:\n    int val;\n    node* left;\n    node* right;\n    node* next;\n\n    node() : val(0), left(null), right(null), next(null) {}\n\n    node(int _val) : val(_val), left(null), right(null), next(null) {}\n\n    node(int _val, node* _left, node* _right, node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass solution {\npublic:\n    node* connect(node* root) {\n        if (!root || (!root->left && !root->right)) {\n            return root;\n        }\n        queue<node*> q;\n        q.push(root);\n        while (!q.empty()) {\n            node* cur = nullptr;\n            for (int i = 0, n = q.size(); i < n; ++i) {\n                node* node = q.front();\n                q.pop();\n                if (node->right) {\n                    q.push(node->right);\n                }\n                if (node->left) {\n                    q.push(node->left);\n                }\n                node->next = cur;\n                cur = node;\n            }\n        }\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode117 Populating Next Right Pointers in Each Node II-zh",frontmatter:{title:"leetcode117 Populating Next Right Pointers in Each Node II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/cd0756/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0117.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/images/117_sample.png"},{name:"twitter:title",content:"leetcode117 Populating Next Right Pointers in Each Node II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0117.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/images/117_sample.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10117.leetcode117%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode117 Populating Next Right Pointers in Each Node II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0117.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/images/117_sample.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10117.leetcode117%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode117 Populating Next Right Pointers in Each Node II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0117.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/images/117_sample.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10117.leetcode117%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II-zh.html",relativePath:"01.算法/24.leetcode/10117.leetcode117 Populating Next Right Pointers in Each Node II-zh.md",key:"v-e3636626",path:"/p/cd0756/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:48},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:515},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:537},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1429},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2649},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3837}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 117. 填充每个节点的下一个右侧节点指针 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树\n\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n\n初始状态下，所有 next 指针都被设置为 NULL。\n\n \n\n进阶：\n\n * 你只能使用常量级额外空间。\n * 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n \n\n示例：\n\n\n\n\n输入：root = [1,2,3,4,5,null,7]\n输出：[1,#,2,3,#,4,5,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。\n\n \n\n提示：\n\n * 树中的节点数小于 6000\n * -100 <= node.val <= 100\n\n \n\n\n# 解法\n\n“BFS 层次遍历”实现。\n\n\n# Python3\n\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if root is None or (root.left is None and root.right is None):\n            return root\n        q = collections.deque([root])\n        while q:\n            size = len(q)\n            cur = None\n            for _ in range(size):\n                node = q.popleft()\n                if node.right:\n                    q.append(node.right)\n                if node.left:\n                    q.append(node.left)\n                node.next = cur\n                cur = node\n        return root\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# Java\n\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null || (root.left == null && root.right == null)) {\n            return root;\n        }\n        Deque<Node> q = new ArrayDeque<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            Node cur = null;\n            for (int i = 0, n = q.size(); i < n; ++i) {\n                Node node = q.pollFirst();\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                node.next = cur;\n                cur = node;\n            }\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# C++\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if (!root || (!root->left && !root->right)) {\n            return root;\n        }\n        queue<Node*> q;\n        q.push(root);\n        while (!q.empty()) {\n            Node* cur = nullptr;\n            for (int i = 0, n = q.size(); i < n; ++i) {\n                Node* node = q.front();\n                q.pop();\n                if (node->right) {\n                    q.push(node->right);\n                }\n                if (node->left) {\n                    q.push(node->left);\n                }\n                node->next = cur;\n                cur = node;\n            }\n        }\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 117. 填充每个节点的下一个右侧节点指针 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树\n\n\nstruct node {\n  int val;\n  node *left;\n  node *right;\n  node *next;\n}\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 null。\n\n初始状态下，所有 next 指针都被设置为 null。\n\n \n\n进阶：\n\n * 你只能使用常量级额外空间。\n * 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n \n\n示例：\n\n\n\n\n输入：root = [1,2,3,4,5,null,7]\n输出：[1,#,2,3,#,4,5,7,#]\n解释：给定二叉树如图 a 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 b 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。\n\n \n\n提示：\n\n * 树中的节点数小于 6000\n * -100 <= node.val <= 100\n\n \n\n\n# 解法\n\n“bfs 层次遍历”实现。\n\n\n# python3\n\n\"\"\"\n# definition for a node.\nclass node:\n    def __init__(self, val: int = 0, left: 'node' = none, right: 'node' = none, next: 'node' = none):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass solution:\n    def connect(self, root: 'node') -> 'node':\n        if root is none or (root.left is none and root.right is none):\n            return root\n        q = collections.deque([root])\n        while q:\n            size = len(q)\n            cur = none\n            for _ in range(size):\n                node = q.popleft()\n                if node.right:\n                    q.append(node.right)\n                if node.left:\n                    q.append(node.left)\n                node.next = cur\n                cur = node\n        return root\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# java\n\n/*\n// definition for a node.\nclass node {\n    public int val;\n    public node left;\n    public node right;\n    public node next;\n\n    public node() {}\n\n    public node(int _val) {\n        val = _val;\n    }\n\n    public node(int _val, node _left, node _right, node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass solution {\n    public node connect(node root) {\n        if (root == null || (root.left == null && root.right == null)) {\n            return root;\n        }\n        deque<node> q = new arraydeque<>();\n        q.offer(root);\n        while (!q.isempty()) {\n            node cur = null;\n            for (int i = 0, n = q.size(); i < n; ++i) {\n                node node = q.pollfirst();\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                node.next = cur;\n                cur = node;\n            }\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# c++\n\n/*\n// definition for a node.\nclass node {\npublic:\n    int val;\n    node* left;\n    node* right;\n    node* next;\n\n    node() : val(0), left(null), right(null), next(null) {}\n\n    node(int _val) : val(_val), left(null), right(null), next(null) {}\n\n    node(int _val, node* _left, node* _right, node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass solution {\npublic:\n    node* connect(node* root) {\n        if (!root || (!root->left && !root->right)) {\n            return root;\n        }\n        queue<node*> q;\n        q.push(root);\n        while (!q.empty()) {\n            node* cur = nullptr;\n            for (int i = 0, n = q.size(); i < n; ++i) {\n                node* node = q.front();\n                q.pop();\n                if (node->right) {\n                    q.push(node->right);\n                }\n                if (node->left) {\n                    q.push(node->left);\n                }\n                node->next = cur;\n                cur = node;\n            }\n        }\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode118 Pascal's Triangle-zh",frontmatter:{title:"leetcode118 Pascal's Triangle-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d24f32/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0118.Pascal%27s%20Triangle/images/PascalTriangleAnimated2.gif"},{name:"twitter:title",content:"leetcode118 Pascal's Triangle-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0118.Pascal%27s%20Triangle/images/PascalTriangleAnimated2.gif"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10118.leetcode118%20Pascal's%20Triangle-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode118 Pascal's Triangle-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0118.Pascal%27s%20Triangle/images/PascalTriangleAnimated2.gif"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10118.leetcode118%20Pascal's%20Triangle-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode118 Pascal's Triangle-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0118.Pascal%27s%20Triangle/images/PascalTriangleAnimated2.gif"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10118.leetcode118%20Pascal's%20Triangle-zh.html",relativePath:"01.算法/24.leetcode/10118.leetcode118 Pascal's Triangle-zh.md",key:"v-7e51c139",path:"/p/d24f32/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:187},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:239},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:601},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1263},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1725},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2011},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2345}],headersStr:"题目描述 解法 Python3 Java C++ Go JavaScript ...",content:"# 118. 杨辉三角\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。\n\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n示例:\n\n输入: 5\n输出:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n\n\n# 解法\n\n先设置每一行首尾元素为 1，其它元素为 0。然后根据杨辉三角，设置每一行其它元素即可。\n\n\n# Python3\n\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        res = []\n        for i in range(numRows):\n            t = [1 if j == 0 or j == i else 0 for j in range(i + 1)]\n            for j in range(1, i):\n                t[j] = res[i - 1][j - 1] + res[i - 1][j]\n            res.append(t)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Java\n\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < numRows; ++i) {\n            List<Integer> t = new ArrayList<>();\n            for (int j = 0; j < i + 1; ++j) {\n                boolean firstOrLast = j == 0 || j == i;\n                t.add(firstOrLast ? 1 : 0);\n            }\n            for (int j = 1; j < i; ++j) {\n                int val = res.get(i - 1).get(j - 1) + res.get(i - 1).get(j);\n                t.set(j, val);\n            }\n            res.add(t);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# C++\n\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> res;\n        for (int i = 0; i < numRows; ++i) {\n            vector<int> t(i + 1);\n            t[0] = 1;\n            t[i] = 1;\n            for (int j = 1; j < i; ++j) {\n                t[j] = res[i - 1][j - 1] + res[i - 1][j];\n            }\n            res.push_back(t);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Go\n\nfunc generate(numRows int) [][]int {\n\tres := make([][]int, numRows)\n\tfor i := 0; i < numRows; i++ {\n\t\tt := make([]int, i+1)\n\t\tt[0] = 1\n\t\tt[i] = 1\n\t\tfor j := 1; j < i; j++ {\n\t\t\tt[j] = res[i-1][j-1] + res[i-1][j]\n\t\t}\n\t\tres[i] = t\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# JavaScript\n\nconst generate = function (numRows) {\n  let arr = [];\n  for (let i = 0; i < numRows; i++) {\n    let row = [];\n    row[0] = 1;\n    row[i] = 1;\n    for (let j = 1; j < row.length - 1; j++) {\n      row[j] = arr[i - 1][j - 1] + arr[i - 1][j];\n    }\n    arr.push(row);\n  }\n  return arr;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 118. 杨辉三角\n\nenglish version\n\n\n# 题目描述\n\n给定一个非负整数 numrows，生成杨辉三角的前 numrows 行。\n\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n示例:\n\n输入: 5\n输出:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n\n\n# 解法\n\n先设置每一行首尾元素为 1，其它元素为 0。然后根据杨辉三角，设置每一行其它元素即可。\n\n\n# python3\n\nclass solution:\n    def generate(self, numrows: int) -> list[list[int]]:\n        res = []\n        for i in range(numrows):\n            t = [1 if j == 0 or j == i else 0 for j in range(i + 1)]\n            for j in range(1, i):\n                t[j] = res[i - 1][j - 1] + res[i - 1][j]\n            res.append(t)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# java\n\nclass solution {\n    public list<list<integer>> generate(int numrows) {\n        list<list<integer>> res = new arraylist<>();\n        for (int i = 0; i < numrows; ++i) {\n            list<integer> t = new arraylist<>();\n            for (int j = 0; j < i + 1; ++j) {\n                boolean firstorlast = j == 0 || j == i;\n                t.add(firstorlast ? 1 : 0);\n            }\n            for (int j = 1; j < i; ++j) {\n                int val = res.get(i - 1).get(j - 1) + res.get(i - 1).get(j);\n                t.set(j, val);\n            }\n            res.add(t);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# c++\n\nclass solution {\npublic:\n    vector<vector<int>> generate(int numrows) {\n        vector<vector<int>> res;\n        for (int i = 0; i < numrows; ++i) {\n            vector<int> t(i + 1);\n            t[0] = 1;\n            t[i] = 1;\n            for (int j = 1; j < i; ++j) {\n                t[j] = res[i - 1][j - 1] + res[i - 1][j];\n            }\n            res.push_back(t);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# go\n\nfunc generate(numrows int) [][]int {\n\tres := make([][]int, numrows)\n\tfor i := 0; i < numrows; i++ {\n\t\tt := make([]int, i+1)\n\t\tt[0] = 1\n\t\tt[i] = 1\n\t\tfor j := 1; j < i; j++ {\n\t\t\tt[j] = res[i-1][j-1] + res[i-1][j]\n\t\t}\n\t\tres[i] = t\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# javascript\n\nconst generate = function (numrows) {\n  let arr = [];\n  for (let i = 0; i < numrows; i++) {\n    let row = [];\n    row[0] = 1;\n    row[i] = 1;\n    for (let j = 1; j < row.length - 1; j++) {\n      row[j] = arr[i - 1][j - 1] + arr[i - 1][j];\n    }\n    arr.push(row);\n  }\n  return arr;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode120 Triangle-zh",frontmatter:{title:"leetcode120 Triangle-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/c386b4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode120 Triangle-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10120.leetcode120%20Triangle-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode120 Triangle-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10120.leetcode120%20Triangle-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode120 Triangle-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10120.leetcode120%20Triangle-zh.html",relativePath:"01.算法/24.leetcode/10120.leetcode120 Triangle-zh.md",key:"v-6fd6c2ca",path:"/p/c386b4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:580},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:594},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1075},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1867},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2487},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2987}],headersStr:"题目描述 解法 Python3 Java C++ Go ...",content:"# 120. 三角形最小路径和\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个三角形 triangle ，找出自顶向下的最小路径和。\n\n每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。\n\n \n\n示例 1：\n\n\n输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n输出：11\n解释：如下面简图所示：\n   2\n  3 4\n 6 5 7\n4 1 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n\n示例 2：\n\n\n输入：triangle = [[-10]]\n输出：-10\n\n\n \n\n提示：\n\n * 1 <= triangle.length <= 200\n * triangle[0].length == 1\n * triangle[i].length == triangle[i - 1].length + 1\n * -104 <= triangle[i][j] <= 104\n\n \n\n进阶：\n\n * 你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？\n\n\n# 解法\n\n动态规划。\n\n\n# Python3\n\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        n = len(triangle)\n        for i in range(1, n):\n            for j in range(i + 1):\n                mi = float('inf')\n                if j > 0:\n                    mi = min(mi, triangle[i - 1][j - 1])\n                if j < i:\n                    mi = min(mi, triangle[i - 1][j])\n                triangle[i][j] += mi\n        return min(triangle[n - 1])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        int n = triangle.size();\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < i + 1; ++j) {\n                int mi = Integer.MAX_VALUE;\n                if (j > 0) {\n                    mi = Math.min(mi, triangle.get(i - 1).get(j - 1));\n                }\n                if (j < i) {\n                    mi = Math.min(mi, triangle.get(i - 1).get(j));\n                }\n                triangle.get(i).set(j, triangle.get(i).get(j) + mi);\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for (int val : triangle.get(n - 1)) {\n            res = Math.min(res, val);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n = triangle.size();\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < i + 1; ++j) {\n                int mi = INT_MAX;\n                if (j > 0) mi = min(mi, triangle[i - 1][j - 1]);\n                if (j < i) mi = min(mi, triangle[i - 1][j]);\n                triangle[i][j] += mi;\n            }\n        }\n        int res = INT_MAX;\n        for (int& val : triangle[n - 1]) {\n            res = min(res, val);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Go\n\nfunc minimumTotal(triangle [][]int) int {\n\tn := len(triangle)\n\tfor i := 1; i < n; i++ {\n\t\tfor j := 0; j < i+1; j++ {\n\t\t\tmi := 2000000\n\t\t\tif j > 0 && mi > triangle[i-1][j-1] {\n\t\t\t\tmi = triangle[i-1][j-1]\n\t\t\t}\n\t\t\tif j < i && mi > triangle[i-1][j] {\n\t\t\t\tmi = triangle[i-1][j]\n\t\t\t}\n\t\t\ttriangle[i][j] += mi\n\t\t}\n\t}\n\n\tres := 2000000\n\tfor j := 0; j < n; j++ {\n\t\tif res > triangle[n-1][j] {\n\t\t\tres = triangle[n-1][j]\n\t\t}\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 120. 三角形最小路径和\n\nenglish version\n\n\n# 题目描述\n\n给定一个三角形 triangle ，找出自顶向下的最小路径和。\n\n每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。\n\n \n\n示例 1：\n\n\n输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n输出：11\n解释：如下面简图所示：\n   2\n  3 4\n 6 5 7\n4 1 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n\n示例 2：\n\n\n输入：triangle = [[-10]]\n输出：-10\n\n\n \n\n提示：\n\n * 1 <= triangle.length <= 200\n * triangle[0].length == 1\n * triangle[i].length == triangle[i - 1].length + 1\n * -104 <= triangle[i][j] <= 104\n\n \n\n进阶：\n\n * 你可以只使用 o(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？\n\n\n# 解法\n\n动态规划。\n\n\n# python3\n\nclass solution:\n    def minimumtotal(self, triangle: list[list[int]]) -> int:\n        n = len(triangle)\n        for i in range(1, n):\n            for j in range(i + 1):\n                mi = float('inf')\n                if j > 0:\n                    mi = min(mi, triangle[i - 1][j - 1])\n                if j < i:\n                    mi = min(mi, triangle[i - 1][j])\n                triangle[i][j] += mi\n        return min(triangle[n - 1])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public int minimumtotal(list<list<integer>> triangle) {\n        int n = triangle.size();\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < i + 1; ++j) {\n                int mi = integer.max_value;\n                if (j > 0) {\n                    mi = math.min(mi, triangle.get(i - 1).get(j - 1));\n                }\n                if (j < i) {\n                    mi = math.min(mi, triangle.get(i - 1).get(j));\n                }\n                triangle.get(i).set(j, triangle.get(i).get(j) + mi);\n            }\n        }\n        int res = integer.max_value;\n        for (int val : triangle.get(n - 1)) {\n            res = math.min(res, val);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# c++\n\nclass solution {\npublic:\n    int minimumtotal(vector<vector<int>>& triangle) {\n        int n = triangle.size();\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < i + 1; ++j) {\n                int mi = int_max;\n                if (j > 0) mi = min(mi, triangle[i - 1][j - 1]);\n                if (j < i) mi = min(mi, triangle[i - 1][j]);\n                triangle[i][j] += mi;\n            }\n        }\n        int res = int_max;\n        for (int& val : triangle[n - 1]) {\n            res = min(res, val);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# go\n\nfunc minimumtotal(triangle [][]int) int {\n\tn := len(triangle)\n\tfor i := 1; i < n; i++ {\n\t\tfor j := 0; j < i+1; j++ {\n\t\t\tmi := 2000000\n\t\t\tif j > 0 && mi > triangle[i-1][j-1] {\n\t\t\t\tmi = triangle[i-1][j-1]\n\t\t\t}\n\t\t\tif j < i && mi > triangle[i-1][j] {\n\t\t\t\tmi = triangle[i-1][j]\n\t\t\t}\n\t\t\ttriangle[i][j] += mi\n\t\t}\n\t}\n\n\tres := 2000000\n\tfor j := 0; j < n; j++ {\n\t\tif res > triangle[n-1][j] {\n\t\t\tres = triangle[n-1][j]\n\t\t}\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode119 Pascal's Triangle II-zh",frontmatter:{title:"leetcode119 Pascal's Triangle II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/5953ec/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0119.Pascal%27s%20Triangle%20II/images/PascalTriangleAnimated2.gif"},{name:"twitter:title",content:"leetcode119 Pascal's Triangle II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0119.Pascal%27s%20Triangle%20II/images/PascalTriangleAnimated2.gif"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10119.leetcode119%20Pascal's%20Triangle%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode119 Pascal's Triangle II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0119.Pascal%27s%20Triangle%20II/images/PascalTriangleAnimated2.gif"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10119.leetcode119%20Pascal's%20Triangle%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode119 Pascal's Triangle II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0119.Pascal%27s%20Triangle%20II/images/PascalTriangleAnimated2.gif"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10119.leetcode119%20Pascal's%20Triangle%20II-zh.html",relativePath:"01.算法/24.leetcode/10119.leetcode119 Pascal's Triangle II-zh.md",key:"v-9b7fbf2c",path:"/p/5953ec/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:166},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:173},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:443},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:888},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1173},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1504},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1718}],headersStr:"题目描述 解法 Python3 Java TypeScript C++ Go ...",content:"# 119. 杨辉三角 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。\n\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n示例:\n\n输入: 3\n输出: [1,3,3,1]\n\n\n进阶：\n\n你可以优化你的算法到 O(k) 空间复杂度吗？\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        row = [1] * (rowIndex + 1)\n        for i in range(2, rowIndex + 1):\n            for j in range(i - 1, 0, -1):\n                row[j] += row[j - 1]\n        return row\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Java\n\nclass Solution {\n    public List<Integer> getRow(int rowIndex) {\n        List<Integer> row = new ArrayList<>();\n        for (int i = 0; i < rowIndex + 1; ++i) {\n            row.add(1);\n        }\n        for (int i = 2; i < rowIndex + 1; ++i) {\n            for (int j = i - 1; j > 0; --j) {\n                row.set(j, row.get(j) + row.get(j - 1));\n            }\n        }\n        return row;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# TypeScript\n\nfunction getRow(rowIndex: number): number[] {\n    let ans = new Array(rowIndex + 1).fill(1);\n    for (let i = 2; i < rowIndex + 1; ++i) {\n        for (let j = i -1; j > 0; --j) {\n            ans[j] += ans[j - 1];\n        }\n    }\n    return ans;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# C++\n\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> row(rowIndex + 1, 1);\n        for (int i = 2; i < rowIndex + 1; ++i) {\n            for (int j = i - 1; j > 0; --j) {\n                row[j] += row[j - 1];\n            }\n        }\n        return row;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Go\n\nfunc getRow(rowIndex int) []int {\n\trow := make([]int, rowIndex+1)\n\trow[0] = 1\n\tfor i := 1; i <= rowIndex; i++ {\n\t\tfor j := i; j > 0; j-- {\n\t\t\trow[j] += row[j-1]\n\t\t}\n\t}\n\treturn row\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 119. 杨辉三角 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。\n\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n示例:\n\n输入: 3\n输出: [1,3,3,1]\n\n\n进阶：\n\n你可以优化你的算法到 o(k) 空间复杂度吗？\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def getrow(self, rowindex: int) -> list[int]:\n        row = [1] * (rowindex + 1)\n        for i in range(2, rowindex + 1):\n            for j in range(i - 1, 0, -1):\n                row[j] += row[j - 1]\n        return row\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# java\n\nclass solution {\n    public list<integer> getrow(int rowindex) {\n        list<integer> row = new arraylist<>();\n        for (int i = 0; i < rowindex + 1; ++i) {\n            row.add(1);\n        }\n        for (int i = 2; i < rowindex + 1; ++i) {\n            for (int j = i - 1; j > 0; --j) {\n                row.set(j, row.get(j) + row.get(j - 1));\n            }\n        }\n        return row;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# typescript\n\nfunction getrow(rowindex: number): number[] {\n    let ans = new array(rowindex + 1).fill(1);\n    for (let i = 2; i < rowindex + 1; ++i) {\n        for (let j = i -1; j > 0; --j) {\n            ans[j] += ans[j - 1];\n        }\n    }\n    return ans;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# c++\n\nclass solution {\npublic:\n    vector<int> getrow(int rowindex) {\n        vector<int> row(rowindex + 1, 1);\n        for (int i = 2; i < rowindex + 1; ++i) {\n            for (int j = i - 1; j > 0; --j) {\n                row[j] += row[j - 1];\n            }\n        }\n        return row;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# go\n\nfunc getrow(rowindex int) []int {\n\trow := make([]int, rowindex+1)\n\trow[0] = 1\n\tfor i := 1; i <= rowindex; i++ {\n\t\tfor j := i; j > 0; j-- {\n\t\t\trow[j] += row[j-1]\n\t\t}\n\t}\n\treturn row\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode121 Best Time to Buy and Sell Stock-zh",frontmatter:{title:"leetcode121 Best Time to Buy and Sell Stock-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/3e318e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode121 Best Time to Buy and Sell Stock-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10121.leetcode121%20Best%20Time%20to%20Buy%20and%20Sell%20Stock-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode121 Best Time to Buy and Sell Stock-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10121.leetcode121%20Best%20Time%20to%20Buy%20and%20Sell%20Stock-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode121 Best Time to Buy and Sell Stock-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10121.leetcode121%20Best%20Time%20to%20Buy%20and%20Sell%20Stock-zh.html",relativePath:"01.算法/24.leetcode/10121.leetcode121 Best Time to Buy and Sell Stock-zh.md",key:"v-05f7c36e",path:"/p/3e318e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:486},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:493},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:744},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1052},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1361},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1728},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:2063},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2387}],headersStr:"题目描述 解法 Python3 Java C++ Go JavaScript C# ...",content:"# 121. 买卖股票的最佳时机\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n \n\n示例 1：\n\n\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\n\n示例 2：\n\n\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n \n\n提示：\n\n * 1 <= prices.length <= 105\n * 0 <= prices[i] <= 104\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        res, mi = 0, prices[0]\n        for price in prices[1:]:\n            res = max(res, price - mi)\n            mi = min(mi, price)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Java\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int res = 0, mi = prices[0];\n        for (int i = 1; i < prices.length; ++i) {\n            res = Math.max(res, prices[i] - mi);\n            mi = Math.min(mi, prices[i]);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int res = 0, mi = prices[0];\n        for (int i = 1; i < prices.size(); ++i) {\n            res = max(res, prices[i] - mi);\n            mi = min(mi, prices[i]);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Go\n\nfunc maxProfit(prices []int) int {\n\tres, mi := 0, prices[0]\n\tfor i := 1; i < len(prices); i++ {\n\t\tres = max(res, prices[i]-mi)\n\t\tmi = min(min, prices[i])\n\t}\n\treturn res\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    let res = 0;\n    let mi = prices[0];\n    for (let i = 1; i < prices.length; ++i) {\n        res = Math.max(res, prices[i] - mi);\n        mi = Math.min(mi, prices[i]);\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# C#\n\npublic class Solution {\n    public int MaxProfit(int[] prices) {\n        int res = 0, mi = prices[0];\n        for (int i = 1; i < prices.Length; ++i)\n        {\n            res = Math.Max(res, prices[i] - mi);\n            mi = Math.Min(mi, prices[i]);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 121. 买卖股票的最佳时机\n\nenglish version\n\n\n# 题目描述\n\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n \n\n示例 1：\n\n\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\n\n示例 2：\n\n\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n \n\n提示：\n\n * 1 <= prices.length <= 105\n * 0 <= prices[i] <= 104\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def maxprofit(self, prices: list[int]) -> int:\n        res, mi = 0, prices[0]\n        for price in prices[1:]:\n            res = max(res, price - mi)\n            mi = min(mi, price)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# java\n\nclass solution {\n    public int maxprofit(int[] prices) {\n        int res = 0, mi = prices[0];\n        for (int i = 1; i < prices.length; ++i) {\n            res = math.max(res, prices[i] - mi);\n            mi = math.min(mi, prices[i]);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# c++\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int res = 0, mi = prices[0];\n        for (int i = 1; i < prices.size(); ++i) {\n            res = max(res, prices[i] - mi);\n            mi = min(mi, prices[i]);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# go\n\nfunc maxprofit(prices []int) int {\n\tres, mi := 0, prices[0]\n\tfor i := 1; i < len(prices); i++ {\n\t\tres = max(res, prices[i]-mi)\n\t\tmi = min(min, prices[i])\n\t}\n\treturn res\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# javascript\n\n/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxprofit = function(prices) {\n    let res = 0;\n    let mi = prices[0];\n    for (let i = 1; i < prices.length; ++i) {\n        res = math.max(res, prices[i] - mi);\n        mi = math.min(mi, prices[i]);\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# c#\n\npublic class solution {\n    public int maxprofit(int[] prices) {\n        int res = 0, mi = prices[0];\n        for (int i = 1; i < prices.length; ++i)\n        {\n            res = math.max(res, prices[i] - mi);\n            mi = math.min(mi, prices[i]);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode122 Best Time to Buy and Sell Stock II-zh",frontmatter:{title:"leetcode122 Best Time to Buy and Sell Stock II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/1c022a/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode122 Best Time to Buy and Sell Stock II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10122.leetcode122%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode122 Best Time to Buy and Sell Stock II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10122.leetcode122%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode122 Best Time to Buy and Sell Stock II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10122.leetcode122%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II-zh.html",relativePath:"01.算法/24.leetcode/10122.leetcode122 Best Time to Buy and Sell Stock II-zh.md",key:"v-a24a8ab2",path:"/p/1c022a/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:41},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:698},{level:3,title:"1. 贪心法",slug:"_1-贪心法",normalizedTitle:"1. 贪心法",charIndex:705},{level:3,title:"2. 动态规划法",slug:"_2-动态规划法",normalizedTitle:"2. 动态规划法",charIndex:755},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1052},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1548},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:2190},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2413},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:3017},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:3485},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4115}],headersStr:"题目描述 解法 1. 贪心法 2. 动态规划法 Python3 Java TypeScript C++ Go C# ...",content:"# 122. 买卖股票的最佳时机 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n示例 1:\n\n\n输入: prices = [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n\n\n示例 2:\n\n\n输入: prices = [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n\n\n示例 3:\n\n\n输入: prices = [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n \n\n提示：\n\n * 1 <= prices.length <= 3 * 104\n * 0 <= prices[i] <= 104\n\n\n# 解法\n\n\n# 1. 贪心法\n\n所有上涨交易日都做买卖，所有下跌交易日都不做买卖，这样便能实现利润最大化。\n\n\n# 2. 动态规划法\n\n设 f1 表示当天结束后持有股票的最大利润，f2 表示当前结束后没有持有股票的最大利润。\n\n初始第 1 天结束时，f1 = -prices[0]，f2 = 0。\n\n从第 2 天开始，当天结束时：\n\n * 若持有股票，则可能是前一天持有股票，然后继续持有；也可能是前一天没有持有股票，然后当天买入股票。最大利润 f1 = max(f1, f2 - prices[i])。\n * 若没有持有股票，则可能是前一天没持有股票，今天也没持有股票；或者前一天持有股票，然后今天卖出。最大利润 f2 = max(f2, f1 + prices[i])。\n\n最后返回 f2 即可。\n\n\n# Python3\n\n贪心：\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        res = 0\n        for i in range(1, len(prices)):\n            t = prices[i] - prices[i - 1]\n            res += max(t, 0)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n动态规划：\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        f1, f2 = -prices[0], 0\n        for price in prices[1:]:\n            f1 = max(f1, f2 - price)\n            f2 = max(f2, f1 + price)\n        return f2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Java\n\n贪心：\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int res = 0;\n        for (int i = 1; i < prices.length; ++i) {\n            // 策略是所有上涨交易日都做买卖，所以下跌交易日都不做买卖\n            int t = prices[i] - prices[i - 1];\n            res += Math.max(t, 0);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n动态规划：\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int f1 = -prices[0], f2 = 0;\n        for (int i = 1; i < prices.length; ++i) {\n            f1 = Math.max(f1, f2 - prices[i]);\n            f2 = Math.max(f2, f1 + prices[i]);\n        }\n        return f2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# TypeScript\n\nfunction maxProfit(prices: number[]): number {\n    let ans = 0;\n    for (let i = 1; i < prices.length; i++) {\n        ans += Math.max(0, prices[i] - prices[i - 1]);\n    }\n    return ans;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# C++\n\n贪心：\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int res = 0;\n        for (int i = 1; i < prices.size(); ++i) {\n            int t = prices[i] - prices[i - 1];\n            res += max(t, 0);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n动态规划：\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int f1 = -prices[0], f2 = 0;\n        for (int i = 1; i < prices.size(); ++i) {\n            f1 = max(f1, f2 - prices[i]);\n            f2 = max(f2, f1 + prices[i]);\n        }\n        return f2;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Go\n\n贪心：\n\nfunc maxProfit(prices []int) int {\n\tres := 0\n\tfor i := 1; i < len(prices); i++ {\n\t\tt := prices[i] - prices[i-1]\n\t\tif t > 0 {\n\t\t\tres += t\n\t\t}\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n动态规划：\n\nfunc maxProfit(prices []int) int {\n\tf1, f2 := -prices[0], 0\n\tfor _, price := range prices[1:] {\n\t\tf1 = max(f1, f2-price)\n\t\tf2 = max(f2, f1+price)\n\t}\n\treturn f2\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# C#\n\n贪心：\n\npublic class Solution {\n    public int MaxProfit(int[] prices) {\n        int res = 0;\n        for (int i = 1; i < prices.Length; ++i)\n        {\n            int t = prices[i] - prices[i - 1];\n            res += Math.Max(t, 0);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n动态规划：\n\npublic class Solution {\n    public int MaxProfit(int[] prices) {\n        int f1 = -prices[0], f2 = 0;\n        for (int i = 1; i < prices.Length; ++i)\n        {\n            f1 = Math.Max(f1, f2 - prices[i]);\n            f2 = Math.Max(f2, f1 + prices[i]);\n        }\n        return f2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 122. 买卖股票的最佳时机 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n示例 1:\n\n\n输入: prices = [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n\n\n示例 2:\n\n\n输入: prices = [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n\n\n示例 3:\n\n\n输入: prices = [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n \n\n提示：\n\n * 1 <= prices.length <= 3 * 104\n * 0 <= prices[i] <= 104\n\n\n# 解法\n\n\n# 1. 贪心法\n\n所有上涨交易日都做买卖，所有下跌交易日都不做买卖，这样便能实现利润最大化。\n\n\n# 2. 动态规划法\n\n设 f1 表示当天结束后持有股票的最大利润，f2 表示当前结束后没有持有股票的最大利润。\n\n初始第 1 天结束时，f1 = -prices[0]，f2 = 0。\n\n从第 2 天开始，当天结束时：\n\n * 若持有股票，则可能是前一天持有股票，然后继续持有；也可能是前一天没有持有股票，然后当天买入股票。最大利润 f1 = max(f1, f2 - prices[i])。\n * 若没有持有股票，则可能是前一天没持有股票，今天也没持有股票；或者前一天持有股票，然后今天卖出。最大利润 f2 = max(f2, f1 + prices[i])。\n\n最后返回 f2 即可。\n\n\n# python3\n\n贪心：\n\nclass solution:\n    def maxprofit(self, prices: list[int]) -> int:\n        res = 0\n        for i in range(1, len(prices)):\n            t = prices[i] - prices[i - 1]\n            res += max(t, 0)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n动态规划：\n\nclass solution:\n    def maxprofit(self, prices: list[int]) -> int:\n        f1, f2 = -prices[0], 0\n        for price in prices[1:]:\n            f1 = max(f1, f2 - price)\n            f2 = max(f2, f1 + price)\n        return f2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# java\n\n贪心：\n\nclass solution {\n    public int maxprofit(int[] prices) {\n        int res = 0;\n        for (int i = 1; i < prices.length; ++i) {\n            // 策略是所有上涨交易日都做买卖，所以下跌交易日都不做买卖\n            int t = prices[i] - prices[i - 1];\n            res += math.max(t, 0);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n动态规划：\n\nclass solution {\n    public int maxprofit(int[] prices) {\n        int f1 = -prices[0], f2 = 0;\n        for (int i = 1; i < prices.length; ++i) {\n            f1 = math.max(f1, f2 - prices[i]);\n            f2 = math.max(f2, f1 + prices[i]);\n        }\n        return f2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# typescript\n\nfunction maxprofit(prices: number[]): number {\n    let ans = 0;\n    for (let i = 1; i < prices.length; i++) {\n        ans += math.max(0, prices[i] - prices[i - 1]);\n    }\n    return ans;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# c++\n\n贪心：\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int res = 0;\n        for (int i = 1; i < prices.size(); ++i) {\n            int t = prices[i] - prices[i - 1];\n            res += max(t, 0);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n动态规划：\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int f1 = -prices[0], f2 = 0;\n        for (int i = 1; i < prices.size(); ++i) {\n            f1 = max(f1, f2 - prices[i]);\n            f2 = max(f2, f1 + prices[i]);\n        }\n        return f2;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# go\n\n贪心：\n\nfunc maxprofit(prices []int) int {\n\tres := 0\n\tfor i := 1; i < len(prices); i++ {\n\t\tt := prices[i] - prices[i-1]\n\t\tif t > 0 {\n\t\t\tres += t\n\t\t}\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n动态规划：\n\nfunc maxprofit(prices []int) int {\n\tf1, f2 := -prices[0], 0\n\tfor _, price := range prices[1:] {\n\t\tf1 = max(f1, f2-price)\n\t\tf2 = max(f2, f1+price)\n\t}\n\treturn f2\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# c#\n\n贪心：\n\npublic class solution {\n    public int maxprofit(int[] prices) {\n        int res = 0;\n        for (int i = 1; i < prices.length; ++i)\n        {\n            int t = prices[i] - prices[i - 1];\n            res += math.max(t, 0);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n动态规划：\n\npublic class solution {\n    public int maxprofit(int[] prices) {\n        int f1 = -prices[0], f2 = 0;\n        for (int i = 1; i < prices.length; ++i)\n        {\n            f1 = math.max(f1, f2 - prices[i]);\n            f2 = math.max(f2, f1 + prices[i]);\n        }\n        return f2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode123 Best Time to Buy and Sell Stock III-zh",frontmatter:{title:"leetcode123 Best Time to Buy and Sell Stock III-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b6d063/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode123 Best Time to Buy and Sell Stock III-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10123.leetcode123%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode123 Best Time to Buy and Sell Stock III-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10123.leetcode123%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode123 Best Time to Buy and Sell Stock III-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10123.leetcode123%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III-zh.html",relativePath:"01.算法/24.leetcode/10123.leetcode123 Best Time to Buy and Sell Stock III-zh.md",key:"v-1d3a2736",path:"/p/b6d063/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:42},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:712},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:890},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1277},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1746},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2168},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:2591},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3038}],headersStr:"题目描述 解法 Python3 Java C++ Go C# ...",content:"# 123. 买卖股票的最佳时机 III\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n示例 1:\n\n\n输入：prices = [3,3,5,0,0,3,1,4]\n输出：6\n解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n\n示例 2：\n\n\n输入：prices = [1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n\n\n示例 3：\n\n\n输入：prices = [7,6,4,3,1] \n输出：0 \n解释：在这个情况下, 没有交易完成, 所以最大利润为 0。\n\n示例 4：\n\n\n输入：prices = [1]\n输出：0\n\n\n \n\n提示：\n\n * 1 <= prices.length <= 105\n * 0 <= prices[i] <= 105\n\n\n# 解法\n\n动态规划法。\n\n设 f1 表示第 1 次买入股票后的最大利润，f2 表示第 1 次卖出股票后的最大利润，f3 表示第 2 次买入股票后的最大利润，f4 表示第 2 次卖出股票后的最大利润。\n\n遍历过程中，直接使用 f1, f2, f3, f4 计算，考虑的是在同一天买入和卖出时，收益是 0，不会对答案产生影响。\n\n最后返回 f2 即可。\n\n\n# Python3\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        # 第一次买入，第一次卖出，第二次买入，第二次卖出\n        f1, f2, f3, f4 = -prices[0], 0, -prices[0], 0\n        for price in prices[1:]:\n            f1 = max(f1, -price)\n            f2 = max(f2, f1 + price)\n            f3 = max(f3, f2 - price)\n            f4 = max(f4, f3 + price)\n        return f4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Java\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        // 第一次买入，第一次卖出，第二次买入，第二次卖出\n        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;\n        for (int i = 1; i < prices.length; ++i) {\n            f1 = Math.max(f1, -prices[i]);\n            f2 = Math.max(f2, f1 + prices[i]);\n            f3 = Math.max(f3, f2 - prices[i]);\n            f4 = Math.max(f4, f3 + prices[i]);\n        }\n        return f4;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;\n        for (int i = 1; i < prices.size(); ++i) {\n            f1 = max(f1, -prices[i]);\n            f2 = max(f2, f1 + prices[i]);\n            f3 = max(f3, f2 - prices[i]);\n            f4 = max(f4, f3 + prices[i]);\n        }\n        return f4;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Go\n\nfunc maxProfit(prices []int) int {\n    f1, f2, f3, f4 := -prices[0], 0, -prices[0], 0\n    for i := 1; i < len(prices); i++ {\n        f1 = max(f1, -prices[i])\n        f2 = max(f2, f1 + prices[i])\n        f3 = max(f3, f2 - prices[i])\n        f4 = max(f4, f3 + prices[i])\n    }\n    return f4\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# C#\n\npublic class Solution {\n    public int MaxProfit(int[] prices) {\n        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;\n        for (int i = 1; i < prices.Length; ++i)\n        {\n            f1 = Math.Max(f1, -prices[i]);\n            f2 = Math.Max(f2, f1 + prices[i]);\n            f3 = Math.Max(f3, f2 - prices[i]);\n            f4 = Math.Max(f4, f3 + prices[i]);\n        }\n        return f4;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 123. 买卖股票的最佳时机 iii\n\nenglish version\n\n\n# 题目描述\n\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n示例 1:\n\n\n输入：prices = [3,3,5,0,0,3,1,4]\n输出：6\n解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n\n示例 2：\n\n\n输入：prices = [1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n\n\n示例 3：\n\n\n输入：prices = [7,6,4,3,1] \n输出：0 \n解释：在这个情况下, 没有交易完成, 所以最大利润为 0。\n\n示例 4：\n\n\n输入：prices = [1]\n输出：0\n\n\n \n\n提示：\n\n * 1 <= prices.length <= 105\n * 0 <= prices[i] <= 105\n\n\n# 解法\n\n动态规划法。\n\n设 f1 表示第 1 次买入股票后的最大利润，f2 表示第 1 次卖出股票后的最大利润，f3 表示第 2 次买入股票后的最大利润，f4 表示第 2 次卖出股票后的最大利润。\n\n遍历过程中，直接使用 f1, f2, f3, f4 计算，考虑的是在同一天买入和卖出时，收益是 0，不会对答案产生影响。\n\n最后返回 f2 即可。\n\n\n# python3\n\nclass solution:\n    def maxprofit(self, prices: list[int]) -> int:\n        # 第一次买入，第一次卖出，第二次买入，第二次卖出\n        f1, f2, f3, f4 = -prices[0], 0, -prices[0], 0\n        for price in prices[1:]:\n            f1 = max(f1, -price)\n            f2 = max(f2, f1 + price)\n            f3 = max(f3, f2 - price)\n            f4 = max(f4, f3 + price)\n        return f4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# java\n\nclass solution {\n    public int maxprofit(int[] prices) {\n        // 第一次买入，第一次卖出，第二次买入，第二次卖出\n        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;\n        for (int i = 1; i < prices.length; ++i) {\n            f1 = math.max(f1, -prices[i]);\n            f2 = math.max(f2, f1 + prices[i]);\n            f3 = math.max(f3, f2 - prices[i]);\n            f4 = math.max(f4, f3 + prices[i]);\n        }\n        return f4;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# c++\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;\n        for (int i = 1; i < prices.size(); ++i) {\n            f1 = max(f1, -prices[i]);\n            f2 = max(f2, f1 + prices[i]);\n            f3 = max(f3, f2 - prices[i]);\n            f4 = max(f4, f3 + prices[i]);\n        }\n        return f4;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# go\n\nfunc maxprofit(prices []int) int {\n    f1, f2, f3, f4 := -prices[0], 0, -prices[0], 0\n    for i := 1; i < len(prices); i++ {\n        f1 = max(f1, -prices[i])\n        f2 = max(f2, f1 + prices[i])\n        f3 = max(f3, f2 - prices[i])\n        f4 = max(f4, f3 + prices[i])\n    }\n    return f4\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# c#\n\npublic class solution {\n    public int maxprofit(int[] prices) {\n        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;\n        for (int i = 1; i < prices.length; ++i)\n        {\n            f1 = math.max(f1, -prices[i]);\n            f2 = math.max(f2, f1 + prices[i]);\n            f3 = math.max(f3, f2 - prices[i]);\n            f4 = math.max(f4, f3 + prices[i]);\n        }\n        return f4;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode124 Binary Tree Maximum Path Sum-zh",frontmatter:{title:"leetcode124 Binary Tree Maximum Path Sum-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/067c87/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0124.Binary%20Tree%20Maximum%20Path%20Sum/images/exx1.jpg"},{name:"twitter:title",content:"leetcode124 Binary Tree Maximum Path Sum-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0124.Binary%20Tree%20Maximum%20Path%20Sum/images/exx1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10124.leetcode124%20Binary%20Tree%20Maximum%20Path%20Sum-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode124 Binary Tree Maximum Path Sum-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0124.Binary%20Tree%20Maximum%20Path%20Sum/images/exx1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10124.leetcode124%20Binary%20Tree%20Maximum%20Path%20Sum-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode124 Binary Tree Maximum Path Sum-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0124.Binary%20Tree%20Maximum%20Path%20Sum/images/exx1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10124.leetcode124%20Binary%20Tree%20Maximum%20Path%20Sum-zh.html",relativePath:"01.算法/24.leetcode/10124.leetcode124 Binary Tree Maximum Path Sum-zh.md",key:"v-0196fb6a",path:"/p/067c87/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:423},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:430},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:449},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:465}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 124. 二叉树中的最大路径和\n\nEnglish Version\n\n\n# 题目描述\n\n路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\n\n路径和 是路径中各节点值的总和。\n\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n\n \n\n示例 1：\n\n\n输入：root = [1,2,3]\n输出：6\n解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6\n\n示例 2：\n\n\n输入：root = [-10,9,20,null,null,15,7]\n输出：42\n解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n\n\n \n\n提示：\n\n * 树中节点数目范围是 [1, 3 * 104]\n * -1000 <= Node.val <= 1000\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 124. 二叉树中的最大路径和\n\nenglish version\n\n\n# 题目描述\n\n路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\n\n路径和 是路径中各节点值的总和。\n\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n\n \n\n示例 1：\n\n\n输入：root = [1,2,3]\n输出：6\n解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6\n\n示例 2：\n\n\n输入：root = [-10,9,20,null,null,15,7]\n输出：42\n解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n\n\n \n\n提示：\n\n * 树中节点数目范围是 [1, 3 * 104]\n * -1000 <= node.val <= 1000\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode125 Valid Palindrome-zh",frontmatter:{title:"leetcode125 Valid Palindrome-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/6d33d7/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode125 Valid Palindrome-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10125.leetcode125%20Valid%20Palindrome-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode125 Valid Palindrome-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10125.leetcode125%20Valid%20Palindrome-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode125 Valid Palindrome-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10125.leetcode125%20Valid%20Palindrome-zh.html",relativePath:"01.算法/24.leetcode/10125.leetcode125 Valid Palindrome-zh.md",key:"v-35ab16a6",path:"/p/6d33d7/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:202},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:209},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:646},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1240},{level:3,title:"tTypeScript",slug:"ttypescript",normalizedTitle:"ttypescript",charIndex:1937},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2551}],headersStr:"题目描述 解法 Python3 Java C++ tTypeScript ...",content:"# 125. 验证回文串\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n示例 1:\n\n输入: \"A man, a plan, a canal: Panama\"\n输出: true\n\n\n示例 2:\n\n输入: \"race a car\"\n输出: false\n\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        i, j = 0, len(s) - 1\n        while i < j:\n            if not s[i].isalnum():\n                i += 1\n            elif not s[j].isalnum():\n                j -= 1\n            elif s[i].lower() != s[j].lower():\n                return False\n            else:\n                i += 1\n                j -= 1\n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Java\n\nclass Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            if (!Character.isLetterOrDigit(s.charAt(i))) {\n                ++i;\n            } else if (!Character.isLetterOrDigit(s.charAt(j))) {\n                --j;\n            } else if (Character.toUpperCase(s.charAt(i)) != Character.toUpperCase(s.charAt(j))) {\n                return false;\n            } else {\n                ++i;\n                --j;\n            }\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# C++\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.size() - 1;\n        while (i < j) {\n            if (!isAlphaNum(s[i])) ++i;\n            else if (!isAlphaNum(s[j])) --j;\n            else if ((s[i] + 32 - 'a') % 32 != (s[j] + 32 - 'a') % 32) return false;\n            else {\n                ++i;\n                --j;\n            }\n        }\n        return true;\n    }\n\nprivate:\n    bool isAlphaNum(char &ch) {\n        if (ch >= 'a' && ch <= 'z') return true;\n        if (ch >= 'A' && ch <= 'Z') return true;\n        if (ch >= '0' && ch <= '9') return true;\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# tTypeScript\n\nfunction isPalindrome(s: string): boolean {\n    let left: number = 0, right: number = s.length - 1;\n    while (left < right) {\n        let char1: string = s.charAt(left);\n        let char2: string = s.charAt(right);\n        if (!(/[a-zA-Z0-9]/).test(char1)) {\n            ++left;\n        } else if (!(/[a-zA-Z0-9]/).test(char2)) {\n            --right;\n        } else if (char1.toLocaleLowerCase() != char2.toLocaleLowerCase()) {\n            return false;\n        } else {\n            ++left;\n            --right;\n        }\n    }\n    return true;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 125. 验证回文串\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n示例 1:\n\n输入: \"a man, a plan, a canal: panama\"\n输出: true\n\n\n示例 2:\n\n输入: \"race a car\"\n输出: false\n\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def ispalindrome(self, s: str) -> bool:\n        i, j = 0, len(s) - 1\n        while i < j:\n            if not s[i].isalnum():\n                i += 1\n            elif not s[j].isalnum():\n                j -= 1\n            elif s[i].lower() != s[j].lower():\n                return false\n            else:\n                i += 1\n                j -= 1\n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# java\n\nclass solution {\n    public boolean ispalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            if (!character.isletterordigit(s.charat(i))) {\n                ++i;\n            } else if (!character.isletterordigit(s.charat(j))) {\n                --j;\n            } else if (character.touppercase(s.charat(i)) != character.touppercase(s.charat(j))) {\n                return false;\n            } else {\n                ++i;\n                --j;\n            }\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# c++\n\nclass solution {\npublic:\n    bool ispalindrome(string s) {\n        int i = 0, j = s.size() - 1;\n        while (i < j) {\n            if (!isalphanum(s[i])) ++i;\n            else if (!isalphanum(s[j])) --j;\n            else if ((s[i] + 32 - 'a') % 32 != (s[j] + 32 - 'a') % 32) return false;\n            else {\n                ++i;\n                --j;\n            }\n        }\n        return true;\n    }\n\nprivate:\n    bool isalphanum(char &ch) {\n        if (ch >= 'a' && ch <= 'z') return true;\n        if (ch >= 'a' && ch <= 'z') return true;\n        if (ch >= '0' && ch <= '9') return true;\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ttypescript\n\nfunction ispalindrome(s: string): boolean {\n    let left: number = 0, right: number = s.length - 1;\n    while (left < right) {\n        let char1: string = s.charat(left);\n        let char2: string = s.charat(right);\n        if (!(/[a-za-z0-9]/).test(char1)) {\n            ++left;\n        } else if (!(/[a-za-z0-9]/).test(char2)) {\n            --right;\n        } else if (char1.tolocalelowercase() != char2.tolocalelowercase()) {\n            return false;\n        } else {\n            ++left;\n            --right;\n        }\n    }\n    return true;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode126 Word Ladder II-zh",frontmatter:{title:"leetcode126 Word Ladder II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b0951d/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode126 Word Ladder II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10126.leetcode126%20Word%20Ladder%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode126 Word Ladder II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10126.leetcode126%20Word%20Ladder%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode126 Word Ladder II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10126.leetcode126%20Word%20Ladder%20II-zh.html",relativePath:"01.算法/24.leetcode/10126.leetcode126 Word Ladder II-zh.md",key:"v-7cc459ac",path:"/p/b0951d/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1101},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1108},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1127},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:131}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 126. 单词接龙 II\n\nEnglish Version\n\n\n# 题目描述\n\n按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：\n\n * 每对相邻的单词之间仅有单个字母不同。\n * 转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。\n * sk == endWord\n\n给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。\n\n \n\n示例 1：\n\n\n输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]\n输出：[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]\n解释：存在 2 种最短的转换序列：\n"hit" -> "hot" -> "dot" -> "dog" -> "cog"\n"hit" -> "hot" -> "lot" -> "log" -> "cog"\n\n\n示例 2：\n\n\n输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]\n输出：[]\n解释：endWord "cog" 不在字典 wordList 中，所以不存在符合要求的转换序列。\n\n\n \n\n提示：\n\n * 1 <= beginWord.length <= 7\n * endWord.length == beginWord.length\n * 1 <= wordList.length <= 5000\n * wordList[i].length == beginWord.length\n * beginWord、endWord 和 wordList[i] 由小写英文字母组成\n * beginWord != endWord\n * wordList 中的所有单词 互不相同\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 126. 单词接龙 ii\n\nenglish version\n\n\n# 题目描述\n\n按字典 wordlist 完成从单词 beginword 到单词 endword 转化，一个表示此过程的 转换序列 是形式上像 beginword -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：\n\n * 每对相邻的单词之间仅有单个字母不同。\n * 转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordlist 中的单词。注意，beginword 不必是字典 wordlist 中的单词。\n * sk == endword\n\n给你两个单词 beginword 和 endword ，以及一个字典 wordlist 。请你找出并返回所有从 beginword 到 endword 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginword, s1, s2, ..., sk] 的形式返回。\n\n \n\n示例 1：\n\n\n输入：beginword = "hit", endword = "cog", wordlist = ["hot","dot","dog","lot","log","cog"]\n输出：[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]\n解释：存在 2 种最短的转换序列：\n"hit" -> "hot" -> "dot" -> "dog" -> "cog"\n"hit" -> "hot" -> "lot" -> "log" -> "cog"\n\n\n示例 2：\n\n\n输入：beginword = "hit", endword = "cog", wordlist = ["hot","dot","dog","lot","log"]\n输出：[]\n解释：endword "cog" 不在字典 wordlist 中，所以不存在符合要求的转换序列。\n\n\n \n\n提示：\n\n * 1 <= beginword.length <= 7\n * endword.length == beginword.length\n * 1 <= wordlist.length <= 5000\n * wordlist[i].length == beginword.length\n * beginword、endword 和 wordlist[i] 由小写英文字母组成\n * beginword != endword\n * wordlist 中的所有单词 互不相同\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode127 Word Ladder-zh",frontmatter:{title:"leetcode127 Word Ladder-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/3ec509/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode127 Word Ladder-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10127.leetcode127%20Word%20Ladder-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode127 Word Ladder-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10127.leetcode127%20Word%20Ladder-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode127 Word Ladder-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10127.leetcode127%20Word%20Ladder-zh.html",relativePath:"01.算法/24.leetcode/10127.leetcode127 Word Ladder-zh.md",key:"v-a9ae197e",path:"/p/3ec509/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:855},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:862},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:881},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:897}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 127. 单词接龙\n\nEnglish Version\n\n\n# 题目描述\n\n字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：\n\n * 序列中第一个单词是 beginWord 。\n * 序列中最后一个单词是 endWord 。\n * 每次转换只能改变一个字母。\n * 转换过程中的中间单词必须是字典 wordList 中的单词。\n\n给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。\n\n \n\n示例 1：\n\n\n输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]\n输出：5\n解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。\n\n\n示例 2：\n\n\n输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]\n输出：0\n解释：endWord "cog" 不在字典中，所以无法进行转换。\n\n \n\n提示：\n\n * 1 <= beginWord.length <= 10\n * endWord.length == beginWord.length\n * 1 <= wordList.length <= 5000\n * wordList[i].length == beginWord.length\n * beginWord、endWord 和 wordList[i] 由小写英文字母组成\n * beginWord != endWord\n * wordList 中的所有字符串 互不相同\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 127. 单词接龙\n\nenglish version\n\n\n# 题目描述\n\n字典 wordlist 中从单词 beginword 和 endword 的 转换序列 是一个按下述规格形成的序列：\n\n * 序列中第一个单词是 beginword 。\n * 序列中最后一个单词是 endword 。\n * 每次转换只能改变一个字母。\n * 转换过程中的中间单词必须是字典 wordlist 中的单词。\n\n给你两个单词 beginword 和 endword 和一个字典 wordlist ，找到从 beginword 到 endword 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。\n\n \n\n示例 1：\n\n\n输入：beginword = "hit", endword = "cog", wordlist = ["hot","dot","dog","lot","log","cog"]\n输出：5\n解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。\n\n\n示例 2：\n\n\n输入：beginword = "hit", endword = "cog", wordlist = ["hot","dot","dog","lot","log"]\n输出：0\n解释：endword "cog" 不在字典中，所以无法进行转换。\n\n \n\n提示：\n\n * 1 <= beginword.length <= 10\n * endword.length == beginword.length\n * 1 <= wordlist.length <= 5000\n * wordlist[i].length == beginword.length\n * beginword、endword 和 wordlist[i] 由小写英文字母组成\n * beginword != endword\n * wordlist 中的所有字符串 互不相同\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode128 Longest Consecutive Sequence-zh",frontmatter:{title:"leetcode128 Longest Consecutive Sequence-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/68f243/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode128 Longest Consecutive Sequence-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10128.leetcode128%20Longest%20Consecutive%20Sequence-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode128 Longest Consecutive Sequence-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10128.leetcode128%20Longest%20Consecutive%20Sequence-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode128 Longest Consecutive Sequence-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10128.leetcode128%20Longest%20Consecutive%20Sequence-zh.html",relativePath:"01.算法/24.leetcode/10128.leetcode128 Longest Consecutive Sequence-zh.md",key:"v-d66a91a0",path:"/p/68f243/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:320},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:327},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:346},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:362}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 128. 最长连续序列\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n \n\n进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？\n\n \n\n示例 1：\n\n\n输入：nums = [100,4,200,1,3,2]\n输出：4\n解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n\n示例 2：\n\n\n输入：nums = [0,3,7,2,5,8,4,6,0,1]\n输出：9\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 128. 最长连续序列\n\nenglish version\n\n\n# 题目描述\n\n给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n \n\n进阶：你可以设计并实现时间复杂度为 o(n) 的解决方案吗？\n\n \n\n示例 1：\n\n\n输入：nums = [100,4,200,1,3,2]\n输出：4\n解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n\n示例 2：\n\n\n输入：nums = [0,3,7,2,5,8,4,6,0,1]\n输出：9\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode129 Sum Root to Leaf Numbers-zh",frontmatter:{title:"leetcode129 Sum Root to Leaf Numbers-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/2dfa58/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0129.Sum%20Root%20to%20Leaf%20Numbers/images/num1tree.jpg"},{name:"twitter:title",content:"leetcode129 Sum Root to Leaf Numbers-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0129.Sum%20Root%20to%20Leaf%20Numbers/images/num1tree.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10129.leetcode129%20Sum%20Root%20to%20Leaf%20Numbers-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode129 Sum Root to Leaf Numbers-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0129.Sum%20Root%20to%20Leaf%20Numbers/images/num1tree.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10129.leetcode129%20Sum%20Root%20to%20Leaf%20Numbers-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode129 Sum Root to Leaf Numbers-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0129.Sum%20Root%20to%20Leaf%20Numbers/images/num1tree.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10129.leetcode129%20Sum%20Root%20to%20Leaf%20Numbers-zh.html",relativePath:"01.算法/24.leetcode/10129.leetcode129 Sum Root to Leaf Numbers-zh.md",key:"v-32c4dbca",path:"/p/2dfa58/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:41},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:536},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:543},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:562},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:578}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 129. 求根节点到叶节点数字之和\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n\n每条从根节点到叶节点的路径都代表一个数字：\n\n\n\n * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n\n计算从根节点到叶节点生成的 所有数字之和 。\n\n叶节点 是指没有子节点的节点。\n\n \n\n示例 1：\n\n\n输入：root = [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12\n从根到叶子节点路径 1->3 代表数字 13\n因此，数字总和 = 12 + 13 = 25\n\n示例 2：\n\n\n输入：root = [4,9,0,5,1]\n输出：1026\n解释：\n从根到叶子节点路径 4->9->5 代表数字 495\n从根到叶子节点路径 4->9->1 代表数字 491\n从根到叶子节点路径 4->0 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = 1026\n\n\n \n\n提示：\n\n * 树中节点的数目在范围 [1, 1000] 内\n * 0 <= Node.val <= 9\n * 树的深度不超过 10\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 129. 求根节点到叶节点数字之和\n\nenglish version\n\n\n# 题目描述\n\n给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n\n每条从根节点到叶节点的路径都代表一个数字：\n\n\n\n * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n\n计算从根节点到叶节点生成的 所有数字之和 。\n\n叶节点 是指没有子节点的节点。\n\n \n\n示例 1：\n\n\n输入：root = [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12\n从根到叶子节点路径 1->3 代表数字 13\n因此，数字总和 = 12 + 13 = 25\n\n示例 2：\n\n\n输入：root = [4,9,0,5,1]\n输出：1026\n解释：\n从根到叶子节点路径 4->9->5 代表数字 495\n从根到叶子节点路径 4->9->1 代表数字 491\n从根到叶子节点路径 4->0 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = 1026\n\n\n \n\n提示：\n\n * 树中节点的数目在范围 [1, 1000] 内\n * 0 <= node.val <= 9\n * 树的深度不超过 10\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode130 Surrounded Regions-zh",frontmatter:{title:"leetcode130 Surrounded Regions-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/e68122/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0130.Surrounded%20Regions/images/xogrid.jpg"},{name:"twitter:title",content:"leetcode130 Surrounded Regions-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0130.Surrounded%20Regions/images/xogrid.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10130.leetcode130%20Surrounded%20Regions-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode130 Surrounded Regions-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0130.Surrounded%20Regions/images/xogrid.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10130.leetcode130%20Surrounded%20Regions-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode130 Surrounded Regions-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0130.Surrounded%20Regions/images/xogrid.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10130.leetcode130%20Surrounded%20Regions-zh.html",relativePath:"01.算法/24.leetcode/10130.leetcode130 Surrounded Regions-zh.md",key:"v-116b07e7",path:"/p/e68122/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:560},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:579},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:598},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:614},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2225}],headersStr:"题目描述 解法 Python3 Java TypeScript ...",content:'# 130. 被围绕的区域\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个 m x n 的矩阵 board ，由若干字符 \'X\' 和 \'O\' ，找到所有被 \'X\' 围绕的区域，并将这些区域里所有的 \'O\' 用 \'X\' 填充。\n\n \n\n\n\n示例 1：\n\n\n输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]\n输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]\n解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 \'O\' 都不会被填充为 \'X\'。 任何不在边界上，或不与边界上的 \'O\' 相连的 \'O\' 最终都会被填充为 \'X\'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。\n\n\n示例 2：\n\n\n输入：board = [["X"]]\n输出：[["X"]]\n\n\n \n\n提示：\n\n * m == board.length\n * n == board[i].length\n * 1 <= m, n <= 200\n * board[i][j] 为 \'X\' 或 \'O\'\n\n\n# 解法\n\ndfs/bfs 均可\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# TypeScript\n\n/**\n Do not return anything, modify board in-place instead.\n */\nfunction solve(board: string[][]): void {\n    let m = board.length, n = board[0].length;\n    if (m < 3 || n < 3) return;\n    let visited = Array.from({ length: m }, v => new Array(n).fill(false));\n    // 第一行，最后一行， 第一列， 最后一列\n    for (let i of [0, m-1]) {\n        for (let j = 0; j < n; ++j) {\n            if (board[i][j] == \'X\') {\n                visited[i][j] = true;\n            } else {\n                dfs(board, i, j, visited, true);\n            }\n        }\n    }\n    for (let i = 0; i < m; ++i) {\n        for (let j of [0, n - 1]) {\n            if (board[i][j] == \'X\') {\n                visited[i][j] = true;\n            } else {\n                dfs(board, i, j, visited, true);\n            }\n        }\n    }\n    for (let i = 1; i < m - 1; ++i) {\n        for (let j = 1; j < n - 1; ++j) {\n            !visited[i][j] && dfs(board, i, j, visited);\n        }\n    }\n};\n\nfunction dfs(board: string[][], i: number, j: number, visited: boolean[][], edge = false): void {\n    let m = board.length, n = board[0].length;\n    if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || visited[i][j]) {\n        return;\n    }\n\n    visited[i][j] = true;\n    if (board[i][j] == \'X\') {\n        return;\n    }\n    if (!edge) {\n        board[i][j] = \'X\';\n    }\n    for (let [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\n        let x = i + dx, y = j + dy;\n        dfs(board, x, y, visited, edge);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 130. 被围绕的区域\n\nenglish version\n\n\n# 题目描述\n\n给你一个 m x n 的矩阵 board ，由若干字符 \'x\' 和 \'o\' ，找到所有被 \'x\' 围绕的区域，并将这些区域里所有的 \'o\' 用 \'x\' 填充。\n\n \n\n\n\n示例 1：\n\n\n输入：board = [["x","x","x","x"],["x","o","o","x"],["x","x","o","x"],["x","o","x","x"]]\n输出：[["x","x","x","x"],["x","x","x","x"],["x","x","x","x"],["x","o","x","x"]]\n解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 \'o\' 都不会被填充为 \'x\'。 任何不在边界上，或不与边界上的 \'o\' 相连的 \'o\' 最终都会被填充为 \'x\'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。\n\n\n示例 2：\n\n\n输入：board = [["x"]]\n输出：[["x"]]\n\n\n \n\n提示：\n\n * m == board.length\n * n == board[i].length\n * 1 <= m, n <= 200\n * board[i][j] 为 \'x\' 或 \'o\'\n\n\n# 解法\n\ndfs/bfs 均可\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# typescript\n\n/**\n do not return anything, modify board in-place instead.\n */\nfunction solve(board: string[][]): void {\n    let m = board.length, n = board[0].length;\n    if (m < 3 || n < 3) return;\n    let visited = array.from({ length: m }, v => new array(n).fill(false));\n    // 第一行，最后一行， 第一列， 最后一列\n    for (let i of [0, m-1]) {\n        for (let j = 0; j < n; ++j) {\n            if (board[i][j] == \'x\') {\n                visited[i][j] = true;\n            } else {\n                dfs(board, i, j, visited, true);\n            }\n        }\n    }\n    for (let i = 0; i < m; ++i) {\n        for (let j of [0, n - 1]) {\n            if (board[i][j] == \'x\') {\n                visited[i][j] = true;\n            } else {\n                dfs(board, i, j, visited, true);\n            }\n        }\n    }\n    for (let i = 1; i < m - 1; ++i) {\n        for (let j = 1; j < n - 1; ++j) {\n            !visited[i][j] && dfs(board, i, j, visited);\n        }\n    }\n};\n\nfunction dfs(board: string[][], i: number, j: number, visited: boolean[][], edge = false): void {\n    let m = board.length, n = board[0].length;\n    if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || visited[i][j]) {\n        return;\n    }\n\n    visited[i][j] = true;\n    if (board[i][j] == \'x\') {\n        return;\n    }\n    if (!edge) {\n        board[i][j] = \'x\';\n    }\n    for (let [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\n        let x = i + dx, y = j + dy;\n        dfs(board, x, y, visited, edge);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode131 Palindrome Partitioning-zh",frontmatter:{title:"leetcode131 Palindrome Partitioning-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fbe3f4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode131 Palindrome Partitioning-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10131.leetcode131%20Palindrome%20Partitioning-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode131 Palindrome Partitioning-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10131.leetcode131%20Palindrome%20Partitioning-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode131 Palindrome Partitioning-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10131.leetcode131%20Palindrome%20Partitioning-zh.html",relativePath:"01.算法/24.leetcode/10131.leetcode131 Palindrome Partitioning-zh.md",key:"v-35faa073",path:"/p/fbe3f4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:255},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:262},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:281},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:297}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 131. 分割回文串\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\n\n回文串 是正着读和反着读都一样的字符串。\n\n \n\n示例 1：\n\n\n输入：s = "aab"\n输出：[["a","a","b"],["aa","b"]]\n\n\n示例 2：\n\n\n输入：s = "a"\n输出：[["a"]]\n\n\n \n\n提示：\n\n * 1 <= s.length <= 16\n * s 仅由小写英文字母组成\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 131. 分割回文串\n\nenglish version\n\n\n# 题目描述\n\n给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\n\n回文串 是正着读和反着读都一样的字符串。\n\n \n\n示例 1：\n\n\n输入：s = "aab"\n输出：[["a","a","b"],["aa","b"]]\n\n\n示例 2：\n\n\n输入：s = "a"\n输出：[["a"]]\n\n\n \n\n提示：\n\n * 1 <= s.length <= 16\n * s 仅由小写英文字母组成\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode132 Palindrome Partitioning II-zh",frontmatter:{title:"leetcode132 Palindrome Partitioning II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/cba4c5/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode132 Palindrome Partitioning II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10132.leetcode132%20Palindrome%20Partitioning%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode132 Palindrome Partitioning II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10132.leetcode132%20Palindrome%20Partitioning%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode132 Palindrome Partitioning II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10132.leetcode132%20Palindrome%20Partitioning%20II-zh.html",relativePath:"01.算法/24.leetcode/10132.leetcode132 Palindrome Partitioning II-zh.md",key:"v-0c342a0a",path:"/p/cba4c5/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:274},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:281},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:300},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:316}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 132. 分割回文串 II\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。\n\n返回符合要求的 最少分割次数 。\n\n \n\n示例 1：\n\n\n输入：s = "aab"\n输出：1\n解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。\n\n\n示例 2：\n\n\n输入：s = "a"\n输出：0\n\n\n示例 3：\n\n\n输入：s = "ab"\n输出：1\n\n\n \n\n提示：\n\n * 1 <= s.length <= 2000\n * s 仅由小写英文字母组成\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 132. 分割回文串 ii\n\nenglish version\n\n\n# 题目描述\n\n给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。\n\n返回符合要求的 最少分割次数 。\n\n \n\n示例 1：\n\n\n输入：s = "aab"\n输出：1\n解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。\n\n\n示例 2：\n\n\n输入：s = "a"\n输出：0\n\n\n示例 3：\n\n\n输入：s = "ab"\n输出：1\n\n\n \n\n提示：\n\n * 1 <= s.length <= 2000\n * s 仅由小写英文字母组成\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode133 Clone Graph-zh",frontmatter:{title:"leetcode133 Clone Graph-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/7ede97/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0133.Clone%20Graph/images/133_clone_graph_question.png"},{name:"twitter:title",content:"leetcode133 Clone Graph-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0133.Clone%20Graph/images/133_clone_graph_question.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10133.leetcode133%20Clone%20Graph-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode133 Clone Graph-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0133.Clone%20Graph/images/133_clone_graph_question.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10133.leetcode133%20Clone%20Graph-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode133 Clone Graph-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0133.Clone%20Graph/images/133_clone_graph_question.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10133.leetcode133%20Clone%20Graph-zh.html",relativePath:"01.算法/24.leetcode/10133.leetcode133 Clone Graph-zh.md",key:"v-1b1ca026",path:"/p/7ede97/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:948},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:955},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:974},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:990}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 133. 克隆图\n\nEnglish Version\n\n\n# 题目描述\n\n给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。\n\n图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\n \n\n测试用例格式：\n\n简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。\n\n邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n\n给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。\n\n \n\n示例 1：\n\n\n\n输入：adjList = [[2,4],[1,3],[2,4],[1,3]]\n输出：[[2,4],[1,3],[2,4],[1,3]]\n解释：\n图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n\n\n示例 2：\n\n\n\n输入：adjList = [[]]\n输出：[[]]\n解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n\n\n示例 3：\n\n输入：adjList = []\n输出：[]\n解释：这个图是空的，它不含任何节点。\n\n\n示例 4：\n\n\n\n输入：adjList = [[2],[1]]\n输出：[[2],[1]]\n\n \n\n提示：\n\n 1. 节点数不超过 100 。\n 2. 每个节点值 Node.val 都是唯一的，1 <= Node.val <= 100。\n 3. 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。\n 4. 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。\n 5. 图是连通图，你可以从给定节点访问到所有节点。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 133. 克隆图\n\nenglish version\n\n\n# 题目描述\n\n给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。\n\n图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[node]）。\n\nclass node {\n    public int val;\n    public list<node> neighbors;\n}\n\n \n\n测试用例格式：\n\n简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。\n\n邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n\n给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。\n\n \n\n示例 1：\n\n\n\n输入：adjlist = [[2,4],[1,3],[2,4],[1,3]]\n输出：[[2,4],[1,3],[2,4],[1,3]]\n解释：\n图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n\n\n示例 2：\n\n\n\n输入：adjlist = [[]]\n输出：[[]]\n解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n\n\n示例 3：\n\n输入：adjlist = []\n输出：[]\n解释：这个图是空的，它不含任何节点。\n\n\n示例 4：\n\n\n\n输入：adjlist = [[2],[1]]\n输出：[[2],[1]]\n\n \n\n提示：\n\n 1. 节点数不超过 100 。\n 2. 每个节点值 node.val 都是唯一的，1 <= node.val <= 100。\n 3. 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。\n 4. 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。\n 5. 图是连通图，你可以从给定节点访问到所有节点。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode134 Gas Station-zh",frontmatter:{title:"leetcode134 Gas Station-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/cc0ab7/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode134 Gas Station-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10134.leetcode134%20Gas%20Station-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode134 Gas Station-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10134.leetcode134%20Gas%20Station-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode134 Gas Station-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10134.leetcode134%20Gas%20Station-zh.html",relativePath:"01.算法/24.leetcode/10134.leetcode134 Gas Station-zh.md",key:"v-8626ba16",path:"/p/cc0ab7/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:843},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:850},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:869},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:885}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 134. 加油站\n\nEnglish Version\n\n\n# 题目描述\n\n在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n\n如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。\n\n说明: \n\n * 如果题目有解，该答案即为唯一答案。\n * 输入数组均为非空数组，且长度相同。\n * 输入数组中的元素均为非负数。\n\n示例 1:\n\n输入: \ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n\n输出: 3\n\n解释:\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。\n\n示例 2:\n\n输入: \ngas  = [2,3,4]\ncost = [3,4,3]\n\n输出: -1\n\n解释:\n你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n因此，无论怎样，你都不可能绕环路行驶一周。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 134. 加油站\n\nenglish version\n\n\n# 题目描述\n\n在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n\n如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。\n\n说明: \n\n * 如果题目有解，该答案即为唯一答案。\n * 输入数组均为非空数组，且长度相同。\n * 输入数组中的元素均为非负数。\n\n示例 1:\n\n输入: \ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n\n输出: 3\n\n解释:\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。\n\n示例 2:\n\n输入: \ngas  = [2,3,4]\ncost = [3,4,3]\n\n输出: -1\n\n解释:\n你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n因此，无论怎样，你都不可能绕环路行驶一周。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode135 Candy-zh",frontmatter:{title:"leetcode135 Candy-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/3f7a76/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode135 Candy-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10135.leetcode135%20Candy-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode135 Candy-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10135.leetcode135%20Candy-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode135 Candy-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10135.leetcode135%20Candy-zh.html",relativePath:"01.算法/24.leetcode/10135.leetcode135 Candy-zh.md",key:"v-d7da2f68",path:"/p/3f7a76/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:335},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:342},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:361},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:377}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 135. 分发糖果\n\nEnglish Version\n\n\n# 题目描述\n\n老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。\n\n你需要按照以下要求，帮助老师给这些孩子分发糖果：\n\n * 每个孩子至少分配到 1 个糖果。\n * 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。\n\n那么这样下来，老师至少需要准备多少颗糖果呢？\n\n \n\n示例 1：\n\n\n输入：[1,0,2]\n输出：5\n解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。\n\n\n示例 2：\n\n\n输入：[1,2,2]\n输出：4\n解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。\n     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 135. 分发糖果\n\nenglish version\n\n\n# 题目描述\n\n老师想给孩子们分发糖果，有 n 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。\n\n你需要按照以下要求，帮助老师给这些孩子分发糖果：\n\n * 每个孩子至少分配到 1 个糖果。\n * 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。\n\n那么这样下来，老师至少需要准备多少颗糖果呢？\n\n \n\n示例 1：\n\n\n输入：[1,0,2]\n输出：5\n解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。\n\n\n示例 2：\n\n\n输入：[1,2,2]\n输出：4\n解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。\n     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode136 Single Number-zh",frontmatter:{title:"leetcode136 Single Number-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/e857cf/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode136 Single Number-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10136.leetcode136%20Single%20Number-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode136 Single Number-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10136.leetcode136%20Single%20Number-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode136 Single Number-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10136.leetcode136%20Single%20Number-zh.html",relativePath:"01.算法/24.leetcode/10136.leetcode136 Single Number-zh.md",key:"v-4b97ba8b",path:"/p/e857cf/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:195},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:265},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:444},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:648},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:860},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:985},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1201}],headersStr:"题目描述 解法 Python3 Java JavaScript Go C++ ...",content:"# 136. 只出现一次的数字\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n\n输入: [2,2,1]\n输出: 1\n\n\n示例 2:\n\n输入: [4,1,2,1,2]\n输出: 4\n\n\n# 解法\n\n异或运算求解。\n\n首先明确，两个相同的数异或之后的结果为 0。对该数组所有元素进行异或运算，结果就是那个只出现一次的数字。\n\n\n# Python3\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        res = 0\n        for num in nums:\n            res ^= num\n        return res\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Java\n\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int res = 0;\n        for (int num : nums) {\n            res ^= num;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function (nums) {\n  let res = 0;\n  for (let num of nums) {\n    res ^= num;\n  }\n  return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Go\n\nfunc singleNumber(nums []int) int {\n\tres := 0\n\tfor _, v := range nums {\n\t\tres ^= v\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int res = 0;\n        for (auto num : nums) {\n            res ^= num;\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 136. 只出现一次的数字\n\nenglish version\n\n\n# 题目描述\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n\n输入: [2,2,1]\n输出: 1\n\n\n示例 2:\n\n输入: [4,1,2,1,2]\n输出: 4\n\n\n# 解法\n\n异或运算求解。\n\n首先明确，两个相同的数异或之后的结果为 0。对该数组所有元素进行异或运算，结果就是那个只出现一次的数字。\n\n\n# python3\n\nclass solution:\n    def singlenumber(self, nums: list[int]) -> int:\n        res = 0\n        for num in nums:\n            res ^= num\n        return res\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# java\n\nclass solution {\n    public int singlenumber(int[] nums) {\n        int res = 0;\n        for (int num : nums) {\n            res ^= num;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singlenumber = function (nums) {\n  let res = 0;\n  for (let num of nums) {\n    res ^= num;\n  }\n  return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# go\n\nfunc singlenumber(nums []int) int {\n\tres := 0\n\tfor _, v := range nums {\n\t\tres ^= v\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# c++\n\nclass solution {\npublic:\n    int singlenumber(vector<int>& nums) {\n        int res = 0;\n        for (auto num : nums) {\n            res ^= num;\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode137 Single Number II-zh",frontmatter:{title:"leetcode137 Single Number II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/0e631d/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode137 Single Number II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10137.leetcode137%20Single%20Number%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode137 Single Number II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10137.leetcode137%20Single%20Number%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode137 Single Number II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10137.leetcode137%20Single%20Number%20II-zh.html",relativePath:"01.算法/24.leetcode/10137.leetcode137 Single Number II-zh.md",key:"v-6b219a6c",path:"/p/0e631d/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:40},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:343},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:432},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:927},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1426}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 137. 只出现一次的数字 II\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。\n\n \n\n示例 1：\n\n\n输入：nums = [2,2,3,2]\n输出：3\n\n\n示例 2：\n\n\n输入：nums = [0,1,0,1,0,1,99]\n输出：99\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 3 * 104\n * -231 <= nums[i] <= 231 - 1\n * nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次\n\n \n\n进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n\n# 解法\n\n统计所有数字每个位中 1 出现的次数，对于某个位，1 出现的次数一定是 3 的倍数 +1 或 0。对这个数 %3 得到的结果就是那个出现一次的数字在该位上的值。\n\n\n# Python3\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        bits = [0] * 32\n        for num in nums:\n            for i in range(32):\n                bits[i] += (num & 1)\n                num >>= 1\n        res = 0\n        for i in range(32):\n            if bits[i] % 3 != 0:\n                res |= (1 << i)\n        # 如果为负数，先将 0-32 位取反（即 res ^ 0xffffffff ），再将所有位取反（即 ~ ）\n        return res if bits[31] % 3 == 0 else ~(res ^ 0xffffffff)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int[] bits = new int[32];\n        for (int num : nums) {\n            for (int i = 0; i < 32; ++i) {\n                bits[i] += (num & 1);\n                num >>= 1;\n            }\n        }\n\n        int res = 0;\n        for (int i = 0; i < 32; ++i) {\n            if (bits[i] % 3 == 1) {\n                res |= (1 << i);\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 137. 只出现一次的数字 ii\n\nenglish version\n\n\n# 题目描述\n\n给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。\n\n \n\n示例 1：\n\n\n输入：nums = [2,2,3,2]\n输出：3\n\n\n示例 2：\n\n\n输入：nums = [0,1,0,1,0,1,99]\n输出：99\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 3 * 104\n * -231 <= nums[i] <= 231 - 1\n * nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次\n\n \n\n进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n\n# 解法\n\n统计所有数字每个位中 1 出现的次数，对于某个位，1 出现的次数一定是 3 的倍数 +1 或 0。对这个数 %3 得到的结果就是那个出现一次的数字在该位上的值。\n\n\n# python3\n\nclass solution:\n    def singlenumber(self, nums: list[int]) -> int:\n        bits = [0] * 32\n        for num in nums:\n            for i in range(32):\n                bits[i] += (num & 1)\n                num >>= 1\n        res = 0\n        for i in range(32):\n            if bits[i] % 3 != 0:\n                res |= (1 << i)\n        # 如果为负数，先将 0-32 位取反（即 res ^ 0xffffffff ），再将所有位取反（即 ~ ）\n        return res if bits[31] % 3 == 0 else ~(res ^ 0xffffffff)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\nclass solution {\n    public int singlenumber(int[] nums) {\n        int[] bits = new int[32];\n        for (int num : nums) {\n            for (int i = 0; i < 32; ++i) {\n                bits[i] += (num & 1);\n                num >>= 1;\n            }\n        }\n\n        int res = 0;\n        for (int i = 0; i < 32; ++i) {\n            if (bits[i] % 3 == 1) {\n                res |= (1 << i);\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode138 Copy List with Random Pointer-zh",frontmatter:{title:"leetcode138 Copy List with Random Pointer-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/529fc9/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0138.Copy%20List%20with%20Random%20Pointer/images/e1.png"},{name:"twitter:title",content:"leetcode138 Copy List with Random Pointer-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0138.Copy%20List%20with%20Random%20Pointer/images/e1.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10138.leetcode138%20Copy%20List%20with%20Random%20Pointer-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode138 Copy List with Random Pointer-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0138.Copy%20List%20with%20Random%20Pointer/images/e1.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10138.leetcode138%20Copy%20List%20with%20Random%20Pointer-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode138 Copy List with Random Pointer-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0138.Copy%20List%20with%20Random%20Pointer/images/e1.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10138.leetcode138%20Copy%20List%20with%20Random%20Pointer-zh.html",relativePath:"01.算法/24.leetcode/10138.leetcode138 Copy List with Random Pointer-zh.md",key:"v-df35d6d8",path:"/p/529fc9/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:918},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1124},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2096},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:3221},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:4333},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:5490},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:6539},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:7502}],headersStr:"题目描述 解法 Python3 Java C++ C# Go JavaScript ...",content:"# 138. 复制带随机指针的链表\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\n\n构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n\n例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --\x3e Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --\x3e y 。\n\n返回复制链表的头节点。\n\n用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：\n\n * val：一个表示 Node.val 的整数。\n * random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。\n\n你的代码 只 接受原链表的头节点 head 作为传入参数。\n\n \n\n示例 1：\n\n\n\n\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n示例 2：\n\n\n\n\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n\n\n示例 3：\n\n\n\n\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n\n\n示例 4：\n\n\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n\n\n \n\n提示：\n\n * 0 <= n <= 1000\n * -10000 <= Node.val <= 10000\n * Node.random 为空（null）或指向链表中的节点。\n\n\n# 解法\n\n首先，遍历链表，完成对每个旧节点的复制。\n\nA -> B -> C -> D -> null\n\n=>\n\nA -> A1 -> B -> B1 -> C -> C1 -> D -> D1 -> null\n\n\n1\n2\n3\n4\n5\n\n\n接着设置新节点的 ramdom 指针。\n\n然后遍历链表，修改旧节点和新节点的指向，将旧节点指向下一个旧节点，而新节点指向下一个新节点。\n\n最后返回第一个新节点即可。\n\n\n# Python3\n\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Node') -> 'Node':\n        if head is None:\n            return None\n\n        cur = head\n        while cur:\n            node = Node(cur.val, cur.next)\n            cur.next = node\n            cur = node.next\n        \n        cur = head\n        while cur:\n            cur.next.random = None if cur.random is None else cur.random.next\n            cur = cur.next.next\n        \n        copy = head.next\n        cur = head\n        while cur:\n            next = cur.next\n            cur.next = next.next\n            next.next = None if next.next is None else next.next.next\n            cur = cur.next\n        return copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# Java\n\n/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n\n        Node cur = head;\n        while (cur != null) {\n            Node node = new Node(cur.val);\n            node.next = cur.next;\n            cur.next = node;\n            cur = node.next;\n        }\n\n        cur = head;\n        while (cur != null) {\n            cur.next.random = cur.random == null ? null : cur.random.next;\n            cur = cur.next.next;\n        }\n\n        Node copy = head.next;\n        cur = head;\n        while (cur != null) {\n            Node next = cur.next;\n            cur.next = next.next;\n            next.next = next.next == null ? null : next.next.next;\n            cur = cur.next;\n        }\n        return copy;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# C++\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if (!head) {\n            return nullptr;\n        }\n        Node* cur = head;\n        while (cur) {\n            Node* node = new Node(cur->val);\n            node->next = cur->next;\n            cur->next = node;\n            cur = node->next;\n        }\n\n        cur = head;\n        while (cur) {\n            cur->next->random = cur->random ? cur->random->next : nullptr;\n            cur = cur->next->next;\n        }\n\n        Node* copy = head->next;\n        cur = head;\n        while (cur) {\n            Node* next = cur->next;\n            cur->next = next->next;\n            next->next = next->next ? next->next->next : nullptr;\n            cur = cur->next;\n        }\n        return copy;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# C#\n\n/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public Node next;\n    public Node random;\n    \n    public Node(int _val) {\n        val = _val;\n        next = null;\n        random = null;\n    }\n}\n*/\n\npublic class Solution {\n    public Node CopyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n        \n        Node cur = head;\n        while (cur != null) {\n            Node node = new Node(cur.val);\n            node.next = cur.next;\n            cur.next = node;\n            cur = node.next;\n        }\n\n        cur = head;\n        while (cur != null) {\n            cur.next.random = cur.random == null ? null : cur.random.next;\n            cur = cur.next.next;\n        }\n\n        Node copy = head.next;\n        cur = head;\n        while (cur != null) {\n            Node next = cur.next;\n            cur.next = next.next;\n            next.next = next.next == null ? null : next.next.next;\n            cur = cur.next;\n        }\n        return copy;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# Go\n\n/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Next *Node\n *     Random *Node\n * }\n */\n\nfunc copyRandomList(head *Node) *Node {\n    if head == nil {\n        return nil\n    }\n\n    cur := head\n    for cur != nil {\n        node := &Node{\n            Val: cur.Val,\n            Next: cur.Next,\n            Random: nil,\n        }\n        cur.Next = node\n        cur = node.Next\n    }\n\n    cur = head\n    for cur != nil {\n        if cur.Random == nil {\n            cur.Next.Random = nil\n        } else {\n            cur.Next.Random = cur.Random.Next\n        }\n        cur = cur.Next.Next\n    }\n\n    copy := head.Next\n    cur = head\n    for cur != nil {\n        next := cur.Next\n        cur.Next = next.Next\n        if (next.Next == nil) {\n            next.Next = nil\n        } else {\n            next.Next = next.Next.Next\n        }\n        cur = cur.Next\n    }\n    return copy\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# JavaScript\n\n/**\n * // Definition for a Node.\n * function Node(val, next, random) {\n *    this.val = val;\n *    this.next = next;\n *    this.random = random;\n * };\n */\n\n/**\n * @param {Node} head\n * @return {Node}\n */\nvar copyRandomList = function(head) {\n    if (head == null) {\n        return null;\n    }\n    let cur = head;\n    while (cur != null) {\n        let node = new Node(cur.val, cur.next);\n        cur.next = node;\n        cur = node.next;\n    }\n\n    cur = head;\n    while (cur != null) {\n        cur.next.random = cur.random == null ? null : cur.random.next;\n        cur = cur.next.next;\n    }\n\n    let copy = head.next;\n    cur = head;\n    while (cur != null) {\n        let next = cur.next;\n        cur.next = next.next;\n        next.next = next.next == null ? null : next.next.next;\n        cur = cur.next;\n    }\n    return copy;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 138. 复制带随机指针的链表\n\nenglish version\n\n\n# 题目描述\n\n给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\n\n构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n\n例如，如果原链表中有 x 和 y 两个节点，其中 x.random --\x3e y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --\x3e y 。\n\n返回复制链表的头节点。\n\n用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：\n\n * val：一个表示 node.val 的整数。\n * random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。\n\n你的代码 只 接受原链表的头节点 head 作为传入参数。\n\n \n\n示例 1：\n\n\n\n\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n示例 2：\n\n\n\n\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n\n\n示例 3：\n\n\n\n\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n\n\n示例 4：\n\n\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n\n\n \n\n提示：\n\n * 0 <= n <= 1000\n * -10000 <= node.val <= 10000\n * node.random 为空（null）或指向链表中的节点。\n\n\n# 解法\n\n首先，遍历链表，完成对每个旧节点的复制。\n\na -> b -> c -> d -> null\n\n=>\n\na -> a1 -> b -> b1 -> c -> c1 -> d -> d1 -> null\n\n\n1\n2\n3\n4\n5\n\n\n接着设置新节点的 ramdom 指针。\n\n然后遍历链表，修改旧节点和新节点的指向，将旧节点指向下一个旧节点，而新节点指向下一个新节点。\n\n最后返回第一个新节点即可。\n\n\n# python3\n\n\"\"\"\n# definition for a node.\nclass node:\n    def __init__(self, x: int, next: 'node' = none, random: 'node' = none):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass solution:\n    def copyrandomlist(self, head: 'node') -> 'node':\n        if head is none:\n            return none\n\n        cur = head\n        while cur:\n            node = node(cur.val, cur.next)\n            cur.next = node\n            cur = node.next\n        \n        cur = head\n        while cur:\n            cur.next.random = none if cur.random is none else cur.random.next\n            cur = cur.next.next\n        \n        copy = head.next\n        cur = head\n        while cur:\n            next = cur.next\n            cur.next = next.next\n            next.next = none if next.next is none else next.next.next\n            cur = cur.next\n        return copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# java\n\n/*\n// definition for a node.\nclass node {\n    int val;\n    node next;\n    node random;\n\n    public node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass solution {\n    public node copyrandomlist(node head) {\n        if (head == null) {\n            return null;\n        }\n\n        node cur = head;\n        while (cur != null) {\n            node node = new node(cur.val);\n            node.next = cur.next;\n            cur.next = node;\n            cur = node.next;\n        }\n\n        cur = head;\n        while (cur != null) {\n            cur.next.random = cur.random == null ? null : cur.random.next;\n            cur = cur.next.next;\n        }\n\n        node copy = head.next;\n        cur = head;\n        while (cur != null) {\n            node next = cur.next;\n            cur.next = next.next;\n            next.next = next.next == null ? null : next.next.next;\n            cur = cur.next;\n        }\n        return copy;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# c++\n\n/*\n// definition for a node.\nclass node {\npublic:\n    int val;\n    node* next;\n    node* random;\n    \n    node(int _val) {\n        val = _val;\n        next = null;\n        random = null;\n    }\n};\n*/\n\nclass solution {\npublic:\n    node* copyrandomlist(node* head) {\n        if (!head) {\n            return nullptr;\n        }\n        node* cur = head;\n        while (cur) {\n            node* node = new node(cur->val);\n            node->next = cur->next;\n            cur->next = node;\n            cur = node->next;\n        }\n\n        cur = head;\n        while (cur) {\n            cur->next->random = cur->random ? cur->random->next : nullptr;\n            cur = cur->next->next;\n        }\n\n        node* copy = head->next;\n        cur = head;\n        while (cur) {\n            node* next = cur->next;\n            cur->next = next->next;\n            next->next = next->next ? next->next->next : nullptr;\n            cur = cur->next;\n        }\n        return copy;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# c#\n\n/*\n// definition for a node.\npublic class node {\n    public int val;\n    public node next;\n    public node random;\n    \n    public node(int _val) {\n        val = _val;\n        next = null;\n        random = null;\n    }\n}\n*/\n\npublic class solution {\n    public node copyrandomlist(node head) {\n        if (head == null) {\n            return null;\n        }\n        \n        node cur = head;\n        while (cur != null) {\n            node node = new node(cur.val);\n            node.next = cur.next;\n            cur.next = node;\n            cur = node.next;\n        }\n\n        cur = head;\n        while (cur != null) {\n            cur.next.random = cur.random == null ? null : cur.random.next;\n            cur = cur.next.next;\n        }\n\n        node copy = head.next;\n        cur = head;\n        while (cur != null) {\n            node next = cur.next;\n            cur.next = next.next;\n            next.next = next.next == null ? null : next.next.next;\n            cur = cur.next;\n        }\n        return copy;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# go\n\n/**\n * definition for a node.\n * type node struct {\n *     val int\n *     next *node\n *     random *node\n * }\n */\n\nfunc copyrandomlist(head *node) *node {\n    if head == nil {\n        return nil\n    }\n\n    cur := head\n    for cur != nil {\n        node := &node{\n            val: cur.val,\n            next: cur.next,\n            random: nil,\n        }\n        cur.next = node\n        cur = node.next\n    }\n\n    cur = head\n    for cur != nil {\n        if cur.random == nil {\n            cur.next.random = nil\n        } else {\n            cur.next.random = cur.random.next\n        }\n        cur = cur.next.next\n    }\n\n    copy := head.next\n    cur = head\n    for cur != nil {\n        next := cur.next\n        cur.next = next.next\n        if (next.next == nil) {\n            next.next = nil\n        } else {\n            next.next = next.next.next\n        }\n        cur = cur.next\n    }\n    return copy\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# javascript\n\n/**\n * // definition for a node.\n * function node(val, next, random) {\n *    this.val = val;\n *    this.next = next;\n *    this.random = random;\n * };\n */\n\n/**\n * @param {node} head\n * @return {node}\n */\nvar copyrandomlist = function(head) {\n    if (head == null) {\n        return null;\n    }\n    let cur = head;\n    while (cur != null) {\n        let node = new node(cur.val, cur.next);\n        cur.next = node;\n        cur = node.next;\n    }\n\n    cur = head;\n    while (cur != null) {\n        cur.next.random = cur.random == null ? null : cur.random.next;\n        cur = cur.next.next;\n    }\n\n    let copy = head.next;\n    cur = head;\n    while (cur != null) {\n        let next = cur.next;\n        cur.next = next.next;\n        next.next = next.next == null ? null : next.next.next;\n        cur = cur.next;\n    }\n    return copy;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode139 Word Break-zh",frontmatter:{title:"leetcode139 Word Break-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d40856/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode139 Word Break-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10139.leetcode139%20Word%20Break-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode139 Word Break-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10139.leetcode139%20Word%20Break-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode139 Word Break-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10139.leetcode139%20Word%20Break-zh.html",relativePath:"01.算法/24.leetcode/10139.leetcode139 Word Break-zh.md",key:"v-10d6ed72",path:"/p/d40856/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:505},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:572},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:985},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1547},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2191},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:2579},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:542}],headersStr:"题目描述 解法 Python3 Java C++ Go C# ...",content:'# 139. 单词拆分\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n说明：\n\n * 拆分时可以重复使用字典中的单词。\n * 你可以假设字典中没有重复的单词。\n\n示例 1：\n\n输入: s = "leetcode", wordDict = ["leet", "code"]\n输出: true\n解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。\n\n\n示例 2：\n\n输入: s = "applepenapple", wordDict = ["apple", "pen"]\n输出: true\n解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。\n     注意你可以重复使用字典中的单词。\n\n\n示例 3：\n\n输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]\n输出: false\n\n\n\n# 解法\n\n动态规划法。\n\ndp[i] 表示前 i 个字符组成的字符串 s[0...i-1] 能否拆分成若干个字典中出现的单词。\n\n\n# Python3\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        words = set(wordDict)\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in words:\n                    dp[i] = True\n                    break\n        return dp[n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> words = new HashSet<>(wordDict);\n        int n = s.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (dp[j] && words.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# C++\n\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> words;\n        for (auto word : wordDict) {\n            words.insert(word);\n        }\n        int n = s.size();\n        vector<bool> dp(n + 1, false);\n        dp[0] = true;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (dp[j] && words.find(s.substr(j, i - j)) != words.end()) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Go\n\nfunc wordBreak(s string, wordDict []string) bool {\n\twords := make(map[string]bool)\n\tfor _, word := range wordDict {\n\t\twords[word] = true\n\t}\n\tn := len(s)\n\tdp := make([]bool, n+1)\n\tdp[0] = true\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tif dp[j] && words[s[j:i]] {\n\t\t\t\tdp[i] = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# C#\n\npublic class Solution {\n    public bool WordBreak(string s, IList<string> wordDict) {\n        var words = new HashSet<string>(wordDict);\n        int n = s.Length;\n        var dp = new bool[n + 1];\n        dp[0] = true;\n        for (int i = 1; i <= n; ++i)\n        {\n            for (int j = 0; j < i; ++j)\n            {\n                if (dp[j] && words.Contains(s.Substring(j, i - j)))\n                {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 139. 单词拆分\n\nenglish version\n\n\n# 题目描述\n\n给定一个非空字符串 s 和一个包含非空单词的列表 worddict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n说明：\n\n * 拆分时可以重复使用字典中的单词。\n * 你可以假设字典中没有重复的单词。\n\n示例 1：\n\n输入: s = "leetcode", worddict = ["leet", "code"]\n输出: true\n解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。\n\n\n示例 2：\n\n输入: s = "applepenapple", worddict = ["apple", "pen"]\n输出: true\n解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。\n     注意你可以重复使用字典中的单词。\n\n\n示例 3：\n\n输入: s = "catsandog", worddict = ["cats", "dog", "sand", "and", "cat"]\n输出: false\n\n\n\n# 解法\n\n动态规划法。\n\ndp[i] 表示前 i 个字符组成的字符串 s[0...i-1] 能否拆分成若干个字典中出现的单词。\n\n\n# python3\n\nclass solution:\n    def wordbreak(self, s: str, worddict: list[str]) -> bool:\n        words = set(worddict)\n        n = len(s)\n        dp = [false] * (n + 1)\n        dp[0] = true\n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in words:\n                    dp[i] = true\n                    break\n        return dp[n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public boolean wordbreak(string s, list<string> worddict) {\n        set<string> words = new hashset<>(worddict);\n        int n = s.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (dp[j] && words.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# c++\n\nclass solution {\npublic:\n    bool wordbreak(string s, vector<string>& worddict) {\n        unordered_set<string> words;\n        for (auto word : worddict) {\n            words.insert(word);\n        }\n        int n = s.size();\n        vector<bool> dp(n + 1, false);\n        dp[0] = true;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (dp[j] && words.find(s.substr(j, i - j)) != words.end()) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# go\n\nfunc wordbreak(s string, worddict []string) bool {\n\twords := make(map[string]bool)\n\tfor _, word := range worddict {\n\t\twords[word] = true\n\t}\n\tn := len(s)\n\tdp := make([]bool, n+1)\n\tdp[0] = true\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tif dp[j] && words[s[j:i]] {\n\t\t\t\tdp[i] = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# c#\n\npublic class solution {\n    public bool wordbreak(string s, ilist<string> worddict) {\n        var words = new hashset<string>(worddict);\n        int n = s.length;\n        var dp = new bool[n + 1];\n        dp[0] = true;\n        for (int i = 1; i <= n; ++i)\n        {\n            for (int j = 0; j < i; ++j)\n            {\n                if (dp[j] && words.contains(s.substring(j, i - j)))\n                {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode140 Word Break II-zh",frontmatter:{title:"leetcode140 Word Break II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/ccca7c/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode140 Word Break II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10140.leetcode140%20Word%20Break%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode140 Word Break II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10140.leetcode140%20Word%20Break%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode140 Word Break II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10140.leetcode140%20Word%20Break%20II-zh.html",relativePath:"01.算法/24.leetcode/10140.leetcode140 Word Break II-zh.md",key:"v-5879d1de",path:"/p/ccca7c/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:583},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:590},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:609},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:625}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 140. 单词拆分 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。\n\n说明：\n\n * 分隔时可以重复使用字典中的单词。\n * 你可以假设字典中没有重复的单词。\n\n示例 1：\n\n输入:\ns = "catsanddog"\nwordDict = ["cat", "cats", "and", "sand", "dog"]\n输出:\n[\n  "cats and dog",\n  "cat sand dog"\n]\n\n\n示例 2：\n\n输入:\ns = "pineapplepenapple"\nwordDict = ["apple", "pen", "applepen", "pine", "pineapple"]\n输出:\n[\n  "pine apple pen apple",\n  "pineapple pen apple",\n  "pine applepen apple"\n]\n解释: 注意你可以重复使用字典中的单词。\n\n\n示例 3：\n\n输入:\ns = "catsandog"\nwordDict = ["cats", "dog", "sand", "and", "cat"]\n输出:\n[]\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 140. 单词拆分 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 worddict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。\n\n说明：\n\n * 分隔时可以重复使用字典中的单词。\n * 你可以假设字典中没有重复的单词。\n\n示例 1：\n\n输入:\ns = "catsanddog"\nworddict = ["cat", "cats", "and", "sand", "dog"]\n输出:\n[\n  "cats and dog",\n  "cat sand dog"\n]\n\n\n示例 2：\n\n输入:\ns = "pineapplepenapple"\nworddict = ["apple", "pen", "applepen", "pine", "pineapple"]\n输出:\n[\n  "pine apple pen apple",\n  "pineapple pen apple",\n  "pine applepen apple"\n]\n解释: 注意你可以重复使用字典中的单词。\n\n\n示例 3：\n\n输入:\ns = "catsandog"\nworddict = ["cats", "dog", "sand", "and", "cat"]\n输出:\n[]\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode141 Linked List Cycle-zh",frontmatter:{title:"leetcode141 Linked List Cycle-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/f2a66f/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0141.Linked%20List%20Cycle/images/circularlinkedlist.png"},{name:"twitter:title",content:"leetcode141 Linked List Cycle-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0141.Linked%20List%20Cycle/images/circularlinkedlist.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10141.leetcode141%20Linked%20List%20Cycle-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode141 Linked List Cycle-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0141.Linked%20List%20Cycle/images/circularlinkedlist.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10141.leetcode141%20Linked%20List%20Cycle-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode141 Linked List Cycle-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0141.Linked%20List%20Cycle/images/circularlinkedlist.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10141.leetcode141%20Linked%20List%20Cycle-zh.html",relativePath:"01.算法/24.leetcode/10141.leetcode141 Linked List Cycle-zh.md",key:"v-7a154764",path:"/p/f2a66f/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:563},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:659},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1097},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1724},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2299},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2817},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3224}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go ...",content:"# 141. 环形链表\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n \n\n进阶：\n\n你能用 O(1)（即，常量）内存解决此问题吗？\n\n \n\n示例 1：\n\n\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n \n\n提示：\n\n * 链表中节点的数目范围是 [0, 104]\n * -105 <= Node.val <= 105\n * pos 为 -1 或者链表中的一个 有效索引 。\n\n\n# 解法\n\n定义快慢指针 slow、fast，初始指向 head。\n\n快指针每次走两步，慢指针每次走一步，不断循环。当相遇时，说明链表存在环。如果循环结束依然没有相遇，说明链表不存在环。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        slow = fast = head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            if slow == fast:\n                return True\n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar hasCycle = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc hasCycle(head *ListNode) bool {\n    slow, fast := head, head\n    for fast != nil && fast.Next != nil {\n        slow, fast = slow.Next, fast.Next.Next\n        if slow == fast {\n            return true\n        }\n    }\n    return false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 141. 环形链表\n\nenglish version\n\n\n# 题目描述\n\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n \n\n进阶：\n\n你能用 o(1)（即，常量）内存解决此问题吗？\n\n \n\n示例 1：\n\n\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n \n\n提示：\n\n * 链表中节点的数目范围是 [0, 104]\n * -105 <= node.val <= 105\n * pos 为 -1 或者链表中的一个 有效索引 。\n\n\n# 解法\n\n定义快慢指针 slow、fast，初始指向 head。\n\n快指针每次走两步，慢指针每次走一步，不断循环。当相遇时，说明链表存在环。如果循环结束依然没有相遇，说明链表不存在环。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def hascycle(self, head: listnode) -> bool:\n        slow = fast = head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            if slow == fast:\n                return true\n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public boolean hascycle(listnode head) {\n        listnode slow = head;\n        listnode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode(int x) : val(x), next(null) {}\n * };\n */\nclass solution {\npublic:\n    bool hascycle(listnode *head) {\n        listnode* slow = head;\n        listnode* fast = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {listnode} head\n * @return {boolean}\n */\nvar hascycle = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\nfunc hascycle(head *listnode) bool {\n    slow, fast := head, head\n    for fast != nil && fast.next != nil {\n        slow, fast = slow.next, fast.next.next\n        if slow == fast {\n            return true\n        }\n    }\n    return false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode142 Linked List Cycle II-zh",frontmatter:{title:"leetcode142 Linked List Cycle II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/1394c2/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/leetcode142-linked-list-cycle-ii.png"},{name:"twitter:title",content:"leetcode142 Linked List Cycle II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/leetcode142-linked-list-cycle-ii.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10142.leetcode142%20Linked%20List%20Cycle%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode142 Linked List Cycle II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/leetcode142-linked-list-cycle-ii.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10142.leetcode142%20Linked%20List%20Cycle%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode142 Linked List Cycle II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/dbdgs/dbdgs.github.io/docs/.vuepress/public/img/leetcode142-linked-list-cycle-ii.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10142.leetcode142%20Linked%20List%20Cycle%20II-zh.html",relativePath:"01.算法/24.leetcode/10142.leetcode142 Linked List Cycle II-zh.md",key:"v-8754a666",path:"/p/1394c2/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:552},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:941},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1553},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2369},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:3160},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:3850},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4406}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go ...",content:"# 142. 环形链表 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\n\n说明：不允许修改给定的链表。\n\n进阶：\n\n * 你是否可以使用 O(1) 空间解决此题？\n\n \n\n示例 1：\n\n\n\n\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n\n\n\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n\n\n\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n\n\n \n\n提示：\n\n * 链表中节点的数目范围在范围 [0, 104] 内\n * -105 <= Node.val <= 105\n * pos 的值为 -1 或者链表中的一个有效索引\n\n\n# 解法\n\n先利用快慢指针判断链表是否有环，没有环则直接返回 null。\n\n若链表有环，我们分析快慢相遇时走过的距离。\n\n对于慢指针（每次走 1 步），走过的距离为 S=X+Y ①；快指针（每次走 2 步）走过的距离为 2S=X+Y+N(Y+Z) ②。如下图所示，其中 N 表示快指针与慢指针相遇时在环中所走过的圈数，而我们要求的环入口，也即是 X 的距离：\n\n\n\n我们根据式子 ①②，得出 X+Y=N(Y+Z) => X=(N-1)(Y+Z)+Z。\n\n当 N=1(快指针在环中走了一圈与慢指针相遇) 时，X=(1-1)(Y+Z)+Z，即 X=Z。此时只要定义一个 p 指针指向头节点，然后慢指针与 p 开始同时走，当慢指针与 p 相遇时，也就到达了环入口，直接返回 p 即可。\n\n当 N>1时，也是同样的，说明慢指针除了走 Z 步，还需要绕 N-1 圈才能与 p 相遇。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        has_cycle = False\n        while not has_cycle and fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            has_cycle = slow == fast\n        if not has_cycle:\n            return None\n        p = head\n        while p != slow:\n            p, slow = p.next, slow.next\n        return p\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        boolean hasCycle = false;\n        while (!hasCycle && fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            hasCycle = slow == fast;\n        }\n        if (!hasCycle) {\n            return null;\n        }\n        ListNode p = head;\n        while (p != slow) {\n            p = p.next;\n            slow = slow.next;\n        }\n        return p;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        bool hasCycle = false;\n        while (!hasCycle && fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            hasCycle = slow == fast;\n        }\n        if (!hasCycle) {\n            return nullptr;\n        }\n        ListNode* p = head;\n        while (p != slow) {\n            p = p->next;\n            slow = slow->next;\n        }\n        return p;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    let slow = head;\n    let fast = head;\n    let hasCycle = false;\n    while (!hasCycle && fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        hasCycle = slow == fast;\n    }\n    if (!hasCycle) {\n        return null;\n    }\n    let p = head;\n    while (p != slow) {\n        p = p.next;\n        slow = slow.next;\n    }\n    return p;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    slow, fast := head, head\n    hasCycle := false\n    for !hasCycle && fast != nil && fast.Next != nil {\n        slow, fast = slow.Next, fast.Next.Next\n        hasCycle = slow == fast\n    }\n    if !hasCycle {\n        return nil\n    }\n    p := head\n    for p != slow {\n        p, slow = p.Next, slow.Next\n    }\n    return p\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 142. 环形链表 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\n\n说明：不允许修改给定的链表。\n\n进阶：\n\n * 你是否可以使用 o(1) 空间解决此题？\n\n \n\n示例 1：\n\n\n\n\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n\n\n\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n\n\n\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n\n\n \n\n提示：\n\n * 链表中节点的数目范围在范围 [0, 104] 内\n * -105 <= node.val <= 105\n * pos 的值为 -1 或者链表中的一个有效索引\n\n\n# 解法\n\n先利用快慢指针判断链表是否有环，没有环则直接返回 null。\n\n若链表有环，我们分析快慢相遇时走过的距离。\n\n对于慢指针（每次走 1 步），走过的距离为 s=x+y ①；快指针（每次走 2 步）走过的距离为 2s=x+y+n(y+z) ②。如下图所示，其中 n 表示快指针与慢指针相遇时在环中所走过的圈数，而我们要求的环入口，也即是 x 的距离：\n\n\n\n我们根据式子 ①②，得出 x+y=n(y+z) => x=(n-1)(y+z)+z。\n\n当 n=1(快指针在环中走了一圈与慢指针相遇) 时，x=(1-1)(y+z)+z，即 x=z。此时只要定义一个 p 指针指向头节点，然后慢指针与 p 开始同时走，当慢指针与 p 相遇时，也就到达了环入口，直接返回 p 即可。\n\n当 n>1时，也是同样的，说明慢指针除了走 z 步，还需要绕 n-1 圈才能与 p 相遇。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def detectcycle(self, head: listnode) -> listnode:\n        slow = fast = head\n        has_cycle = false\n        while not has_cycle and fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            has_cycle = slow == fast\n        if not has_cycle:\n            return none\n        p = head\n        while p != slow:\n            p, slow = p.next, slow.next\n        return p\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public listnode detectcycle(listnode head) {\n        listnode slow = head, fast = head;\n        boolean hascycle = false;\n        while (!hascycle && fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            hascycle = slow == fast;\n        }\n        if (!hascycle) {\n            return null;\n        }\n        listnode p = head;\n        while (p != slow) {\n            p = p.next;\n            slow = slow.next;\n        }\n        return p;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode(int x) : val(x), next(null) {}\n * };\n */\nclass solution {\npublic:\n    listnode *detectcycle(listnode *head) {\n        listnode* slow = head;\n        listnode* fast = head;\n        bool hascycle = false;\n        while (!hascycle && fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            hascycle = slow == fast;\n        }\n        if (!hascycle) {\n            return nullptr;\n        }\n        listnode* p = head;\n        while (p != slow) {\n            p = p->next;\n            slow = slow->next;\n        }\n        return p;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {listnode} head\n * @return {listnode}\n */\nvar detectcycle = function(head) {\n    let slow = head;\n    let fast = head;\n    let hascycle = false;\n    while (!hascycle && fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        hascycle = slow == fast;\n    }\n    if (!hascycle) {\n        return null;\n    }\n    let p = head;\n    while (p != slow) {\n        p = p.next;\n        slow = slow.next;\n    }\n    return p;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\nfunc detectcycle(head *listnode) *listnode {\n    slow, fast := head, head\n    hascycle := false\n    for !hascycle && fast != nil && fast.next != nil {\n        slow, fast = slow.next, fast.next.next\n        hascycle = slow == fast\n    }\n    if !hascycle {\n        return nil\n    }\n    p := head\n    for p != slow {\n        p, slow = p.next, slow.next\n    }\n    return p\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode143 Reorder List-zh",frontmatter:{title:"leetcode143 Reorder List-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/820427/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode143 Reorder List-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10143.leetcode143%20Reorder%20List-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode143 Reorder List-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10143.leetcode143%20Reorder%20List-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode143 Reorder List-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10143.leetcode143%20Reorder%20List-zh.html",relativePath:"01.算法/24.leetcode/10143.leetcode143 Reorder List-zh.md",key:"v-0f188b26",path:"/p/820427/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:231},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:294},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1340},{level:3,title:"C#",slug:"c",normalizedTitle:"c#",charIndex:2518},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:3739},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:4497},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:5499}],headersStr:"题目描述 解法 Python3 Java C# Go JavaScript ...",content:'# 143. 重排链表\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个单链表 L：L0→L1→…→Ln-1→Ln ，\n将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n示例 1:\n\n给定链表 1->2->3->4, 重新排列为 1->4->2->3.\n\n示例 2:\n\n给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.\n\n\n# 解法\n\n先通过快慢指针找到链表中点，将链表划分为左右两部分。之后反转右半部分的链表，然后将左右两个链接依次连接即可。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reorderList(self, head: ListNode) -> None:\n        """\n        Do not return anything, modify head in-place instead.\n        """\n        if head is None or head.next is None:\n            return\n\n        # 快慢指针找到链表中点\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        \n        # cur 指向右半部分链表\n        cur = slow.next\n        slow.next = None\n\n        # 反转右半部分链表\n        pre = None\n        while cur:\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        cur = head\n        # 此时 cur, pre 分别指向链表左右两半的第一个节点\n\n        while pre:\n            t = pre.next\n            pre.next = cur.next\n            cur.next = pre\n            cur, pre = pre.next, t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null) {\n            return;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        ListNode cur = slow.next;\n        slow.next = null;\n\n        ListNode pre = null;\n        while (cur != null) {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        cur = head;\n\n        while (pre != null) {\n            ListNode t = pre.next;\n            pre.next = cur.next;\n            cur.next = pre;\n            cur = pre.next;\n            pre = t;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# C#\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public void ReorderList(ListNode head) {\n        if (head == null || head.next == null)\n        {\n            return;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        ListNode cur = slow.next;\n        slow.next = null;\n\n        ListNode pre = null;\n        while (cur != null)\n        {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        cur = head;\n\n        while (pre != null)\n        {\n            ListNode t = pre.next;\n            pre.next = cur.next;\n            cur.next = pre;\n            cur = pre.next;\n            pre = t;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n func reorderList(head *ListNode)  {\n    if head == nil || head.Next == nil {\n        return\n    }\n    slow, fast := head, head.Next\n    for fast != nil && fast.Next != nil {\n        slow, fast = slow.Next, fast.Next.Next\n    }\n\n    cur := slow.Next\n    slow.Next = nil\n\n    var pre *ListNode\n    for cur != nil {\n        t := cur.Next\n        cur.Next = pre\n        pre, cur = cur, t\n    }\n    cur = head\n\n    for pre != nil {\n        t := pre.Next\n        pre.Next = cur.Next\n        cur.Next = pre\n        cur, pre = pre.Next, t\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {void} Do not return anything, modify head in-place instead.\n */\nvar reorderList = function(head) {\n    if (!head || !head.next) {\n        return;\n    }\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    let cur = slow.next;\n    slow.next = null;\n\n    let pre = null;\n    while (cur) {\n        const t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    cur = head;\n\n    while (pre) {\n        const t = pre.next;\n        pre.next = cur.next;\n        cur.next = pre;\n        cur = pre.next;\n        pre = t;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 143. 重排链表\n\nenglish version\n\n\n# 题目描述\n\n给定一个单链表 l：l0→l1→…→ln-1→ln ，\n将其重新排列后变为： l0→ln→l1→ln-1→l2→ln-2→…\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n示例 1:\n\n给定链表 1->2->3->4, 重新排列为 1->4->2->3.\n\n示例 2:\n\n给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.\n\n\n# 解法\n\n先通过快慢指针找到链表中点，将链表划分为左右两部分。之后反转右半部分的链表，然后将左右两个链接依次连接即可。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def reorderlist(self, head: listnode) -> none:\n        """\n        do not return anything, modify head in-place instead.\n        """\n        if head is none or head.next is none:\n            return\n\n        # 快慢指针找到链表中点\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        \n        # cur 指向右半部分链表\n        cur = slow.next\n        slow.next = none\n\n        # 反转右半部分链表\n        pre = none\n        while cur:\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        cur = head\n        # 此时 cur, pre 分别指向链表左右两半的第一个节点\n\n        while pre:\n            t = pre.next\n            pre.next = cur.next\n            cur.next = pre\n            cur, pre = pre.next, t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public void reorderlist(listnode head) {\n        if (head == null || head.next == null) {\n            return;\n        }\n        listnode slow = head;\n        listnode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        listnode cur = slow.next;\n        slow.next = null;\n\n        listnode pre = null;\n        while (cur != null) {\n            listnode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        cur = head;\n\n        while (pre != null) {\n            listnode t = pre.next;\n            pre.next = cur.next;\n            cur.next = pre;\n            cur = pre.next;\n            pre = t;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# c#\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     public int val;\n *     public listnode next;\n *     public listnode(int val=0, listnode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class solution {\n    public void reorderlist(listnode head) {\n        if (head == null || head.next == null)\n        {\n            return;\n        }\n        listnode slow = head;\n        listnode fast = head.next;\n        while (fast != null && fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        listnode cur = slow.next;\n        slow.next = null;\n\n        listnode pre = null;\n        while (cur != null)\n        {\n            listnode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        cur = head;\n\n        while (pre != null)\n        {\n            listnode t = pre.next;\n            pre.next = cur.next;\n            cur.next = pre;\n            cur = pre.next;\n            pre = t;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\n func reorderlist(head *listnode)  {\n    if head == nil || head.next == nil {\n        return\n    }\n    slow, fast := head, head.next\n    for fast != nil && fast.next != nil {\n        slow, fast = slow.next, fast.next.next\n    }\n\n    cur := slow.next\n    slow.next = nil\n\n    var pre *listnode\n    for cur != nil {\n        t := cur.next\n        cur.next = pre\n        pre, cur = cur, t\n    }\n    cur = head\n\n    for pre != nil {\n        t := pre.next\n        pre.next = cur.next\n        cur.next = pre\n        cur, pre = pre.next, t\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {void} do not return anything, modify head in-place instead.\n */\nvar reorderlist = function(head) {\n    if (!head || !head.next) {\n        return;\n    }\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    let cur = slow.next;\n    slow.next = null;\n\n    let pre = null;\n    while (cur) {\n        const t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    cur = head;\n\n    while (pre) {\n        const t = pre.next;\n        pre.next = cur.next;\n        cur.next = pre;\n        cur = pre.next;\n        pre = t;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode144 Binary Tree Preorder Traversal-zh",frontmatter:{title:"leetcode144 Binary Tree Preorder Traversal-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/89277c/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0144.Binary%20Tree%20Preorder%20Traversal/images/inorder_1.jpg"},{name:"twitter:title",content:"leetcode144 Binary Tree Preorder Traversal-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0144.Binary%20Tree%20Preorder%20Traversal/images/inorder_1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10144.leetcode144%20Binary%20Tree%20Preorder%20Traversal-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode144 Binary Tree Preorder Traversal-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0144.Binary%20Tree%20Preorder%20Traversal/images/inorder_1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10144.leetcode144%20Binary%20Tree%20Preorder%20Traversal-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode144 Binary Tree Preorder Traversal-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0144.Binary%20Tree%20Preorder%20Traversal/images/inorder_1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10144.leetcode144%20Binary%20Tree%20Preorder%20Traversal-zh.html",relativePath:"01.算法/24.leetcode/10144.leetcode144 Binary Tree Preorder Traversal-zh.md",key:"v-0246fc47",path:"/p/89277c/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:349},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:493},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1677},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:3580},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4480}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 144. 二叉树的前序遍历\n\nEnglish Version\n\n\n# 题目描述\n\n给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n\n \n\n示例 1：\n\n\n输入：root = [1,null,2,3]\n输出：[1,2,3]\n\n\n示例 2：\n\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [1]\n输出：[1]\n\n\n示例 4：\n\n\n输入：root = [1,2]\n输出：[1,2]\n\n\n示例 5：\n\n\n输入：root = [1,null,2]\n输出：[1,2]\n\n\n \n\n提示：\n\n * 树中节点数目在范围 [0, 100] 内\n * -100 <= Node.val <= 100\n\n \n\n进阶：递归算法很简单，你可以通过迭代算法完成吗？\n\n\n# 解法\n\n递归遍历或利用栈实现非递归遍历。\n\n非递归的思路如下：\n\n 1. 定义一个栈，先将根节点压入栈\n 2. 若栈不为空，每次从栈中弹出一个节点\n 3. 处理该节点\n 4. 先把节点右孩子压入栈，接着把节点左孩子压入栈（如果有孩子节点）\n 5. 重复 2-4\n 6. 返回结果\n\n\n# Python3\n\n递归：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\n        def preorder(root):\n            if root:\n                res.append(root.val)\n                preorder(root.left)\n                preorder(root.right)\n        res = []\n        preorder(root)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n非递归：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\n        if root is None:\n            return []\n        res = []\n        s = [root]\n        while s:\n            node = s.pop()\n            res.append(node.val)\n            if node.right:\n                s.append(node.right)\n            if node.left:\n                s.append(node.left)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java\n\n递归：\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    private List<Integer> res;\n\n    public List<Integer> preorderTraversal(TreeNode root) {\n        res = new ArrayList<>();\n        preorder(root);\n        return res;\n    }\n\n    private void preorder(TreeNode root) {\n        if (root != null) {\n            res.add(root.val);\n            preorder(root.left);\n            preorder(root.right);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n非递归：\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        List<Integer> res = new ArrayList<>();\n        Deque<TreeNode> s = new ArrayDeque<>();\n        s.push(root);\n        while (!s.isEmpty()) {\n            TreeNode node = s.pop();\n            res.add(node.val);\n            if (node.right != null) {\n                s.push(node.right);\n            }\n            if (node.left != null) {\n                s.push(node.left);\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# C++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> res;\n        if (root == nullptr) return res;\n        stack<TreeNode*> s;\n        s.push(root);\n        while (!s.empty()) {\n            TreeNode *node = s.top();\n            s.pop();\n            res.push_back(node->val);\n            if (node->right) s.push(node->right);\n            if (node->left) s.push(node->left);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 144. 二叉树的前序遍历\n\nenglish version\n\n\n# 题目描述\n\n给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n\n \n\n示例 1：\n\n\n输入：root = [1,null,2,3]\n输出：[1,2,3]\n\n\n示例 2：\n\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [1]\n输出：[1]\n\n\n示例 4：\n\n\n输入：root = [1,2]\n输出：[1,2]\n\n\n示例 5：\n\n\n输入：root = [1,null,2]\n输出：[1,2]\n\n\n \n\n提示：\n\n * 树中节点数目在范围 [0, 100] 内\n * -100 <= node.val <= 100\n\n \n\n进阶：递归算法很简单，你可以通过迭代算法完成吗？\n\n\n# 解法\n\n递归遍历或利用栈实现非递归遍历。\n\n非递归的思路如下：\n\n 1. 定义一个栈，先将根节点压入栈\n 2. 若栈不为空，每次从栈中弹出一个节点\n 3. 处理该节点\n 4. 先把节点右孩子压入栈，接着把节点左孩子压入栈（如果有孩子节点）\n 5. 重复 2-4\n 6. 返回结果\n\n\n# python3\n\n递归：\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def preordertraversal(self, root: treenode) -> list[int]:\n        def preorder(root):\n            if root:\n                res.append(root.val)\n                preorder(root.left)\n                preorder(root.right)\n        res = []\n        preorder(root)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n非递归：\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def preordertraversal(self, root: treenode) -> list[int]:\n        if root is none:\n            return []\n        res = []\n        s = [root]\n        while s:\n            node = s.pop()\n            res.append(node.val)\n            if node.right:\n                s.append(node.right)\n            if node.left:\n                s.append(node.left)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java\n\n递归：\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n\n    private list<integer> res;\n\n    public list<integer> preordertraversal(treenode root) {\n        res = new arraylist<>();\n        preorder(root);\n        return res;\n    }\n\n    private void preorder(treenode root) {\n        if (root != null) {\n            res.add(root.val);\n            preorder(root.left);\n            preorder(root.right);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n非递归：\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public list<integer> preordertraversal(treenode root) {\n        if (root == null) {\n            return collections.emptylist();\n        }\n        list<integer> res = new arraylist<>();\n        deque<treenode> s = new arraydeque<>();\n        s.push(root);\n        while (!s.isempty()) {\n            treenode node = s.pop();\n            res.add(node.val);\n            if (node.right != null) {\n                s.push(node.right);\n            }\n            if (node.left != null) {\n                s.push(node.left);\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# c++\n\n/**\n * definition for a binary tree node.\n * struct treenode {\n *     int val;\n *     treenode *left;\n *     treenode *right;\n *     treenode() : val(0), left(nullptr), right(nullptr) {}\n *     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass solution {\npublic:\n    vector<int> preordertraversal(treenode* root) {\n        vector<int> res;\n        if (root == nullptr) return res;\n        stack<treenode*> s;\n        s.push(root);\n        while (!s.empty()) {\n            treenode *node = s.top();\n            s.pop();\n            res.push_back(node->val);\n            if (node->right) s.push(node->right);\n            if (node->left) s.push(node->left);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode145 Binary Tree Postorder Traversal-zh",frontmatter:{title:"leetcode145 Binary Tree Postorder Traversal-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/31fafb/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode145 Binary Tree Postorder Traversal-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10145.leetcode145%20Binary%20Tree%20Postorder%20Traversal-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode145 Binary Tree Postorder Traversal-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10145.leetcode145%20Binary%20Tree%20Postorder%20Traversal-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode145 Binary Tree Postorder Traversal-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10145.leetcode145%20Binary%20Tree%20Postorder%20Traversal-zh.html",relativePath:"01.算法/24.leetcode/10145.leetcode145 Binary Tree Postorder Traversal-zh.md",key:"v-de88eb66",path:"/p/31fafb/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:162},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:300},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1494},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3442}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 145. 二叉树的后序遍历\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，返回它的 后序 遍历。\n\n示例:\n\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n输出: [3,2,1]\n\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n\n\n# 解法\n\n递归遍历或利用栈实现非递归遍历。\n\n非递归的思路如下：\n\n先序遍历的顺序是：头、左、右，如果我们改变左右孩子的顺序，就能将顺序变成：头、右、左。\n\n我们先不打印头节点，而是存放到另一个收集栈 s2 中，最后遍历结束，输出收集栈元素，即是后序遍历：左、右、头。\n\n\n# Python3\n\n递归：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\n        def postorder(root):\n            if root:\n                postorder(root.left)\n                postorder(root.right)\n                res.append(root.val)\n        res = []\n        postorder(root)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n非递归：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\n        if not root:\n            return []\n        s1 = [root]\n        s2 = []\n        while s1:\n            node = s1.pop()\n            s2.append(node.val)\n            if node.left:\n                s1.append(node.left)\n            if node.right:\n                s1.append(node.right)\n        return s2[::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java\n\n递归：\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    private List<Integer> res;\n\n    public List<Integer> postorderTraversal(TreeNode root) {\n        res = new ArrayList<>();\n        postorder(root);\n        return res;\n    }\n\n    private void postorder(TreeNode root) {\n        if (root != null) {\n            postorder(root.left);\n            postorder(root.right);\n            res.add(root.val);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n非递归：\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        Deque<TreeNode> s1 = new ArrayDeque<>();\n        List<Integer> s2 = new ArrayList<>();\n        s1.push(root);\n        while (!s1.isEmpty()) {\n            TreeNode node = s1.pop();\n            s2.add(node.val);\n            if (node.left != null) {\n                s1.push(node.left);\n            }\n            if (node.right != null) {\n                s1.push(node.right);\n            }\n        }\n        Collections.reverse(s2);\n        return s2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 145. 二叉树的后序遍历\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，返回它的 后序 遍历。\n\n示例:\n\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n输出: [3,2,1]\n\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n\n\n# 解法\n\n递归遍历或利用栈实现非递归遍历。\n\n非递归的思路如下：\n\n先序遍历的顺序是：头、左、右，如果我们改变左右孩子的顺序，就能将顺序变成：头、右、左。\n\n我们先不打印头节点，而是存放到另一个收集栈 s2 中，最后遍历结束，输出收集栈元素，即是后序遍历：左、右、头。\n\n\n# python3\n\n递归：\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def postordertraversal(self, root: treenode) -> list[int]:\n        def postorder(root):\n            if root:\n                postorder(root.left)\n                postorder(root.right)\n                res.append(root.val)\n        res = []\n        postorder(root)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n非递归：\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def postordertraversal(self, root: treenode) -> list[int]:\n        if not root:\n            return []\n        s1 = [root]\n        s2 = []\n        while s1:\n            node = s1.pop()\n            s2.append(node.val)\n            if node.left:\n                s1.append(node.left)\n            if node.right:\n                s1.append(node.right)\n        return s2[::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java\n\n递归：\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n\n    private list<integer> res;\n\n    public list<integer> postordertraversal(treenode root) {\n        res = new arraylist<>();\n        postorder(root);\n        return res;\n    }\n\n    private void postorder(treenode root) {\n        if (root != null) {\n            postorder(root.left);\n            postorder(root.right);\n            res.add(root.val);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n非递归：\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public list<integer> postordertraversal(treenode root) {\n        if (root == null) {\n            return collections.emptylist();\n        }\n        deque<treenode> s1 = new arraydeque<>();\n        list<integer> s2 = new arraylist<>();\n        s1.push(root);\n        while (!s1.isempty()) {\n            treenode node = s1.pop();\n            s2.add(node.val);\n            if (node.left != null) {\n                s1.push(node.left);\n            }\n            if (node.right != null) {\n                s1.push(node.right);\n            }\n        }\n        collections.reverse(s2);\n        return s2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode146 Lru Cache-zh",frontmatter:{title:"leetcode146 Lru Cache-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/2b0d9a/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode146 Lru Cache-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10146.leetcode146%20Lru%20Cache-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode146 Lru Cache-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10146.leetcode146%20Lru%20Cache-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode146 Lru Cache-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10146.leetcode146%20Lru%20Cache-zh.html",relativePath:"01.算法/24.leetcode/10146.leetcode146 Lru Cache-zh.md",key:"v-51c9fe7e",path:"/p/2b0d9a/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1049},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1827},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:3730},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:5961}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 146. LRU 缓存机制\n\nEnglish Version\n\n\n# 题目描述\n\n运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。\n\n实现 LRUCache 类：\n\n * LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存\n * int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\n * void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n \n\n进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？\n\n \n\n示例：\n\n\n输入\n["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n\n\n \n\n提示：\n\n * 1 <= capacity <= 3000\n * 0 <= key <= 3000\n * 0 <= value <= 104\n * 最多调用 3 * 104 次 get 和 put\n\n\n# 解法\n\n“哈希表 + 双向链表”实现。其中：\n\n * 双向链表按照被使用的顺序存储 kv 键值对，靠近头部的 kv 键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\n * 哈希表通过缓存的 key 映射到双向链表中的位置。我们可以在 O(1) 时间内定位到缓存的 key 所对应的 value 在链表中的位置。\n\n对于 get 操作，判断 key 是否存在哈希表中：\n\n * 若不存在，返回 -1\n * 若存在，则 key 对应的节点 node 是最近使用的节点。将该节点移动到双向链表的头部，最后返回该节点的值即可。\n\n对于 put 操作，同样先判断 key 是否存在哈希表中：\n\n * 若不存在，则创建一个新的 node 节点，放入哈希表中。然后在双向链表的头部添加该节点。接着判断双向链表节点数是否超过 capacity。若超过，则删除双向链表的尾部节点，以及在哈希表中对应的项。\n * 若存在，则更新 node 节点的值，然后该节点移动到双向链表的头部。\n\n双向链表节点（哈希表的 value）的结构如下：\n\nclass Node {\n\tint key;\n\tint value;\n\tNode prev;\n\tNode next;\n\tNode() {\n\n\t}\n\tNode(int key, int value) {\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n你可能会问，哈希表的 value 为何还要存放 key？\n\n这是因为，双向链表有一个删除尾节点的操作。我们定位到双向链表的尾节点，在链表中删除之后，还要找到该尾节点在哈希表中的位置，因此需要根据 value 中存放的 key，定位到哈希表的数据项，然后将其删除。\n\n\n# Python3\n\nclass Node:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.capacity = capacity\n        self.size = 0\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_head(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self.move_to_head(node)\n        else:\n            node = Node(key, value)\n            self.cache[key] = node\n            self.add_to_head(node)\n            self.size += 1\n            if self.size > self.capacity:\n                node = self.remove_tail()\n                self.cache.pop(node.key)\n                self.size -= 1\n    \n    def move_to_head(self, node):\n        self.remove_node(node)\n        self.add_to_head(node)\n    \n    def remove_node(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    \n    def add_to_head(self, node):\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n        node.prev = self.head\n\n    def remove_tail(self):\n        node = self.tail.prev\n        self.remove_node(node)\n        return node\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# Java\n\nclass LRUCache {\n    class Node {\n        int key;\n        int value;\n        Node prev;\n        Node next;\n        Node() {\n\n        }\n        Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    private Map<Integer, Node> cache;\n    private Node head;\n    private Node tail;\n    private int capacity;\n    private int size;\n\n    public LRUCache(int capacity) {\n        cache = new HashMap<>();\n        this.capacity = capacity;\n        head = new Node();\n        tail = new Node();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        Node node = cache.get(key);\n        moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            node.value = value;\n            moveToHead(node);\n        } else {\n            Node node = new Node(key, value);\n            cache.put(key, node);\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                node = removeTail();\n                cache.remove(node.key);\n                --size;\n            }\n        }\n    }\n\n    private void moveToHead(Node node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void addToHead(Node node) {\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        node.prev = head;\n    }\n\n    private Node removeTail() {\n        Node node = tail.prev;\n        removeNode(node);\n        return node;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 146. lru 缓存机制\n\nenglish version\n\n\n# 题目描述\n\n运用你所掌握的数据结构，设计和实现一个  lru (最近最少使用) 缓存机制 。\n\n实现 lrucache 类：\n\n * lrucache(int capacity) 以正整数作为容量 capacity 初始化 lru 缓存\n * int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\n * void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n \n\n进阶：你是否可以在 o(1) 时间复杂度内完成这两种操作？\n\n \n\n示例：\n\n\n输入\n["lrucache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nlrucache lrucache = new lrucache(2);\nlrucache.put(1, 1); // 缓存是 {1=1}\nlrucache.put(2, 2); // 缓存是 {1=1, 2=2}\nlrucache.get(1);    // 返回 1\nlrucache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlrucache.get(2);    // 返回 -1 (未找到)\nlrucache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlrucache.get(1);    // 返回 -1 (未找到)\nlrucache.get(3);    // 返回 3\nlrucache.get(4);    // 返回 4\n\n\n \n\n提示：\n\n * 1 <= capacity <= 3000\n * 0 <= key <= 3000\n * 0 <= value <= 104\n * 最多调用 3 * 104 次 get 和 put\n\n\n# 解法\n\n“哈希表 + 双向链表”实现。其中：\n\n * 双向链表按照被使用的顺序存储 kv 键值对，靠近头部的 kv 键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\n * 哈希表通过缓存的 key 映射到双向链表中的位置。我们可以在 o(1) 时间内定位到缓存的 key 所对应的 value 在链表中的位置。\n\n对于 get 操作，判断 key 是否存在哈希表中：\n\n * 若不存在，返回 -1\n * 若存在，则 key 对应的节点 node 是最近使用的节点。将该节点移动到双向链表的头部，最后返回该节点的值即可。\n\n对于 put 操作，同样先判断 key 是否存在哈希表中：\n\n * 若不存在，则创建一个新的 node 节点，放入哈希表中。然后在双向链表的头部添加该节点。接着判断双向链表节点数是否超过 capacity。若超过，则删除双向链表的尾部节点，以及在哈希表中对应的项。\n * 若存在，则更新 node 节点的值，然后该节点移动到双向链表的头部。\n\n双向链表节点（哈希表的 value）的结构如下：\n\nclass node {\n\tint key;\n\tint value;\n\tnode prev;\n\tnode next;\n\tnode() {\n\n\t}\n\tnode(int key, int value) {\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n你可能会问，哈希表的 value 为何还要存放 key？\n\n这是因为，双向链表有一个删除尾节点的操作。我们定位到双向链表的尾节点，在链表中删除之后，还要找到该尾节点在哈希表中的位置，因此需要根据 value 中存放的 key，定位到哈希表的数据项，然后将其删除。\n\n\n# python3\n\nclass node:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = none\n        self.next = none\n\nclass lrucache:\n\n    def __init__(self, capacity: int):\n        self.cache = {}\n        self.head = node()\n        self.tail = node()\n        self.capacity = capacity\n        self.size = 0\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_head(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> none:\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self.move_to_head(node)\n        else:\n            node = node(key, value)\n            self.cache[key] = node\n            self.add_to_head(node)\n            self.size += 1\n            if self.size > self.capacity:\n                node = self.remove_tail()\n                self.cache.pop(node.key)\n                self.size -= 1\n    \n    def move_to_head(self, node):\n        self.remove_node(node)\n        self.add_to_head(node)\n    \n    def remove_node(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    \n    def add_to_head(self, node):\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n        node.prev = self.head\n\n    def remove_tail(self):\n        node = self.tail.prev\n        self.remove_node(node)\n        return node\n\n\n# your lrucache object will be instantiated and called as such:\n# obj = lrucache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# java\n\nclass lrucache {\n    class node {\n        int key;\n        int value;\n        node prev;\n        node next;\n        node() {\n\n        }\n        node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    private map<integer, node> cache;\n    private node head;\n    private node tail;\n    private int capacity;\n    private int size;\n\n    public lrucache(int capacity) {\n        cache = new hashmap<>();\n        this.capacity = capacity;\n        head = new node();\n        tail = new node();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if (!cache.containskey(key)) {\n            return -1;\n        }\n        node node = cache.get(key);\n        movetohead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containskey(key)) {\n            node node = cache.get(key);\n            node.value = value;\n            movetohead(node);\n        } else {\n            node node = new node(key, value);\n            cache.put(key, node);\n            addtohead(node);\n            ++size;\n            if (size > capacity) {\n                node = removetail();\n                cache.remove(node.key);\n                --size;\n            }\n        }\n    }\n\n    private void movetohead(node node) {\n        removenode(node);\n        addtohead(node);\n    }\n\n    private void removenode(node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void addtohead(node node) {\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        node.prev = head;\n    }\n\n    private node removetail() {\n        node node = tail.prev;\n        removenode(node);\n        return node;\n    }\n}\n\n/**\n * your lrucache object will be instantiated and called as such:\n * lrucache obj = new lrucache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode147 Insertion Sort List-zh",frontmatter:{title:"leetcode147 Insertion Sort List-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/085977/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0147.Insertion%20Sort%20List/images/Insertion-sort-example-300px.gif"},{name:"twitter:title",content:"leetcode147 Insertion Sort List-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0147.Insertion%20Sort%20List/images/Insertion-sort-example-300px.gif"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10147.leetcode147%20Insertion%20Sort%20List-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode147 Insertion Sort List-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0147.Insertion%20Sort%20List/images/Insertion-sort-example-300px.gif"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10147.leetcode147%20Insertion%20Sort%20List-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode147 Insertion Sort List-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0147.Insertion%20Sort%20List/images/Insertion-sort-example-300px.gif"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10147.leetcode147%20Insertion%20Sort%20List-zh.html",relativePath:"01.算法/24.leetcode/10147.leetcode147 Insertion Sort List-zh.md",key:"v-6e287744",path:"/p/085977/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:368},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:521},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1331},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2425},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3339}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 147. 对链表进行插入排序\n\nEnglish Version\n\n\n# 题目描述\n\n对链表进行插入排序。\n\n\n插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。\n每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。\n\n \n\n插入排序算法：\n\n 1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。\n 2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。\n 3. 重复直到所有输入数据插入完为止。\n\n \n\n示例 1：\n\n输入: 4->2->1->3\n输出: 1->2->3->4\n\n\n示例 2：\n\n输入: -1->5->3->4->0\n输出: -1->0->3->4->5\n\n\n\n# 解法\n\n遍历链表，每次将遍历到的结点 cur 与前一个结点 pre 进行值比较：\n\n * 若结点 cur 的值比 pre 的大，说明当前 cur 已在正确的位置，直接往下遍历。\n * 否则，从链表第一个结点开始遍历，将结点 cur 插入到正确的位置。\n\n依次遍历，直至 cur 指向空，遍历结束。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertionSortList(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        dummy = ListNode(head.val, head)\n        pre, cur = dummy, head\n        while cur:\n            if pre.val <= cur.val:\n                pre, cur = cur, cur.next\n                continue\n            p = dummy\n            while p.next.val <= cur.val:\n                p = p.next\n            t = cur.next\n            cur.next = p.next\n            p.next = cur\n            pre.next = t\n            cur = t\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(head.val, head);\n        ListNode pre = dummy, cur = head;\n        while (cur != null) {\n            if (pre.val <= cur.val) {\n                pre = cur;\n                cur = cur.next;\n                continue;\n            }\n            ListNode p = dummy;\n            while (p.next.val <= cur.val) {\n                p = p.next;\n            }\n            ListNode t = cur.next;\n            cur.next = p.next;\n            p.next = cur;\n            pre.next = t;\n            cur = t;\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar insertionSortList = function(head) {\n    if (head == null || head.next == null) return head;\n    let dummy = new ListNode(head.val, head);\n    let prev = dummy, cur = head;\n    while (cur != null) {\n        if (prev.val <= cur.val) {\n            prev = cur;\n            cur = cur.next;\n            continue;\n        }\n        let p = dummy;\n        while (p.next.val <= cur.val) {\n            p = p.next;\n        }\n        let t = cur.next;\n        cur.next = p.next;\n        p.next = cur;\n        prev.next = t;\n        cur = t;\n    }\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 147. 对链表进行插入排序\n\nenglish version\n\n\n# 题目描述\n\n对链表进行插入排序。\n\n\n插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。\n每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。\n\n \n\n插入排序算法：\n\n 1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。\n 2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。\n 3. 重复直到所有输入数据插入完为止。\n\n \n\n示例 1：\n\n输入: 4->2->1->3\n输出: 1->2->3->4\n\n\n示例 2：\n\n输入: -1->5->3->4->0\n输出: -1->0->3->4->5\n\n\n\n# 解法\n\n遍历链表，每次将遍历到的结点 cur 与前一个结点 pre 进行值比较：\n\n * 若结点 cur 的值比 pre 的大，说明当前 cur 已在正确的位置，直接往下遍历。\n * 否则，从链表第一个结点开始遍历，将结点 cur 插入到正确的位置。\n\n依次遍历，直至 cur 指向空，遍历结束。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def insertionsortlist(self, head: listnode) -> listnode:\n        if head is none or head.next is none:\n            return head\n        dummy = listnode(head.val, head)\n        pre, cur = dummy, head\n        while cur:\n            if pre.val <= cur.val:\n                pre, cur = cur, cur.next\n                continue\n            p = dummy\n            while p.next.val <= cur.val:\n                p = p.next\n            t = cur.next\n            cur.next = p.next\n            p.next = cur\n            pre.next = t\n            cur = t\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode insertionsortlist(listnode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        listnode dummy = new listnode(head.val, head);\n        listnode pre = dummy, cur = head;\n        while (cur != null) {\n            if (pre.val <= cur.val) {\n                pre = cur;\n                cur = cur.next;\n                continue;\n            }\n            listnode p = dummy;\n            while (p.next.val <= cur.val) {\n                p = p.next;\n            }\n            listnode t = cur.next;\n            cur.next = p.next;\n            p.next = cur;\n            pre.next = t;\n            cur = t;\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {listnode}\n */\nvar insertionsortlist = function(head) {\n    if (head == null || head.next == null) return head;\n    let dummy = new listnode(head.val, head);\n    let prev = dummy, cur = head;\n    while (cur != null) {\n        if (prev.val <= cur.val) {\n            prev = cur;\n            cur = cur.next;\n            continue;\n        }\n        let p = dummy;\n        while (p.next.val <= cur.val) {\n            p = p.next;\n        }\n        let t = cur.next;\n        cur.next = p.next;\n        p.next = cur;\n        prev.next = t;\n        cur = t;\n    }\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode148 Sort List-zh",frontmatter:{title:"leetcode148 Sort List-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fa1546/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0148.Sort%20List/images/sort_list_1.jpg"},{name:"twitter:title",content:"leetcode148 Sort List-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0148.Sort%20List/images/sort_list_1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10148.leetcode148%20Sort%20List-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode148 Sort List-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0148.Sort%20List/images/sort_list_1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10148.leetcode148%20Sort%20List-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode148 Sort List-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0148.Sort%20List/images/sort_list_1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10148.leetcode148%20Sort%20List-zh.html",relativePath:"01.算法/24.leetcode/10148.leetcode148 Sort List-zh.md",key:"v-be1a0b66",path:"/p/fa1546/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:322},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:378},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1301},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2559},{level:3,title:"C#",slug:"c",normalizedTitle:"c#",charIndex:3584},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:4919},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:6161}],headersStr:"题目描述 解法 Python3 Java JavaScript C# TypeScript ...",content:"# 148. 排序链表\n\nEnglish Version\n\n\n# 题目描述\n\n给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。\n\n进阶：\n\n * 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n\n \n\n示例 1：\n\n\n输入：head = [4,2,1,3]\n输出：[1,2,3,4]\n\n\n示例 2：\n\n\n输入：head = [-1,5,3,4,0]\n输出：[-1,0,3,4,5]\n\n\n示例 3：\n\n\n输入：head = []\n输出：[]\n\n\n \n\n提示：\n\n * 链表中节点的数目在范围 [0, 5 * 104] 内\n * -105 <= Node.val <= 105\n\n\n# 解法\n\n先用快慢指针找到链表中点，然后分成左右两个链表，递归排序左右链表。最后合并两个排序的链表即可。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        t = slow.next\n        slow.next = None\n        l1, l2 = self.sortList(head), self.sortList(t)\n        dummy = ListNode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        cur.next = l1 or l2\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode slow = head, fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode t = slow.next;\n        slow.next = null;\n        ListNode l1 = sortList(head);\n        ListNode l2 = sortList(t);\n        ListNode dummy = new ListNode();\n        ListNode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar sortList = function(head) {\n    if (!head || !head.next) {\n        return head;\n    }\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let t = slow.next;\n    slow.next = null;\n    let l1 = sortList(head);\n    let l2 = sortList(t);\n    const dummy = new ListNode();\n    let cur = dummy;\n    while (l1 && l2) {\n        if (l1.val <= l2.val) {\n            cur.next = l1;\n            l1 = l1.next;\n        } else {\n            cur.next = l2;\n            l2 = l2.next;\n        }\n        cur = cur.next;\n    }\n    cur.next = l1 || l2;\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# C#\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode SortList(ListNode head) {\n        if (head == null || head.next == null)\n        {\n            return head;\n        }\n        ListNode slow = head, fast = head.next;\n        while (fast != null && fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode t = slow.next;\n        slow.next = null;\n        ListNode l1 = SortList(head);\n        ListNode l2 = SortList(t);\n        ListNode dummy = new ListNode();\n        ListNode cur = dummy;\n        while (l1 != null && l2 != null)\n        {\n            if (l1.val <= l2.val)\n            {\n                cur.next = l1;\n                l1 = l1.next;\n            }\n            else\n            {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# TypeScript\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction sortList(head: ListNode | null): ListNode | null {\n    if (head == null || head.next == null) return head;\n    // 快慢指针定位中点\n    let slow: ListNode = head, fast: ListNode = head.next;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    // 归并排序\n    let mid: ListNode = slow.next;\n    slow.next = null;\n    let l1: ListNode = sortList(head);\n    let l2: ListNode = sortList(mid);\n    let dummy: ListNode = new ListNode();\n    let cur: ListNode = dummy;\n    while (l1 != null && l2 != null) {\n        if (l1.val <= l2.val) {\n            cur.next = l1;\n            l1 = l1.next;\n        } else {\n            cur.next = l2;\n            l2 = l2.next;\n        }\n        cur = cur.next;\n    }\n    cur.next = l1 == null ? l2 : l1;\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 148. 排序链表\n\nenglish version\n\n\n# 题目描述\n\n给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。\n\n进阶：\n\n * 你可以在 o(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n\n \n\n示例 1：\n\n\n输入：head = [4,2,1,3]\n输出：[1,2,3,4]\n\n\n示例 2：\n\n\n输入：head = [-1,5,3,4,0]\n输出：[-1,0,3,4,5]\n\n\n示例 3：\n\n\n输入：head = []\n输出：[]\n\n\n \n\n提示：\n\n * 链表中节点的数目在范围 [0, 5 * 104] 内\n * -105 <= node.val <= 105\n\n\n# 解法\n\n先用快慢指针找到链表中点，然后分成左右两个链表，递归排序左右链表。最后合并两个排序的链表即可。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def sortlist(self, head: listnode) -> listnode:\n        if head is none or head.next is none:\n            return head\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        t = slow.next\n        slow.next = none\n        l1, l2 = self.sortlist(head), self.sortlist(t)\n        dummy = listnode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        cur.next = l1 or l2\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode sortlist(listnode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        listnode slow = head, fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        listnode t = slow.next;\n        slow.next = null;\n        listnode l1 = sortlist(head);\n        listnode l2 = sortlist(t);\n        listnode dummy = new listnode();\n        listnode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {listnode}\n */\nvar sortlist = function(head) {\n    if (!head || !head.next) {\n        return head;\n    }\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let t = slow.next;\n    slow.next = null;\n    let l1 = sortlist(head);\n    let l2 = sortlist(t);\n    const dummy = new listnode();\n    let cur = dummy;\n    while (l1 && l2) {\n        if (l1.val <= l2.val) {\n            cur.next = l1;\n            l1 = l1.next;\n        } else {\n            cur.next = l2;\n            l2 = l2.next;\n        }\n        cur = cur.next;\n    }\n    cur.next = l1 || l2;\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# c#\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     public int val;\n *     public listnode next;\n *     public listnode(int val=0, listnode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class solution {\n    public listnode sortlist(listnode head) {\n        if (head == null || head.next == null)\n        {\n            return head;\n        }\n        listnode slow = head, fast = head.next;\n        while (fast != null && fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        listnode t = slow.next;\n        slow.next = null;\n        listnode l1 = sortlist(head);\n        listnode l2 = sortlist(t);\n        listnode dummy = new listnode();\n        listnode cur = dummy;\n        while (l1 != null && l2 != null)\n        {\n            if (l1.val <= l2.val)\n            {\n                cur.next = l1;\n                l1 = l1.next;\n            }\n            else\n            {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# typescript\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     val: number\n *     next: listnode | null\n *     constructor(val?: number, next?: listnode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction sortlist(head: listnode | null): listnode | null {\n    if (head == null || head.next == null) return head;\n    // 快慢指针定位中点\n    let slow: listnode = head, fast: listnode = head.next;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    // 归并排序\n    let mid: listnode = slow.next;\n    slow.next = null;\n    let l1: listnode = sortlist(head);\n    let l2: listnode = sortlist(mid);\n    let dummy: listnode = new listnode();\n    let cur: listnode = dummy;\n    while (l1 != null && l2 != null) {\n        if (l1.val <= l2.val) {\n            cur.next = l1;\n            l1 = l1.next;\n        } else {\n            cur.next = l2;\n            l2 = l2.next;\n        }\n        cur = cur.next;\n    }\n    cur.next = l1 == null ? l2 : l1;\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode149 Max Points on a Line-zh",frontmatter:{title:"leetcode149 Max Points on a Line-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/949028/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode149 Max Points on a Line-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10149.leetcode149%20Max%20Points%20on%20a%20Line-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode149 Max Points on a Line-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10149.leetcode149%20Max%20Points%20on%20a%20Line-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode149 Max Points on a Line-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10149.leetcode149%20Max%20Points%20on%20a%20Line-zh.html",relativePath:"01.算法/24.leetcode/10149.leetcode149 Max Points on a Line-zh.md",key:"v-06605e90",path:"/p/949028/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:339},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:612},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1600},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2810},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3501}],headersStr:"题目描述 解法 Python3 Java Go ...",content:"# 149. 直线上最多的点数\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。\n\n示例 1:\n\n输入: [[1,1],[2,2],[3,3]]\n输出: 3\n解释:\n^\n|\n|        o\n|     o\n|  o  \n+-------------\x3e\n0  1  2  3  4\n\n\n示例 2:\n\n输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n输出: 4\n解释:\n^\n|\n|  o\n|     o        o\n|        o\n|  o        o\n+-------------------\x3e\n0  1  2  3  4  5  6\n\n\n# 解法\n\n在平面上确定一个点 points[i]，其他点与 point[i] 可以求得一个斜率，斜率相同的点意味着它们与 points[i] 在同一条直线上。\n\n所以可以用哈希表作为计数器，其中斜率作为 key，然后累计当前点相同的斜率出现的次数。斜率可能是小数，我们可以用分数形式表示，先求分子分母的最大公约数，然后约分，最后将“分子.分母” 作为 key 即可。\n\n需要注意，如果平面上有和当前点重叠的点，如果进行约分，会出现除 0 的情况，那么我们单独用一个变量 duplicate 统计重复点的个数，重复点一定是过当前点的直线的。\n\n\n# Python3\n\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        def gcd(a, b) -> int:\n            return a if b == 0 else gcd(b, a % b)\n\n        n = len(points)\n        if n < 3:\n            return n\n        res = 0\n        for i in range(n - 1):\n            counter = collections.Counter()\n            t_max = duplicate = 0\n            for j in range(i + 1, n):\n                delta_x = points[i][0] - points[j][0]\n                delta_y = points[i][1] - points[j][1]\n                if delta_x == 0 and delta_y == 0:\n                    duplicate += 1\n                    continue\n                g = gcd(delta_x, delta_y)\n                d_x = delta_x // g\n                d_y = delta_y // g\n                key = f'{d_x}.{d_y}'\n                counter[key] += 1\n                t_max = max(t_max, counter[key])\n            res = max(res, t_max + duplicate + 1)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java\n\nclass Solution {\n    public int maxPoints(int[][] points) {\n        int n = points.length;\n        if (n < 3) {\n            return n;\n        }\n        int res = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            Map<String, Integer> kCounter = new HashMap<>();\n            int max = 0;\n            int duplicate = 0;\n            for (int j = i + 1; j < n; ++j) {\n                int deltaX = points[i][0] - points[j][0];\n                int deltaY = points[i][1] - points[j][1];\n                if (deltaX == 0 && deltaY == 0) {\n                    ++duplicate;\n                    continue;\n                }\n                int gcd = gcd(deltaX, deltaY);\n                int dX = deltaX / gcd;\n                int dY = deltaY / gcd;\n                String key = dX + \".\" + dY;\n                kCounter.put(key, kCounter.getOrDefault(key, 0) + 1);\n                max = Math.max(max, kCounter.get(key));\n            }\n            res = Math.max(res, max + duplicate + 1);\n        }\n        return res;\n    }\n\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# Go\n\nfunc maxPoints(points [][]int) int {\n\ttype pair struct {\n\t\tfirst  int\n\t\tsecond int\n\t}\n\tn := len(points)\n\tif n <= 2 {\n\t\treturn n\n\t}\n\tans := 0\n\tfor i := 0; i < n-1; i++ {\n\t\tfreq := make(map[pair]int)\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tx1, y1, x2, y2 := points[i][0], points[i][1], points[j][0], points[j][1]\n\t\t\tdx, dy := x2-x1, y2-y1\n\t\t\tg := gcd(dx, dy)\n\t\t\tp := pair{dx / g, dy / g}\n\t\t\tfreq[p]++\n\t\t\tans = max(ans, freq[p]+1)\n\t\t}\n\t}\n\treturn ans\n}\n\nfunc gcd(a, b int) int {\n\tfor b != 0 {\n\t\ta, b = b, a%b\n\t}\n\treturn a\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 149. 直线上最多的点数\n\nenglish version\n\n\n# 题目描述\n\n给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。\n\n示例 1:\n\n输入: [[1,1],[2,2],[3,3]]\n输出: 3\n解释:\n^\n|\n|        o\n|     o\n|  o  \n+-------------\x3e\n0  1  2  3  4\n\n\n示例 2:\n\n输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n输出: 4\n解释:\n^\n|\n|  o\n|     o        o\n|        o\n|  o        o\n+-------------------\x3e\n0  1  2  3  4  5  6\n\n\n# 解法\n\n在平面上确定一个点 points[i]，其他点与 point[i] 可以求得一个斜率，斜率相同的点意味着它们与 points[i] 在同一条直线上。\n\n所以可以用哈希表作为计数器，其中斜率作为 key，然后累计当前点相同的斜率出现的次数。斜率可能是小数，我们可以用分数形式表示，先求分子分母的最大公约数，然后约分，最后将“分子.分母” 作为 key 即可。\n\n需要注意，如果平面上有和当前点重叠的点，如果进行约分，会出现除 0 的情况，那么我们单独用一个变量 duplicate 统计重复点的个数，重复点一定是过当前点的直线的。\n\n\n# python3\n\nclass solution:\n    def maxpoints(self, points: list[list[int]]) -> int:\n        def gcd(a, b) -> int:\n            return a if b == 0 else gcd(b, a % b)\n\n        n = len(points)\n        if n < 3:\n            return n\n        res = 0\n        for i in range(n - 1):\n            counter = collections.counter()\n            t_max = duplicate = 0\n            for j in range(i + 1, n):\n                delta_x = points[i][0] - points[j][0]\n                delta_y = points[i][1] - points[j][1]\n                if delta_x == 0 and delta_y == 0:\n                    duplicate += 1\n                    continue\n                g = gcd(delta_x, delta_y)\n                d_x = delta_x // g\n                d_y = delta_y // g\n                key = f'{d_x}.{d_y}'\n                counter[key] += 1\n                t_max = max(t_max, counter[key])\n            res = max(res, t_max + duplicate + 1)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java\n\nclass solution {\n    public int maxpoints(int[][] points) {\n        int n = points.length;\n        if (n < 3) {\n            return n;\n        }\n        int res = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            map<string, integer> kcounter = new hashmap<>();\n            int max = 0;\n            int duplicate = 0;\n            for (int j = i + 1; j < n; ++j) {\n                int deltax = points[i][0] - points[j][0];\n                int deltay = points[i][1] - points[j][1];\n                if (deltax == 0 && deltay == 0) {\n                    ++duplicate;\n                    continue;\n                }\n                int gcd = gcd(deltax, deltay);\n                int dx = deltax / gcd;\n                int dy = deltay / gcd;\n                string key = dx + \".\" + dy;\n                kcounter.put(key, kcounter.getordefault(key, 0) + 1);\n                max = math.max(max, kcounter.get(key));\n            }\n            res = math.max(res, max + duplicate + 1);\n        }\n        return res;\n    }\n\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# go\n\nfunc maxpoints(points [][]int) int {\n\ttype pair struct {\n\t\tfirst  int\n\t\tsecond int\n\t}\n\tn := len(points)\n\tif n <= 2 {\n\t\treturn n\n\t}\n\tans := 0\n\tfor i := 0; i < n-1; i++ {\n\t\tfreq := make(map[pair]int)\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tx1, y1, x2, y2 := points[i][0], points[i][1], points[j][0], points[j][1]\n\t\t\tdx, dy := x2-x1, y2-y1\n\t\t\tg := gcd(dx, dy)\n\t\t\tp := pair{dx / g, dy / g}\n\t\t\tfreq[p]++\n\t\t\tans = max(ans, freq[p]+1)\n\t\t}\n\t}\n\treturn ans\n}\n\nfunc gcd(a, b int) int {\n\tfor b != 0 {\n\t\ta, b = b, a%b\n\t}\n\treturn a\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode150 Evaluate Reverse Polish Notation-zh",frontmatter:{title:"leetcode150 Evaluate Reverse Polish Notation-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/76312a/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode150 Evaluate Reverse Polish Notation-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10150.leetcode150%20Evaluate%20Reverse%20Polish%20Notation-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode150 Evaluate Reverse Polish Notation-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10150.leetcode150%20Evaluate%20Reverse%20Polish%20Notation-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode150 Evaluate Reverse Polish Notation-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10150.leetcode150%20Evaluate%20Reverse%20Polish%20Notation-zh.html",relativePath:"01.算法/24.leetcode/10150.leetcode150 Evaluate Reverse Polish Notation-zh.md",key:"v-1e673d87",path:"/p/76312a/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:991},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1072},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1577},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2594}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 150. 逆波兰表达式求值\n\nEnglish Version\n\n\n# 题目描述\n\n根据 逆波兰表示法，求表达式的值。\n\n有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n\n \n\n说明：\n\n * 整数除法只保留整数部分。\n * 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n\n \n\n示例 1：\n\n\n输入：tokens = ["2","1","+","3","*"]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n\n\n示例 2：\n\n\n输入：tokens = ["4","13","5","/","+"]\n输出：6\n解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n\n\n示例 3：\n\n\n输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]\n输出：22\n解释：\n该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n \n\n提示：\n\n * 1 <= tokens.length <= 104\n * tokens[i] 要么是一个算符（"+"、"-"、"*" 或 "/"），要么是一个在范围 [-200, 200] 内的整数\n\n \n\n逆波兰表达式：\n\n逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\n\n * 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。\n * 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。\n\n逆波兰表达式主要有以下两个优点：\n\n * 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。\n * 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。\n\n\n# 解法\n\n栈实现。\n\n遍历数组，遇到数字则压入栈中，遇到运算符号，则从栈中弹出右、左操作数，运算过后，将结果压入栈中。\n\n遍历结束后，返回栈中的唯一元素。\n\n\n# Python3\n\nimport operator\n\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        opt = {\n            "+": operator.add,\n            "-": operator.sub,\n            "*": operator.mul,\n            "/": operator.truediv\n        }\n        s = []\n        for token in tokens:\n            if token in opt:\n                s.append(int(opt[token](s.pop(-2), s.pop(-1))))\n            else:\n                s.append(int(token))\n        return s[0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Java\n\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Deque<Integer> s = new ArrayDeque<>();\n        int left, right;\n        for (String token : tokens) {\n            switch(token) {\n            case "+":\n                right = s.pop();\n                left = s.pop();\n                s.push(left + right);\n                break;\n            case "-":\n                right = s.pop();\n                left = s.pop();\n                s.push(left - right);\n                break;\n            case "*":\n                right = s.pop();\n                left = s.pop();\n                s.push(left * right);\n                break;\n            case "/":\n                right = s.pop();\n                left = s.pop();\n                s.push(left / right);\n                break;\n            default:\n                s.push(Integer.valueOf(token));\n            }\n        }\n        return s.pop();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 150. 逆波兰表达式求值\n\nenglish version\n\n\n# 题目描述\n\n根据 逆波兰表示法，求表达式的值。\n\n有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n\n \n\n说明：\n\n * 整数除法只保留整数部分。\n * 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n\n \n\n示例 1：\n\n\n输入：tokens = ["2","1","+","3","*"]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n\n\n示例 2：\n\n\n输入：tokens = ["4","13","5","/","+"]\n输出：6\n解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n\n\n示例 3：\n\n\n输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]\n输出：22\n解释：\n该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n \n\n提示：\n\n * 1 <= tokens.length <= 104\n * tokens[i] 要么是一个算符（"+"、"-"、"*" 或 "/"），要么是一个在范围 [-200, 200] 内的整数\n\n \n\n逆波兰表达式：\n\n逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\n\n * 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。\n * 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。\n\n逆波兰表达式主要有以下两个优点：\n\n * 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。\n * 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。\n\n\n# 解法\n\n栈实现。\n\n遍历数组，遇到数字则压入栈中，遇到运算符号，则从栈中弹出右、左操作数，运算过后，将结果压入栈中。\n\n遍历结束后，返回栈中的唯一元素。\n\n\n# python3\n\nimport operator\n\nclass solution:\n    def evalrpn(self, tokens: list[str]) -> int:\n        opt = {\n            "+": operator.add,\n            "-": operator.sub,\n            "*": operator.mul,\n            "/": operator.truediv\n        }\n        s = []\n        for token in tokens:\n            if token in opt:\n                s.append(int(opt[token](s.pop(-2), s.pop(-1))))\n            else:\n                s.append(int(token))\n        return s[0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# java\n\nclass solution {\n    public int evalrpn(string[] tokens) {\n        deque<integer> s = new arraydeque<>();\n        int left, right;\n        for (string token : tokens) {\n            switch(token) {\n            case "+":\n                right = s.pop();\n                left = s.pop();\n                s.push(left + right);\n                break;\n            case "-":\n                right = s.pop();\n                left = s.pop();\n                s.push(left - right);\n                break;\n            case "*":\n                right = s.pop();\n                left = s.pop();\n                s.push(left * right);\n                break;\n            case "/":\n                right = s.pop();\n                left = s.pop();\n                s.push(left / right);\n                break;\n            default:\n                s.push(integer.valueof(token));\n            }\n        }\n        return s.pop();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode151 Reverse Words in a String-zh",frontmatter:{title:"leetcode151 Reverse Words in a String-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/780e72/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode151 Reverse Words in a String-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10151.leetcode151%20Reverse%20Words%20in%20a%20String-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode151 Reverse Words in a String-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10151.leetcode151%20Reverse%20Words%20in%20a%20String-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode151 Reverse Words in a String-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10151.leetcode151%20Reverse%20Words%20in%20a%20String-zh.html",relativePath:"01.算法/24.leetcode/10151.leetcode151 Reverse Words in a String-zh.md",key:"v-244162d4",path:"/p/780e72/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:648},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:663},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:817},{level:3,title:"C#",slug:"c",normalizedTitle:"c#",charIndex:1056},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:1298},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1472}],headersStr:"题目描述 解法 Python3 Java C# TypeScript ...",content:'# 151. 翻转字符串里的单词\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串，逐个翻转字符串中的每个单词。\n\n说明：\n\n * 无空格字符构成一个 单词 。\n * 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n * 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n \n\n示例 1：\n\n输入："the sky is blue"\n输出："blue is sky the"\n\n\n示例 2：\n\n输入："  hello world!  "\n输出："world! hello"\n解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n\n\n示例 3：\n\n输入："a good   example"\n输出："example good a"\n解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n\n示例 4：\n\n输入：s = "  Bob    Loves  Alice   "\n输出："Alice Loves Bob"\n\n\n示例 5：\n\n输入：s = "Alice does not even like bob"\n输出："bob like even not does Alice"\n\n\n \n\n提示：\n\n * 1 <= s.length <= 104\n * s 包含英文大小写字母、数字和空格 \' \'\n * s 中 至少存在一个 单词\n\n \n\n进阶：\n\n * 请尝试使用 O(1) 额外空间复杂度的原地解法。\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        words = s.strip().split()\n        return \' \'.join(words[::-1])\n\n\n1\n2\n3\n4\n\n\n\n# Java\n\nclass Solution {\n    public String reverseWords(String s) {\n        List<String> words = Arrays.asList(s.trim().split("\\\\s+"));\n        Collections.reverse(words);\n        return String.join(" ", words);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# C#\n\npublic class Solution {\n    public string ReverseWords(string s) {\n         return string.Join(" ", s.Trim().Split(" ").Where(word => !string.IsNullOrEmpty(word) && !string.IsNullOrEmpty(word.Trim())).Reverse());\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# TypeScript\n\nfunction reverseWords(s: string): string {\n    let words: string[] = s.trim().split(/\\s+/g);\n    words.reverse();\n    return words.join(\' \');\n};\n\n\n1\n2\n3\n4\n5\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 151. 翻转字符串里的单词\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串，逐个翻转字符串中的每个单词。\n\n说明：\n\n * 无空格字符构成一个 单词 。\n * 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n * 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n \n\n示例 1：\n\n输入："the sky is blue"\n输出："blue is sky the"\n\n\n示例 2：\n\n输入："  hello world!  "\n输出："world! hello"\n解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n\n\n示例 3：\n\n输入："a good   example"\n输出："example good a"\n解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n\n示例 4：\n\n输入：s = "  bob    loves  alice   "\n输出："alice loves bob"\n\n\n示例 5：\n\n输入：s = "alice does not even like bob"\n输出："bob like even not does alice"\n\n\n \n\n提示：\n\n * 1 <= s.length <= 104\n * s 包含英文大小写字母、数字和空格 \' \'\n * s 中 至少存在一个 单词\n\n \n\n进阶：\n\n * 请尝试使用 o(1) 额外空间复杂度的原地解法。\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def reversewords(self, s: str) -> str:\n        words = s.strip().split()\n        return \' \'.join(words[::-1])\n\n\n1\n2\n3\n4\n\n\n\n# java\n\nclass solution {\n    public string reversewords(string s) {\n        list<string> words = arrays.aslist(s.trim().split("\\\\s+"));\n        collections.reverse(words);\n        return string.join(" ", words);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# c#\n\npublic class solution {\n    public string reversewords(string s) {\n         return string.join(" ", s.trim().split(" ").where(word => !string.isnullorempty(word) && !string.isnullorempty(word.trim())).reverse());\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# typescript\n\nfunction reversewords(s: string): string {\n    let words: string[] = s.trim().split(/\\s+/g);\n    words.reverse();\n    return words.join(\' \');\n};\n\n\n1\n2\n3\n4\n5\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode152 Maximum Product Subarray-zh",frontmatter:{title:"leetcode152 Maximum Product Subarray-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/769c10/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode152 Maximum Product Subarray-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10152.leetcode152%20Maximum%20Product%20Subarray-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode152 Maximum Product Subarray-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10152.leetcode152%20Maximum%20Product%20Subarray-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode152 Maximum Product Subarray-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10152.leetcode152%20Maximum%20Product%20Subarray-zh.html",relativePath:"01.算法/24.leetcode/10152.leetcode152 Maximum Product Subarray-zh.md",key:"v-40451dd0",path:"/p/769c10/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:224},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:568},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:907},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:1372},{level:3,title:"C#",slug:"c",normalizedTitle:"c#",charIndex:1807},{level:3,title:"C++",slug:"c-2",normalizedTitle:"c++",charIndex:2288},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2739},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3214}],headersStr:"题目描述 解法 Python3 Java TypeScript C# C++ Go ...",content:"# 152. 乘积最大子数组\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n \n\n示例 1:\n\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n\n\n示例 2:\n\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n\n\n# 解法\n\n考虑当前位置 i：\n\n * 如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。\n * 如果是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。\n\n因此，分别维护 fmax 和 fmin。\n\n * fmax(i) = max(nums[i], fmax(i - 1) * nums[i], fmin(i - 1) * nums[i])\n * fmin(i) = min(nums[i], fmax(i - 1) * nums[i], fmin(i - 1) * nums[i])\n * res = max(fmax(i)), i∈[0, n)\n\n\n# Python3\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        maxf = minf = res = nums[0]\n        for num in nums[1:]:\n            m, n = maxf, minf\n            maxf = max(num, m * num, n * num)\n            minf = min(num, m * num, n * num)\n            res = max(res, maxf)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Java\n\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int maxf = nums[0], minf = nums[0], res = nums[0];\n        for (int i = 1; i < nums.length; ++i) {\n            int m = maxf, n = minf;\n            maxf = Math.max(nums[i], Math.max(m * nums[i], n * nums[i]));\n            minf = Math.min(nums[i], Math.min(m * nums[i], n * nums[i]));\n            res = Math.max(res, maxf);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# TypeScript\n\nfunction maxProduct(nums: number[]): number {\n    let n = nums.length;\n    let preMax = nums[0], preMin = nums[0], ans = nums[0];\n    for (let i = 1; i < n; ++i) {\n        let cur = nums[i];\n        let x = preMax, y = preMin;\n        preMax = Math.max(x * cur, y * cur, cur);\n        preMin = Math.min(x * cur, y * cur, cur);\n        ans = Math.max(preMax, ans);\n    }\n    return ans;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# C#\n\npublic class Solution {\n    public int MaxProduct(int[] nums) {\n        int maxf = nums[0], minf = nums[0], res = nums[0];\n        for (int i = 1; i < nums.Length; ++i)\n        {\n            int m = maxf, n = minf;\n            maxf = Math.Max(nums[i], Math.Max(nums[i] * m, nums[i] * n));\n            minf = Math.Min(nums[i], Math.Min(nums[i] * m, nums[i] * n));\n            res = Math.Max(res, maxf);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int maxf = nums[0], minf = nums[0], res = nums[0];\n        for (int i = 1; i < nums.size(); ++i) {\n            int m = maxf, n = minf;\n            maxf = max(nums[i], max(nums[i] * m, nums[i] * n));\n            minf = min(nums[i], min(nums[i] * m, nums[i] * n));\n            res = max(res, maxf);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Go\n\nfunc maxProduct(nums []int) int {\n\tmaxf, minf, res := nums[0], nums[0], nums[0]\n\tfor i := 1; i < len(nums); i++ {\n\t\tm, n := maxf, minf\n\t\tmaxf = max(nums[i], max(nums[i]*m, nums[i]*n))\n\t\tminf = min(nums[i], min(nums[i]*m, nums[i]*n))\n\t\tres = max(res, maxf)\n\t}\n\treturn res\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 152. 乘积最大子数组\n\nenglish version\n\n\n# 题目描述\n\n给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n \n\n示例 1:\n\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n\n\n示例 2:\n\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n\n\n# 解法\n\n考虑当前位置 i：\n\n * 如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。\n * 如果是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。\n\n因此，分别维护 fmax 和 fmin。\n\n * fmax(i) = max(nums[i], fmax(i - 1) * nums[i], fmin(i - 1) * nums[i])\n * fmin(i) = min(nums[i], fmax(i - 1) * nums[i], fmin(i - 1) * nums[i])\n * res = max(fmax(i)), i∈[0, n)\n\n\n# python3\n\nclass solution:\n    def maxproduct(self, nums: list[int]) -> int:\n        maxf = minf = res = nums[0]\n        for num in nums[1:]:\n            m, n = maxf, minf\n            maxf = max(num, m * num, n * num)\n            minf = min(num, m * num, n * num)\n            res = max(res, maxf)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# java\n\nclass solution {\n    public int maxproduct(int[] nums) {\n        int maxf = nums[0], minf = nums[0], res = nums[0];\n        for (int i = 1; i < nums.length; ++i) {\n            int m = maxf, n = minf;\n            maxf = math.max(nums[i], math.max(m * nums[i], n * nums[i]));\n            minf = math.min(nums[i], math.min(m * nums[i], n * nums[i]));\n            res = math.max(res, maxf);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# typescript\n\nfunction maxproduct(nums: number[]): number {\n    let n = nums.length;\n    let premax = nums[0], premin = nums[0], ans = nums[0];\n    for (let i = 1; i < n; ++i) {\n        let cur = nums[i];\n        let x = premax, y = premin;\n        premax = math.max(x * cur, y * cur, cur);\n        premin = math.min(x * cur, y * cur, cur);\n        ans = math.max(premax, ans);\n    }\n    return ans;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# c#\n\npublic class solution {\n    public int maxproduct(int[] nums) {\n        int maxf = nums[0], minf = nums[0], res = nums[0];\n        for (int i = 1; i < nums.length; ++i)\n        {\n            int m = maxf, n = minf;\n            maxf = math.max(nums[i], math.max(nums[i] * m, nums[i] * n));\n            minf = math.min(nums[i], math.min(nums[i] * m, nums[i] * n));\n            res = math.max(res, maxf);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# c++\n\nclass solution {\npublic:\n    int maxproduct(vector<int>& nums) {\n        int maxf = nums[0], minf = nums[0], res = nums[0];\n        for (int i = 1; i < nums.size(); ++i) {\n            int m = maxf, n = minf;\n            maxf = max(nums[i], max(nums[i] * m, nums[i] * n));\n            minf = min(nums[i], min(nums[i] * m, nums[i] * n));\n            res = max(res, maxf);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# go\n\nfunc maxproduct(nums []int) int {\n\tmaxf, minf, res := nums[0], nums[0], nums[0]\n\tfor i := 1; i < len(nums); i++ {\n\t\tm, n := maxf, minf\n\t\tmaxf = max(nums[i], max(nums[i]*m, nums[i]*n))\n\t\tminf = min(nums[i], min(nums[i]*m, nums[i]*n))\n\t\tres = max(res, maxf)\n\t}\n\treturn res\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode153 Find Minimum in Rotated Sorted Array-zh",frontmatter:{title:"leetcode153 Find Minimum in Rotated Sorted Array-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/67e5b5/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode153 Find Minimum in Rotated Sorted Array-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10153.leetcode153%20Find%20Minimum%20in%20Rotated%20Sorted%20Array-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode153 Find Minimum in Rotated Sorted Array-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10153.leetcode153%20Find%20Minimum%20in%20Rotated%20Sorted%20Array-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode153 Find Minimum in Rotated Sorted Array-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10153.leetcode153%20Find%20Minimum%20in%20Rotated%20Sorted%20Array-zh.html",relativePath:"01.算法/24.leetcode/10153.leetcode153 Find Minimum in Rotated Sorted Array-zh.md",key:"v-06229c47",path:"/p/67e5b5/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:42},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:734},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:804},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1172},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1556},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1918},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2248},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:229}],headersStr:"题目描述 解法 Python3 Java C++ Go JavaScript ...",content:"# 153. 寻找旋转排序数组中的最小值\n\nEnglish Version\n\n\n# 题目描述\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：\n\n * 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]\n * 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]\n\n\n\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n\n给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n\n \n\n示例 1：\n\n\n输入：nums = [3,4,5,1,2]\n输出：1\n解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n\n\n示例 2：\n\n\n输入：nums = [4,5,6,7,0,1,2]\n输出：0\n解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n\n\n示例 3：\n\n\n输入：nums = [11,13,15,17]\n输出：11\n解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n\n\n \n\n提示：\n\n * n == nums.length\n * 1 <= n <= 5000\n * -5000 <= nums[i] <= 5000\n * nums 中的所有整数 互不相同\n * nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转\n\n\n# 解法\n\n二分查找。\n\n若 nums[m] > nums[r]，说明最小值在 m 的右边，否则说明最小值在 m 的左边（包括 m）。\n\n\n# Python3\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        if nums[l] < nums[r]:\n            return nums[0]\n        while l < r:\n            m = (l + r) >> 1\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n        return nums[l]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        // 说明是递增顺序，直接返回第一个元素\n        if (nums[l] < nums[r]) return nums[0];\n        while (l < r) {\n            int m = (l + r) >>> 1;\n            if (nums[m] > nums[r]) l = m + 1;\n            else r = m;\n        }\n        return nums[l];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1;\n        if (nums[l] < nums[r]) return nums[0];\n        while (l < r) {\n            int m = (l + r) >> 1;\n            if (nums[m] > nums[r]) l = m + 1;\n            else r = m;\n        }\n        return nums[l];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Go\n\nfunc findMin(nums []int) int {\n    l, r := 0, len(nums) - 1\n    if nums[l] < nums[r] {\n        return nums[0]\n    }\n    for l < r {\n        m := (l + r) >> 1\n        if nums[m] > nums[r] {\n            l = m + 1\n        } else {\n            r = m\n        }\n    }\n    return nums[l]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function (nums) {\n  let l = 0,\n    r = nums.length - 1;\n  if (nums[l] < nums[r]) return nums[0];\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (nums[m] > nums[r]) l = m + 1;\n    else r = m;\n  }\n  return nums[l];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 153. 寻找旋转排序数组中的最小值\n\nenglish version\n\n\n# 题目描述\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：\n\n * 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]\n * 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]\n\n\n\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n\n给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n\n \n\n示例 1：\n\n\n输入：nums = [3,4,5,1,2]\n输出：1\n解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n\n\n示例 2：\n\n\n输入：nums = [4,5,6,7,0,1,2]\n输出：0\n解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n\n\n示例 3：\n\n\n输入：nums = [11,13,15,17]\n输出：11\n解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n\n\n \n\n提示：\n\n * n == nums.length\n * 1 <= n <= 5000\n * -5000 <= nums[i] <= 5000\n * nums 中的所有整数 互不相同\n * nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转\n\n\n# 解法\n\n二分查找。\n\n若 nums[m] > nums[r]，说明最小值在 m 的右边，否则说明最小值在 m 的左边（包括 m）。\n\n\n# python3\n\nclass solution:\n    def findmin(self, nums: list[int]) -> int:\n        l, r = 0, len(nums) - 1\n        if nums[l] < nums[r]:\n            return nums[0]\n        while l < r:\n            m = (l + r) >> 1\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n        return nums[l]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public int findmin(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        // 说明是递增顺序，直接返回第一个元素\n        if (nums[l] < nums[r]) return nums[0];\n        while (l < r) {\n            int m = (l + r) >>> 1;\n            if (nums[m] > nums[r]) l = m + 1;\n            else r = m;\n        }\n        return nums[l];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# c++\n\nclass solution {\npublic:\n    int findmin(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1;\n        if (nums[l] < nums[r]) return nums[0];\n        while (l < r) {\n            int m = (l + r) >> 1;\n            if (nums[m] > nums[r]) l = m + 1;\n            else r = m;\n        }\n        return nums[l];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# go\n\nfunc findmin(nums []int) int {\n    l, r := 0, len(nums) - 1\n    if nums[l] < nums[r] {\n        return nums[0]\n    }\n    for l < r {\n        m := (l + r) >> 1\n        if nums[m] > nums[r] {\n            l = m + 1\n        } else {\n            r = m\n        }\n    }\n    return nums[l]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findmin = function (nums) {\n  let l = 0,\n    r = nums.length - 1;\n  if (nums[l] < nums[r]) return nums[0];\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (nums[m] > nums[r]) l = m + 1;\n    else r = m;\n  }\n  return nums[l];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode154 Find Minimum in Rotated Sorted Array II-zh",frontmatter:{title:"leetcode154 Find Minimum in Rotated Sorted Array II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/9d0183/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode154 Find Minimum in Rotated Sorted Array II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10154.leetcode154%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode154 Find Minimum in Rotated Sorted Array II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10154.leetcode154%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode154 Find Minimum in Rotated Sorted Array II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10154.leetcode154%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II-zh.html",relativePath:"01.算法/24.leetcode/10154.leetcode154 Find Minimum in Rotated Sorted Array II-zh.md",key:"v-8d798c44",path:"/p/9d0183/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:45},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:629},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:758},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1128},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1478},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1838},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:232}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript ...",content:"# 154. 寻找旋转排序数组中的最小值 II\n\nEnglish Version\n\n\n# 题目描述\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：\n\n * 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]\n * 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]\n\n\n\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n\n给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n\n \n\n示例 1：\n\n\n输入：nums = [1,3,5]\n输出：1\n\n\n示例 2：\n\n\n输入：nums = [2,2,2,0,1]\n输出：0\n\n\n \n\n提示：\n\n * n == nums.length\n * 1 <= n <= 5000\n * -5000 <= nums[i] <= 5000\n * nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转\n\n \n\n进阶：\n\n * 这道题是 寻找旋转排序数组中的最小值 的延伸题目。\n * 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？\n\n\n# 解法\n\n二分法。\n\n若 nums[m] > nums[r]，说明最小值在 m 的右边；若 nums[m] < nums[r]，说明最小值在 m 的左边（包括 m）；若相等，无法判断，直接将 r 减 1。循环比较。\n\n最后返回 nums[l] 即可。\n\n\n# Python3\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) >> 1\n            if nums[m] > nums[r]:\n                l = m + 1\n            elif nums[m] < nums[r]:\n                r = m\n            else:\n                r -= 1\n        return nums[l]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while (l < r) {\n            int m = (l + r) >>> 1;\n            if (nums[m] > nums[r]) l = m + 1;\n            else if (nums[m] < nums[r]) r = m;\n            else --r;\n        }\n        return nums[l];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int m = (l + r) >> 1;\n            if (nums[m] > nums[r]) l = m + 1;\n            else if (nums[m] < nums[r]) r = m;\n            else --r;\n        }\n        return nums[l];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function (nums) {\n  let l = 0,\n    r = nums.length - 1;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (nums[m] > nums[r]) l = m + 1;\n    else if (nums[m] < nums[r]) r = m;\n    else --r;\n  }\n  return nums[l];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 154. 寻找旋转排序数组中的最小值 ii\n\nenglish version\n\n\n# 题目描述\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：\n\n * 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]\n * 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]\n\n\n\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n\n给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n\n \n\n示例 1：\n\n\n输入：nums = [1,3,5]\n输出：1\n\n\n示例 2：\n\n\n输入：nums = [2,2,2,0,1]\n输出：0\n\n\n \n\n提示：\n\n * n == nums.length\n * 1 <= n <= 5000\n * -5000 <= nums[i] <= 5000\n * nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转\n\n \n\n进阶：\n\n * 这道题是 寻找旋转排序数组中的最小值 的延伸题目。\n * 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？\n\n\n# 解法\n\n二分法。\n\n若 nums[m] > nums[r]，说明最小值在 m 的右边；若 nums[m] < nums[r]，说明最小值在 m 的左边（包括 m）；若相等，无法判断，直接将 r 减 1。循环比较。\n\n最后返回 nums[l] 即可。\n\n\n# python3\n\nclass solution:\n    def findmin(self, nums: list[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) >> 1\n            if nums[m] > nums[r]:\n                l = m + 1\n            elif nums[m] < nums[r]:\n                r = m\n            else:\n                r -= 1\n        return nums[l]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public int findmin(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while (l < r) {\n            int m = (l + r) >>> 1;\n            if (nums[m] > nums[r]) l = m + 1;\n            else if (nums[m] < nums[r]) r = m;\n            else --r;\n        }\n        return nums[l];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# c++\n\nclass solution {\npublic:\n    int findmin(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int m = (l + r) >> 1;\n            if (nums[m] > nums[r]) l = m + 1;\n            else if (nums[m] < nums[r]) r = m;\n            else --r;\n        }\n        return nums[l];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findmin = function (nums) {\n  let l = 0,\n    r = nums.length - 1;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (nums[m] > nums[r]) l = m + 1;\n    else if (nums[m] < nums[r]) r = m;\n    else --r;\n  }\n  return nums[l];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode155 Min Stack-zh",frontmatter:{title:"leetcode155 Min Stack-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a7d71e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode155 Min Stack-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10155.leetcode155%20Min%20Stack-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode155 Min Stack-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10155.leetcode155%20Min%20Stack-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode155 Min Stack-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10155.leetcode155%20Min%20Stack-zh.html",relativePath:"01.算法/24.leetcode/10155.leetcode155 Min Stack-zh.md",key:"v-8d89c36a",path:"/p/a7d71e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:581},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:598},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1321},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2195},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2947},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3929}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript ...",content:'# 155. 最小栈\n\nEnglish Version\n\n\n# 题目描述\n\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\n * push(x) —— 将元素 x 推入栈中。\n * pop() —— 删除栈顶的元素。\n * top() —— 获取栈顶元素。\n * getMin() —— 检索栈中的最小元素。\n\n \n\n示例:\n\n输入：\n["MinStack","push","push","push","getMin","pop","top","getMin"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --\x3e 返回 -3.\nminStack.pop();\nminStack.top();      --\x3e 返回 0.\nminStack.getMin();   --\x3e 返回 -2.\n\n\n \n\n提示：\n\n * pop、top 和 getMin 操作总是在 非空栈 上调用。\n\n\n# 解法\n\n“辅助栈”实现。\n\n\n# Python3\n\nclass MinStack:\n\n    def __init__(self):\n        """\n        initialize your data structure here.\n        """\n        self.s = []\n        self.mins = [float(\'inf\')]\n\n    def push(self, val: int) -> None:\n        self.s.append(val)\n        self.mins.append(min(self.mins[-1], val))\n\n    def pop(self) -> None:\n        self.s.pop()\n        self.mins.pop()\n\n    def top(self) -> int:\n        return self.s[-1]\n\n    def getMin(self) -> int:\n        return self.mins[-1]\n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# Java\n\nclass MinStack {\n    private Deque<Integer> s;\n    private Deque<Integer> mins;\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        s = new ArrayDeque<>();\n        mins = new ArrayDeque<>();\n        mins.push(Integer.MAX_VALUE);\n    }\n\n    public void push(int val) {\n        s.push(val);\n        mins.push(Math.min(mins.peek(), val));\n    }\n\n    public void pop() {\n        s.pop();\n        mins.pop();\n    }\n\n    public int top() {\n        return s.peek();\n    }\n\n    public int getMin() {\n        return mins.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# C++\n\nclass MinStack {\nprivate:\n    stack<int> s;\n    stack<int> mins;\n\npublic:\n    /** initialize your data structure here. */\n    MinStack() {\n        mins.push(INT_MAX);\n    }\n\n    void push(int val) {\n        s.push(val);\n        mins.push(min(mins.top(), val));\n    }\n\n    void pop() {\n        s.pop();\n        mins.pop();\n    }\n\n    int top() {\n        return s.top();\n    }\n\n    int getMin() {\n        return mins.top();\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# JavaScript\n\n/**\n * initialize your data structure here.\n */\nvar MinStack = function() {\n    this.s = [];\n    this.mins = [Infinity];\n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nMinStack.prototype.push = function(val) {\n    this.s.push(val);\n    this.mins.push(Math.min(this.mins[this.mins.length - 1], val));\n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function() {\n    this.s.pop();\n    this.mins.pop();\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function() {\n    return this.s[this.s.length - 1];\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function() {\n    return this.mins[this.mins.length - 1];\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(val)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 155. 最小栈\n\nenglish version\n\n\n# 题目描述\n\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\n * push(x) —— 将元素 x 推入栈中。\n * pop() —— 删除栈顶的元素。\n * top() —— 获取栈顶元素。\n * getmin() —— 检索栈中的最小元素。\n\n \n\n示例:\n\n输入：\n["minstack","push","push","push","getmin","pop","top","getmin"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nminstack minstack = new minstack();\nminstack.push(-2);\nminstack.push(0);\nminstack.push(-3);\nminstack.getmin();   --\x3e 返回 -3.\nminstack.pop();\nminstack.top();      --\x3e 返回 0.\nminstack.getmin();   --\x3e 返回 -2.\n\n\n \n\n提示：\n\n * pop、top 和 getmin 操作总是在 非空栈 上调用。\n\n\n# 解法\n\n“辅助栈”实现。\n\n\n# python3\n\nclass minstack:\n\n    def __init__(self):\n        """\n        initialize your data structure here.\n        """\n        self.s = []\n        self.mins = [float(\'inf\')]\n\n    def push(self, val: int) -> none:\n        self.s.append(val)\n        self.mins.append(min(self.mins[-1], val))\n\n    def pop(self) -> none:\n        self.s.pop()\n        self.mins.pop()\n\n    def top(self) -> int:\n        return self.s[-1]\n\n    def getmin(self) -> int:\n        return self.mins[-1]\n\n\n# your minstack object will be instantiated and called as such:\n# obj = minstack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getmin()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# java\n\nclass minstack {\n    private deque<integer> s;\n    private deque<integer> mins;\n\n    /** initialize your data structure here. */\n    public minstack() {\n        s = new arraydeque<>();\n        mins = new arraydeque<>();\n        mins.push(integer.max_value);\n    }\n\n    public void push(int val) {\n        s.push(val);\n        mins.push(math.min(mins.peek(), val));\n    }\n\n    public void pop() {\n        s.pop();\n        mins.pop();\n    }\n\n    public int top() {\n        return s.peek();\n    }\n\n    public int getmin() {\n        return mins.peek();\n    }\n}\n\n/**\n * your minstack object will be instantiated and called as such:\n * minstack obj = new minstack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getmin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# c++\n\nclass minstack {\nprivate:\n    stack<int> s;\n    stack<int> mins;\n\npublic:\n    /** initialize your data structure here. */\n    minstack() {\n        mins.push(int_max);\n    }\n\n    void push(int val) {\n        s.push(val);\n        mins.push(min(mins.top(), val));\n    }\n\n    void pop() {\n        s.pop();\n        mins.pop();\n    }\n\n    int top() {\n        return s.top();\n    }\n\n    int getmin() {\n        return mins.top();\n    }\n};\n\n/**\n * your minstack object will be instantiated and called as such:\n * minstack* obj = new minstack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getmin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# javascript\n\n/**\n * initialize your data structure here.\n */\nvar minstack = function() {\n    this.s = [];\n    this.mins = [infinity];\n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nminstack.prototype.push = function(val) {\n    this.s.push(val);\n    this.mins.push(math.min(this.mins[this.mins.length - 1], val));\n};\n\n/**\n * @return {void}\n */\nminstack.prototype.pop = function() {\n    this.s.pop();\n    this.mins.pop();\n};\n\n/**\n * @return {number}\n */\nminstack.prototype.top = function() {\n    return this.s[this.s.length - 1];\n};\n\n/**\n * @return {number}\n */\nminstack.prototype.getmin = function() {\n    return this.mins[this.mins.length - 1];\n};\n\n/**\n * your minstack object will be instantiated and called as such:\n * var obj = new minstack()\n * obj.push(val)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getmin()\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode156 Binary Tree Upside Down-zh",frontmatter:{title:"leetcode156 Binary Tree Upside Down-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/357d2e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode156 Binary Tree Upside Down-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10156.leetcode156%20Binary%20Tree%20Upside%20Down-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode156 Binary Tree Upside Down-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10156.leetcode156%20Binary%20Tree%20Upside%20Down-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode156 Binary Tree Upside Down-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10156.leetcode156%20Binary%20Tree%20Upside%20Down-zh.html",relativePath:"01.算法/24.leetcode/10156.leetcode156 Binary Tree Upside Down-zh.md",key:"v-f1ed640a",path:"/p/357d2e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:439},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:446},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:465},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:481}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 156. 上下翻转二叉树\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，其中所有的右节点要么是具有兄弟节点（拥有相同父节点的左节点）的叶节点，要么为空，将此二叉树上下翻转并将它变成一棵树， 原来的右节点将转换成左叶节点。返回新的根。\n\n例子:\n\n输入: [1,2,3,4,5]\n\n    1\n   / \\\n  2   3\n / \\\n4   5\n\n输出: 返回二叉树的根 [4,5,2,#,#,3,1]\n\n   4\n  / \\\n 5   2\n    / \\\n   3   1  \n\n\n说明:\n\n对 [4,5,2,#,#,3,1] 感到困惑? 下面详细介绍请查看 二叉树是如何被序列化的。\n\n二叉树的序列化遵循层次遍历规则，当没有节点存在时，'#' 表示路径终止符。\n\n这里有一个例子:\n\n   1\n  / \\\n 2   3\n    /\n   4\n    \\\n     5\n\n\n上面的二叉树则被序列化为 [1,2,3,#,#,4,#,#,5].\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 156. 上下翻转二叉树\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，其中所有的右节点要么是具有兄弟节点（拥有相同父节点的左节点）的叶节点，要么为空，将此二叉树上下翻转并将它变成一棵树， 原来的右节点将转换成左叶节点。返回新的根。\n\n例子:\n\n输入: [1,2,3,4,5]\n\n    1\n   / \\\n  2   3\n / \\\n4   5\n\n输出: 返回二叉树的根 [4,5,2,#,#,3,1]\n\n   4\n  / \\\n 5   2\n    / \\\n   3   1  \n\n\n说明:\n\n对 [4,5,2,#,#,3,1] 感到困惑? 下面详细介绍请查看 二叉树是如何被序列化的。\n\n二叉树的序列化遵循层次遍历规则，当没有节点存在时，'#' 表示路径终止符。\n\n这里有一个例子:\n\n   1\n  / \\\n 2   3\n    /\n   4\n    \\\n     5\n\n\n上面的二叉树则被序列化为 [1,2,3,#,#,4,#,#,5].\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode157 Read N Characters Given Read4-zh",frontmatter:{title:"leetcode157 Read N Characters Given Read4-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/11e2e0/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode157 Read N Characters Given Read4-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10157.leetcode157%20Read%20N%20Characters%20Given%20Read4-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode157 Read N Characters Given Read4-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10157.leetcode157%20Read%20N%20Characters%20Given%20Read4-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode157 Read N Characters Given Read4-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10157.leetcode157%20Read%20N%20Characters%20Given%20Read4-zh.html",relativePath:"01.算法/24.leetcode/10157.leetcode157 Read N Characters Given Read4-zh.md",key:"v-ad145af8",path:"/p/11e2e0/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:45},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1363},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1370},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1389},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1405}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 157. 用 Read4 读取 N 个字符\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个文件，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法使其能够读取 n 个字符。\n\nread4 方法：\n\nAPI read4 可以从文件中读取 4 个连续的字符，并且将它们写入缓存数组 buf 中。\n\n返回值为实际读取的字符个数。\n\n注意 read4() 自身拥有文件指针，很类似于 C 语言中的 FILE *fp 。\n\nread4 的定义：\n\n参数类型: char[] buf4\n返回类型: int\n\n注意: buf4[] 是目标缓存区不是源缓存区，read4 的返回结果将会复制到 buf4[] 当中。\n\n\n下列是一些使用 read4 的例子：\n\n\n\nFile file("abcde"); // 文件名为 "abcde"， 初始文件指针 (fp) 指向 \'a\' \nchar[] buf4 = new char[4]; // 创建一个缓存区使其能容纳足够的字符\nread4(buf4); // read4 返回 4。现在 buf4 = "abcd"，fp 指向 \'e\'\nread4(buf4); // read4 返回 1。现在 buf4 = "e"，fp 指向文件末尾\nread4(buf4); // read4 返回 0。现在 buf = ""，fp 指向文件末尾\n\nread 方法：\n\n通过使用 read4 方法，实现 read 方法。该方法可以从文件中读取 n 个字符并将其存储到缓存数组 buf 中。您 不能 直接操作文件。\n\n返回值为实际读取的字符。\n\nread 的定义：\n\n参数类型:   char[] buf, int n\n返回类型:   int\n\n注意: buf[] 是目标缓存区不是源缓存区，你需要将结果写入 buf[] 中。\n\n\n \n\n示例 1：\n\n输入： file = "abc", n = 4\n输出： 3\n解释： 当执行你的 read 方法后，buf 需要包含 "abc"。 文件一共 3 个字符，因此返回 3。 注意 "abc" 是文件的内容，不是 buf 的内容，buf 是你需要写入结果的目标缓存区。 \n\n示例 2：\n\n输入： file = "abcde", n = 5\n输出： 5\n解释： 当执行你的 read 方法后，buf 需要包含 "abcde"。文件共 5 个字符，因此返回 5。\n\n\n示例 3:\n\n输入： file = "abcdABCD1234", n = 12\n输出： 12\n解释： 当执行你的 read 方法后，buf 需要包含 "abcdABCD1234"。文件一共 12 个字符，因此返回 12。\n\n\n示例 4:\n\n输入： file = "leetcode", n = 5\n输出： 5\n解释： 当执行你的 read 方法后，buf 需要包含 "leetc"。文件中一共 5 个字符，因此返回 5。\n\n\n \n\n提示：\n\n * 你 不能 直接操作该文件，文件只能通过 read4 获取而 不能 通过 read。\n * read  函数只在每个测试用例调用一次。\n * 你可以假定目标缓存数组 buf 保证有足够的空间存下 n 个字符。 \n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 157. 用 read4 读取 n 个字符\n\nenglish version\n\n\n# 题目描述\n\n给你一个文件，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法使其能够读取 n 个字符。\n\nread4 方法：\n\napi read4 可以从文件中读取 4 个连续的字符，并且将它们写入缓存数组 buf 中。\n\n返回值为实际读取的字符个数。\n\n注意 read4() 自身拥有文件指针，很类似于 c 语言中的 file *fp 。\n\nread4 的定义：\n\n参数类型: char[] buf4\n返回类型: int\n\n注意: buf4[] 是目标缓存区不是源缓存区，read4 的返回结果将会复制到 buf4[] 当中。\n\n\n下列是一些使用 read4 的例子：\n\n\n\nfile file("abcde"); // 文件名为 "abcde"， 初始文件指针 (fp) 指向 \'a\' \nchar[] buf4 = new char[4]; // 创建一个缓存区使其能容纳足够的字符\nread4(buf4); // read4 返回 4。现在 buf4 = "abcd"，fp 指向 \'e\'\nread4(buf4); // read4 返回 1。现在 buf4 = "e"，fp 指向文件末尾\nread4(buf4); // read4 返回 0。现在 buf = ""，fp 指向文件末尾\n\nread 方法：\n\n通过使用 read4 方法，实现 read 方法。该方法可以从文件中读取 n 个字符并将其存储到缓存数组 buf 中。您 不能 直接操作文件。\n\n返回值为实际读取的字符。\n\nread 的定义：\n\n参数类型:   char[] buf, int n\n返回类型:   int\n\n注意: buf[] 是目标缓存区不是源缓存区，你需要将结果写入 buf[] 中。\n\n\n \n\n示例 1：\n\n输入： file = "abc", n = 4\n输出： 3\n解释： 当执行你的 read 方法后，buf 需要包含 "abc"。 文件一共 3 个字符，因此返回 3。 注意 "abc" 是文件的内容，不是 buf 的内容，buf 是你需要写入结果的目标缓存区。 \n\n示例 2：\n\n输入： file = "abcde", n = 5\n输出： 5\n解释： 当执行你的 read 方法后，buf 需要包含 "abcde"。文件共 5 个字符，因此返回 5。\n\n\n示例 3:\n\n输入： file = "abcdabcd1234", n = 12\n输出： 12\n解释： 当执行你的 read 方法后，buf 需要包含 "abcdabcd1234"。文件一共 12 个字符，因此返回 12。\n\n\n示例 4:\n\n输入： file = "leetcode", n = 5\n输出： 5\n解释： 当执行你的 read 方法后，buf 需要包含 "leetc"。文件中一共 5 个字符，因此返回 5。\n\n\n \n\n提示：\n\n * 你 不能 直接操作该文件，文件只能通过 read4 获取而 不能 通过 read。\n * read  函数只在每个测试用例调用一次。\n * 你可以假定目标缓存数组 buf 保证有足够的空间存下 n 个字符。 \n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode158 Read N Characters Given Read4 II - Call multiple times-zh",frontmatter:{title:"leetcode158 Read N Characters Given Read4 II - Call multiple times-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/638bc7/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0158.Read%20N%20Characters%20Given%20Read4%20II%20-%20Call%20multiple%20times/images/157_example.png"},{name:"twitter:title",content:"leetcode158 Read N Characters Given Read4 II - Call multiple times-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0158.Read%20N%20Characters%20Given%20Read4%20II%20-%20Call%20multiple%20times/images/157_example.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10158.leetcode158%20Read%20N%20Characters%20Given%20Read4%20II%20-%20Call%20multiple%20times-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode158 Read N Characters Given Read4 II - Call multiple times-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0158.Read%20N%20Characters%20Given%20Read4%20II%20-%20Call%20multiple%20times/images/157_example.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10158.leetcode158%20Read%20N%20Characters%20Given%20Read4%20II%20-%20Call%20multiple%20times-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode158 Read N Characters Given Read4 II - Call multiple times-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0158.Read%20N%20Characters%20Given%20Read4%20II%20-%20Call%20multiple%20times/images/157_example.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10158.leetcode158%20Read%20N%20Characters%20Given%20Read4%20II%20-%20Call%20multiple%20times-zh.html",relativePath:"01.算法/24.leetcode/10158.leetcode158 Read N Characters Given Read4 II - Call multiple times-zh.md",key:"v-604efc27",path:"/p/638bc7/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:48},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1461},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1468},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1487},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1503}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 158. 用 Read4 读取 N 个字符 II\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个文件，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法使其能够读取 n 个字符。注意：你的 read 方法可能会被调用多次。\n\nread4 的定义：\n\nread4 API 从文件中读取 4 个连续的字符，然后将这些字符写入缓冲区数组 buf4 。\n\n返回值是读取的实际字符数。\n\n请注意，read4() 有其自己的文件指针，类似于 C 中的 FILE * fp 。\n\n\n参数类型: char[] buf4\n返回类型: int\n\n注意: buf4[] 是目标缓存区不是源缓存区，read4 的返回结果将会复制到 buf4[] 当中。\n\n\n下列是一些使用 read4 的例子：\n\n\n\n\nFile file("abcde"); // 文件名为 "abcde"， 初始文件指针 (fp) 指向 \'a\' \nchar[] buf4 = new char[4]; // 创建一个缓存区使其能容纳足够的字符\nread4(buf4); // read4 返回 4。现在 buf4 = "abcd"，fp 指向 \'e\'\nread4(buf4); // read4 返回 1。现在 buf4 = "e"，fp 指向文件末尾\nread4(buf4); // read4 返回 0。现在 buf4 = ""，fp 指向文件末尾\n\nread 方法：\n\n通过使用 read4 方法，实现 read 方法。该方法可以从文件中读取 n 个字符并将其存储到缓存数组 buf 中。您 不能 直接操作文件。\n\n返回值为实际读取的字符。\n\nread 的定义：\n\n\n参数:   char[] buf, int n\n返回值: int\n\n注意: buf[] 是目标缓存区不是源缓存区，你需要将结果写入 buf[] 中。\n\n\n \n\n示例 1：\n\n\nFile file("abc");\nSolution sol;\n// 假定 buf 已经被分配了内存，并且有足够的空间来存储文件中的所有字符。\nsol.read(buf, 1); // 当调用了您的 read 方法后，buf 需要包含 "a"。 一共读取 1 个字符，因此返回 1。\nsol.read(buf, 2); // 现在 buf 需要包含 "bc"。一共读取 2 个字符，因此返回 2。\nsol.read(buf, 1); // 由于已经到达了文件末尾，没有更多的字符可以读取，因此返回 0。\n\n\n示例 2：\n\n\nFile file("abc");\nSolution sol;\nsol.read(buf, 4); // 当调用了您的 read 方法后，buf 需要包含 "abc"。 一共只能读取 3 个字符，因此返回 3。\nsol.read(buf, 1); // 由于已经到达了文件末尾，没有更多的字符可以读取，因此返回 0。\n\n\n \n\n提示：\n\n * 你 不能 直接操作该文件，文件只能通过 read4 获取而 不能 通过 read。\n * read  函数可以被调用 多次。\n * 请记得 重置 在 Solution 中声明的类变量（静态变量），因为类变量会 在多个测试用例中保持不变，影响判题准确。请 查阅 这里。\n * 你可以假定目标缓存数组 buf 保证有足够的空间存下 n 个字符。 \n * 保证在一个给定测试用例中，read 函数使用的是同一个 buf。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 158. 用 read4 读取 n 个字符 ii\n\nenglish version\n\n\n# 题目描述\n\n给你一个文件，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法使其能够读取 n 个字符。注意：你的 read 方法可能会被调用多次。\n\nread4 的定义：\n\nread4 api 从文件中读取 4 个连续的字符，然后将这些字符写入缓冲区数组 buf4 。\n\n返回值是读取的实际字符数。\n\n请注意，read4() 有其自己的文件指针，类似于 c 中的 file * fp 。\n\n\n参数类型: char[] buf4\n返回类型: int\n\n注意: buf4[] 是目标缓存区不是源缓存区，read4 的返回结果将会复制到 buf4[] 当中。\n\n\n下列是一些使用 read4 的例子：\n\n\n\n\nfile file("abcde"); // 文件名为 "abcde"， 初始文件指针 (fp) 指向 \'a\' \nchar[] buf4 = new char[4]; // 创建一个缓存区使其能容纳足够的字符\nread4(buf4); // read4 返回 4。现在 buf4 = "abcd"，fp 指向 \'e\'\nread4(buf4); // read4 返回 1。现在 buf4 = "e"，fp 指向文件末尾\nread4(buf4); // read4 返回 0。现在 buf4 = ""，fp 指向文件末尾\n\nread 方法：\n\n通过使用 read4 方法，实现 read 方法。该方法可以从文件中读取 n 个字符并将其存储到缓存数组 buf 中。您 不能 直接操作文件。\n\n返回值为实际读取的字符。\n\nread 的定义：\n\n\n参数:   char[] buf, int n\n返回值: int\n\n注意: buf[] 是目标缓存区不是源缓存区，你需要将结果写入 buf[] 中。\n\n\n \n\n示例 1：\n\n\nfile file("abc");\nsolution sol;\n// 假定 buf 已经被分配了内存，并且有足够的空间来存储文件中的所有字符。\nsol.read(buf, 1); // 当调用了您的 read 方法后，buf 需要包含 "a"。 一共读取 1 个字符，因此返回 1。\nsol.read(buf, 2); // 现在 buf 需要包含 "bc"。一共读取 2 个字符，因此返回 2。\nsol.read(buf, 1); // 由于已经到达了文件末尾，没有更多的字符可以读取，因此返回 0。\n\n\n示例 2：\n\n\nfile file("abc");\nsolution sol;\nsol.read(buf, 4); // 当调用了您的 read 方法后，buf 需要包含 "abc"。 一共只能读取 3 个字符，因此返回 3。\nsol.read(buf, 1); // 由于已经到达了文件末尾，没有更多的字符可以读取，因此返回 0。\n\n\n \n\n提示：\n\n * 你 不能 直接操作该文件，文件只能通过 read4 获取而 不能 通过 read。\n * read  函数可以被调用 多次。\n * 请记得 重置 在 solution 中声明的类变量（静态变量），因为类变量会 在多个测试用例中保持不变，影响判题准确。请 查阅 这里。\n * 你可以假定目标缓存数组 buf 保证有足够的空间存下 n 个字符。 \n * 保证在一个给定测试用例中，read 函数使用的是同一个 buf。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode159 Longest Substring with At Most Two Distinct Characters-zh",frontmatter:{title:"leetcode159 Longest Substring with At Most Two Distinct Characters-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/13bb7d/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode159 Longest Substring with At Most Two Distinct Characters-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10159.leetcode159%20Longest%20Substring%20with%20At%20Most%20Two%20Distinct%20Characters-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode159 Longest Substring with At Most Two Distinct Characters-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10159.leetcode159%20Longest%20Substring%20with%20At%20Most%20Two%20Distinct%20Characters-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode159 Longest Substring with At Most Two Distinct Characters-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10159.leetcode159%20Longest%20Substring%20with%20At%20Most%20Two%20Distinct%20Characters-zh.html",relativePath:"01.算法/24.leetcode/10159.leetcode159 Longest Substring with At Most Two Distinct Characters-zh.md",key:"v-2e8ac566",path:"/p/13bb7d/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:44},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:197},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:204},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:223},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:239}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 159. 至多包含两个不同字符的最长子串\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t ，并返回该子串的长度。\n\n示例 1:\n\n输入: "eceba"\n输出: 3\n解释: t 是 "ece"，长度为3。\n\n\n示例 2:\n\n输入: "ccaabbb"\n输出: 5\n解释: t 是 "aabbb"，长度为5。\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 159. 至多包含两个不同字符的最长子串\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t ，并返回该子串的长度。\n\n示例 1:\n\n输入: "eceba"\n输出: 3\n解释: t 是 "ece"，长度为3。\n\n\n示例 2:\n\n输入: "ccaabbb"\n输出: 5\n解释: t 是 "aabbb"，长度为5。\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode160 Intersection of Two Linked Lists-zh",frontmatter:{title:"leetcode160 Intersection of Two Linked Lists-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/8e04cc/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0160.Intersection%20of%20Two%20Linked%20Lists/images/160_statement.png"},{name:"twitter:title",content:"leetcode160 Intersection of Two Linked Lists-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0160.Intersection%20of%20Two%20Linked%20Lists/images/160_statement.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10160.leetcode160%20Intersection%20of%20Two%20Linked%20Lists-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode160 Intersection of Two Linked Lists-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0160.Intersection%20of%20Two%20Linked%20Lists/images/160_statement.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10160.leetcode160%20Intersection%20of%20Two%20Linked%20Lists-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode160 Intersection of Two Linked Lists-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0160.Intersection%20of%20Two%20Linked%20Lists/images/160_statement.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10160.leetcode160%20Intersection%20of%20Two%20Linked%20Lists-zh.html",relativePath:"01.算法/24.leetcode/10160.leetcode160 Intersection of Two Linked Lists-zh.md",key:"v-03f0b06c",path:"/p/8e04cc/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:941},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1139},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1611},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2191},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2735},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:3240},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:3777},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4447}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go TypeScript ...",content:"# 160. 相交链表\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个程序，找到两个单链表相交的起始节点。\n\n如下面的两个链表：\n\n\n\n在节点 c1 开始相交。\n\n \n\n示例 1：\n\n\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n \n\n示例 2：\n\n\n\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n \n\n示例 3：\n\n\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n\n\n \n\n注意：\n\n * 如果两个链表没有交点，返回 null.\n * 在返回结果后，两个链表仍须保持原有的结构。\n * 可假定整个链表结构中没有循环。\n * 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\n\n\n# 解法\n\n使用两个指针 cur1, cur2 分别指向两个链表 headA, headB。\n\n同时遍历链表，当 cur1 到达链表 headA 的末尾时，重新定位到链表 headB 的头节点；当 cur2 到达链表 headB 的末尾时，重新定位到链表 headA 的头节点。\n\n若两指针相遇，所指向的结点就是第一个公共节点。若没相遇，说明两链表无公共节点，此时两个指针都指向 null。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        cur1, cur2 = headA, headB\n        while cur1 != cur2:\n            cur1 = headB if cur1 is None else cur1.next\n            cur2 = headA if cur2 is None else cur2.next\n        return cur1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode cur1 = headA, cur2 = headB;\n        while (cur1 != cur2) {\n            cur1 = cur1 == null ? headB : cur1.next;\n            cur2 = cur2 == null ? headA : cur2.next;\n        }\n        return cur1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* cur1 = headA;\n        ListNode* cur2 = headB;\n        while (cur1 != cur2) {\n            cur1 = cur1 ? cur1->next : headB;\n            cur2 = cur2 ? cur2->next : headA;\n        }\n        return cur1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\n var getIntersectionNode = function(headA, headB) {\n  let cur1 = headA;\n  let cur2 = headB;\n  while (cur1 != cur2) {\n      cur1 = cur1 ? cur1.next : headB;\n      cur2 = cur2 ? cur2.next : headA;\n  }\n  return cur1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n func getIntersectionNode(headA, headB *ListNode) *ListNode {\n    cur1, cur2 := headA, headB\n    for cur1 != cur2 {\n        if cur1 == nil {\n            cur1 = headB\n        } else {\n            cur1 = cur1.Next\n        }\n        if cur2 == nil {\n            cur2 = headA\n        } else {\n            cur2 = cur2.Next\n        }\n    }\n    return cur1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# TypeScript\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    let p1: ListNode | null = headA;\n    let p2: ListNode | null = headB;\n    while (p1 != p2) {\n        p1 = p1 == null ? headB : p1.next;\n        p2 = p2 == null ? headA : p2.next;\n    }\n    return p1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 160. 相交链表\n\nenglish version\n\n\n# 题目描述\n\n编写一个程序，找到两个单链表相交的起始节点。\n\n如下面的两个链表：\n\n\n\n在节点 c1 开始相交。\n\n \n\n示例 1：\n\n\n\n输入：intersectval = 8, lista = [4,1,8,4,5], listb = [5,0,1,8,4,5], skipa = 2, skipb = 3\n输出：reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 a 为 [4,1,8,4,5]，链表 b 为 [5,0,1,8,4,5]。在 a 中，相交节点前有 2 个节点；在 b 中，相交节点前有 3 个节点。\n\n\n \n\n示例 2：\n\n\n\n输入：intersectval = 2, lista = [0,9,1,2,4], listb = [3,2,4], skipa = 3, skipb = 1\n输出：reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 a 为 [0,9,1,2,4]，链表 b 为 [3,2,4]。在 a 中，相交节点前有 3 个节点；在 b 中，相交节点前有 1 个节点。\n\n\n \n\n示例 3：\n\n\n\n输入：intersectval = 0, lista = [2,6,4], listb = [1,5], skipa = 3, skipb = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 a 为 [2,6,4]，链表 b 为 [1,5]。由于这两个链表不相交，所以 intersectval 必须为 0，而 skipa 和 skipb 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n\n\n \n\n注意：\n\n * 如果两个链表没有交点，返回 null.\n * 在返回结果后，两个链表仍须保持原有的结构。\n * 可假定整个链表结构中没有循环。\n * 程序尽量满足 o(n) 时间复杂度，且仅用 o(1) 内存。\n\n\n# 解法\n\n使用两个指针 cur1, cur2 分别指向两个链表 heada, headb。\n\n同时遍历链表，当 cur1 到达链表 heada 的末尾时，重新定位到链表 headb 的头节点；当 cur2 到达链表 headb 的末尾时，重新定位到链表 heada 的头节点。\n\n若两指针相遇，所指向的结点就是第一个公共节点。若没相遇，说明两链表无公共节点，此时两个指针都指向 null。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def getintersectionnode(self, heada: listnode, headb: listnode) -> listnode:\n        cur1, cur2 = heada, headb\n        while cur1 != cur2:\n            cur1 = headb if cur1 is none else cur1.next\n            cur2 = heada if cur2 is none else cur2.next\n        return cur1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public listnode getintersectionnode(listnode heada, listnode headb) {\n        listnode cur1 = heada, cur2 = headb;\n        while (cur1 != cur2) {\n            cur1 = cur1 == null ? headb : cur1.next;\n            cur2 = cur2 == null ? heada : cur2.next;\n        }\n        return cur1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode(int x) : val(x), next(null) {}\n * };\n */\nclass solution {\npublic:\n    listnode *getintersectionnode(listnode *heada, listnode *headb) {\n        listnode* cur1 = heada;\n        listnode* cur2 = headb;\n        while (cur1 != cur2) {\n            cur1 = cur1 ? cur1->next : headb;\n            cur2 = cur2 ? cur2->next : heada;\n        }\n        return cur1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {listnode} heada\n * @param {listnode} headb\n * @return {listnode}\n */\n var getintersectionnode = function(heada, headb) {\n  let cur1 = heada;\n  let cur2 = headb;\n  while (cur1 != cur2) {\n      cur1 = cur1 ? cur1.next : headb;\n      cur2 = cur2 ? cur2.next : heada;\n  }\n  return cur1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\n func getintersectionnode(heada, headb *listnode) *listnode {\n    cur1, cur2 := heada, headb\n    for cur1 != cur2 {\n        if cur1 == nil {\n            cur1 = headb\n        } else {\n            cur1 = cur1.next\n        }\n        if cur2 == nil {\n            cur2 = heada\n        } else {\n            cur2 = cur2.next\n        }\n    }\n    return cur1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# typescript\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     val: number\n *     next: listnode | null\n *     constructor(val?: number, next?: listnode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction getintersectionnode(heada: listnode | null, headb: listnode | null): listnode | null {\n    let p1: listnode | null = heada;\n    let p2: listnode | null = headb;\n    while (p1 != p2) {\n        p1 = p1 == null ? headb : p1.next;\n        p2 = p2 == null ? heada : p2.next;\n    }\n    return p1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode161 One Edit Distance-zh",frontmatter:{title:"leetcode161 One Edit Distance-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/3ba9d1/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode161 One Edit Distance-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10161.leetcode161%20One%20Edit%20Distance-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode161 One Edit Distance-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10161.leetcode161%20One%20Edit%20Distance-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode161 One Edit Distance-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10161.leetcode161%20One%20Edit%20Distance-zh.html",relativePath:"01.算法/24.leetcode/10161.leetcode161 One Edit Distance-zh.md",key:"v-cb385bb0",path:"/p/3ba9d1/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:40},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:382},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:389},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:408},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:424}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 161. 相隔为 1 的编辑距离\n\nEnglish Version\n\n\n# 题目描述\n\n给定两个字符串 s 和 t，判断他们的编辑距离是否为 1。\n\n注意：\n\n满足编辑距离等于 1 有三种可能的情形：\n\n 1. 往 s 中插入一个字符得到 t\n 2. 从 s 中删除一个字符得到 t\n 3. 在 s 中替换一个字符得到 t\n\n示例 1：\n\n输入: s = "ab", t = "acb"\n输出: true\n解释: 可以将 \'c\' 插入字符串 s 来得到 t。\n\n\n示例 2:\n\n输入: s = "cab", t = "ad"\n输出: false\n解释: 无法通过 1 步操作使 s 变为 t。\n\n示例 3:\n\n输入: s = "1203", t = "1213"\n输出: true\n解释: 可以将字符串 s 中的 \'0\' 替换为 \'1\' 来得到 t。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 161. 相隔为 1 的编辑距离\n\nenglish version\n\n\n# 题目描述\n\n给定两个字符串 s 和 t，判断他们的编辑距离是否为 1。\n\n注意：\n\n满足编辑距离等于 1 有三种可能的情形：\n\n 1. 往 s 中插入一个字符得到 t\n 2. 从 s 中删除一个字符得到 t\n 3. 在 s 中替换一个字符得到 t\n\n示例 1：\n\n输入: s = "ab", t = "acb"\n输出: true\n解释: 可以将 \'c\' 插入字符串 s 来得到 t。\n\n\n示例 2:\n\n输入: s = "cab", t = "ad"\n输出: false\n解释: 无法通过 1 步操作使 s 变为 t。\n\n示例 3:\n\n输入: s = "1203", t = "1213"\n输出: true\n解释: 可以将字符串 s 中的 \'0\' 替换为 \'1\' 来得到 t。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode162 Find Peak Element-zh",frontmatter:{title:"leetcode162 Find Peak Element-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/7b7235/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode162 Find Peak Element-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10162.leetcode162%20Find%20Peak%20Element-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode162 Find Peak Element-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10162.leetcode162%20Find%20Peak%20Element-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode162 Find Peak Element-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10162.leetcode162%20Find%20Peak%20Element-zh.html",relativePath:"01.算法/24.leetcode/10162.leetcode162 Find Peak Element-zh.md",key:"v-74182564",path:"/p/7b7235/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:461},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:475},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:827},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:1236},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1595},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1849},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2267}],headersStr:"题目描述 解法 Python3 Java TypeScript Go C++ ...",content:"# 162. 寻找峰值\n\nEnglish Version\n\n\n# 题目描述\n\n峰值元素是指其值大于左右相邻值的元素。\n\n给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n\n你可以假设 nums[-1] = nums[n] = -∞ 。\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,3,1]\n输出：2\n解释：3 是峰值元素，你的函数应该返回其索引 2。\n\n示例 2：\n\n\n输入：nums = [1,2,1,3,5,6,4]\n输出：1 或 5 \n解释：你的函数可以返回索引 1，其峰值元素为 2；\n     或者返回索引 5， 其峰值元素为 6。\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 1000\n * -231 <= nums[i] <= 231 - 1\n * 对于所有有效的 i 都有 nums[i] != nums[i + 1]\n\n \n\n进阶：你可以实现时间复杂度为 O(logN) 的解决方案吗？\n\n\n# 解法\n\n二分查找。\n\n\n# Python3\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Java\n\nclass Solution {\n    public int findPeakElement(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] > nums[mid + 1]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# TypeScript\n\nfunction findPeakElement(nums: number[]): number {\n    let left = 0, right = nums.length - 1;\n    while (left < right) {\n        let mid: number = (left + right) >> 1;\n        if (nums[mid] <= nums[mid+1]) {\n            left = mid +1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Go\n\nfunc findPeakElement(nums []int) int {\n\tleft, right := 0, len(nums)-1\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tif nums[mid] > nums[mid+1] {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\treturn left\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            int mid = left + right >> 1;\n            if (nums[mid] > nums[mid + 1]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 162. 寻找峰值\n\nenglish version\n\n\n# 题目描述\n\n峰值元素是指其值大于左右相邻值的元素。\n\n给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n\n你可以假设 nums[-1] = nums[n] = -∞ 。\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,3,1]\n输出：2\n解释：3 是峰值元素，你的函数应该返回其索引 2。\n\n示例 2：\n\n\n输入：nums = [1,2,1,3,5,6,4]\n输出：1 或 5 \n解释：你的函数可以返回索引 1，其峰值元素为 2；\n     或者返回索引 5， 其峰值元素为 6。\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 1000\n * -231 <= nums[i] <= 231 - 1\n * 对于所有有效的 i 都有 nums[i] != nums[i + 1]\n\n \n\n进阶：你可以实现时间复杂度为 o(logn) 的解决方案吗？\n\n\n# 解法\n\n二分查找。\n\n\n# python3\n\nclass solution:\n    def findpeakelement(self, nums: list[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# java\n\nclass solution {\n    public int findpeakelement(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] > nums[mid + 1]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# typescript\n\nfunction findpeakelement(nums: number[]): number {\n    let left = 0, right = nums.length - 1;\n    while (left < right) {\n        let mid: number = (left + right) >> 1;\n        if (nums[mid] <= nums[mid+1]) {\n            left = mid +1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# go\n\nfunc findpeakelement(nums []int) int {\n\tleft, right := 0, len(nums)-1\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tif nums[mid] > nums[mid+1] {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\treturn left\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# c++\n\nclass solution {\npublic:\n    int findpeakelement(vector<int>& nums) {\n        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            int mid = left + right >> 1;\n            if (nums[mid] > nums[mid + 1]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode163 Missing Ranges-zh",frontmatter:{title:"leetcode163 Missing Ranges-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/073c7e/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode163 Missing Ranges-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10163.leetcode163%20Missing%20Ranges-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode163 Missing Ranges-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10163.leetcode163%20Missing%20Ranges-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode163 Missing Ranges-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10163.leetcode163%20Missing%20Ranges-zh.html",relativePath:"01.算法/24.leetcode/10163.leetcode163 Missing Ranges-zh.md",key:"v-0ede2966",path:"/p/073c7e/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:209},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:216},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:235},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:251}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 163. 缺失的区间\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个排序的整数数组 nums ，其中元素的范围在 闭区间 [lower, upper] 当中，返回不包含在数组中的缺失区间。\n\n示例：\n\n输入: nums = [0, 1, 3, 50, 75], lower = 0 和 upper = 99,\n输出: ["2", "4->49", "51->74", "76->99"]\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 163. 缺失的区间\n\nenglish version\n\n\n# 题目描述\n\n给定一个排序的整数数组 nums ，其中元素的范围在 闭区间 [lower, upper] 当中，返回不包含在数组中的缺失区间。\n\n示例：\n\n输入: nums = [0, 1, 3, 50, 75], lower = 0 和 upper = 99,\n输出: ["2", "4->49", "51->74", "76->99"]\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode164 Maximum Gap-zh",frontmatter:{title:"leetcode164 Maximum Gap-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/881ab1/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode164 Maximum Gap-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10164.leetcode164%20Maximum%20Gap-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode164 Maximum Gap-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10164.leetcode164%20Maximum%20Gap-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode164 Maximum Gap-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10164.leetcode164%20Maximum%20Gap-zh.html",relativePath:"01.算法/24.leetcode/10164.leetcode164 Maximum Gap-zh.md",key:"v-2fc7dd8a",path:"/p/881ab1/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:306},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:313},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:332},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:348}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 164. 最大间距\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。\n\n如果数组元素个数小于 2，则返回 0。\n\n示例 1:\n\n输入: [3,6,9,1]\n输出: 3\n解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。\n\n示例 2:\n\n输入: [10]\n输出: 0\n解释: 数组元素个数小于 2，因此返回 0。\n\n说明:\n\n * 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。\n * 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 164. 最大间距\n\nenglish version\n\n\n# 题目描述\n\n给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。\n\n如果数组元素个数小于 2，则返回 0。\n\n示例 1:\n\n输入: [3,6,9,1]\n输出: 3\n解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。\n\n示例 2:\n\n输入: [10]\n输出: 0\n解释: 数组元素个数小于 2，因此返回 0。\n\n说明:\n\n * 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。\n * 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode165 Compare Version Numbers-zh",frontmatter:{title:"leetcode165 Compare Version Numbers-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/1808db/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode165 Compare Version Numbers-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10165.leetcode165%20Compare%20Version%20Numbers-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode165 Compare Version Numbers-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10165.leetcode165%20Compare%20Version%20Numbers-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode165 Compare Version Numbers-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10165.leetcode165%20Compare%20Version%20Numbers-zh.html",relativePath:"01.算法/24.leetcode/10165.leetcode165 Compare Version Numbers-zh.md",key:"v-e3b62984",path:"/p/1808db/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1095},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1102},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1121},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1137}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 165. 比较版本号\n\nEnglish Version\n\n\n# 题目描述\n\n给你两个版本号 version1 和 version2 ，请你比较它们。\n\n版本号由一个或多个修订号组成，各修订号由一个 \'.\' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。\n\n比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。\n\n返回规则如下：\n\n * 如果 version1 > version2 返回 1，\n * 如果 version1 < version2 返回 -1，\n * 除此之外返回 0。\n\n \n\n示例 1：\n\n\n输入：version1 = "1.01", version2 = "1.001"\n输出：0\n解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"\n\n\n示例 2：\n\n\n输入：version1 = "1.0", version2 = "1.0.0"\n输出：0\n解释：version1 没有指定下标为 2 的修订号，即视为 "0"\n\n\n示例 3：\n\n\n输入：version1 = "0.1", version2 = "1.1"\n输出：-1\n解释：version1 中下标为 0 的修订号是 "0"，version2 中下标为 0 的修订号是 "1" 。0 < 1，所以 version1 < version2\n\n\n示例 4：\n\n\n输入：version1 = "1.0.1", version2 = "1"\n输出：1\n\n\n示例 5：\n\n\n输入：version1 = "7.5.2.4", version2 = "7.5.3"\n输出：-1\n\n\n \n\n提示：\n\n * 1 <= version1.length, version2.length <= 500\n * version1 和 version2 仅包含数字和 \'.\'\n * version1 和 version2 都是 有效版本号\n * version1 和 version2 的所有修订号都可以存储在 32 位整数 中\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 165. 比较版本号\n\nenglish version\n\n\n# 题目描述\n\n给你两个版本号 version1 和 version2 ，请你比较它们。\n\n版本号由一个或多个修订号组成，各修订号由一个 \'.\' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。\n\n比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。\n\n返回规则如下：\n\n * 如果 version1 > version2 返回 1，\n * 如果 version1 < version2 返回 -1，\n * 除此之外返回 0。\n\n \n\n示例 1：\n\n\n输入：version1 = "1.01", version2 = "1.001"\n输出：0\n解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"\n\n\n示例 2：\n\n\n输入：version1 = "1.0", version2 = "1.0.0"\n输出：0\n解释：version1 没有指定下标为 2 的修订号，即视为 "0"\n\n\n示例 3：\n\n\n输入：version1 = "0.1", version2 = "1.1"\n输出：-1\n解释：version1 中下标为 0 的修订号是 "0"，version2 中下标为 0 的修订号是 "1" 。0 < 1，所以 version1 < version2\n\n\n示例 4：\n\n\n输入：version1 = "1.0.1", version2 = "1"\n输出：1\n\n\n示例 5：\n\n\n输入：version1 = "7.5.2.4", version2 = "7.5.3"\n输出：-1\n\n\n \n\n提示：\n\n * 1 <= version1.length, version2.length <= 500\n * version1 和 version2 仅包含数字和 \'.\'\n * version1 和 version2 都是 有效版本号\n * version1 和 version2 的所有修订号都可以存储在 32 位整数 中\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode166 Fraction to Recurring Decimal-zh",frontmatter:{title:"leetcode166 Fraction to Recurring Decimal-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/c52337/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode166 Fraction to Recurring Decimal-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10166.leetcode166%20Fraction%20to%20Recurring%20Decimal-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode166 Fraction to Recurring Decimal-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10166.leetcode166%20Fraction%20to%20Recurring%20Decimal-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode166 Fraction to Recurring Decimal-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10166.leetcode166%20Fraction%20to%20Recurring%20Decimal-zh.html",relativePath:"01.算法/24.leetcode/10166.leetcode166 Fraction to Recurring Decimal-zh.md",key:"v-3c44de45",path:"/p/c52337/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:529},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:536},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:555},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:571}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 166. 分数到小数\n\nEnglish Version\n\n\n# 题目描述\n\n给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。\n\n如果小数部分为循环小数，则将循环的部分括在括号内。\n\n如果存在多个答案，只需返回 任意一个 。\n\n对于所有给定的输入，保证 答案字符串的长度小于 104 。\n\n \n\n示例 1：\n\n\n输入：numerator = 1, denominator = 2\n输出："0.5"\n\n\n示例 2：\n\n\n输入：numerator = 2, denominator = 1\n输出："2"\n\n\n示例 3：\n\n\n输入：numerator = 2, denominator = 3\n输出："0.(6)"\n\n\n示例 4：\n\n\n输入：numerator = 4, denominator = 333\n输出："0.(012)"\n\n\n示例 5：\n\n\n输入：numerator = 1, denominator = 5\n输出："0.2"\n\n\n \n\n提示：\n\n * -231 <= numerator, denominator <= 231 - 1\n * denominator != 0\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 166. 分数到小数\n\nenglish version\n\n\n# 题目描述\n\n给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。\n\n如果小数部分为循环小数，则将循环的部分括在括号内。\n\n如果存在多个答案，只需返回 任意一个 。\n\n对于所有给定的输入，保证 答案字符串的长度小于 104 。\n\n \n\n示例 1：\n\n\n输入：numerator = 1, denominator = 2\n输出："0.5"\n\n\n示例 2：\n\n\n输入：numerator = 2, denominator = 1\n输出："2"\n\n\n示例 3：\n\n\n输入：numerator = 2, denominator = 3\n输出："0.(6)"\n\n\n示例 4：\n\n\n输入：numerator = 4, denominator = 333\n输出："0.(012)"\n\n\n示例 5：\n\n\n输入：numerator = 1, denominator = 5\n输出："0.2"\n\n\n \n\n提示：\n\n * -231 <= numerator, denominator <= 231 - 1\n * denominator != 0\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode167 Two Sum II - Input array is sorted-zh",frontmatter:{title:"leetcode167 Two Sum II - Input array is sorted-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a20291/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode167 Two Sum II - Input array is sorted-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10167.leetcode167%20Two%20Sum%20II%20-%20Input%20array%20is%20sorted-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode167 Two Sum II - Input array is sorted-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10167.leetcode167%20Two%20Sum%20II%20-%20Input%20array%20is%20sorted-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode167 Two Sum II - Input array is sorted-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10167.leetcode167%20Two%20Sum%20II%20-%20Input%20array%20is%20sorted-zh.html",relativePath:"01.算法/24.leetcode/10167.leetcode167 Two Sum II - Input array is sorted-zh.md",key:"v-0741be07",path:"/p/a20291/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:45},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:609},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:624},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1060},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1576},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2091}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 167. 两数之和 II - 输入有序数组\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。\n\n函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。\n\n你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n \n\n示例 1：\n\n\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n\n\n示例 2：\n\n\n输入：numbers = [2,3,4], target = 6\n输出：[1,3]\n\n\n示例 3：\n\n\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n\n\n \n\n提示：\n\n * 2 <= numbers.length <= 3 * 104\n * -1000 <= numbers[i] <= 1000\n * numbers 按 递增顺序 排列\n * -1000 <= target <= 1000\n * 仅存在一个有效答案\n\n\n# 解法\n\n双指针解决。\n\n\n# Python3\n\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        low, high = 0, len(numbers) - 1\n        while low <= high:\n            if numbers[low] + numbers[high] == target:\n                return [low + 1, high + 1]\n            if numbers[low] + numbers[high] < target:\n                low += 1\n            else:\n                high -= 1\n        return [-1, -1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Java\n\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int low = 0, high = numbers.length - 1;\n        while (low <= high) {\n            if (numbers[low] + numbers[high] == target) {\n                return new int[]{low + 1, high + 1};\n            }\n            if (numbers[low] + numbers[high] < target) {\n                ++low;\n            } else {\n                --high;\n            }\n        }\n        return new int[]{-1, -1};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# C++\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int low = 0, high = numbers.size() - 1;\n        while (low <= high) {\n            if (numbers[low] + numbers[high] == target) {\n                return {low + 1, high + 1};\n            }\n            if (numbers[low] + numbers[high] < target) {\n                ++low;\n            } else {\n                --high;\n            }\n        }\n        return {-1, -1};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 167. 两数之和 ii - 输入有序数组\n\nenglish version\n\n\n# 题目描述\n\n给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。\n\n函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。\n\n你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n \n\n示例 1：\n\n\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n\n\n示例 2：\n\n\n输入：numbers = [2,3,4], target = 6\n输出：[1,3]\n\n\n示例 3：\n\n\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n\n\n \n\n提示：\n\n * 2 <= numbers.length <= 3 * 104\n * -1000 <= numbers[i] <= 1000\n * numbers 按 递增顺序 排列\n * -1000 <= target <= 1000\n * 仅存在一个有效答案\n\n\n# 解法\n\n双指针解决。\n\n\n# python3\n\nclass solution:\n    def twosum(self, numbers: list[int], target: int) -> list[int]:\n        low, high = 0, len(numbers) - 1\n        while low <= high:\n            if numbers[low] + numbers[high] == target:\n                return [low + 1, high + 1]\n            if numbers[low] + numbers[high] < target:\n                low += 1\n            else:\n                high -= 1\n        return [-1, -1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# java\n\nclass solution {\n    public int[] twosum(int[] numbers, int target) {\n        int low = 0, high = numbers.length - 1;\n        while (low <= high) {\n            if (numbers[low] + numbers[high] == target) {\n                return new int[]{low + 1, high + 1};\n            }\n            if (numbers[low] + numbers[high] < target) {\n                ++low;\n            } else {\n                --high;\n            }\n        }\n        return new int[]{-1, -1};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# c++\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& numbers, int target) {\n        int low = 0, high = numbers.size() - 1;\n        while (low <= high) {\n            if (numbers[low] + numbers[high] == target) {\n                return {low + 1, high + 1};\n            }\n            if (numbers[low] + numbers[high] < target) {\n                ++low;\n            } else {\n                --high;\n            }\n        }\n        return {-1, -1};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode168 Excel Sheet Column Title-zh",frontmatter:{title:"leetcode168 Excel Sheet Column Title-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/57b4e1/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode168 Excel Sheet Column Title-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10168.leetcode168%20Excel%20Sheet%20Column%20Title-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode168 Excel Sheet Column Title-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10168.leetcode168%20Excel%20Sheet%20Column%20Title-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode168 Excel Sheet Column Title-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10168.leetcode168%20Excel%20Sheet%20Column%20Title-zh.html",relativePath:"01.算法/24.leetcode/10168.leetcode168 Excel Sheet Column Title-zh.md",key:"v-41ff946d",path:"/p/57b4e1/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:248},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:255},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:558},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:927},{level:3,title:"C#",slug:"c",normalizedTitle:"c#",charIndex:1291},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:118}],headersStr:"题目描述 解法 Python3 Java TypeScript C# ...",content:"# 168. Excel 表列名称\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个正整数，返回它在 Excel 表中相对应的列名称。\n\n例如，\n\n    1 -> A\n    2 -> B\n    3 -> C\n    ...\n    26 -> Z\n    27 -> AA\n    28 -> AB \n    ...\n\n\n示例 1:\n\n输入: 1\n输出: \"A\"\n\n\n示例 2:\n\n输入: 28\n输出: \"AB\"\n\n\n示例 3:\n\n输入: 701\n输出: \"ZY\"\n\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = []\n        while columnNumber:\n            columnNumber -= 1\n            res.append(chr(ord('A') + columnNumber % 26))\n            columnNumber //= 26\n        return ''.join(res[::-1])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Java\n\nclass Solution {\n    public String convertToTitle(int columnNumber) {\n        StringBuilder res = new StringBuilder();\n        while (columnNumber != 0) {\n            --columnNumber;\n            res.append((char) ('A' + columnNumber % 26));\n            columnNumber /= 26;\n        }\n        return res.reverse().toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# TypeScript\n\nfunction convertToTitle(columnNumber: number): string {\n    let res: string[] = [];\n    while (columnNumber > 0) {\n        --columnNumber;\n        let num: number = columnNumber % 26;\n        res.unshift(String.fromCharCode(num + 65));\n        columnNumber = Math.floor(columnNumber / 26);\n    }\n    return res.join('');\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# C#\n\npublic class Solution {\n    public string ConvertToTitle(int columnNumber) {\n        StringBuilder res = new StringBuilder();\n        while (columnNumber != 0) {\n            --columnNumber;\n            res.Append((char) ('A' + columnNumber % 26));\n            columnNumber /= 26;\n        }\n        return new string(res.ToString().Reverse().ToArray());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 168. excel 表列名称\n\nenglish version\n\n\n# 题目描述\n\n给定一个正整数，返回它在 excel 表中相对应的列名称。\n\n例如，\n\n    1 -> a\n    2 -> b\n    3 -> c\n    ...\n    26 -> z\n    27 -> aa\n    28 -> ab \n    ...\n\n\n示例 1:\n\n输入: 1\n输出: \"a\"\n\n\n示例 2:\n\n输入: 28\n输出: \"ab\"\n\n\n示例 3:\n\n输入: 701\n输出: \"zy\"\n\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def converttotitle(self, columnnumber: int) -> str:\n        res = []\n        while columnnumber:\n            columnnumber -= 1\n            res.append(chr(ord('a') + columnnumber % 26))\n            columnnumber //= 26\n        return ''.join(res[::-1])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# java\n\nclass solution {\n    public string converttotitle(int columnnumber) {\n        stringbuilder res = new stringbuilder();\n        while (columnnumber != 0) {\n            --columnnumber;\n            res.append((char) ('a' + columnnumber % 26));\n            columnnumber /= 26;\n        }\n        return res.reverse().tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# typescript\n\nfunction converttotitle(columnnumber: number): string {\n    let res: string[] = [];\n    while (columnnumber > 0) {\n        --columnnumber;\n        let num: number = columnnumber % 26;\n        res.unshift(string.fromcharcode(num + 65));\n        columnnumber = math.floor(columnnumber / 26);\n    }\n    return res.join('');\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# c#\n\npublic class solution {\n    public string converttotitle(int columnnumber) {\n        stringbuilder res = new stringbuilder();\n        while (columnnumber != 0) {\n            --columnnumber;\n            res.append((char) ('a' + columnnumber % 26));\n            columnnumber /= 26;\n        }\n        return new string(res.tostring().reverse().toarray());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode169 Majority Element-zh",frontmatter:{title:"leetcode169 Majority Element-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a36e82/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode169 Majority Element-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10169.leetcode169%20Majority%20Element-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode169 Majority Element-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10169.leetcode169%20Majority%20Element-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode169 Majority Element-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10169.leetcode169%20Majority%20Element-zh.html",relativePath:"01.算法/24.leetcode/10169.leetcode169 Majority Element-zh.md",key:"v-76f8e447",path:"/p/a36e82/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:240},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:277},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:601},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:977},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1365},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:1752},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2194}],headersStr:"题目描述 解法 Python3 Java JavaScript C++ C# ...",content:"# 169. 多数元素\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n \n\n示例 1：\n\n\n输入：[3,2,3]\n输出：3\n\n示例 2：\n\n\n输入：[2,2,1,1,1,2,2]\n输出：2\n\n\n \n\n进阶：\n\n * 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。\n\n\n# 解法\n\n摩尔投票法。时间复杂度 O(n)，空间复杂度 O(1)。\n\n\n# Python3\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        cnt = major = 0\n        for num in nums:\n            if cnt == 0:\n                major = num\n                cnt = 1\n            else:\n                cnt += (1 if major == num else -1)\n        return major\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Java\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int cnt = 0, major = 0;\n        for (int num : nums) {\n            if (cnt == 0) {\n                major = num;\n                cnt = 1;\n            } else {\n                cnt += (major == num ? 1 : -1);\n            }\n        }\n        return major;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function(nums) {\n    let cnt = 0;\n    let major = 0;\n    for (const num of nums) {\n        if (cnt == 0) {\n            major = num;\n            cnt = 1;\n        } else {\n            cnt += (major == num ? 1 : -1);\n        }\n    }\n    return major;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int cnt = 0, major = 0;\n        for (int num : nums) {\n            if (cnt == 0) {\n                major = num;\n                cnt = 1;\n            } else {\n                cnt += (major == num ? 1 : -1);\n            }\n        }\n        return major;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# C#\n\npublic class Solution {\n    public int MajorityElement(int[] nums) {\n        int cnt = 0, major = 0;\n        foreach (int num in nums)\n        {\n            if (cnt == 0)\n            {\n                major = num;\n                cnt = 1;\n            }\n            else\n            {\n                cnt += (major == num ? 1 : -1);\n            }\n        }\n        return major;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 169. 多数元素\n\nenglish version\n\n\n# 题目描述\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n \n\n示例 1：\n\n\n输入：[3,2,3]\n输出：3\n\n示例 2：\n\n\n输入：[2,2,1,1,1,2,2]\n输出：2\n\n\n \n\n进阶：\n\n * 尝试设计时间复杂度为 o(n)、空间复杂度为 o(1) 的算法解决此问题。\n\n\n# 解法\n\n摩尔投票法。时间复杂度 o(n)，空间复杂度 o(1)。\n\n\n# python3\n\nclass solution:\n    def majorityelement(self, nums: list[int]) -> int:\n        cnt = major = 0\n        for num in nums:\n            if cnt == 0:\n                major = num\n                cnt = 1\n            else:\n                cnt += (1 if major == num else -1)\n        return major\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# java\n\nclass solution {\n    public int majorityelement(int[] nums) {\n        int cnt = 0, major = 0;\n        for (int num : nums) {\n            if (cnt == 0) {\n                major = num;\n                cnt = 1;\n            } else {\n                cnt += (major == num ? 1 : -1);\n            }\n        }\n        return major;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityelement = function(nums) {\n    let cnt = 0;\n    let major = 0;\n    for (const num of nums) {\n        if (cnt == 0) {\n            major = num;\n            cnt = 1;\n        } else {\n            cnt += (major == num ? 1 : -1);\n        }\n    }\n    return major;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# c++\n\nclass solution {\npublic:\n    int majorityelement(vector<int>& nums) {\n        int cnt = 0, major = 0;\n        for (int num : nums) {\n            if (cnt == 0) {\n                major = num;\n                cnt = 1;\n            } else {\n                cnt += (major == num ? 1 : -1);\n            }\n        }\n        return major;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# c#\n\npublic class solution {\n    public int majorityelement(int[] nums) {\n        int cnt = 0, major = 0;\n        foreach (int num in nums)\n        {\n            if (cnt == 0)\n            {\n                major = num;\n                cnt = 1;\n            }\n            else\n            {\n                cnt += (major == num ? 1 : -1);\n            }\n        }\n        return major;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode170 Two Sum III - Data structure design-zh",frontmatter:{title:"leetcode170 Two Sum III - Data structure design-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/6d9984/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode170 Two Sum III - Data structure design-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10170.leetcode170%20Two%20Sum%20III%20-%20Data%20structure%20design-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode170 Two Sum III - Data structure design-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10170.leetcode170%20Two%20Sum%20III%20-%20Data%20structure%20design-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode170 Two Sum III - Data structure design-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10170.leetcode170%20Two%20Sum%20III%20-%20Data%20structure%20design-zh.html",relativePath:"01.算法/24.leetcode/10170.leetcode170 Two Sum III - Data structure design-zh.md",key:"v-81264718",path:"/p/6d9984/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:46},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:713},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:730},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1701},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2819}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 170. 两数之和 III - 数据结构设计\n\nEnglish Version\n\n\n# 题目描述\n\n设计一个接收整数流的数据结构，该数据结构支持检查是否存在两数之和等于特定值。\n\n实现 TwoSum 类：\n\n * TwoSum() 使用空数组初始化 TwoSum 对象\n * void add(int number) 向数据结构添加一个数 number\n * boolean find(int value) 寻找数据结构中是否存在一对整数，使得两数之和与给定的值相等。如果存在，返回 true ；否则，返回 false 。\n\n \n\n示例：\n\n\n输入：\n["TwoSum", "add", "add", "add", "find", "find"]\n[[], [1], [3], [5], [4], [7]]\n输出：\n[null, null, null, null, true, false]\n\n解释：\nTwoSum twoSum = new TwoSum();\ntwoSum.add(1);   // [] --\x3e [1]\ntwoSum.add(3);   // [1] --\x3e [1,3]\ntwoSum.add(5);   // [1,3] --\x3e [1,3,5]\ntwoSum.find(4);  // 1 + 3 = 4，返回 true\ntwoSum.find(7);  // 没有两个整数加起来等于 7 ，返回 false\n\n \n\n提示：\n\n * -105 <= number <= 105\n * -231 <= value <= 231 - 1\n * 最多调用 5 * 104 次 add 和 find\n\n\n# 解法\n\n“计数器”实现。\n\n\n# Python3\n\nclass TwoSum:\n\n    def __init__(self):\n        """\n        Initialize your data structure here.\n        """\n        self.counter = collections.Counter()\n\n    def add(self, number: int) -> None:\n        """\n        Add the number to an internal data structure..\n        """\n        self.counter[number] += 1\n\n    def find(self, value: int) -> bool:\n        """\n        Find if there exists any pair of numbers which sum is equal to the value.\n        """\n        for num in self.counter.keys():\n            other = value - num\n            if other in self.counter:\n                if other != num:\n                    return True\n                if other == num and self.counter[num] > 1:\n                    return True\n        return False\n\n\n# Your TwoSum object will be instantiated and called as such:\n# obj = TwoSum()\n# obj.add(number)\n# param_2 = obj.find(value)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# Java\n\nclass TwoSum {\n    private Map<Integer, Integer> counter;\n\n    /** Initialize your data structure here. */\n    public TwoSum() {\n        counter = new HashMap<>();\n    }\n    \n    /** Add the number to an internal data structure.. */\n    public void add(int number) {\n        counter.put(number, counter.getOrDefault(number, 0) + 1);\n    }\n    \n    /** Find if there exists any pair of numbers which sum is equal to the value. */\n    public boolean find(int value) {\n        for (int num : counter.keySet()) {\n            int other = value - num;\n            if (counter.containsKey(other)) {\n                if (num != other) {\n                    return true;\n                }\n                if (num == other && counter.get(other) > 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * TwoSum obj = new TwoSum();\n * obj.add(number);\n * boolean param_2 = obj.find(value);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 170. 两数之和 iii - 数据结构设计\n\nenglish version\n\n\n# 题目描述\n\n设计一个接收整数流的数据结构，该数据结构支持检查是否存在两数之和等于特定值。\n\n实现 twosum 类：\n\n * twosum() 使用空数组初始化 twosum 对象\n * void add(int number) 向数据结构添加一个数 number\n * boolean find(int value) 寻找数据结构中是否存在一对整数，使得两数之和与给定的值相等。如果存在，返回 true ；否则，返回 false 。\n\n \n\n示例：\n\n\n输入：\n["twosum", "add", "add", "add", "find", "find"]\n[[], [1], [3], [5], [4], [7]]\n输出：\n[null, null, null, null, true, false]\n\n解释：\ntwosum twosum = new twosum();\ntwosum.add(1);   // [] --\x3e [1]\ntwosum.add(3);   // [1] --\x3e [1,3]\ntwosum.add(5);   // [1,3] --\x3e [1,3,5]\ntwosum.find(4);  // 1 + 3 = 4，返回 true\ntwosum.find(7);  // 没有两个整数加起来等于 7 ，返回 false\n\n \n\n提示：\n\n * -105 <= number <= 105\n * -231 <= value <= 231 - 1\n * 最多调用 5 * 104 次 add 和 find\n\n\n# 解法\n\n“计数器”实现。\n\n\n# python3\n\nclass twosum:\n\n    def __init__(self):\n        """\n        initialize your data structure here.\n        """\n        self.counter = collections.counter()\n\n    def add(self, number: int) -> none:\n        """\n        add the number to an internal data structure..\n        """\n        self.counter[number] += 1\n\n    def find(self, value: int) -> bool:\n        """\n        find if there exists any pair of numbers which sum is equal to the value.\n        """\n        for num in self.counter.keys():\n            other = value - num\n            if other in self.counter:\n                if other != num:\n                    return true\n                if other == num and self.counter[num] > 1:\n                    return true\n        return false\n\n\n# your twosum object will be instantiated and called as such:\n# obj = twosum()\n# obj.add(number)\n# param_2 = obj.find(value)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# java\n\nclass twosum {\n    private map<integer, integer> counter;\n\n    /** initialize your data structure here. */\n    public twosum() {\n        counter = new hashmap<>();\n    }\n    \n    /** add the number to an internal data structure.. */\n    public void add(int number) {\n        counter.put(number, counter.getordefault(number, 0) + 1);\n    }\n    \n    /** find if there exists any pair of numbers which sum is equal to the value. */\n    public boolean find(int value) {\n        for (int num : counter.keyset()) {\n            int other = value - num;\n            if (counter.containskey(other)) {\n                if (num != other) {\n                    return true;\n                }\n                if (num == other && counter.get(other) > 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * your twosum object will be instantiated and called as such:\n * twosum obj = new twosum();\n * obj.add(number);\n * boolean param_2 = obj.find(value);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode171 Excel Sheet Column Number-zh",frontmatter:{title:"leetcode171 Excel Sheet Column Number-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/7d969b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode171 Excel Sheet Column Number-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10171.leetcode171%20Excel%20Sheet%20Column%20Number-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode171 Excel Sheet Column Number-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10171.leetcode171%20Excel%20Sheet%20Column%20Number-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode171 Excel Sheet Column Number-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10171.leetcode171%20Excel%20Sheet%20Column%20Number-zh.html",relativePath:"01.算法/24.leetcode/10171.leetcode171 Excel Sheet Column Number-zh.md",key:"v-2db38f71",path:"/p/7d969b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:274},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:281},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:497},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:750},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:973},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:115}],headersStr:"题目描述 解法 Python3 Java TypeScript C++ ...",content:"# 171. Excel表列序号\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个Excel表格中的列名称，返回其相应的列序号。\n\n例如，\n\n    A -> 1\n    B -> 2\n    C -> 3\n    ...\n    Z -> 26\n    AA -> 27\n    AB -> 28 \n    ...\n\n\n示例 1:\n\n输入: \"A\"\n输出: 1\n\n\n示例 2:\n\n输入: \"AB\"\n输出: 28\n\n\n示例 3:\n\n输入: \"ZY\"\n输出: 701\n\n致谢：\n特别感谢 @ts 添加此问题并创建所有测试用例。\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        res = 0\n        for c in columnTitle:\n            res = res * 26 + (ord(c) - ord('A') + 1)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Java\n\nclass Solution {\n    public int titleToNumber(String columnTitle) {\n        int res = 0;\n        for (char c : columnTitle.toCharArray()) {\n            res = res * 26 + (c - 'A' + 1);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# TypeScript\n\nfunction titleToNumber(columnTitle: string): number {\n    let res: number = 0;\n    for (let char of columnTitle) {\n        res = res * 26 + char.charCodeAt(0) - 64;\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int titleToNumber(string columnTitle) {\n        int res = 0;\n        for (char c : columnTitle) {\n            res = res * 26 + (c - 'A' + 1);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 171. excel表列序号\n\nenglish version\n\n\n# 题目描述\n\n给定一个excel表格中的列名称，返回其相应的列序号。\n\n例如，\n\n    a -> 1\n    b -> 2\n    c -> 3\n    ...\n    z -> 26\n    aa -> 27\n    ab -> 28 \n    ...\n\n\n示例 1:\n\n输入: \"a\"\n输出: 1\n\n\n示例 2:\n\n输入: \"ab\"\n输出: 28\n\n\n示例 3:\n\n输入: \"zy\"\n输出: 701\n\n致谢：\n特别感谢 @ts 添加此问题并创建所有测试用例。\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def titletonumber(self, columntitle: str) -> int:\n        res = 0\n        for c in columntitle:\n            res = res * 26 + (ord(c) - ord('a') + 1)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# java\n\nclass solution {\n    public int titletonumber(string columntitle) {\n        int res = 0;\n        for (char c : columntitle.tochararray()) {\n            res = res * 26 + (c - 'a' + 1);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# typescript\n\nfunction titletonumber(columntitle: string): number {\n    let res: number = 0;\n    for (let char of columntitle) {\n        res = res * 26 + char.charcodeat(0) - 64;\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# c++\n\nclass solution {\npublic:\n    int titletonumber(string columntitle) {\n        int res = 0;\n        for (char c : columntitle) {\n            res = res * 26 + (c - 'a' + 1);\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode172 Factorial Trailing Zeroes-zh",frontmatter:{title:"leetcode172 Factorial Trailing Zeroes-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/4f95d4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode172 Factorial Trailing Zeroes-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10172.leetcode172%20Factorial%20Trailing%20Zeroes-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode172 Factorial Trailing Zeroes-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10172.leetcode172%20Factorial%20Trailing%20Zeroes-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode172 Factorial Trailing Zeroes-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10172.leetcode172%20Factorial%20Trailing%20Zeroes-zh.html",relativePath:"01.算法/24.leetcode/10172.leetcode172 Factorial Trailing Zeroes-zh.md",key:"v-22a05178",path:"/p/4f95d4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:183},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:198},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:217},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:233},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:430}],headersStr:"题目描述 解法 Python3 Java TypeScript ...",content:"# 172. 阶乘后的零\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数 n，返回 n! 结果尾数中零的数量。\n\n示例 1:\n\n输入: 3\n输出: 0\n解释: 3! = 6, 尾数中没有零。\n\n示例 2:\n\n输入: 5\n输出: 1\n解释: 5! = 120, 尾数中有 1 个零.\n\n说明: 你算法的时间复杂度应为 O(log n) 。\n\n\n# 解法\n\n统计5的个数\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# TypeScript\n\nfunction trailingZeroes(n: number): number {\n    let count = 0;\n    while (n > 0) {\n        n = Math.floor(n / 5);\n        count += n;\n    }\n    return count;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 172. 阶乘后的零\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数 n，返回 n! 结果尾数中零的数量。\n\n示例 1:\n\n输入: 3\n输出: 0\n解释: 3! = 6, 尾数中没有零。\n\n示例 2:\n\n输入: 5\n输出: 1\n解释: 5! = 120, 尾数中有 1 个零.\n\n说明: 你算法的时间复杂度应为 o(log n) 。\n\n\n# 解法\n\n统计5的个数\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# typescript\n\nfunction trailingzeroes(n: number): number {\n    let count = 0;\n    while (n > 0) {\n        n = math.floor(n / 5);\n        count += n;\n    }\n    return count;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode174 Dungeon Game-zh",frontmatter:{title:"leetcode174 Dungeon Game-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/43f342/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode174 Dungeon Game-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10174.leetcode174%20Dungeon%20Game-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode174 Dungeon Game-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10174.leetcode174%20Dungeon%20Game-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode174 Dungeon Game-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10174.leetcode174%20Dungeon%20Game-zh.html",relativePath:"01.算法/24.leetcode/10174.leetcode174 Dungeon Game-zh.md",key:"v-6f5582e6",path:"/p/43f342/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:577},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:584},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:603},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:619}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 174. 地下城游戏\n\nEnglish Version\n\n\n# 题目描述\n\n一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。\n\n骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。\n\n有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。\n\n为了尽快到达公主，骑士决定每次只向右或向下移动一步。\n\n \n\n编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。\n\n例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。\n\n-2 (K)   -3    3\n-5       -10   1\n10       30    -5 (P)\n\n \n\n说明:\n\n * 骑士的健康点数没有上限。\n\n * 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 174. 地下城游戏\n\nenglish version\n\n\n# 题目描述\n\n一些恶魔抓住了公主（p）并将她关在了地下城的右下角。地下城是由 m x n 个房间组成的二维网格。我们英勇的骑士（k）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。\n\n骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。\n\n有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。\n\n为了尽快到达公主，骑士决定每次只向右或向下移动一步。\n\n \n\n编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。\n\n例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。\n\n-2 (k)   -3    3\n-5       -10   1\n10       30    -5 (p)\n\n \n\n说明:\n\n * 骑士的健康点数没有上限。\n\n * 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode173 Binary Search Tree Iterator-zh",frontmatter:{title:"leetcode173 Binary Search Tree Iterator-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/64c315/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0173.Binary%20Search%20Tree%20Iterator/images/bst-tree.png"},{name:"twitter:title",content:"leetcode173 Binary Search Tree Iterator-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0173.Binary%20Search%20Tree%20Iterator/images/bst-tree.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10173.leetcode173%20Binary%20Search%20Tree%20Iterator-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode173 Binary Search Tree Iterator-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0173.Binary%20Search%20Tree%20Iterator/images/bst-tree.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10173.leetcode173%20Binary%20Search%20Tree%20Iterator-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode173 Binary Search Tree Iterator-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0173.Binary%20Search%20Tree%20Iterator/images/bst-tree.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10173.leetcode173%20Binary%20Search%20Tree%20Iterator-zh.html",relativePath:"01.算法/24.leetcode/10173.leetcode173 Binary Search Tree Iterator-zh.md",key:"v-0328ed0a",path:"/p/64c315/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1229},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1418},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2344},{level:2,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:3571},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4686}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:'# 173. 二叉搜索树迭代器\n\nEnglish Version\n\n\n# 题目描述\n\n实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：\n\n * BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。\n * boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。\n * int next()将指针向右移动，然后返回指针处的数字。\n\n\n\n注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。\n\n你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。\n\n \n\n示例：\n\n\n输入\n["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n输出\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n\n解释\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // 返回 3\nbSTIterator.next();    // 返回 7\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 9\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 15\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 20\nbSTIterator.hasNext(); // 返回 False\n\n\n \n\n\n\n提示：\n\n * 树中节点的数目在范围 [1, 105] 内\n * 0 <= Node.val <= 106\n * 最多调用 105 次 hasNext 和 next 操作\n\n \n\n进阶：\n\n * 你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。\n\n\n# 解法\n\n初始化数据时，递归中序遍历，将二叉搜索树每个结点的值保存在列表 vals 中。用 cur/next 指针记录外部即将遍历的位置，初始化为 0。\n\n调用 next() 时，返回 vals[cur]，同时 cur 指针自增。调用 hasNext() 时，判断 cur 指针是否已经达到 vals 个数，若是，说明已经遍历结束，返回 false，否则返回 true。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n\n    def __init__(self, root: TreeNode):\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.vals.append(root.val)\n            inorder(root.right)\n\n        self.cur = 0\n        self.vals = []\n        inorder(root)\n\n    def next(self) -> int:\n        res = self.vals[self.cur]\n        self.cur += 1\n        return res\n\n    def hasNext(self) -> bool:\n        return self.cur < len(self.vals)\n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n\n    private List<Integer> vals;\n    private int next;\n\n    public BSTIterator(TreeNode root) {\n        next = 0;\n        vals = new ArrayList<>();\n        inorder(root);\n    }\n\n    public int next() {\n        return vals.get(next++);\n    }\n\n    public boolean hasNext() {\n        return next < vals.size();\n    }\n\n    private void inorder(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        inorder(root.left);\n        vals.add(root.val);\n        inorder(root.right);\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# JavaScript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nvar BSTIterator = function (root) {\n    this.stk = [];\n    this.cur = root;\n}\n\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function () {\n    while (this.cur) {\n        this.stk.push(this.cur);\n        this.cur = this.cur.left;\n    }\n    this.cur = this.stk.pop();\n    let res = this.cur.val;\n    this.cur = this.cur.right;\n    return (res);\n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function () {\n    if (this.stk.length === 0 && this.cur === null) return false;\n    return true;\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 173. 二叉搜索树迭代器\n\nenglish version\n\n\n# 题目描述\n\n实现一个二叉搜索树迭代器类bstiterator ，表示一个按中序遍历二叉搜索树（bst）的迭代器：\n\n * bstiterator(treenode root) 初始化 bstiterator 类的一个对象。bst 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 bst 中的数字，且该数字小于 bst 中的任何元素。\n * boolean hasnext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。\n * int next()将指针向右移动，然后返回指针处的数字。\n\n\n\n注意，指针初始化为一个不存在于 bst 中的数字，所以对 next() 的首次调用将返回 bst 中的最小元素。\n\n你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，bst 的中序遍历中至少存在一个下一个数字。\n\n \n\n示例：\n\n\n输入\n["bstiterator", "next", "next", "hasnext", "next", "hasnext", "next", "hasnext", "next", "hasnext"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n输出\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n\n解释\nbstiterator bstiterator = new bstiterator([7, 3, 15, null, null, 9, 20]);\nbstiterator.next();    // 返回 3\nbstiterator.next();    // 返回 7\nbstiterator.hasnext(); // 返回 true\nbstiterator.next();    // 返回 9\nbstiterator.hasnext(); // 返回 true\nbstiterator.next();    // 返回 15\nbstiterator.hasnext(); // 返回 true\nbstiterator.next();    // 返回 20\nbstiterator.hasnext(); // 返回 false\n\n\n \n\n\n\n提示：\n\n * 树中节点的数目在范围 [1, 105] 内\n * 0 <= node.val <= 106\n * 最多调用 105 次 hasnext 和 next 操作\n\n \n\n进阶：\n\n * 你可以设计一个满足下述条件的解决方案吗？next() 和 hasnext() 操作均摊时间复杂度为 o(1) ，并使用 o(h) 内存。其中 h 是树的高度。\n\n\n# 解法\n\n初始化数据时，递归中序遍历，将二叉搜索树每个结点的值保存在列表 vals 中。用 cur/next 指针记录外部即将遍历的位置，初始化为 0。\n\n调用 next() 时，返回 vals[cur]，同时 cur 指针自增。调用 hasnext() 时，判断 cur 指针是否已经达到 vals 个数，若是，说明已经遍历结束，返回 false，否则返回 true。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass bstiterator:\n\n    def __init__(self, root: treenode):\n        def inorder(root):\n            if root is none:\n                return\n            inorder(root.left)\n            self.vals.append(root.val)\n            inorder(root.right)\n\n        self.cur = 0\n        self.vals = []\n        inorder(root)\n\n    def next(self) -> int:\n        res = self.vals[self.cur]\n        self.cur += 1\n        return res\n\n    def hasnext(self) -> bool:\n        return self.cur < len(self.vals)\n\n\n# your bstiterator object will be instantiated and called as such:\n# obj = bstiterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasnext()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass bstiterator {\n\n    private list<integer> vals;\n    private int next;\n\n    public bstiterator(treenode root) {\n        next = 0;\n        vals = new arraylist<>();\n        inorder(root);\n    }\n\n    public int next() {\n        return vals.get(next++);\n    }\n\n    public boolean hasnext() {\n        return next < vals.size();\n    }\n\n    private void inorder(treenode root) {\n        if (root == null) {\n            return;\n        }\n        inorder(root.left);\n        vals.add(root.val);\n        inorder(root.right);\n    }\n}\n\n/**\n * your bstiterator object will be instantiated and called as such:\n * bstiterator obj = new bstiterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasnext();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# javascript\n\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n */\nvar bstiterator = function (root) {\n    this.stk = [];\n    this.cur = root;\n}\n\n\n/**\n * @return {number}\n */\nbstiterator.prototype.next = function () {\n    while (this.cur) {\n        this.stk.push(this.cur);\n        this.cur = this.cur.left;\n    }\n    this.cur = this.stk.pop();\n    let res = this.cur.val;\n    this.cur = this.cur.right;\n    return (res);\n};\n\n/**\n * @return {boolean}\n */\nbstiterator.prototype.hasnext = function () {\n    if (this.stk.length === 0 && this.cur === null) return false;\n    return true;\n};\n\n/**\n * your bstiterator object will be instantiated and called as such:\n * var obj = new bstiterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasnext()\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode175 Combine Two Tables-zh",frontmatter:{title:"leetcode175 Combine Two Tables-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/2a7c04/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode175 Combine Two Tables-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10175.leetcode175%20Combine%20Two%20Tables-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode175 Combine Two Tables-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10175.leetcode175%20Combine%20Two%20Tables-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode175 Combine Two Tables-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10175.leetcode175%20Combine%20Two%20Tables-zh.html",relativePath:"01.算法/24.leetcode/10175.leetcode175 Combine Two Tables-zh.md",key:"v-3186c650",path:"/p/2a7c04/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:591},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:493}],headersStr:"题目描述 解法 SQL",content:"# 175. 组合两个表\n\nEnglish Version\n\n\n# 题目描述\n\n表1: Person\n\n+-------------+---------+\n| 列名         | 类型     |\n+-------------+---------+\n| PersonId    | int     |\n| FirstName   | varchar |\n| LastName    | varchar |\n+-------------+---------+\nPersonId 是上表主键\n\n\n表2: Address\n\n+-------------+---------+\n| 列名         | 类型    |\n+-------------+---------+\n| AddressId   | int     |\n| PersonId    | int     |\n| City        | varchar |\n| State       | varchar |\n+-------------+---------+\nAddressId 是上表主键\n\n\n \n\n编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：\n\n \n\nFirstName, LastName, City, State\n\n\n\n# 解法\n\n左连接。\n\n\n# SQL\n\n# Write your MySQL query statement below\nSELECT p.FirstName, p.LastName, a.City, a.State\nFROM Person p\nLEFT JOIN Address a\nON p.PersonId = a.PersonId;\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# 175. 组合两个表\n\nenglish version\n\n\n# 题目描述\n\n表1: person\n\n+-------------+---------+\n| 列名         | 类型     |\n+-------------+---------+\n| personid    | int     |\n| firstname   | varchar |\n| lastname    | varchar |\n+-------------+---------+\npersonid 是上表主键\n\n\n表2: address\n\n+-------------+---------+\n| 列名         | 类型    |\n+-------------+---------+\n| addressid   | int     |\n| personid    | int     |\n| city        | varchar |\n| state       | varchar |\n+-------------+---------+\naddressid 是上表主键\n\n\n \n\n编写一个 sql 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：\n\n \n\nfirstname, lastname, city, state\n\n\n\n# 解法\n\n左连接。\n\n\n# sql\n\n# write your mysql query statement below\nselect p.firstname, p.lastname, a.city, a.state\nfrom person p\nleft join address a\non p.personid = a.personid;\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode176 Second Highest Salary-zh",frontmatter:{title:"leetcode176 Second Highest Salary-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/076d61/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode176 Second Highest Salary-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10176.leetcode176%20Second%20Highest%20Salary-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode176 Second Highest Salary-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10176.leetcode176%20Second%20Highest%20Salary-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode176 Second Highest Salary-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10176.leetcode176%20Second%20Highest%20Salary-zh.html",relativePath:"01.算法/24.leetcode/10176.leetcode176 Second Highest Salary-zh.md",key:"v-68c34360",path:"/p/076d61/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:390},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:46}],headersStr:"题目描述 解法 SQL",content:"# 176. 第二高的薪水\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。\n\n+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\n\n例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。\n\n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| 200                 |\n+---------------------+\n\n\n\n# 解法\n\n\n# SQL\n\n解法 1：使用 LIMIT 语句和子查询。\n\n# Write your MySQL query statement below\nSELECT\n(\n    SELECT DISTINCT Salary\n    FROM Employee\n    ORDER BY Salary DESC\n    LIMIT 1 OFFSET 1\n) AS SecondHighestSalary;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n解法 2：使用 MAX() 函数，从小于 MAX() 的 Salary 中挑选最大值 MAX() 即可。\n\n# Write your MySQL query statement below\nSELECT MAX(Salary) AS SecondHighestSalary\nFROM Employee\nWHERE Salary < (\n    SELECT MAX(Salary)\n    FROM Employee\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# 176. 第二高的薪水\n\nenglish version\n\n\n# 题目描述\n\n编写一个 sql 查询，获取 employee 表中第二高的薪水（salary） 。\n\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\n\n例如上述 employee 表，sql查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。\n\n+---------------------+\n| secondhighestsalary |\n+---------------------+\n| 200                 |\n+---------------------+\n\n\n\n# 解法\n\n\n# sql\n\n解法 1：使用 limit 语句和子查询。\n\n# write your mysql query statement below\nselect\n(\n    select distinct salary\n    from employee\n    order by salary desc\n    limit 1 offset 1\n) as secondhighestsalary;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n解法 2：使用 max() 函数，从小于 max() 的 salary 中挑选最大值 max() 即可。\n\n# write your mysql query statement below\nselect max(salary) as secondhighestsalary\nfrom employee\nwhere salary < (\n    select max(salary)\n    from employee\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode178 Rank Scores-zh",frontmatter:{title:"leetcode178 Rank Scores-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a2620f/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode178 Rank Scores-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10178.leetcode178%20Rank%20Scores-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode178 Rank Scores-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10178.leetcode178%20Rank%20Scores-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode178 Rank Scores-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10178.leetcode178%20Rank%20Scores-zh.html",relativePath:"01.算法/24.leetcode/10178.leetcode178 Rank Scores-zh.md",key:"v-6f27372b",path:"/p/a2620f/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:560},{level:3,title:"MySQL8",slug:"mysql8",normalizedTitle:"mysql8",charIndex:567},{level:3,title:"MySQL5",slug:"mysql5",normalizedTitle:"mysql5",charIndex:1045}],headersStr:"题目描述 解法 MySQL8 MySQL5",content:"# 178. 分数排名\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个 SQL 查询来实现分数排名。\n\n如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。\n\n+----+-------+\n| Id | Score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n\n\n例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：\n\n+-------+------+\n| Score | Rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n\n\n重要提示：对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 `Rank`\n\n\n# 解法\n\n\n# MySQL8\n\n使用 DENSE_RANK() 函数，语法如下：\n\nDENSE_RANK() OVER (\n    PARTITION BY <expression>[{,<expression>...}]\n    ORDER BY <expression> [ASC|DESC], [{,<expression>...}]\n)\n\n\n1\n2\n3\n4\n\n\n在这个语法中：\n\n * 首先，PARTITION BY 子句将 FROM 子句生成的结果集划分为分区。DENSE_RANK()函数应用于每个分区。\n * 其次，ORDER BY 子句指定 DENSE_RANK() 函数操作的每个分区中的行顺序。\n\n与 RANK() 函数不同，DENSE_RANK() 函数始终返回连续的排名值。\n\n题解如下：\n\n# Write your MySQL query statement below\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) 'Rank'\nFROM Scores;\n\n\n1\n2\n3\n\n\n\n# MySQL5\n\nMySQL 8 开始才提供了 ROW_NUMBER()，RANK()，DENSE_RANK() 等窗口函数，在之前的版本，可以使用变量实现类似的功能：\n\nSELECT Score,\n       CONVERT(rk, SIGNED) `Rank`\nFROM (SELECT Score,\n             IF(@latest = Score, @rank, @rank := @rank + 1) rk,\n             @latest := Score\n      FROM Scores,\n           (SELECT @rank := 0, @latest := NULL) tmp\n      ORDER BY Score DESC) s;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# 178. 分数排名\n\nenglish version\n\n\n# 题目描述\n\n编写一个 sql 查询来实现分数排名。\n\n如果两个分数相同，则两个分数排名（rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。\n\n+----+-------+\n| id | score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n\n\n例如，根据上述给定的 scores 表，你的查询应该返回（按分数从高到低排列）：\n\n+-------+------+\n| score | rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n\n\n重要提示：对于 mysql 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 `rank`\n\n\n# 解法\n\n\n# mysql8\n\n使用 dense_rank() 函数，语法如下：\n\ndense_rank() over (\n    partition by <expression>[{,<expression>...}]\n    order by <expression> [asc|desc], [{,<expression>...}]\n)\n\n\n1\n2\n3\n4\n\n\n在这个语法中：\n\n * 首先，partition by 子句将 from 子句生成的结果集划分为分区。dense_rank()函数应用于每个分区。\n * 其次，order by 子句指定 dense_rank() 函数操作的每个分区中的行顺序。\n\n与 rank() 函数不同，dense_rank() 函数始终返回连续的排名值。\n\n题解如下：\n\n# write your mysql query statement below\nselect score, dense_rank() over (order by score desc) 'rank'\nfrom scores;\n\n\n1\n2\n3\n\n\n\n# mysql5\n\nmysql 8 开始才提供了 row_number()，rank()，dense_rank() 等窗口函数，在之前的版本，可以使用变量实现类似的功能：\n\nselect score,\n       convert(rk, signed) `rank`\nfrom (select score,\n             if(@latest = score, @rank, @rank := @rank + 1) rk,\n             @latest := score\n      from scores,\n           (select @rank := 0, @latest := null) tmp\n      order by score desc) s;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode177 Nth Highest Salary-zh",frontmatter:{title:"leetcode177 Nth Highest Salary-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/1b72ec/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode177 Nth Highest Salary-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10177.leetcode177%20Nth%20Highest%20Salary-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode177 Nth Highest Salary-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10177.leetcode177%20Nth%20Highest%20Salary-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode177 Nth Highest Salary-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10177.leetcode177%20Nth%20Highest%20Salary-zh.html",relativePath:"01.算法/24.leetcode/10177.leetcode177 Nth Highest Salary-zh.md",key:"v-14b3b590",path:"/p/1b72ec/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:407},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:46}],headersStr:"题目描述 解法 SQL",content:"# 177. 第N高的薪水\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。\n\n+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\n\n例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。\n\n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| 200                    |\n+------------------------+\n\n\n\n# 解法\n\n\n# SQL\n\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT\nBEGIN\n    SET N = N - 1;\n  RETURN (\n      # Write your MySQL query statement below.\n      SELECT (\n          SELECT DISTINCT Salary\n          FROM Employee\n          ORDER BY Salary DESC\n          LIMIT 1 OFFSET N\n      )\n  );\nEND\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# 177. 第n高的薪水\n\nenglish version\n\n\n# 题目描述\n\n编写一个 sql 查询，获取 employee 表中第 n 高的薪水（salary）。\n\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\n\n例如上述 employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。\n\n+------------------------+\n| getnthhighestsalary(2) |\n+------------------------+\n| 200                    |\n+------------------------+\n\n\n\n# 解法\n\n\n# sql\n\ncreate function getnthhighestsalary(n int) returns int\nbegin\n    set n = n - 1;\n  return (\n      # write your mysql query statement below.\n      select (\n          select distinct salary\n          from employee\n          order by salary desc\n          limit 1 offset n\n      )\n  );\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode179 Largest Number-zh",frontmatter:{title:"leetcode179 Largest Number-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/2aa7a2/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode179 Largest Number-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10179.leetcode179%20Largest%20Number-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode179 Largest Number-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10179.leetcode179%20Largest%20Number-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode179 Largest Number-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10179.leetcode179%20Largest%20Number-zh.html",relativePath:"01.算法/24.leetcode/10179.leetcode179 Largest Number-zh.md",key:"v-22cacea6",path:"/p/2aa7a2/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:329},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:379},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:692},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1208}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 179. 最大数\n\nEnglish Version\n\n\n# 题目描述\n\n给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。\n\n注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。\n\n \n\n示例 1：\n\n\n输入：nums = [10,2]\n输出："210"\n\n示例 2：\n\n\n输入：nums = [3,30,34,5,9]\n输出："9534330"\n\n\n示例 3：\n\n\n输入：nums = [1]\n输出："1"\n\n\n示例 4：\n\n\n输入：nums = [10]\n输出："10"\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 109\n\n\n# 解法\n\n先转成字符串列表，再对字符串列表进行字典序降序排列。最后将列表所有字符串拼接即可。\n\n\n# Python3\n\nfrom functools import cmp_to_key\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        num_list = list(map(str, nums))\n        num_list.sort(key=cmp_to_key(lambda x, y: int(y + x) - int(x + y)))\n        return \'0\' if num_list[0] == \'0\' else \'\'.join(num_list)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Java\n\nclass Solution {\n    public String largestNumber(int[] nums) {\n        List<String> numList = new ArrayList<>();\n        for (int num : nums) {\n            numList.add(String.valueOf(num));\n        }\n        numList.sort((a, b) -> (b + a).compareTo(a + b));\n        if ("0".equals(numList.get(0))) return "0";\n        StringBuilder sb = new StringBuilder();\n        for (String s : numList) {\n            sb.append(s);\n        }\n        return sb.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 179. 最大数\n\nenglish version\n\n\n# 题目描述\n\n给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。\n\n注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。\n\n \n\n示例 1：\n\n\n输入：nums = [10,2]\n输出："210"\n\n示例 2：\n\n\n输入：nums = [3,30,34,5,9]\n输出："9534330"\n\n\n示例 3：\n\n\n输入：nums = [1]\n输出："1"\n\n\n示例 4：\n\n\n输入：nums = [10]\n输出："10"\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 109\n\n\n# 解法\n\n先转成字符串列表，再对字符串列表进行字典序降序排列。最后将列表所有字符串拼接即可。\n\n\n# python3\n\nfrom functools import cmp_to_key\n\nclass solution:\n    def largestnumber(self, nums: list[int]) -> str:\n        num_list = list(map(str, nums))\n        num_list.sort(key=cmp_to_key(lambda x, y: int(y + x) - int(x + y)))\n        return \'0\' if num_list[0] == \'0\' else \'\'.join(num_list)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# java\n\nclass solution {\n    public string largestnumber(int[] nums) {\n        list<string> numlist = new arraylist<>();\n        for (int num : nums) {\n            numlist.add(string.valueof(num));\n        }\n        numlist.sort((a, b) -> (b + a).compareto(a + b));\n        if ("0".equals(numlist.get(0))) return "0";\n        stringbuilder sb = new stringbuilder();\n        for (string s : numlist) {\n            sb.append(s);\n        }\n        return sb.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode180 Consecutive Numbers-zh",frontmatter:{title:"leetcode180 Consecutive Numbers-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/647279/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode180 Consecutive Numbers-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10180.leetcode180%20Consecutive%20Numbers-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode180 Consecutive Numbers-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10180.leetcode180%20Consecutive%20Numbers-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode180 Consecutive Numbers-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10180.leetcode180%20Consecutive%20Numbers-zh.html",relativePath:"01.算法/24.leetcode/10180.leetcode180 Consecutive Numbers-zh.md",key:"v-31cf86c2",path:"/p/647279/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:586},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:228}],headersStr:"题目描述 解法 SQL",content:"# 180. 连续出现的数字\n\nEnglish Version\n\n\n# 题目描述\n\n表：Logs\n\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| num         | varchar |\n+-------------+---------+\nid 是这个表的主键。\n\n \n\n编写一个 SQL 查询，查找所有至少连续出现三次的数字。\n\n返回的结果表中的数据可以按 任意顺序 排列。\n\n \n\n查询结果格式如下面的例子所示：\n\n \n\n\nLogs 表：\n+----+-----+\n| Id | Num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\n\nResult 表：\n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n1 是唯一连续出现至少三次的数字。\n\n\n\n# 解法\n\n\n# SQL\n\nselect distinct(Num) as ConsecutiveNums from Logs Curr where\n    Num = (select Num from Logs where id = Curr.id - 1) and\n    Num = (select Num from Logs where id = Curr.id - 2)\n\n\n1\n2\n3\n",normalizedContent:"# 180. 连续出现的数字\n\nenglish version\n\n\n# 题目描述\n\n表：logs\n\n\n+-------------+---------+\n| column name | type    |\n+-------------+---------+\n| id          | int     |\n| num         | varchar |\n+-------------+---------+\nid 是这个表的主键。\n\n \n\n编写一个 sql 查询，查找所有至少连续出现三次的数字。\n\n返回的结果表中的数据可以按 任意顺序 排列。\n\n \n\n查询结果格式如下面的例子所示：\n\n \n\n\nlogs 表：\n+----+-----+\n| id | num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\n\nresult 表：\n+-----------------+\n| consecutivenums |\n+-----------------+\n| 1               |\n+-----------------+\n1 是唯一连续出现至少三次的数字。\n\n\n\n# 解法\n\n\n# sql\n\nselect distinct(num) as consecutivenums from logs curr where\n    num = (select num from logs where id = curr.id - 1) and\n    num = (select num from logs where id = curr.id - 2)\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode181 Employees Earning More Than Their Managers-zh",frontmatter:{title:"leetcode181 Employees Earning More Than Their Managers-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a2cad5/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode181 Employees Earning More Than Their Managers-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10181.leetcode181%20Employees%20Earning%20More%20Than%20Their%20Managers-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode181 Employees Earning More Than Their Managers-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10181.leetcode181%20Employees%20Earning%20More%20Than%20Their%20Managers-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode181 Employees Earning More Than Their Managers-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10181.leetcode181%20Employees%20Earning%20More%20Than%20Their%20Managers-zh.html",relativePath:"01.算法/24.leetcode/10181.leetcode181 Employees Earning More Than Their Managers-zh.md",key:"v-24505513",path:"/p/a2cad5/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:543},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:413}],headersStr:"题目描述 解法 SQL",content:"# 181. 超过经理收入的员工\n\nEnglish Version\n\n\n# 题目描述\n\nEmployee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。\n\n+----+-------+--------+-----------+\n| Id | Name  | Salary | ManagerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | NULL      |\n| 4  | Max   | 90000  | NULL      |\n+----+-------+--------+-----------+\n\n\n给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。\n\n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n\n\n\n# 解法\n\n\n# SQL\n\nselect Name as Employee from Employee Curr where\n    Salary > (select Salary from Employee where Id = Curr.ManagerId)\n\n\n1\n2\n",normalizedContent:"# 181. 超过经理收入的员工\n\nenglish version\n\n\n# 题目描述\n\nemployee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 id，此外还有一列对应员工的经理的 id。\n\n+----+-------+--------+-----------+\n| id | name  | salary | managerid |\n+----+-------+--------+-----------+\n| 1  | joe   | 70000  | 3         |\n| 2  | henry | 80000  | 4         |\n| 3  | sam   | 60000  | null      |\n| 4  | max   | 90000  | null      |\n+----+-------+--------+-----------+\n\n\n给定 employee 表，编写一个 sql 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，joe 是唯一一个收入超过他的经理的员工。\n\n+----------+\n| employee |\n+----------+\n| joe      |\n+----------+\n\n\n\n# 解法\n\n\n# sql\n\nselect name as employee from employee curr where\n    salary > (select salary from employee where id = curr.managerid)\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode182 Duplicate Emails-zh",frontmatter:{title:"leetcode182 Duplicate Emails-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/ea4745/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode182 Duplicate Emails-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10182.leetcode182%20Duplicate%20Emails-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode182 Duplicate Emails-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10182.leetcode182%20Duplicate%20Emails-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode182 Duplicate Emails-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10182.leetcode182%20Duplicate%20Emails-zh.html",relativePath:"01.算法/24.leetcode/10182.leetcode182 Duplicate Emails-zh.md",key:"v-2f38b2cd",path:"/p/ea4745/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:310},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:49}],headersStr:"题目描述 解法 SQL",content:"# 182. 查找重复的电子邮箱\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。\n\n示例：\n\n+----+---------+\n| Id | Email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n\n\n根据以上输入，你的查询应返回以下结果：\n\n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n\n\n说明：所有电子邮箱都是小写字母。\n\n\n# 解法\n\n\n# SQL\n\nselect Email from Person group by Email having count(Email) > 1\n\n\n1\n",normalizedContent:"# 182. 查找重复的电子邮箱\n\nenglish version\n\n\n# 题目描述\n\n编写一个 sql 查询，查找 person 表中所有重复的电子邮箱。\n\n示例：\n\n+----+---------+\n| id | email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n\n\n根据以上输入，你的查询应返回以下结果：\n\n+---------+\n| email   |\n+---------+\n| a@b.com |\n+---------+\n\n\n说明：所有电子邮箱都是小写字母。\n\n\n# 解法\n\n\n# sql\n\nselect email from person group by email having count(email) > 1\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode183 Customers Who Never Order-zh",frontmatter:{title:"leetcode183 Customers Who Never Order-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/2e1a79/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode183 Customers Who Never Order-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10183.leetcode183%20Customers%20Who%20Never%20Order-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode183 Customers Who Never Order-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10183.leetcode183%20Customers%20Who%20Never%20Order-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode183 Customers Who Never Order-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10183.leetcode183%20Customers%20Who%20Never%20Order-zh.html",relativePath:"01.算法/24.leetcode/10183.leetcode183 Customers Who Never Order-zh.md",key:"v-2d1f7017",path:"/p/2e1a79/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:480},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:78}],headersStr:"题目描述 解法 SQL",content:"# 183. 从不订购的客户\n\nEnglish Version\n\n\n# 题目描述\n\n某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。\n\nCustomers 表：\n\n+----+-------+\n| Id | Name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\n\n\nOrders 表：\n\n+----+------------+\n| Id | CustomerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n\n\n例如给定上述表格，你的查询应返回：\n\n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+\n\n\n\n# 解法\n\n\n# SQL\n\nselect Name as Customers from Customers\n    where id not in (select CustomerId from Orders)\n\n\n1\n2\n",normalizedContent:"# 183. 从不订购的客户\n\nenglish version\n\n\n# 题目描述\n\n某网站包含两个表，customers 表和 orders 表。编写一个 sql 查询，找出所有从不订购任何东西的客户。\n\ncustomers 表：\n\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | joe   |\n| 2  | henry |\n| 3  | sam   |\n| 4  | max   |\n+----+-------+\n\n\norders 表：\n\n+----+------------+\n| id | customerid |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n\n\n例如给定上述表格，你的查询应返回：\n\n+-----------+\n| customers |\n+-----------+\n| henry     |\n| max       |\n+-----------+\n\n\n\n# 解法\n\n\n# sql\n\nselect name as customers from customers\n    where id not in (select customerid from orders)\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode184 Department Highest Salary-zh",frontmatter:{title:"leetcode184 Department Highest Salary-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/df5343/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode184 Department Highest Salary-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10184.leetcode184%20Department%20Highest%20Salary-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode184 Department Highest Salary-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10184.leetcode184%20Department%20Highest%20Salary-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode184 Department Highest Salary-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10184.leetcode184%20Department%20Highest%20Salary-zh.html",relativePath:"01.算法/24.leetcode/10184.leetcode184 Department Highest Salary-zh.md",key:"v-66feb918",path:"/p/df5343/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:947},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:594}],headersStr:"题目描述 解法 SQL",content:"# 184. 部门工资最高的员工\n\nEnglish Version\n\n\n# 题目描述\n\nEmployee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。\n\n+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Jim   | 90000  | 1            |\n| 3  | Henry | 80000  | 2            |\n| 4  | Sam   | 60000  | 2            |\n| 5  | Max   | 90000  | 1            |\n+----+-------+--------+--------------+\n\nDepartment 表包含公司所有部门的信息。\n\n+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+\n\n编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。\n\n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Jim      | 90000  |\n| Sales      | Henry    | 80000  |\n+------------+----------+--------+\n\n解释：\n\nMax 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。\n\n\n# 解法\n\n\n# SQL\n\nSELECT\n\tDepartment.NAME AS Department,\n\tEmployee.NAME AS Employee,\n\tSalary\nFROM\n\tEmployee,\n\tDepartment\nWHERE\n\tEmployee.DepartmentId = Department.Id\n\tAND ( Employee.DepartmentId, Salary )\n    IN (SELECT DepartmentId, max( Salary )\n        FROM Employee\n        GROUP BY DepartmentId )\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# 184. 部门工资最高的员工\n\nenglish version\n\n\n# 题目描述\n\nemployee 表包含所有员工信息，每个员工有其对应的 id, salary 和 department id。\n\n+----+-------+--------+--------------+\n| id | name  | salary | departmentid |\n+----+-------+--------+--------------+\n| 1  | joe   | 70000  | 1            |\n| 2  | jim   | 90000  | 1            |\n| 3  | henry | 80000  | 2            |\n| 4  | sam   | 60000  | 2            |\n| 5  | max   | 90000  | 1            |\n+----+-------+--------+--------------+\n\ndepartment 表包含公司所有部门的信息。\n\n+----+----------+\n| id | name     |\n+----+----------+\n| 1  | it       |\n| 2  | sales    |\n+----+----------+\n\n编写一个 sql 查询，找出每个部门工资最高的员工。对于上述表，您的 sql 查询应返回以下行（行的顺序无关紧要）。\n\n+------------+----------+--------+\n| department | employee | salary |\n+------------+----------+--------+\n| it         | max      | 90000  |\n| it         | jim      | 90000  |\n| sales      | henry    | 80000  |\n+------------+----------+--------+\n\n解释：\n\nmax 和 jim 在 it 部门的工资都是最高的，henry 在销售部的工资最高。\n\n\n# 解法\n\n\n# sql\n\nselect\n\tdepartment.name as department,\n\temployee.name as employee,\n\tsalary\nfrom\n\temployee,\n\tdepartment\nwhere\n\temployee.departmentid = department.id\n\tand ( employee.departmentid, salary )\n    in (select departmentid, max( salary )\n        from employee\n        group by departmentid )\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode185 Department Top Three Salaries-zh",frontmatter:{title:"leetcode185 Department Top Three Salaries-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d64ea2/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode185 Department Top Three Salaries-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10185.leetcode185%20Department%20Top%20Three%20Salaries-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode185 Department Top Three Salaries-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10185.leetcode185%20Department%20Top%20Three%20Salaries-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode185 Department Top Three Salaries-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10185.leetcode185%20Department%20Top%20Three%20Salaries-zh.html",relativePath:"01.算法/24.leetcode/10185.leetcode185 Department Top Three Salaries-zh.md",key:"v-4484de06",path:"/p/d64ea2/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:41},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1196},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:691}],headersStr:"题目描述 解法 SQL",content:"# 185. 部门工资前三高的所有员工\n\nEnglish Version\n\n\n# 题目描述\n\nEmployee 表包含所有员工信息，每个员工有其对应的工号 Id，姓名 Name，工资 Salary 和部门编号 DepartmentId 。\n\n+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\n\nDepartment 表包含公司所有部门的信息。\n\n+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+\n\n编写一个 SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：\n\n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Randy    | 85000  |\n| IT         | Joe      | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n\n解释：\n\nIT 部门中，Max 获得了最高的工资，Randy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。销售部门（Sales）只有两名员工，Henry 的工资最高，Sam 的工资排第二。\n\n\n# 解法\n\n\n# SQL\n\nSELECT\n\tDepartment.NAME AS Department,\n\tEmployee.NAME AS Employee,\n\tSalary\nFROM\n\tEmployee,\n\tDepartment\nWHERE\n\tEmployee.DepartmentId = Department.Id\n\tAND  (SELECT\n            COUNT(DISTINCT e2.Salary)\n        FROM\n            Employee e2\n        WHERE\n            e2.Salary > Employee.Salary\n                AND Employee.DepartmentId = e2.DepartmentId\n    ) < 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"# 185. 部门工资前三高的所有员工\n\nenglish version\n\n\n# 题目描述\n\nemployee 表包含所有员工信息，每个员工有其对应的工号 id，姓名 name，工资 salary 和部门编号 departmentid 。\n\n+----+-------+--------+--------------+\n| id | name  | salary | departmentid |\n+----+-------+--------+--------------+\n| 1  | joe   | 85000  | 1            |\n| 2  | henry | 80000  | 2            |\n| 3  | sam   | 60000  | 2            |\n| 4  | max   | 90000  | 1            |\n| 5  | janet | 69000  | 1            |\n| 6  | randy | 85000  | 1            |\n| 7  | will  | 70000  | 1            |\n+----+-------+--------+--------------+\n\ndepartment 表包含公司所有部门的信息。\n\n+----+----------+\n| id | name     |\n+----+----------+\n| 1  | it       |\n| 2  | sales    |\n+----+----------+\n\n编写一个 sql 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：\n\n+------------+----------+--------+\n| department | employee | salary |\n+------------+----------+--------+\n| it         | max      | 90000  |\n| it         | randy    | 85000  |\n| it         | joe      | 85000  |\n| it         | will     | 70000  |\n| sales      | henry    | 80000  |\n| sales      | sam      | 60000  |\n+------------+----------+--------+\n\n解释：\n\nit 部门中，max 获得了最高的工资，randy 和 joe 都拿到了第二高的工资，will 的工资排第三。销售部门（sales）只有两名员工，henry 的工资最高，sam 的工资排第二。\n\n\n# 解法\n\n\n# sql\n\nselect\n\tdepartment.name as department,\n\temployee.name as employee,\n\tsalary\nfrom\n\temployee,\n\tdepartment\nwhere\n\temployee.departmentid = department.id\n\tand  (select\n            count(distinct e2.salary)\n        from\n            employee e2\n        where\n            e2.salary > employee.salary\n                and employee.departmentid = e2.departmentid\n    ) < 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode186 Reverse Words in a String II-zh",frontmatter:{title:"leetcode186 Reverse Words in a String II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/036d01/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode186 Reverse Words in a String II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10186.leetcode186%20Reverse%20Words%20in%20a%20String%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode186 Reverse Words in a String II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10186.leetcode186%20Reverse%20Words%20in%20a%20String%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode186 Reverse Words in a String II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10186.leetcode186%20Reverse%20Words%20in%20a%20String%20II-zh.html",relativePath:"01.算法/24.leetcode/10186.leetcode186 Reverse Words in a String II-zh.md",key:"v-12c5050d",path:"/p/036d01/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:41},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:301},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:316},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:335},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:351}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 186. 翻转字符串里的单词 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串，逐个翻转字符串中的每个单词。\n\n示例：\n\n输入: ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]\n输出: ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]\n\n注意：\n\n * 单词的定义是不包含空格的一系列字符\n * 输入字符串中不会包含前置或尾随的空格\n * 单词与单词之间永远是以单个空格隔开的\n\n进阶：使用 O(1) 额外空间复杂度的原地解法。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 186. 翻转字符串里的单词 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串，逐个翻转字符串中的每个单词。\n\n示例：\n\n输入: ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]\n输出: ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]\n\n注意：\n\n * 单词的定义是不包含空格的一系列字符\n * 输入字符串中不会包含前置或尾随的空格\n * 单词与单词之间永远是以单个空格隔开的\n\n进阶：使用 o(1) 额外空间复杂度的原地解法。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode188 Best Time to Buy and Sell Stock IV-zh",frontmatter:{title:"leetcode188 Best Time to Buy and Sell Stock IV-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/8e4d7f/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode188 Best Time to Buy and Sell Stock IV-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10188.leetcode188%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20IV-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode188 Best Time to Buy and Sell Stock IV-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10188.leetcode188%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20IV-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode188 Best Time to Buy and Sell Stock IV-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10188.leetcode188%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20IV-zh.html",relativePath:"01.算法/24.leetcode/10188.leetcode188 Best Time to Buy and Sell Stock IV-zh.md",key:"v-7c3f7872",path:"/p/8e4d7f/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:41},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:581},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:588},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:607},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:623}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 188. 买卖股票的最佳时机 IV\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n示例 1：\n\n\n输入：k = 2, prices = [2,4,1]\n输出：2\n解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\n\n示例 2：\n\n\n输入：k = 2, prices = [3,2,6,5,0,3]\n输出：7\n解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。\n     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n\n \n\n提示：\n\n * 0 <= k <= 100\n * 0 <= prices.length <= 1000\n * 0 <= prices[i] <= 1000\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 188. 买卖股票的最佳时机 iv\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n示例 1：\n\n\n输入：k = 2, prices = [2,4,1]\n输出：2\n解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\n\n示例 2：\n\n\n输入：k = 2, prices = [3,2,6,5,0,3]\n输出：7\n解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。\n     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n\n \n\n提示：\n\n * 0 <= k <= 100\n * 0 <= prices.length <= 1000\n * 0 <= prices[i] <= 1000\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode187 Repeated DNA Sequences-zh",frontmatter:{title:"leetcode187 Repeated DNA Sequences-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/99a96f/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode187 Repeated DNA Sequences-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10187.leetcode187%20Repeated%20DNA%20Sequences-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode187 Repeated DNA Sequences-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10187.leetcode187%20Repeated%20DNA%20Sequences-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode187 Repeated DNA Sequences-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10187.leetcode187%20Repeated%20DNA%20Sequences-zh.html",relativePath:"01.算法/24.leetcode/10187.leetcode187 Repeated DNA Sequences-zh.md",key:"v-6fccf164",path:"/p/99a96f/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:391},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:398},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:748},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1255},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1622}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 187. 重复的DNA序列\n\nEnglish Version\n\n\n# 题目描述\n\n所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T' 的核苷酸组成，例如：\"ACGAATTCCG\"。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。\n\n编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。\n\n \n\n示例 1：\n\n\n输入：s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n输出：[\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n\n\n示例 2：\n\n\n输入：s = \"AAAAAAAAAAAAA\"\n输出：[\"AAAAAAAAAA\"]\n\n\n \n\n提示：\n\n * 0 <= s.length <= 105\n * s[i] 为 'A'、'C'、'G' 或 'T'\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        n = 10\n        subs = set()\n        res = set()\n        for i in range(len(s) - n + 1):\n            sub = s[i:i + n]\n            if sub in subs:\n                res.add(sub)\n            subs.add(sub)\n        return list(res)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Java\n\nclass Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        int len = 10;\n        Set<String> subs = new HashSet<>();\n        Set<String> res = new HashSet<>();\n        for (int i = 0; i < s.length() - len + 1; ++i) {\n            String sub = s.substring(i, i + len);\n            if (subs.contains(sub)) {\n                res.add(sub);\n            }\n            subs.add(sub);\n        }\n        return new ArrayList<>(res);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# JavaScript\n\n/**\n * @param {string} s\n * @return {string[]}\n */\nvar findRepeatedDnaSequences = function(s) {\n    let n = 10;\n    let subs = new Set();\n    let res = new Set();\n    for (let i = 0; i < s.length - n + 1; i++) {\n        let sub = s.slice(i, i + n);\n        if (subs.has(sub)) {\n            res.add(sub);\n        }\n        subs.add(sub);\n    }\n    return [...res];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 187. 重复的dna序列\n\nenglish version\n\n\n# 题目描述\n\n所有 dna 都由一系列缩写为 'a'，'c'，'g' 和 't' 的核苷酸组成，例如：\"acgaattccg\"。在研究 dna 时，识别 dna 中的重复序列有时会对研究非常有帮助。\n\n编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 dna 字符串 s 中出现次数超过一次。\n\n \n\n示例 1：\n\n\n输入：s = \"aaaaacccccaaaaaccccccaaaaagggttt\"\n输出：[\"aaaaaccccc\",\"cccccaaaaa\"]\n\n\n示例 2：\n\n\n输入：s = \"aaaaaaaaaaaaa\"\n输出：[\"aaaaaaaaaa\"]\n\n\n \n\n提示：\n\n * 0 <= s.length <= 105\n * s[i] 为 'a'、'c'、'g' 或 't'\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def findrepeateddnasequences(self, s: str) -> list[str]:\n        n = 10\n        subs = set()\n        res = set()\n        for i in range(len(s) - n + 1):\n            sub = s[i:i + n]\n            if sub in subs:\n                res.add(sub)\n            subs.add(sub)\n        return list(res)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# java\n\nclass solution {\n    public list<string> findrepeateddnasequences(string s) {\n        int len = 10;\n        set<string> subs = new hashset<>();\n        set<string> res = new hashset<>();\n        for (int i = 0; i < s.length() - len + 1; ++i) {\n            string sub = s.substring(i, i + len);\n            if (subs.contains(sub)) {\n                res.add(sub);\n            }\n            subs.add(sub);\n        }\n        return new arraylist<>(res);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# javascript\n\n/**\n * @param {string} s\n * @return {string[]}\n */\nvar findrepeateddnasequences = function(s) {\n    let n = 10;\n    let subs = new set();\n    let res = new set();\n    for (let i = 0; i < s.length - n + 1; i++) {\n        let sub = s.slice(i, i + n);\n        if (subs.has(sub)) {\n            res.add(sub);\n        }\n        subs.add(sub);\n    }\n    return [...res];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode189 Rotate Array-zh",frontmatter:{title:"leetcode189 Rotate Array-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/035bd4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode189 Rotate Array-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10189.leetcode189%20Rotate%20Array-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode189 Rotate Array-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10189.leetcode189%20Rotate%20Array-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode189 Rotate Array-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10189.leetcode189%20Rotate%20Array-zh.html",relativePath:"01.算法/24.leetcode/10189.leetcode189 Rotate Array-zh.md",key:"v-6fe55fb2",path:"/p/035bd4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:510},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:711},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1092},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1716},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1966}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:'# 189. 旋转数组\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。\n\n \n\n进阶：\n\n * 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n * 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？\n\n \n\n示例 1:\n\n\n输入: nums = [1,2,3,4,5,6,7], k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]\n\n\n示例 2:\n\n\n输入：nums = [-1,-100,3,99], k = 2\n输出：[3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]\n\n \n\n提示：\n\n * 1 <= nums.length <= 2 * 104\n * -231 <= nums[i] <= 231 - 1\n * 0 <= k <= 105\n\n\n# 解法\n\n若 k=3，nums=[1,2,3,4,5,6,7]。\n\n先将 nums 整体翻转：[1,2,3,4,5,6,7] -> [7,6,5,4,3,2,1]\n\n再翻转 0~k-1 范围内的元素：[7,6,5,4,3,2,1] -> [5,6,7,4,3,2,1]\n\n最后翻转 k~n-1 范围内的元素，即可得到最终结果：[5,6,7,4,3,2,1] -> [5,6,7,1,2,3,4]\n\n\n# Python3\n\nclass Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        """\n        Do not return anything, modify nums in-place instead.\n        """\n        n = len(nums)\n        k %= n\n        if n < 2 or k == 0:\n            return\n        nums[:] = nums[::-1]\n        nums[:k] = nums[:k][::-1]\n        nums[k:] = nums[k:][::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        if (nums == null) {\n            return;\n        }\n        int n = nums.length;\n        k %= n;\n        if (n < 2 || k == 0) {\n            return;\n        }\n\n        rotate(nums, 0, n - 1);\n        rotate(nums, 0, k - 1);\n        rotate(nums, k, n - 1);\n    }\n\n    private void rotate(int[] nums, int i, int j) {\n        while (i < j) {\n            int t = nums[i];\n            nums[i] = nums[j];\n            nums[j] = t;\n            ++i;\n            --j;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# JavaScript\n\n使用原生 API 将数组的 k~n-1 范围内的元素插入到前面\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar rotate = function (nums, k) {\n    k %= nums.length;\n    nums.splice(0, 0, ...nums.splice(-k, k))\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 189. 旋转数组\n\nenglish version\n\n\n# 题目描述\n\n给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。\n\n \n\n进阶：\n\n * 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n * 你可以使用空间复杂度为 o(1) 的 原地 算法解决这个问题吗？\n\n \n\n示例 1:\n\n\n输入: nums = [1,2,3,4,5,6,7], k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]\n\n\n示例 2:\n\n\n输入：nums = [-1,-100,3,99], k = 2\n输出：[3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]\n\n \n\n提示：\n\n * 1 <= nums.length <= 2 * 104\n * -231 <= nums[i] <= 231 - 1\n * 0 <= k <= 105\n\n\n# 解法\n\n若 k=3，nums=[1,2,3,4,5,6,7]。\n\n先将 nums 整体翻转：[1,2,3,4,5,6,7] -> [7,6,5,4,3,2,1]\n\n再翻转 0~k-1 范围内的元素：[7,6,5,4,3,2,1] -> [5,6,7,4,3,2,1]\n\n最后翻转 k~n-1 范围内的元素，即可得到最终结果：[5,6,7,4,3,2,1] -> [5,6,7,1,2,3,4]\n\n\n# python3\n\nclass solution:\n    def rotate(self, nums: list[int], k: int) -> none:\n        """\n        do not return anything, modify nums in-place instead.\n        """\n        n = len(nums)\n        k %= n\n        if n < 2 or k == 0:\n            return\n        nums[:] = nums[::-1]\n        nums[:k] = nums[:k][::-1]\n        nums[k:] = nums[k:][::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public void rotate(int[] nums, int k) {\n        if (nums == null) {\n            return;\n        }\n        int n = nums.length;\n        k %= n;\n        if (n < 2 || k == 0) {\n            return;\n        }\n\n        rotate(nums, 0, n - 1);\n        rotate(nums, 0, k - 1);\n        rotate(nums, k, n - 1);\n    }\n\n    private void rotate(int[] nums, int i, int j) {\n        while (i < j) {\n            int t = nums[i];\n            nums[i] = nums[j];\n            nums[j] = t;\n            ++i;\n            --j;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# javascript\n\n使用原生 api 将数组的 k~n-1 范围内的元素插入到前面\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} do not return anything, modify nums in-place instead.\n */\nvar rotate = function (nums, k) {\n    k %= nums.length;\n    nums.splice(0, 0, ...nums.splice(-k, k))\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode190 Reverse Bits-zh",frontmatter:{title:"leetcode190 Reverse Bits-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/2f9de5/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode190 Reverse Bits-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10190.leetcode190%20Reverse%20Bits-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode190 Reverse Bits-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10190.leetcode190%20Reverse%20Bits-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode190 Reverse Bits-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10190.leetcode190%20Reverse%20Bits-zh.html",relativePath:"01.算法/24.leetcode/10190.leetcode190 Reverse Bits-zh.md",key:"v-087510e6",path:"/p/2f9de5/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:1203},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1210},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:87},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1736},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2003},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2317}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript ...",content:"# 190. 颠倒二进制位\n\nEnglish Version\n\n\n# 题目描述\n\n颠倒给定的 32 位无符号整数的二进制位。\n\n \n\n提示：\n\n * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。\n\n \n\n进阶:\n如果多次调用这个函数，你将如何优化你的算法？\n\n \n\n示例 1：\n\n\n输入: 00000010100101000001111010011100\n输出: 00111001011110000010100101000000\n解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，\n     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n\n示例 2：\n\n\n输入：11111111111111111111111111111101\n输出：10111111111111111111111111111111\n解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，\n     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。\n\n示例 1：\n\n\n输入：n = 00000010100101000001111010011100\n输出：964176192 (00111001011110000010100101000000)\n解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，\n     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n\n示例 2：\n\n\n输入：n = 11111111111111111111111111111101\n输出：3221225471 (10111111111111111111111111111111)\n解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，\n     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。\n\n \n\n提示：\n\n * 输入是一个长度为 32 的二进制字符串\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def reverseBits(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            res |= ((n & 1) << (31 - i))\n            n >>= 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Java\n\npublic class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int res = 0;\n        for (int i = 0; i < 32 && n != 0; ++i) {\n            res |= ((n & 1) << (31 - i));\n            n >>>= 1;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# C++\n\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t res = 0;\n        for (int i = 0; i < 32; ++i) {\n            res |= ((n & 1) << (31 - i));\n            n >>= 1;\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# JavaScript\n\n/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nvar reverseBits = function (n) {\n  let res = 0;\n  for (let i = 0; i < 32 && n > 0; ++i) {\n    res |= (n & 1) << (31 - i);\n    n >>>= 1;\n  }\n  // 无符号右移\n  return res >>> 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 190. 颠倒二进制位\n\nenglish version\n\n\n# 题目描述\n\n颠倒给定的 32 位无符号整数的二进制位。\n\n \n\n提示：\n\n * 请注意，在某些语言（如 java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n * 在 java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。\n\n \n\n进阶:\n如果多次调用这个函数，你将如何优化你的算法？\n\n \n\n示例 1：\n\n\n输入: 00000010100101000001111010011100\n输出: 00111001011110000010100101000000\n解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，\n     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n\n示例 2：\n\n\n输入：11111111111111111111111111111101\n输出：10111111111111111111111111111111\n解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，\n     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。\n\n示例 1：\n\n\n输入：n = 00000010100101000001111010011100\n输出：964176192 (00111001011110000010100101000000)\n解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，\n     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n\n示例 2：\n\n\n输入：n = 11111111111111111111111111111101\n输出：3221225471 (10111111111111111111111111111111)\n解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，\n     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。\n\n \n\n提示：\n\n * 输入是一个长度为 32 的二进制字符串\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def reversebits(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            res |= ((n & 1) << (31 - i))\n            n >>= 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# java\n\npublic class solution {\n    // you need treat n as an unsigned value\n    public int reversebits(int n) {\n        int res = 0;\n        for (int i = 0; i < 32 && n != 0; ++i) {\n            res |= ((n & 1) << (31 - i));\n            n >>>= 1;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# c++\n\nclass solution {\npublic:\n    uint32_t reversebits(uint32_t n) {\n        uint32_t res = 0;\n        for (int i = 0; i < 32; ++i) {\n            res |= ((n & 1) << (31 - i));\n            n >>= 1;\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# javascript\n\n/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nvar reversebits = function (n) {\n  let res = 0;\n  for (let i = 0; i < 32 && n > 0; ++i) {\n    res |= (n & 1) << (31 - i);\n    n >>>= 1;\n  }\n  // 无符号右移\n  return res >>> 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode191 Number of 1 Bits-zh",frontmatter:{title:"leetcode191 Number of 1 Bits-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/ca7d94/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode191 Number of 1 Bits-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10191.leetcode191%20Number%20of%201%20Bits-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode191 Number of 1 Bits-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10191.leetcode191%20Number%20of%201%20Bits-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode191 Number of 1 Bits-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10191.leetcode191%20Number%20of%201%20Bits-zh.html",relativePath:"01.算法/24.leetcode/10191.leetcode191 Number of 1 Bits-zh.md",key:"v-76f71d4d",path:"/p/ca7d94/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:681},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:745},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:127},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1209},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1437}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 191. 位1的个数\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。\n\n \n\n提示：\n\n * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n\n \n\n示例 1：\n\n\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n\n\n示例 2：\n\n\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n\n\n示例 3：\n\n\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n\n \n\n提示：\n\n * 输入必须是长度为 32 的 二进制串 。\n\n \n\n进阶：\n\n * 如果多次调用这个函数，你将如何优化你的算法？\n\n\n# 解法\n\nn & (n - 1) 会消除 n 中最后一位中的 1。\n\n同 剑指 Offer 15. 二进制中 1 的个数\n\n\n# Python3\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            n &= (n - 1)\n            res += 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Java\n\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int res = 0;\n        while (n != 0) {\n            n &= (n - 1);\n            ++res;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# JavaScript\n\n/**\n * @param {number} n - a positive integer\n * @return {number}\n */\nvar hammingWeight = function (n) {\n  let res = 0;\n  while (n) {\n    n &= n - 1;\n    ++res;\n  }\n  return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 191. 位1的个数\n\nenglish version\n\n\n# 题目描述\n\n编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。\n\n \n\n提示：\n\n * 请注意，在某些语言（如 java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n * 在 java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n\n \n\n示例 1：\n\n\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n\n\n示例 2：\n\n\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n\n\n示例 3：\n\n\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n\n \n\n提示：\n\n * 输入必须是长度为 32 的 二进制串 。\n\n \n\n进阶：\n\n * 如果多次调用这个函数，你将如何优化你的算法？\n\n\n# 解法\n\nn & (n - 1) 会消除 n 中最后一位中的 1。\n\n同 剑指 offer 15. 二进制中 1 的个数\n\n\n# python3\n\nclass solution:\n    def hammingweight(self, n: int) -> int:\n        res = 0\n        while n:\n            n &= (n - 1)\n            res += 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# java\n\npublic class solution {\n    // you need to treat n as an unsigned value\n    public int hammingweight(int n) {\n        int res = 0;\n        while (n != 0) {\n            n &= (n - 1);\n            ++res;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# javascript\n\n/**\n * @param {number} n - a positive integer\n * @return {number}\n */\nvar hammingweight = function (n) {\n  let res = 0;\n  while (n) {\n    n &= n - 1;\n    ++res;\n  }\n  return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode192 Word Frequency-zh",frontmatter:{title:"leetcode192 Word Frequency-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/610d36/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode192 Word Frequency-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10192.leetcode192%20Word%20Frequency-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode192 Word Frequency-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10192.leetcode192%20Word%20Frequency-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode192 Word Frequency-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10192.leetcode192%20Word%20Frequency-zh.html",relativePath:"01.算法/24.leetcode/10192.leetcode192 Word Frequency-zh.md",key:"v-47133da7",path:"/p/610d36/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:350},{level:3,title:"Bash",slug:"bash",normalizedTitle:"bash",charIndex:357}],headersStr:"题目描述 解法 Bash",content:"# 192. 统计词频\n\nEnglish Version\n\n\n# 题目描述\n\n写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。\n\n为了简单起见，你可以假设：\n\n * words.txt只包括小写字母和 ' ' 。\n * 每个单词只由小写字母组成。\n * 单词间由一个或多个空格字符分隔。\n\n示例:\n\n假设 words.txt 内容如下：\n\nthe day is sunny the the\nthe sunny is is\n\n\n你的脚本应当输出（以词频降序排列）：\n\nthe 4\nis 3\nsunny 2\nday 1\n\n\n说明:\n\n * 不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。\n * 你可以使用一行 Unix pipes 实现吗？\n\n\n# 解法\n\n\n# Bash\n\n\n\n\n1\n",normalizedContent:"# 192. 统计词频\n\nenglish version\n\n\n# 题目描述\n\n写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。\n\n为了简单起见，你可以假设：\n\n * words.txt只包括小写字母和 ' ' 。\n * 每个单词只由小写字母组成。\n * 单词间由一个或多个空格字符分隔。\n\n示例:\n\n假设 words.txt 内容如下：\n\nthe day is sunny the the\nthe sunny is is\n\n\n你的脚本应当输出（以词频降序排列）：\n\nthe 4\nis 3\nsunny 2\nday 1\n\n\n说明:\n\n * 不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。\n * 你可以使用一行 unix pipes 实现吗？\n\n\n# 解法\n\n\n# bash\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode193 Valid Phone Numbers-zh",frontmatter:{title:"leetcode193 Valid Phone Numbers-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/bc41dd/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode193 Valid Phone Numbers-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10193.leetcode193%20Valid%20Phone%20Numbers-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode193 Valid Phone Numbers-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10193.leetcode193%20Valid%20Phone%20Numbers-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode193 Valid Phone Numbers-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10193.leetcode193%20Valid%20Phone%20Numbers-zh.html",relativePath:"01.算法/24.leetcode/10193.leetcode193 Valid Phone Numbers-zh.md",key:"v-56e01078",path:"/p/bc41dd/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:320},{level:3,title:"Bash",slug:"bash",normalizedTitle:"bash",charIndex:327}],headersStr:"题目描述 解法 Bash",content:"# 193. 有效电话号码\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。\n\n你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）\n\n你也可以假设每行前后没有多余的空格字符。\n\n \n\n示例：\n\n假设 file.txt 内容如下：\n\n\n987-123-4567\n123 456 7890\n(123) 456-7890\n\n\n你的脚本应当输出下列有效的电话号码：\n\n\n987-123-4567\n(123) 456-7890\n\n\n\n# 解法\n\n\n# Bash\n\n\n\n\n1\n",normalizedContent:"# 193. 有效电话号码\n\nenglish version\n\n\n# 题目描述\n\n给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。\n\n你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）\n\n你也可以假设每行前后没有多余的空格字符。\n\n \n\n示例：\n\n假设 file.txt 内容如下：\n\n\n987-123-4567\n123 456 7890\n(123) 456-7890\n\n\n你的脚本应当输出下列有效的电话号码：\n\n\n987-123-4567\n(123) 456-7890\n\n\n\n# 解法\n\n\n# bash\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode194 Transpose File-zh",frontmatter:{title:"leetcode194 Transpose File-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/abe998/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode194 Transpose File-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10194.leetcode194%20Transpose%20File-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode194 Transpose File-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10194.leetcode194%20Transpose%20File-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode194 Transpose File-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10194.leetcode194%20Transpose%20File-zh.html",relativePath:"01.算法/24.leetcode/10194.leetcode194 Transpose File-zh.md",key:"v-2638102d",path:"/p/abe998/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:190},{level:3,title:"Bash",slug:"bash",normalizedTitle:"bash",charIndex:197}],headersStr:"题目描述 解法 Bash",content:"# 194. 转置文件\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个文件 file.txt，转置它的内容。\n\n你可以假设每行列数相同，并且每个字段由 ' ' 分隔。\n\n \n\n示例：\n\n假设 file.txt 文件内容如下：\n\n\nname age\nalice 21\nryan 30\n\n\n应当输出：\n\n\nname alice ryan\nage 21 30\n\n\n\n# 解法\n\n\n# Bash\n\n\n\n\n1\n",normalizedContent:"# 194. 转置文件\n\nenglish version\n\n\n# 题目描述\n\n给定一个文件 file.txt，转置它的内容。\n\n你可以假设每行列数相同，并且每个字段由 ' ' 分隔。\n\n \n\n示例：\n\n假设 file.txt 文件内容如下：\n\n\nname age\nalice 21\nryan 30\n\n\n应当输出：\n\n\nname alice ryan\nage 21 30\n\n\n\n# 解法\n\n\n# bash\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode195 Tenth Line-zh",frontmatter:{title:"leetcode195 Tenth Line-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fb58c4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode195 Tenth Line-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10195.leetcode195%20Tenth%20Line-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode195 Tenth Line-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10195.leetcode195%20Tenth%20Line-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode195 Tenth Line-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10195.leetcode195%20Tenth%20Line-zh.html",relativePath:"01.算法/24.leetcode/10195.leetcode195 Tenth Line-zh.md",key:"v-6fd2026d",path:"/p/fb58c4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:230},{level:3,title:"Bash",slug:"bash",normalizedTitle:"bash",charIndex:259}],headersStr:"题目描述 解法 Bash",content:"# 195. 第十行\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个文本文件 file.txt，请只打印这个文件中的第十行。\n\n示例:\n\n假设 file.txt 有如下内容：\n\nLine 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\n\n\n你的脚本应当显示第十行：\n\nLine 10\n\n\n说明:\n1. 如果文件少于十行，你应当输出什么？\n2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。\n\n\n# 解法\n\n\n# Bash\n\n\n\n\n1\n",normalizedContent:"# 195. 第十行\n\nenglish version\n\n\n# 题目描述\n\n给定一个文本文件 file.txt，请只打印这个文件中的第十行。\n\n示例:\n\n假设 file.txt 有如下内容：\n\nline 1\nline 2\nline 3\nline 4\nline 5\nline 6\nline 7\nline 8\nline 9\nline 10\n\n\n你的脚本应当显示第十行：\n\nline 10\n\n\n说明:\n1. 如果文件少于十行，你应当输出什么？\n2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。\n\n\n# 解法\n\n\n# bash\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode196 Delete Duplicate Emails-zh",frontmatter:{title:"leetcode196 Delete Duplicate Emails-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b142e0/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode196 Delete Duplicate Emails-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10196.leetcode196%20Delete%20Duplicate%20Emails-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode196 Delete Duplicate Emails-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10196.leetcode196%20Delete%20Duplicate%20Emails-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode196 Delete Duplicate Emails-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10196.leetcode196%20Delete%20Duplicate%20Emails-zh.html",relativePath:"01.算法/24.leetcode/10196.leetcode196 Delete Duplicate Emails-zh.md",key:"v-1eea3c94",path:"/p/b142e0/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:550},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:49}],headersStr:"题目描述 解法 SQL",content:"# 196. 删除重复的电子邮箱\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。\n\n+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\nId 是这个表的主键。\n\n\n例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行:\n\n+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n\n\n \n\n提示：\n\n * 执行 SQL 之后，输出是整个 Person 表。\n * 使用 delete 语句。\n\n\n# 解法\n\n\n# SQL\n\ndelete from Person where Id not in (select min(Id) from (select * from Person) as p group by p.Email)\n\n\n1\n",normalizedContent:"# 196. 删除重复的电子邮箱\n\nenglish version\n\n\n# 题目描述\n\n编写一个 sql 查询，来删除 person 表中所有重复的电子邮箱，重复的邮箱里只保留 id 最小 的那个。\n\n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\nid 是这个表的主键。\n\n\n例如，在运行你的查询语句之后，上面的 person 表应返回以下几行:\n\n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n\n\n \n\n提示：\n\n * 执行 sql 之后，输出是整个 person 表。\n * 使用 delete 语句。\n\n\n# 解法\n\n\n# sql\n\ndelete from person where id not in (select min(id) from (select * from person) as p group by p.email)\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode197 Rising Temperature-zh",frontmatter:{title:"leetcode197 Rising Temperature-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/81acc9/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode197 Rising Temperature-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10197.leetcode197%20Rising%20Temperature-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode197 Rising Temperature-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10197.leetcode197%20Rising%20Temperature-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode197 Rising Temperature-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10197.leetcode197%20Rising%20Temperature-zh.html",relativePath:"01.算法/24.leetcode/10197.leetcode197 Rising Temperature-zh.md",key:"v-053dc7a7",path:"/p/81acc9/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:750},{level:3,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:282}],headersStr:"题目描述 解法 SQL",content:"# 197. 上升的温度\n\nEnglish Version\n\n\n# 题目描述\n\n表 Weather\n\n\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| recordDate    | date    |\n| temperature   | int     |\n+---------------+---------+\nid 是这个表的主键\n该表包含特定日期的温度信息\n\n \n\n编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。\n\n返回结果 不要求顺序 。\n\n查询结果格式如下例：\n\n\nWeather\n+----+------------+-------------+\n| id | recordDate | Temperature |\n+----+------------+-------------+\n| 1  | 2015-01-01 | 10          |\n| 2  | 2015-01-02 | 25          |\n| 3  | 2015-01-03 | 20          |\n| 4  | 2015-01-04 | 30          |\n+----+------------+-------------+\n\nResult table:\n+----+\n| id |\n+----+\n| 2  |\n| 4  |\n+----+\n2015-01-02 的温度比前一天高（10 -> 25）\n2015-01-04 的温度比前一天高（20 -> 30）\n\n\n\n# 解法\n\n\n# SQL\n\nselect w1.Id\nfrom\n    Weather w1,\n    Weather w2\nwhere\n    DATEDIFF(w1.RecordDate, w2.RecordDate) = 1 and w1.Temperature > w2.Temperature\n\n\n1\n2\n3\n4\n5\n6\n",normalizedContent:"# 197. 上升的温度\n\nenglish version\n\n\n# 题目描述\n\n表 weather\n\n\n+---------------+---------+\n| column name   | type    |\n+---------------+---------+\n| id            | int     |\n| recorddate    | date    |\n| temperature   | int     |\n+---------------+---------+\nid 是这个表的主键\n该表包含特定日期的温度信息\n\n \n\n编写一个 sql 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。\n\n返回结果 不要求顺序 。\n\n查询结果格式如下例：\n\n\nweather\n+----+------------+-------------+\n| id | recorddate | temperature |\n+----+------------+-------------+\n| 1  | 2015-01-01 | 10          |\n| 2  | 2015-01-02 | 25          |\n| 3  | 2015-01-03 | 20          |\n| 4  | 2015-01-04 | 30          |\n+----+------------+-------------+\n\nresult table:\n+----+\n| id |\n+----+\n| 2  |\n| 4  |\n+----+\n2015-01-02 的温度比前一天高（10 -> 25）\n2015-01-04 的温度比前一天高（20 -> 30）\n\n\n\n# 解法\n\n\n# sql\n\nselect w1.id\nfrom\n    weather w1,\n    weather w2\nwhere\n    datediff(w1.recorddate, w2.recorddate) = 1 and w1.temperature > w2.temperature\n\n\n1\n2\n3\n4\n5\n6\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode198 House Robber-zh",frontmatter:{title:"leetcode198 House Robber-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/6f8e73/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode198 House Robber-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10198.leetcode198%20House%20Robber-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode198 House Robber-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10198.leetcode198%20House%20Robber-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode198 House Robber-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10198.leetcode198%20House%20Robber-zh.html",relativePath:"01.算法/24.leetcode/10198.leetcode198 House Robber-zh.md",key:"v-6d4c0ee6",path:"/p/6f8e73/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:477},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:548},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:745},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1061},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1376},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1651}],headersStr:"题目描述 解法 Python3 Java C++ Go ...",content:"# 198. 打家劫舍\n\nEnglish Version\n\n\n# 题目描述\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n \n\n示例 1：\n\n\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 2：\n\n\n输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 400\n\n\n# 解法\n\n动态规划法。状态转移方程：f(n) = Math.max(f(n - 2) + nums[n], nums[n - 1])。\n\n\n# Python3\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        a, b = 0, nums[0]\n        for num in nums[1:]:\n            a, b = b, max(num + a, b)\n        return b\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Java\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        int a = 0, b = nums[0];\n        for (int i = 1; i < n; ++i) {\n            int c = max(nums[i] + a, b);\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        int a = 0, b = nums[0];\n        for (int i = 1; i < n; ++i) {\n            int c = max(nums[i] + a, b);\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Go\n\nfunc rob(nums []int) int {\n    a, b, n := 0, nums[0], len(nums)\n    for i := 1; i < n; i++ {\n        a, b = b, max(nums[i] + a, b)\n    }\n    return b\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 198. 打家劫舍\n\nenglish version\n\n\n# 题目描述\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n \n\n示例 1：\n\n\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 2：\n\n\n输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 400\n\n\n# 解法\n\n动态规划法。状态转移方程：f(n) = math.max(f(n - 2) + nums[n], nums[n - 1])。\n\n\n# python3\n\nclass solution:\n    def rob(self, nums: list[int]) -> int:\n        a, b = 0, nums[0]\n        for num in nums[1:]:\n            a, b = b, max(num + a, b)\n        return b\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# java\n\nclass solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        int a = 0, b = nums[0];\n        for (int i = 1; i < n; ++i) {\n            int c = max(nums[i] + a, b);\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# c++\n\nclass solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        int a = 0, b = nums[0];\n        for (int i = 1; i < n; ++i) {\n            int c = max(nums[i] + a, b);\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# go\n\nfunc rob(nums []int) int {\n    a, b, n := 0, nums[0], len(nums)\n    for i := 1; i < n; i++ {\n        a, b = b, max(nums[i] + a, b)\n    }\n    return b\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode199 Binary Tree Right Side View-zh",frontmatter:{title:"leetcode199 Binary Tree Right Side View-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/098207/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode199 Binary Tree Right Side View-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10199.leetcode199%20Binary%20Tree%20Right%20Side%20View-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode199 Binary Tree Right Side View-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10199.leetcode199%20Binary%20Tree%20Right%20Side%20View-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode199 Binary Tree Right Side View-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10199.leetcode199%20Binary%20Tree%20Right%20Side%20View-zh.html",relativePath:"01.算法/24.leetcode/10199.leetcode199 Binary Tree Right Side View-zh.md",key:"v-2aeda3f0",path:"/p/098207/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:223},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:237},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:980},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2037}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 199. 二叉树的右视图\n\nEnglish Version\n\n\n# 题目描述\n\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n示例:\n\n输入: [1,2,3,null,5,null,4]\n输出: [1, 3, 4]\n解释:\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\n\n\n\n# 解法\n\n队列实现。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: TreeNode) -> List[int]:\n        if not root:\n            return []\n        q = collections.deque([root])\n        res = []\n        while q:\n            size = len(q)\n            res.append(q[0].val)\n            for _ in range(size):\n                node = q.popleft()\n                if node.right:\n                    q.append(node.right)\n                if node.left:\n                    q.append(node.left)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        if (root == null) return Collections.emptyList();\n        Deque<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        List<Integer> res = new ArrayList<>();\n        while (!q.isEmpty()) {\n            int size = q.size();\n            res.add(q.peek().val);\n            while (size-- > 0) {\n                TreeNode node = q.poll();\n                if (node.right != null) q.offer(node.right);\n                if (node.left != null) q.offer(node.left);\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 199. 二叉树的右视图\n\nenglish version\n\n\n# 题目描述\n\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n示例:\n\n输入: [1,2,3,null,5,null,4]\n输出: [1, 3, 4]\n解释:\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\n\n\n\n# 解法\n\n队列实现。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def rightsideview(self, root: treenode) -> list[int]:\n        if not root:\n            return []\n        q = collections.deque([root])\n        res = []\n        while q:\n            size = len(q)\n            res.append(q[0].val)\n            for _ in range(size):\n                node = q.popleft()\n                if node.right:\n                    q.append(node.right)\n                if node.left:\n                    q.append(node.left)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public list<integer> rightsideview(treenode root) {\n        if (root == null) return collections.emptylist();\n        deque<treenode> q = new arraydeque<>();\n        q.offer(root);\n        list<integer> res = new arraylist<>();\n        while (!q.isempty()) {\n            int size = q.size();\n            res.add(q.peek().val);\n            while (size-- > 0) {\n                treenode node = q.poll();\n                if (node.right != null) q.offer(node.right);\n                if (node.left != null) q.offer(node.left);\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode200 Number of Islands-zh",frontmatter:{title:"leetcode200 Number of Islands-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/394356/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode200 Number of Islands-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10200.leetcode200%20Number%20of%20Islands-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode200 Number of Islands-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10200.leetcode200%20Number%20of%20Islands-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode200 Number of Islands-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10200.leetcode200%20Number%20of%20Islands-zh.html",relativePath:"01.算法/24.leetcode/10200.leetcode200 Number of Islands-zh.md",key:"v-cb64dc94",path:"/p/394356/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:511},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:530},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:549},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:565},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1324}],headersStr:"题目描述 解法 Python3 Java TypeScript ...",content:'# 200. 岛屿数量\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个由 \'1\'（陆地）和 \'0\'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n \n\n示例 1：\n\n\n输入：grid = [\n  ["1","1","1","1","0"],\n  ["1","1","0","1","0"],\n  ["1","1","0","0","0"],\n  ["0","0","0","0","0"]\n]\n输出：1\n\n\n示例 2：\n\n\n输入：grid = [\n  ["1","1","0","0","0"],\n  ["1","1","0","0","0"],\n  ["0","0","1","0","0"],\n  ["0","0","0","1","1"]\n]\n输出：3\n\n\n \n\n提示：\n\n * m == grid.length\n * n == grid[i].length\n * 1 <= m, n <= 300\n * grid[i][j] 的值为 \'0\' 或 \'1\'\n\n\n# 解法\n\nBFS/DFS 均可\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# TypeScript\n\nfunction numIslands(grid: string[][]): number {\n    let m = grid.length, n = grid[0].length;\n    let ans = 0;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j] == \'1\') {\n                dfs(grid, i, j);\n                ++ans;\n            }\n        }\n    }\n    return ans;\n};\n\nfunction dfs(grid: string[][], i: number, j: number) {\n    let m = grid.length, n = grid[0].length;\n    if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || grid[i][j] == \'0\') {\n        return;\n    }\n    grid[i][j] = \'0\';\n    for (let [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\n        let x = i + dx, y = j + dy;\n        dfs(grid, x, y);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 200. 岛屿数量\n\nenglish version\n\n\n# 题目描述\n\n给你一个由 \'1\'（陆地）和 \'0\'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n \n\n示例 1：\n\n\n输入：grid = [\n  ["1","1","1","1","0"],\n  ["1","1","0","1","0"],\n  ["1","1","0","0","0"],\n  ["0","0","0","0","0"]\n]\n输出：1\n\n\n示例 2：\n\n\n输入：grid = [\n  ["1","1","0","0","0"],\n  ["1","1","0","0","0"],\n  ["0","0","1","0","0"],\n  ["0","0","0","1","1"]\n]\n输出：3\n\n\n \n\n提示：\n\n * m == grid.length\n * n == grid[i].length\n * 1 <= m, n <= 300\n * grid[i][j] 的值为 \'0\' 或 \'1\'\n\n\n# 解法\n\nbfs/dfs 均可\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# typescript\n\nfunction numislands(grid: string[][]): number {\n    let m = grid.length, n = grid[0].length;\n    let ans = 0;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j] == \'1\') {\n                dfs(grid, i, j);\n                ++ans;\n            }\n        }\n    }\n    return ans;\n};\n\nfunction dfs(grid: string[][], i: number, j: number) {\n    let m = grid.length, n = grid[0].length;\n    if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || grid[i][j] == \'0\') {\n        return;\n    }\n    grid[i][j] = \'0\';\n    for (let [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\n        let x = i + dx, y = j + dy;\n        dfs(grid, x, y);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode201 Bitwise AND of Numbers Range-zh",frontmatter:{title:"leetcode201 Bitwise AND of Numbers Range-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d93f2b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode201 Bitwise AND of Numbers Range-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10201.leetcode201%20Bitwise%20AND%20of%20Numbers%20Range-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode201 Bitwise AND of Numbers Range-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10201.leetcode201%20Bitwise%20AND%20of%20Numbers%20Range-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode201 Bitwise AND of Numbers Range-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10201.leetcode201%20Bitwise%20AND%20of%20Numbers%20Range-zh.html",relativePath:"01.算法/24.leetcode/10201.leetcode201 Bitwise AND of Numbers Range-zh.md",key:"v-67e15bec",path:"/p/d93f2b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:294},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:301},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:320},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:336}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 201. 数字范围按位与\n\nEnglish Version\n\n\n# 题目描述\n\n给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。\n\n \n\n示例 1：\n\n\n输入：left = 5, right = 7\n输出：4\n\n\n示例 2：\n\n\n输入：left = 0, right = 0\n输出：0\n\n\n示例 3：\n\n\n输入：left = 1, right = 2147483647\n输出：0\n\n\n \n\n提示：\n\n * 0 <= left <= right <= 231 - 1\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 201. 数字范围按位与\n\nenglish version\n\n\n# 题目描述\n\n给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。\n\n \n\n示例 1：\n\n\n输入：left = 5, right = 7\n输出：4\n\n\n示例 2：\n\n\n输入：left = 0, right = 0\n输出：0\n\n\n示例 3：\n\n\n输入：left = 1, right = 2147483647\n输出：0\n\n\n \n\n提示：\n\n * 0 <= left <= right <= 231 - 1\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode202 Happy Number-zh",frontmatter:{title:"leetcode202 Happy Number-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/c9273c/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode202 Happy Number-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10202.leetcode202%20Happy%20Number-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode202 Happy Number-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10202.leetcode202%20Happy%20Number-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode202 Happy Number-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10202.leetcode202%20Happy%20Number-zh.html",relativePath:"01.算法/24.leetcode/10202.leetcode202 Happy Number-zh.md",key:"v-1c60702d",path:"/p/c9273c/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:360},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:367},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:778},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1285}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 202. 快乐数\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个算法来判断一个数 n 是不是快乐数。\n\n「快乐数」定义为：\n\n * 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n * 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\n * 如果 可以变为  1，那么这个数就是快乐数。\n\n如果 n 是快乐数就返回 true ；不是，则返回 false 。\n\n \n\n示例 1：\n\n\n输入：19\n输出：true\n解释：\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n\n示例 2：\n\n\n输入：n = 2\n输出：false\n\n\n \n\n提示：\n\n * 1 <= n <= 231 - 1\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        def get_next(n):\n            s = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                s += digit ** 2\n            return s\n\n        visited = set()\n        while n != 1 and n not in visited:\n            visited.add(n)\n            n = get_next(n)\n        return n == 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Java\n\nclass Solution {\n    public boolean isHappy(int n) {\n        Set<Integer> visited = new HashSet<>();\n        while (n != 1 && !visited.contains(n)) {\n            visited.add(n);\n            n = getNext(n);\n        }\n        return n == 1;\n    }\n\n    private int getNext(int n) {\n        int s = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            s += digit * digit;\n            n /= 10;\n        }\n        return s;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 202. 快乐数\n\nenglish version\n\n\n# 题目描述\n\n编写一个算法来判断一个数 n 是不是快乐数。\n\n「快乐数」定义为：\n\n * 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n * 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\n * 如果 可以变为  1，那么这个数就是快乐数。\n\n如果 n 是快乐数就返回 true ；不是，则返回 false 。\n\n \n\n示例 1：\n\n\n输入：19\n输出：true\n解释：\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n\n示例 2：\n\n\n输入：n = 2\n输出：false\n\n\n \n\n提示：\n\n * 1 <= n <= 231 - 1\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def ishappy(self, n: int) -> bool:\n        def get_next(n):\n            s = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                s += digit ** 2\n            return s\n\n        visited = set()\n        while n != 1 and n not in visited:\n            visited.add(n)\n            n = get_next(n)\n        return n == 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# java\n\nclass solution {\n    public boolean ishappy(int n) {\n        set<integer> visited = new hashset<>();\n        while (n != 1 && !visited.contains(n)) {\n            visited.add(n);\n            n = getnext(n);\n        }\n        return n == 1;\n    }\n\n    private int getnext(int n) {\n        int s = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            s += digit * digit;\n            n /= 10;\n        }\n        return s;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode203 Remove Linked List Elements-zh",frontmatter:{title:"leetcode203 Remove Linked List Elements-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fbd6a2/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0203.Remove%20Linked%20List%20Elements/images/removelinked-list.jpg"},{name:"twitter:title",content:"leetcode203 Remove Linked List Elements-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0203.Remove%20Linked%20List%20Elements/images/removelinked-list.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10203.leetcode203%20Remove%20Linked%20List%20Elements-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode203 Remove Linked List Elements-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0203.Remove%20Linked%20List%20Elements/images/removelinked-list.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10203.leetcode203%20Remove%20Linked%20List%20Elements-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode203 Remove Linked List Elements-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0203.Remove%20Linked%20List%20Elements/images/removelinked-list.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10203.leetcode203%20Remove%20Linked%20List%20Elements-zh.html",relativePath:"01.算法/24.leetcode/10203.leetcode203 Remove Linked List Elements-zh.md",key:"v-5de0b9c9",path:"/p/fbd6a2/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:336},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:343},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:869},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1544},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1992},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:2268},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2995}],headersStr:"题目描述 解法 Python3 Java C++ Go TypeScript ...",content:"# 203. 移除链表元素\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n\n \n\n\n\n示例 1：\n\n\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n\n\n示例 2：\n\n\n输入：head = [], val = 1\n输出：[]\n\n\n示例 3：\n\n\n输入：head = [7,7,7,7], val = 7\n输出：[]\n\n\n \n\n提示：\n\n * 列表中的节点在范围 [0, 104] 内\n * 1 <= Node.val <= 50\n * 0 <= k <= 50\n\n\n# 解法\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        dummy = ListNode(-1, head)\n        pre = dummy\n        while pre and pre.next:\n            if pre.next.val != val:\n                pre = pre.next\n            else:\n                pre.next = pre.next.next\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode dummy = new ListNode(-1, head);\n        ListNode pre = dummy;\n        while (pre != null && pre.next != null) {\n            if (pre.next.val != val) pre = pre.next;\n            else pre.next = pre.next.next;\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# C++\n\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode* dummy = new ListNode();\n        dummy->next = head;\n        ListNode* p = dummy;\n        while (p->next) {\n            if (p->next->val == val) {\n                p->next = p->next->next;\n            } else {\n                p = p->next;\n            }\n        }\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Go\n\nfunc removeElements(head *ListNode, val int) *ListNode {\n\tdummy := new(ListNode)\n\tdummy.Next = head\n\tp := dummy\n\tfor p.Next != nil {\n\t\tif p.Next.Val == val {\n\t\t\tp.Next = p.Next.Next\n\t\t} else {\n\t\t\tp = p.Next\n\t\t}\n\t}\n\treturn dummy.Next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# TypeScript\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n function removeElements(head: ListNode | null, val: number): ListNode | null {\n    let dummy: ListNode = new ListNode(0, head);\n    let cur: ListNode = dummy;\n    while (cur.next != null) {\n        if (cur.next.val == val) {\n            cur.next = cur.next.next;\n        } else {\n            cur = cur.next;\n        }\n    }\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 203. 移除链表元素\n\nenglish version\n\n\n# 题目描述\n\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 node.val == val 的节点，并返回 新的头节点 。\n\n \n\n\n\n示例 1：\n\n\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n\n\n示例 2：\n\n\n输入：head = [], val = 1\n输出：[]\n\n\n示例 3：\n\n\n输入：head = [7,7,7,7], val = 7\n输出：[]\n\n\n \n\n提示：\n\n * 列表中的节点在范围 [0, 104] 内\n * 1 <= node.val <= 50\n * 0 <= k <= 50\n\n\n# 解法\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def removeelements(self, head: listnode, val: int) -> listnode:\n        dummy = listnode(-1, head)\n        pre = dummy\n        while pre and pre.next:\n            if pre.next.val != val:\n                pre = pre.next\n            else:\n                pre.next = pre.next.next\n        return dummy.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode removeelements(listnode head, int val) {\n        listnode dummy = new listnode(-1, head);\n        listnode pre = dummy;\n        while (pre != null && pre.next != null) {\n            if (pre.next.val != val) pre = pre.next;\n            else pre.next = pre.next.next;\n        }\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# c++\n\nclass solution {\npublic:\n    listnode* removeelements(listnode* head, int val) {\n        listnode* dummy = new listnode();\n        dummy->next = head;\n        listnode* p = dummy;\n        while (p->next) {\n            if (p->next->val == val) {\n                p->next = p->next->next;\n            } else {\n                p = p->next;\n            }\n        }\n        return dummy->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# go\n\nfunc removeelements(head *listnode, val int) *listnode {\n\tdummy := new(listnode)\n\tdummy.next = head\n\tp := dummy\n\tfor p.next != nil {\n\t\tif p.next.val == val {\n\t\t\tp.next = p.next.next\n\t\t} else {\n\t\t\tp = p.next\n\t\t}\n\t}\n\treturn dummy.next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# typescript\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     val: number\n *     next: listnode | null\n *     constructor(val?: number, next?: listnode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n function removeelements(head: listnode | null, val: number): listnode | null {\n    let dummy: listnode = new listnode(0, head);\n    let cur: listnode = dummy;\n    while (cur.next != null) {\n        if (cur.next.val == val) {\n            cur.next = cur.next.next;\n        } else {\n            cur = cur.next;\n        }\n    }\n    return dummy.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode204 Count Primes-zh",frontmatter:{title:"leetcode204 Count Primes-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/73017b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode204 Count Primes-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10204.leetcode204%20Count%20Primes-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode204 Count Primes-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10204.leetcode204%20Count%20Primes-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode204 Count Primes-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10204.leetcode204%20Count%20Primes-zh.html",relativePath:"01.算法/24.leetcode/10204.leetcode204 Count Primes-zh.md",key:"v-64a8ceed",path:"/p/73017b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:205},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:488},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:869},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1433}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 204. 计数质数\n\nEnglish Version\n\n\n# 题目描述\n\n统计所有小于非负整数 n 的质数的数量。\n\n \n\n示例 1：\n\n输入：n = 10\n输出：4\n解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n\n\n示例 2：\n\n输入：n = 0\n输出：0\n\n\n示例 3：\n\n输入：n = 1\n输出：0\n\n\n \n\n提示：\n\n * 0 <= n <= 5 * 106\n\n\n# 解法\n\n如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。\n\n我们设 primes[i] 表示数 i 是不是质数，如果是质数则为 true，否则为 false。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 false，这样在运行结束的时候我们即能知道质数的个数。\n\n对于一个质数 x，我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。\n\n\n# Python3\n\nclass Solution:\n    def countPrimes(self, n: int) -> int:\n        if n < 2:\n            return 0\n        res = 0\n        primes = [True for _ in range(n)]\n        for i in range(2, n):\n            if primes[i]:\n                res += 1\n                for j in range(i * i, n, i):\n                    primes[j] = False\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public int countPrimes(int n) {\n        if (n < 2) return 0;\n        boolean[] primes = new boolean[n];\n        Arrays.fill(primes, true);\n        int res = 0;\n        for (int i = 2; i < n; ++i) {\n            if (primes[i]) {\n                ++res;\n                if ((long) i * i < n) {\n                    for (int j = i * i; j < n; j += i) {\n                        primes[j] = false;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 204. 计数质数\n\nenglish version\n\n\n# 题目描述\n\n统计所有小于非负整数 n 的质数的数量。\n\n \n\n示例 1：\n\n输入：n = 10\n输出：4\n解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n\n\n示例 2：\n\n输入：n = 0\n输出：0\n\n\n示例 3：\n\n输入：n = 1\n输出：0\n\n\n \n\n提示：\n\n * 0 <= n <= 5 * 106\n\n\n# 解法\n\n如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。\n\n我们设 primes[i] 表示数 i 是不是质数，如果是质数则为 true，否则为 false。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 false，这样在运行结束的时候我们即能知道质数的个数。\n\n对于一个质数 x，我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。\n\n\n# python3\n\nclass solution:\n    def countprimes(self, n: int) -> int:\n        if n < 2:\n            return 0\n        res = 0\n        primes = [true for _ in range(n)]\n        for i in range(2, n):\n            if primes[i]:\n                res += 1\n                for j in range(i * i, n, i):\n                    primes[j] = false\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public int countprimes(int n) {\n        if (n < 2) return 0;\n        boolean[] primes = new boolean[n];\n        arrays.fill(primes, true);\n        int res = 0;\n        for (int i = 2; i < n; ++i) {\n            if (primes[i]) {\n                ++res;\n                if ((long) i * i < n) {\n                    for (int j = i * i; j < n; j += i) {\n                        primes[j] = false;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode205 Isomorphic Strings-zh",frontmatter:{title:"leetcode205 Isomorphic Strings-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/18ca2f/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode205 Isomorphic Strings-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10205.leetcode205%20Isomorphic%20Strings-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode205 Isomorphic Strings-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10205.leetcode205%20Isomorphic%20Strings-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode205 Isomorphic Strings-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10205.leetcode205%20Isomorphic%20Strings-zh.html",relativePath:"01.算法/24.leetcode/10205.leetcode205 Isomorphic Strings-zh.md",key:"v-ec1f55f2",path:"/p/18ca2f/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:348},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:355},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:733},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1288}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 205. 同构字符串\n\nEnglish Version\n\n\n# 题目描述\n\n给定两个字符串 s 和 t，判断它们是否是同构的。\n\n如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。\n\n每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n\n \n\n示例 1:\n\n\n输入：s = "egg", t = "add"\n输出：true\n\n\n示例 2：\n\n\n输入：s = "foo", t = "bar"\n输出：false\n\n示例 3：\n\n\n输入：s = "paper", t = "title"\n输出：true\n\n \n\n提示：\n\n * 可以假设 s 和 t 长度相同。\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        a2b, b2a = {}, {}\n        n = len(s)\n        for i in range(n):\n            a, b = s[i], t[i]\n            if (a in a2b and a2b[a] != b) or (b in b2a and b2a[b] != a):\n                return False\n            a2b[a] = b\n            b2a[b] = a\n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Java\n\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        int n = s.length();\n        Map<Character, Character> a2b = new HashMap<>();\n        Map<Character, Character> b2a = new HashMap<>();\n        for (int i = 0; i < n; ++i) {\n            char a = s.charAt(i), b = t.charAt(i);\n            if ((a2b.containsKey(a) && a2b.get(a) != b) || (b2a.containsKey(b) && b2a.get(b) != a)) return false;\n            a2b.put(a, b);\n            b2a.put(b, a);\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 205. 同构字符串\n\nenglish version\n\n\n# 题目描述\n\n给定两个字符串 s 和 t，判断它们是否是同构的。\n\n如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。\n\n每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n\n \n\n示例 1:\n\n\n输入：s = "egg", t = "add"\n输出：true\n\n\n示例 2：\n\n\n输入：s = "foo", t = "bar"\n输出：false\n\n示例 3：\n\n\n输入：s = "paper", t = "title"\n输出：true\n\n \n\n提示：\n\n * 可以假设 s 和 t 长度相同。\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def isisomorphic(self, s: str, t: str) -> bool:\n        a2b, b2a = {}, {}\n        n = len(s)\n        for i in range(n):\n            a, b = s[i], t[i]\n            if (a in a2b and a2b[a] != b) or (b in b2a and b2a[b] != a):\n                return false\n            a2b[a] = b\n            b2a[b] = a\n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# java\n\nclass solution {\n    public boolean isisomorphic(string s, string t) {\n        int n = s.length();\n        map<character, character> a2b = new hashmap<>();\n        map<character, character> b2a = new hashmap<>();\n        for (int i = 0; i < n; ++i) {\n            char a = s.charat(i), b = t.charat(i);\n            if ((a2b.containskey(a) && a2b.get(a) != b) || (b2a.containskey(b) && b2a.get(b) != a)) return false;\n            a2b.put(a, b);\n            b2a.put(b, a);\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode206 Reverse Linked List-zh",frontmatter:{title:"leetcode206 Reverse Linked List-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/c4fbe9/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode206 Reverse Linked List-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10206.leetcode206%20Reverse%20Linked%20List-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode206 Reverse Linked List-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10206.leetcode206%20Reverse%20Linked%20List-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode206 Reverse Linked List-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10206.leetcode206%20Reverse%20Linked%20List-zh.html",relativePath:"01.算法/24.leetcode/10206.leetcode206 Reverse Linked List-zh.md",key:"v-43829904",path:"/p/c4fbe9/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:140},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:288},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:696},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1682},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2128},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2488}],headersStr:"题目描述 解法 Python3 Java JavaScript Go ...",content:"# 206. 反转链表\n\nEnglish Version\n\n\n# 题目描述\n\n反转一个单链表。\n\n示例:\n\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n\n进阶:\n你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n\n# 解法\n\n定义指针 p、q 分别指向头节点和下一个节点，pre 指向头节点的前一个节点。\n\n遍历链表，改变指针 p 指向的节点的指向，将其指向 pre 指针指向的节点，即 p.next = pre。然后 pre 指针指向 p，p、q 指针往前走。\n\n当遍历结束后，返回 pre 指针即可。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        pre, p = None, head\n        while p:\n            q = p.next\n            p.next = pre\n            pre = p\n            p = q\n        return pre\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java\n\n迭代版本：\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null, p = head;\n        while (p != null) {\n            ListNode q = p.next;\n            p.next = pre;\n            pre = p;\n            p = q;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n递归版本：\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode res = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n  let node = head;\n  let pre = null;\n  while (node) {\n    let cur = node;\n    node = cur.next;\n    cur.next = pre;\n    pre = cur;\n  }\n  return pre;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Go\n\nfunc reverseList(head *ListNode) *ListNode {\n    if head == nil ||head.Next == nil {\n        return head\n    }\n    dummyHead := &ListNode{}\n    cur := head\n    for cur != nil {\n        tmp := cur.Next\n        cur.Next = dummyHead.Next\n        dummyHead.Next = cur\n        cur = tmp\n    }\n    return dummyHead.Next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 206. 反转链表\n\nenglish version\n\n\n# 题目描述\n\n反转一个单链表。\n\n示例:\n\n输入: 1->2->3->4->5->null\n输出: 5->4->3->2->1->null\n\n进阶:\n你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n\n# 解法\n\n定义指针 p、q 分别指向头节点和下一个节点，pre 指向头节点的前一个节点。\n\n遍历链表，改变指针 p 指向的节点的指向，将其指向 pre 指针指向的节点，即 p.next = pre。然后 pre 指针指向 p，p、q 指针往前走。\n\n当遍历结束后，返回 pre 指针即可。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def reverselist(self, head: listnode) -> listnode:\n        pre, p = none, head\n        while p:\n            q = p.next\n            p.next = pre\n            pre = p\n            p = q\n        return pre\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java\n\n迭代版本：\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode reverselist(listnode head) {\n        listnode pre = null, p = head;\n        while (p != null) {\n            listnode q = p.next;\n            p.next = pre;\n            pre = p;\n            p = q;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n递归版本：\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode reverselist(listnode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        listnode res = reverselist(head.next);\n        head.next.next = head;\n        head.next = null;\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {listnode} head\n * @return {listnode}\n */\nvar reverselist = function (head) {\n  let node = head;\n  let pre = null;\n  while (node) {\n    let cur = node;\n    node = cur.next;\n    cur.next = pre;\n    pre = cur;\n  }\n  return pre;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# go\n\nfunc reverselist(head *listnode) *listnode {\n    if head == nil ||head.next == nil {\n        return head\n    }\n    dummyhead := &listnode{}\n    cur := head\n    for cur != nil {\n        tmp := cur.next\n        cur.next = dummyhead.next\n        dummyhead.next = cur\n        cur = tmp\n    }\n    return dummyhead.next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode207 Course Schedule-zh",frontmatter:{title:"leetcode207 Course Schedule-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/96e670/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode207 Course Schedule-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10207.leetcode207%20Course%20Schedule-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode207 Course Schedule-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10207.leetcode207%20Course%20Schedule-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode207 Course Schedule-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10207.leetcode207%20Course%20Schedule-zh.html",relativePath:"01.算法/24.leetcode/10207.leetcode207 Course Schedule-zh.md",key:"v-2f8a2e55",path:"/p/96e670/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:695},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:702},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:721},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:737}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 207. 课程表\n\nEnglish Version\n\n\n# 题目描述\n\n你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。\n\n在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。\n\n * 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。\n\n请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。\n\n \n\n示例 1：\n\n\n输入：numCourses = 2, prerequisites = [[1,0]]\n输出：true\n解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。\n\n示例 2：\n\n\n输入：numCourses = 2, prerequisites = [[1,0],[0,1]]\n输出：false\n解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。\n\n \n\n提示：\n\n * 1 <= numCourses <= 105\n * 0 <= prerequisites.length <= 5000\n * prerequisites[i].length == 2\n * 0 <= ai, bi < numCourses\n * prerequisites[i] 中的所有课程对 互不相同\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 207. 课程表\n\nenglish version\n\n\n# 题目描述\n\n你这个学期必须选修 numcourses 门课程，记为 0 到 numcourses - 1 。\n\n在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。\n\n * 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。\n\n请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。\n\n \n\n示例 1：\n\n\n输入：numcourses = 2, prerequisites = [[1,0]]\n输出：true\n解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。\n\n示例 2：\n\n\n输入：numcourses = 2, prerequisites = [[1,0],[0,1]]\n输出：false\n解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。\n\n \n\n提示：\n\n * 1 <= numcourses <= 105\n * 0 <= prerequisites.length <= 5000\n * prerequisites[i].length == 2\n * 0 <= ai, bi < numcourses\n * prerequisites[i] 中的所有课程对 互不相同\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode208 Implement Trie (Prefix Tree)-zh",frontmatter:{title:"leetcode208 Implement Trie (Prefix Tree)-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a86416/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode208 Implement Trie (Prefix Tree)-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10208.leetcode208%20Implement%20Trie%20(Prefix%20Tree)-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode208 Implement Trie (Prefix Tree)-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10208.leetcode208%20Implement%20Trie%20(Prefix%20Tree)-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode208 Implement Trie (Prefix Tree)-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10208.leetcode208%20Implement%20Trie%20(Prefix%20Tree)-zh.html",relativePath:"01.算法/24.leetcode/10208.leetcode208 Implement Trie (Prefix Tree)-zh.md",key:"v-711f4807",path:"/p/a86416/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:42},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:932},{level:3,title:"1. 插入字符串",slug:"_1-插入字符串",normalizedTitle:"1. 插入字符串",charIndex:1085},{level:3,title:"2. 查找前缀",slug:"_2-查找前缀",normalizedTitle:"2. 查找前缀",charIndex:1275},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1479},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2995},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:4753},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1023}],headersStr:"题目描述 解法 1. 插入字符串 2. 查找前缀 Python3 Java JavaScript ...",content:'# 208. 实现 Trie (前缀树)\n\nEnglish Version\n\n\n# 题目描述\n\nTrie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\n\n请你实现 Trie 类：\n\n * Trie() 初始化前缀树对象。\n * void insert(String word) 向前缀树中插入字符串 word 。\n * boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。\n * boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。\n\n \n\n示例：\n\n\n输入\n["Trie", "insert", "search", "search", "startsWith", "insert", "search"]\n[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]\n输出\n[null, null, true, false, true, null, true]\n\n解释\nTrie trie = new Trie();\ntrie.insert("apple");\ntrie.search("apple");   // 返回 True\ntrie.search("app");     // 返回 False\ntrie.startsWith("app"); // 返回 True\ntrie.insert("app");\ntrie.search("app");     // 返回 True\n\n\n \n\n提示：\n\n * 1 <= word.length, prefix.length <= 2000\n * word 和 prefix 仅由小写英文字母组成\n * insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次\n\n\n# 解法\n\n前缀树每个节点包括两部分：\n\n 1. 指向子节点的指针数组 children，对于本题而言，数组长度为 26，即小写英文字母的数量。children[0] 对应小写字母 a，...，children[25] 对应小写字母 z。\n 2. 布尔字段 isEnd，表示该节点是否为字符串的结尾。\n\n\n# 1. 插入字符串\n\n我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：\n\n * 子节点存在。沿着指针移动到子节点，继续处理下一个字符。\n * 子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。\n\n重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。\n\n\n# 2. 查找前缀\n\n我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：\n\n * 子节点存在。沿着指针移动到子节点，继续搜索下一个字符。\n * 子节点不存在。说明字典树中不包含该前缀，返回空指针。\n\n重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。\n\n若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串。\n\n\n# Python3\n\nclass Trie:\n\n    def __init__(self):\n        """\n        Initialize your data structure here.\n        """\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, word: str) -> None:\n        """\n        Inserts a word into the trie.\n        """\n        node = self\n        for c in word:\n            index = ord(c) - ord("a")\n            if node.children[index] is None:\n                node.children[index] = Trie()\n            node = node.children[index]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        """\n        Returns if the word is in the trie.\n        """\n        node = self._search_prefix(word)\n        return node is not None and node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        """\n        Returns if there is any word in the trie that starts with the given prefix.\n        """\n        node = self._search_prefix(prefix)\n        return node is not None\n\n    def _search_prefix(self, prefix: str):\n        node = self\n        for c in prefix:\n            index = ord(c) - ord("a")\n            if node.children[index] is None:\n                return None\n            node = node.children[index]\n        return node\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# Java\n\nclass Trie {\n    private Trie[] children;\n    private boolean isEnd;\n\n    /** Initialize your data structure here. */\n    public Trie() {\n        children = new Trie[26];\n        isEnd = false;\n    }\n\n    /** Inserts a word into the trie. */\n    public void insert(String word) {\n        Trie node = this;\n        for (int i = 0; i < word.length(); ++i) {\n            char c = word.charAt(i);\n            int index = c - \'a\';\n            if (node.children[index] == null) {\n                node.children[index] = new Trie();\n            }\n            node = node.children[index];\n        }\n        node.isEnd = true;\n    }\n\n    /** Returns if the word is in the trie. */\n    public boolean search(String word) {\n        Trie node = searchPrefix(word);\n        return node != null && node.isEnd;\n    }\n\n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    public boolean startsWith(String prefix) {\n        Trie node = searchPrefix(prefix);\n        return node != null;\n    }\n\n    private Trie searchPrefix(String prefix) {\n        Trie node = this;\n        for (int i = 0; i < prefix.length(); ++i) {\n            char c = prefix.charAt(i);\n            int index = c - \'a\';\n            if (node.children[index] == null) {\n                return null;\n            }\n            node = node.children[index];\n        }\n        return node;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# JavaScript\n\n/**\n * Initialize your data structure here.\n */\nvar Trie = function() {\n    this.children = {};\n};\n\n/**\n * Inserts a word into the trie. \n * @param {string} word\n * @return {void}\n */\nTrie.prototype.insert = function(word) {\n    let node = this.children;\n    for (let char of word) {\n        if (!node[char]) {\n            node[char] = {};\n        }\n        node = node[char];\n    }\n    node.isEnd = true;\n};\n\n/**\n * Returns if the word is in the trie. \n * @param {string} word\n * @return {boolean}\n */\nTrie.prototype.search = function(word) {\n    let node = this.searchPrefix(word);\n    return node != undefined && node.isEnd != undefined;\n};\n\nTrie.prototype.searchPrefix = function (prefix) {\n    let node = this.children;\n    for (let char of prefix) {\n        if (!node[char]) return false;\n        node = node[char];\n    }\n    return node;\n}\n\n/**\n * Returns if there is any word in the trie that starts with the given prefix. \n * @param {string} prefix\n * @return {boolean}\n */\nTrie.prototype.startsWith = function(prefix) {\n    return this.searchPrefix(prefix);\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 208. 实现 trie (前缀树)\n\nenglish version\n\n\n# 题目描述\n\ntrie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\n\n请你实现 trie 类：\n\n * trie() 初始化前缀树对象。\n * void insert(string word) 向前缀树中插入字符串 word 。\n * boolean search(string word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。\n * boolean startswith(string prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。\n\n \n\n示例：\n\n\n输入\n["trie", "insert", "search", "search", "startswith", "insert", "search"]\n[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]\n输出\n[null, null, true, false, true, null, true]\n\n解释\ntrie trie = new trie();\ntrie.insert("apple");\ntrie.search("apple");   // 返回 true\ntrie.search("app");     // 返回 false\ntrie.startswith("app"); // 返回 true\ntrie.insert("app");\ntrie.search("app");     // 返回 true\n\n\n \n\n提示：\n\n * 1 <= word.length, prefix.length <= 2000\n * word 和 prefix 仅由小写英文字母组成\n * insert、search 和 startswith 调用次数 总计 不超过 3 * 104 次\n\n\n# 解法\n\n前缀树每个节点包括两部分：\n\n 1. 指向子节点的指针数组 children，对于本题而言，数组长度为 26，即小写英文字母的数量。children[0] 对应小写字母 a，...，children[25] 对应小写字母 z。\n 2. 布尔字段 isend，表示该节点是否为字符串的结尾。\n\n\n# 1. 插入字符串\n\n我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：\n\n * 子节点存在。沿着指针移动到子节点，继续处理下一个字符。\n * 子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。\n\n重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。\n\n\n# 2. 查找前缀\n\n我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：\n\n * 子节点存在。沿着指针移动到子节点，继续搜索下一个字符。\n * 子节点不存在。说明字典树中不包含该前缀，返回空指针。\n\n重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。\n\n若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 isend 为真，则说明字典树中存在该字符串。\n\n\n# python3\n\nclass trie:\n\n    def __init__(self):\n        """\n        initialize your data structure here.\n        """\n        self.children = [none] * 26\n        self.is_end = false\n\n    def insert(self, word: str) -> none:\n        """\n        inserts a word into the trie.\n        """\n        node = self\n        for c in word:\n            index = ord(c) - ord("a")\n            if node.children[index] is none:\n                node.children[index] = trie()\n            node = node.children[index]\n        node.is_end = true\n\n    def search(self, word: str) -> bool:\n        """\n        returns if the word is in the trie.\n        """\n        node = self._search_prefix(word)\n        return node is not none and node.is_end\n\n    def startswith(self, prefix: str) -> bool:\n        """\n        returns if there is any word in the trie that starts with the given prefix.\n        """\n        node = self._search_prefix(prefix)\n        return node is not none\n\n    def _search_prefix(self, prefix: str):\n        node = self\n        for c in prefix:\n            index = ord(c) - ord("a")\n            if node.children[index] is none:\n                return none\n            node = node.children[index]\n        return node\n\n# your trie object will be instantiated and called as such:\n# obj = trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startswith(prefix)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# java\n\nclass trie {\n    private trie[] children;\n    private boolean isend;\n\n    /** initialize your data structure here. */\n    public trie() {\n        children = new trie[26];\n        isend = false;\n    }\n\n    /** inserts a word into the trie. */\n    public void insert(string word) {\n        trie node = this;\n        for (int i = 0; i < word.length(); ++i) {\n            char c = word.charat(i);\n            int index = c - \'a\';\n            if (node.children[index] == null) {\n                node.children[index] = new trie();\n            }\n            node = node.children[index];\n        }\n        node.isend = true;\n    }\n\n    /** returns if the word is in the trie. */\n    public boolean search(string word) {\n        trie node = searchprefix(word);\n        return node != null && node.isend;\n    }\n\n    /** returns if there is any word in the trie that starts with the given prefix. */\n    public boolean startswith(string prefix) {\n        trie node = searchprefix(prefix);\n        return node != null;\n    }\n\n    private trie searchprefix(string prefix) {\n        trie node = this;\n        for (int i = 0; i < prefix.length(); ++i) {\n            char c = prefix.charat(i);\n            int index = c - \'a\';\n            if (node.children[index] == null) {\n                return null;\n            }\n            node = node.children[index];\n        }\n        return node;\n    }\n}\n\n/**\n * your trie object will be instantiated and called as such:\n * trie obj = new trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startswith(prefix);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# javascript\n\n/**\n * initialize your data structure here.\n */\nvar trie = function() {\n    this.children = {};\n};\n\n/**\n * inserts a word into the trie. \n * @param {string} word\n * @return {void}\n */\ntrie.prototype.insert = function(word) {\n    let node = this.children;\n    for (let char of word) {\n        if (!node[char]) {\n            node[char] = {};\n        }\n        node = node[char];\n    }\n    node.isend = true;\n};\n\n/**\n * returns if the word is in the trie. \n * @param {string} word\n * @return {boolean}\n */\ntrie.prototype.search = function(word) {\n    let node = this.searchprefix(word);\n    return node != undefined && node.isend != undefined;\n};\n\ntrie.prototype.searchprefix = function (prefix) {\n    let node = this.children;\n    for (let char of prefix) {\n        if (!node[char]) return false;\n        node = node[char];\n    }\n    return node;\n}\n\n/**\n * returns if there is any word in the trie that starts with the given prefix. \n * @param {string} prefix\n * @return {boolean}\n */\ntrie.prototype.startswith = function(prefix) {\n    return this.searchprefix(prefix);\n};\n\n/**\n * your trie object will be instantiated and called as such:\n * var obj = new trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startswith(prefix)\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode210 Course Schedule II-zh",frontmatter:{title:"leetcode210 Course Schedule II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/198892/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode210 Course Schedule II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10210.leetcode210%20Course%20Schedule%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode210 Course Schedule II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10210.leetcode210%20Course%20Schedule%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode210 Course Schedule II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10210.leetcode210%20Course%20Schedule%20II-zh.html",relativePath:"01.算法/24.leetcode/10210.leetcode210 Course Schedule II-zh.md",key:"v-1709b7ac",path:"/p/198892/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:717},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:724},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:743},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:759}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 210. 课程表 II\n\nEnglish Version\n\n\n# 题目描述\n\n现在你总共有 n 门课需要选，记为 0 到 n-1。\n\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]\n\n给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。\n\n可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。\n\n示例 1:\n\n输入: 2, [[1,0]] \n输出: [0,1]\n解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。\n\n示例 2:\n\n输入: 4, [[1,0],[2,0],[3,1],[3,2]]\n输出: [0,1,2,3] or [0,2,1,3]\n解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n\n\n说明:\n\n 1. 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。\n 2. 你可以假定输入的先决条件中没有重复的边。\n\n提示:\n\n 1. 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。\n 2. 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。\n\n 3. 拓扑排序也可以通过 BFS 完成。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 210. 课程表 ii\n\nenglish version\n\n\n# 题目描述\n\n现在你总共有 n 门课需要选，记为 0 到 n-1。\n\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]\n\n给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。\n\n可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。\n\n示例 1:\n\n输入: 2, [[1,0]] \n输出: [0,1]\n解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。\n\n示例 2:\n\n输入: 4, [[1,0],[2,0],[3,1],[3,2]]\n输出: [0,1,2,3] or [0,2,1,3]\n解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n\n\n说明:\n\n 1. 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。\n 2. 你可以假定输入的先决条件中没有重复的边。\n\n提示:\n\n 1. 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。\n 2. 通过 dfs 进行拓扑排序 - 一个关于coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。\n\n 3. 拓扑排序也可以通过 bfs 完成。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode209 Minimum Size Subarray Sum-zh",frontmatter:{title:"leetcode209 Minimum Size Subarray Sum-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/2de570/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode209 Minimum Size Subarray Sum-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10209.leetcode209%20Minimum%20Size%20Subarray%20Sum-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode209 Minimum Size Subarray Sum-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10209.leetcode209%20Minimum%20Size%20Subarray%20Sum-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode209 Minimum Size Subarray Sum-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10209.leetcode209%20Minimum%20Size%20Subarray%20Sum-zh.html",relativePath:"01.算法/24.leetcode/10209.leetcode209 Minimum Size Subarray Sum-zh.md",key:"v-7f96c701",path:"/p/2de570/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:472},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:915},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2153},{level:3,title:"C#",slug:"c",normalizedTitle:"c#",charIndex:3566},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:126}],headersStr:"题目描述 解法 Python3 Java C# ...",content:"# 209. 长度最小的子数组\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n \n\n示例 1：\n\n\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\n\n示例 2：\n\n\n输入：target = 4, nums = [1,4,4]\n输出：1\n\n\n示例 3：\n\n\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n\n\n \n\n提示：\n\n * 1 <= target <= 109\n * 1 <= nums.length <= 105\n * 1 <= nums[i] <= 105\n\n \n\n进阶：\n\n * 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。\n\n\n# 解法\n\n“前缀和 + 二分查找”，先求出数组的前缀和 preSum，然后根据 preSum[i] - preSum[j] >= target => preSum[i] >= preSum[j] + target，对 preSum[i] 进行二分查找，然后更新最小长度即可。时间复杂度 O(n logn)。\n\n也可以用“滑动窗口”。\n\n使用指针 left, right 分别表示子数组的开始位置和结束位置，维护变量 sum 表示子数组 nums[left...right] 元素之和。初始时 left, right 均指向 0。每一次迭代，将 nums[right] 加到 sum，如果此时 sum >= target，更新最小长度即可。然后将 sum 减去 nums[left]，接着 left 指针右移直至 sum < target。每一次迭代最后，将 right 指针右移。时间复杂度 O(n)。\n\n\n# Python3\n\n“前缀和 + 二分查找”。\n\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        n = len(nums)\n        pre_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            pre_sum[i] = pre_sum[i - 1] + nums[i - 1]\n        res = n + 1\n        for i in range(1, n + 1):\n            t = pre_sum[i - 1] + target\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) >> 1\n                if pre_sum[mid] >= t:\n                    right = mid\n                else:\n                    left = mid + 1\n            if pre_sum[left] - pre_sum[i - 1] >= target:\n                res = min(res, left - i + 1)\n        return 0 if res == n + 1 else res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n“滑动窗口”。\n\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        n = len(nums)\n        left = right = 0\n        sum, res = 0, n + 1\n        while right < n:\n            sum += nums[right]\n            while sum >= target:\n                res = min(res, right - left + 1)\n                sum -= nums[left]\n                left += 1\n            right += 1\n        return 0 if res == n + 1 else res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\n“前缀和 + 二分查找”。\n\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int n = nums.length;\n        int[] preSum = new int[n + 1];\n        for (int i = 1; i <= n; ++i) {\n            preSum[i] = preSum[i - 1] +nums[i - 1];\n        }\n        int res = n + 1;\n        for (int i = 1; i <= n; ++i) {\n            int t = preSum[i - 1] + target;\n            int left = 0, right = n;\n            while (left < right) {\n                int mid = (left + right) >> 1;\n                if (preSum[mid] >= t) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            if (preSum[left] - preSum[i - 1] >= target) {\n                res = Math.min(res, left - i + 1);\n            }\n        }\n        return res == n + 1 ? 0 : res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n“滑动窗口”。\n\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int n = nums.length;\n        int left = 0, right = 0;\n        int sum = 0, res = n + 1;\n        while (right < n) {\n            sum += nums[right];\n            while (sum >= target) {\n                res = Math.min(res, right - left + 1);\n                sum -= nums[left++];\n            }\n            ++right;\n        }\n        return res == n + 1 ? 0 : res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# C#\n\npublic class Solution {\n    public int MinSubArrayLen(int target, int[] nums) {\n        int n = nums.Length;\n        int left = 0, right = 0;\n        int sum = 0, res = n + 1;\n        while (right < n)\n        {\n            sum += nums[right];\n            while (sum >= target)\n            {\n                res = Math.Min(res, right - left + 1);\n                sum -= nums[left++];\n            }\n            ++right;\n        }\n        return res == n + 1 ? 0 : res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 209. 长度最小的子数组\n\nenglish version\n\n\n# 题目描述\n\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n \n\n示例 1：\n\n\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\n\n示例 2：\n\n\n输入：target = 4, nums = [1,4,4]\n输出：1\n\n\n示例 3：\n\n\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n\n\n \n\n提示：\n\n * 1 <= target <= 109\n * 1 <= nums.length <= 105\n * 1 <= nums[i] <= 105\n\n \n\n进阶：\n\n * 如果你已经实现 o(n) 时间复杂度的解法, 请尝试设计一个 o(n log(n)) 时间复杂度的解法。\n\n\n# 解法\n\n“前缀和 + 二分查找”，先求出数组的前缀和 presum，然后根据 presum[i] - presum[j] >= target => presum[i] >= presum[j] + target，对 presum[i] 进行二分查找，然后更新最小长度即可。时间复杂度 o(n logn)。\n\n也可以用“滑动窗口”。\n\n使用指针 left, right 分别表示子数组的开始位置和结束位置，维护变量 sum 表示子数组 nums[left...right] 元素之和。初始时 left, right 均指向 0。每一次迭代，将 nums[right] 加到 sum，如果此时 sum >= target，更新最小长度即可。然后将 sum 减去 nums[left]，接着 left 指针右移直至 sum < target。每一次迭代最后，将 right 指针右移。时间复杂度 o(n)。\n\n\n# python3\n\n“前缀和 + 二分查找”。\n\nclass solution:\n    def minsubarraylen(self, target: int, nums: list[int]) -> int:\n        n = len(nums)\n        pre_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            pre_sum[i] = pre_sum[i - 1] + nums[i - 1]\n        res = n + 1\n        for i in range(1, n + 1):\n            t = pre_sum[i - 1] + target\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) >> 1\n                if pre_sum[mid] >= t:\n                    right = mid\n                else:\n                    left = mid + 1\n            if pre_sum[left] - pre_sum[i - 1] >= target:\n                res = min(res, left - i + 1)\n        return 0 if res == n + 1 else res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n“滑动窗口”。\n\nclass solution:\n    def minsubarraylen(self, target: int, nums: list[int]) -> int:\n        n = len(nums)\n        left = right = 0\n        sum, res = 0, n + 1\n        while right < n:\n            sum += nums[right]\n            while sum >= target:\n                res = min(res, right - left + 1)\n                sum -= nums[left]\n                left += 1\n            right += 1\n        return 0 if res == n + 1 else res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\n“前缀和 + 二分查找”。\n\nclass solution {\n    public int minsubarraylen(int target, int[] nums) {\n        int n = nums.length;\n        int[] presum = new int[n + 1];\n        for (int i = 1; i <= n; ++i) {\n            presum[i] = presum[i - 1] +nums[i - 1];\n        }\n        int res = n + 1;\n        for (int i = 1; i <= n; ++i) {\n            int t = presum[i - 1] + target;\n            int left = 0, right = n;\n            while (left < right) {\n                int mid = (left + right) >> 1;\n                if (presum[mid] >= t) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            if (presum[left] - presum[i - 1] >= target) {\n                res = math.min(res, left - i + 1);\n            }\n        }\n        return res == n + 1 ? 0 : res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n“滑动窗口”。\n\nclass solution {\n    public int minsubarraylen(int target, int[] nums) {\n        int n = nums.length;\n        int left = 0, right = 0;\n        int sum = 0, res = n + 1;\n        while (right < n) {\n            sum += nums[right];\n            while (sum >= target) {\n                res = math.min(res, right - left + 1);\n                sum -= nums[left++];\n            }\n            ++right;\n        }\n        return res == n + 1 ? 0 : res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# c#\n\npublic class solution {\n    public int minsubarraylen(int target, int[] nums) {\n        int n = nums.length;\n        int left = 0, right = 0;\n        int sum = 0, res = n + 1;\n        while (right < n)\n        {\n            sum += nums[right];\n            while (sum >= target)\n            {\n                res = math.min(res, right - left + 1);\n                sum -= nums[left++];\n            }\n            ++right;\n        }\n        return res == n + 1 ? 0 : res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode211 Design Add and Search Words Data Structure-zh",frontmatter:{title:"leetcode211 Design Add and Search Words Data Structure-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/43f608/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode211 Design Add and Search Words Data Structure-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10211.leetcode211%20Design%20Add%20and%20Search%20Words%20Data%20Structure-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode211 Design Add and Search Words Data Structure-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10211.leetcode211%20Design%20Add%20and%20Search%20Words%20Data%20Structure-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode211 Design Add and Search Words Data Structure-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10211.leetcode211%20Design%20Add%20and%20Search%20Words%20Data%20Structure-zh.html",relativePath:"01.算法/24.leetcode/10211.leetcode211 Design Add and Search Words Data Structure-zh.md",key:"v-5c6e50c4",path:"/p/43f608/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:45},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:978},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:995},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2436},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4260}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 211. 添加与搜索单词 - 数据结构设计\n\nEnglish Version\n\n\n# 题目描述\n\n请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。\n\n实现词典类 WordDictionary ：\n\n * WordDictionary() 初始化词典对象\n * void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配\n * bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 \'.\' ，每个 . 都可以表示任何一个字母。\n\n \n\n示例：\n\n\n输入：\n["WordDictionary","addWord","addWord","addWord","search","search","search","search"]\n[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]\n输出：\n[null,null,null,null,false,true,true,true]\n\n解释：\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord("bad");\nwordDictionary.addWord("dad");\nwordDictionary.addWord("mad");\nwordDictionary.search("pad"); // return False\nwordDictionary.search("bad"); // return True\nwordDictionary.search(".ad"); // return True\nwordDictionary.search("b.."); // return True\n\n\n \n\n提示：\n\n * 1 <= word.length <= 500\n * addWord 中的 word 由小写英文字母组成\n * search 中的 word 由 \'.\' 或小写英文字母组成\n * 最多调用 50000 次 addWord 和 search\n\n\n# 解法\n\n“前缀树”实现。\n\n\n# Python3\n\nclass Trie:\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n\nclass WordDictionary:\n\n    def __init__(self):\n        """\n        Initialize your data structure here.\n        """\n        self.trie = Trie()\n\n    def addWord(self, word: str) -> None:\n        node = self.trie\n        for c in word:\n            index = ord(c) - ord(\'a\')\n            if node.children[index] is None:\n                node.children[index] = Trie()\n            node = node.children[index]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        return self._search(word, self.trie)\n\n    def _search(self, word: str, node: Trie) -> bool:\n        for i in range(len(word)):\n            c = word[i]\n            index = ord(c) - ord(\'a\')\n            if c != \'.\' and node.children[index] is None:\n                return False\n            if c == \'.\':\n                for j in range(26):\n                    if node.children[j] is not None and self._search(word[i + 1:], node.children[j]):\n                        return True\n                return False\n            node = node.children[index]\n        return node.is_end\n\n# Your WordDictionary object will be instantiated and called as such:\n# obj = WordDictionary()\n# obj.addWord(word)\n# param_2 = obj.search(word)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# Java\n\nclass WordDictionary {\n    class Trie {\n        Trie[] children;\n        boolean isEnd;\n        Trie() {\n            children = new Trie[26];\n            isEnd = false;\n        }\n    }\n\n    private Trie trie;\n\n    /** Initialize your data structure here. */\n    public WordDictionary() {\n        trie = new Trie();\n    }\n\n    public void addWord(String word) {\n        Trie node = trie;\n        for (int i = 0; i < word.length(); ++i) {\n            char c = word.charAt(i);\n            int index = c - \'a\';\n            if (node.children[index] == null) {\n                node.children[index] = new Trie();\n            }\n            node = node.children[index];\n        }\n        node.isEnd = true;\n    }\n\n    public boolean search(String word) {\n        return search(word, trie);\n    }\n\n    private boolean search(String word, Trie node) {\n        for (int i = 0; i < word.length(); ++i) {\n            char c = word.charAt(i);\n            int index = c - \'a\';\n            if (c != \'.\' && node.children[index] == null) {\n                return false;\n            }\n            if (c == \'.\') {\n                for (int j = 0; j < 26; ++j) {\n                    if (node.children[j] != null && search(word.substring(i + 1), node.children[j])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            node = node.children[index];\n        }\n        return node.isEnd;\n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 211. 添加与搜索单词 - 数据结构设计\n\nenglish version\n\n\n# 题目描述\n\n请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。\n\n实现词典类 worddictionary ：\n\n * worddictionary() 初始化词典对象\n * void addword(word) 将 word 添加到数据结构中，之后可以对它进行匹配\n * bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 \'.\' ，每个 . 都可以表示任何一个字母。\n\n \n\n示例：\n\n\n输入：\n["worddictionary","addword","addword","addword","search","search","search","search"]\n[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]\n输出：\n[null,null,null,null,false,true,true,true]\n\n解释：\nworddictionary worddictionary = new worddictionary();\nworddictionary.addword("bad");\nworddictionary.addword("dad");\nworddictionary.addword("mad");\nworddictionary.search("pad"); // return false\nworddictionary.search("bad"); // return true\nworddictionary.search(".ad"); // return true\nworddictionary.search("b.."); // return true\n\n\n \n\n提示：\n\n * 1 <= word.length <= 500\n * addword 中的 word 由小写英文字母组成\n * search 中的 word 由 \'.\' 或小写英文字母组成\n * 最多调用 50000 次 addword 和 search\n\n\n# 解法\n\n“前缀树”实现。\n\n\n# python3\n\nclass trie:\n\n    def __init__(self):\n        self.children = [none] * 26\n        self.is_end = false\n\n\nclass worddictionary:\n\n    def __init__(self):\n        """\n        initialize your data structure here.\n        """\n        self.trie = trie()\n\n    def addword(self, word: str) -> none:\n        node = self.trie\n        for c in word:\n            index = ord(c) - ord(\'a\')\n            if node.children[index] is none:\n                node.children[index] = trie()\n            node = node.children[index]\n        node.is_end = true\n\n    def search(self, word: str) -> bool:\n        return self._search(word, self.trie)\n\n    def _search(self, word: str, node: trie) -> bool:\n        for i in range(len(word)):\n            c = word[i]\n            index = ord(c) - ord(\'a\')\n            if c != \'.\' and node.children[index] is none:\n                return false\n            if c == \'.\':\n                for j in range(26):\n                    if node.children[j] is not none and self._search(word[i + 1:], node.children[j]):\n                        return true\n                return false\n            node = node.children[index]\n        return node.is_end\n\n# your worddictionary object will be instantiated and called as such:\n# obj = worddictionary()\n# obj.addword(word)\n# param_2 = obj.search(word)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# java\n\nclass worddictionary {\n    class trie {\n        trie[] children;\n        boolean isend;\n        trie() {\n            children = new trie[26];\n            isend = false;\n        }\n    }\n\n    private trie trie;\n\n    /** initialize your data structure here. */\n    public worddictionary() {\n        trie = new trie();\n    }\n\n    public void addword(string word) {\n        trie node = trie;\n        for (int i = 0; i < word.length(); ++i) {\n            char c = word.charat(i);\n            int index = c - \'a\';\n            if (node.children[index] == null) {\n                node.children[index] = new trie();\n            }\n            node = node.children[index];\n        }\n        node.isend = true;\n    }\n\n    public boolean search(string word) {\n        return search(word, trie);\n    }\n\n    private boolean search(string word, trie node) {\n        for (int i = 0; i < word.length(); ++i) {\n            char c = word.charat(i);\n            int index = c - \'a\';\n            if (c != \'.\' && node.children[index] == null) {\n                return false;\n            }\n            if (c == \'.\') {\n                for (int j = 0; j < 26; ++j) {\n                    if (node.children[j] != null && search(word.substring(i + 1), node.children[j])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            node = node.children[index];\n        }\n        return node.isend;\n    }\n}\n\n/**\n * your worddictionary object will be instantiated and called as such:\n * worddictionary obj = new worddictionary();\n * obj.addword(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode212 Word Search II-zh",frontmatter:{title:"leetcode212 Word Search II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fd6811/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0212.Word%20Search%20II/images/search1.jpg"},{name:"twitter:title",content:"leetcode212 Word Search II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0212.Word%20Search%20II/images/search1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10212.leetcode212%20Word%20Search%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode212 Word Search II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0212.Word%20Search%20II/images/search1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10212.leetcode212%20Word%20Search%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode212 Word Search II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0212.Word%20Search%20II/images/search1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10212.leetcode212%20Word%20Search%20II-zh.html",relativePath:"01.算法/24.leetcode/10212.leetcode212 Word Search II-zh.md",key:"v-67ce5dea",path:"/p/fd6811/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:615},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:622},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:641},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:657}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 212. 单词搜索 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。\n\n单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。\n\n \n\n示例 1：\n\n\n输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]\n输出：["eat","oath"]\n\n\n示例 2：\n\n\n输入：board = [["a","b"],["c","d"]], words = ["abcb"]\n输出：[]\n\n\n \n\n提示：\n\n * m == board.length\n * n == board[i].length\n * 1 <= m, n <= 12\n * board[i][j] 是一个小写英文字母\n * 1 <= words.length <= 3 * 104\n * 1 <= words[i].length <= 10\n * words[i] 由小写英文字母组成\n * words 中的所有字符串互不相同\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 212. 单词搜索 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。\n\n单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。\n\n \n\n示例 1：\n\n\n输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]\n输出：["eat","oath"]\n\n\n示例 2：\n\n\n输入：board = [["a","b"],["c","d"]], words = ["abcb"]\n输出：[]\n\n\n \n\n提示：\n\n * m == board.length\n * n == board[i].length\n * 1 <= m, n <= 12\n * board[i][j] 是一个小写英文字母\n * 1 <= words.length <= 3 * 104\n * 1 <= words[i].length <= 10\n * words[i] 由小写英文字母组成\n * words 中的所有字符串互不相同\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode213 House Robber II-zh",frontmatter:{title:"leetcode213 House Robber II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b3cf16/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode213 House Robber II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10213.leetcode213%20House%20Robber%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode213 House Robber II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10213.leetcode213%20House%20Robber%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode213 House Robber II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10213.leetcode213%20House%20Robber%20II-zh.html",relativePath:"01.算法/24.leetcode/10213.leetcode213 House Robber II-zh.md",key:"v-b92268dc",path:"/p/b3cf16/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:508},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:577},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1016},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1596},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2146},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2576}],headersStr:"题目描述 解法 Python3 Java C++ Go ...",content:"# 213. 打家劫舍 II\n\nEnglish Version\n\n\n# 题目描述\n\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\n\n \n\n示例 1：\n\n\n输入：nums = [2,3,2]\n输出：3\n解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n\n\n示例 2：\n\n\n输入：nums = [1,2,3,1]\n输出：4\n解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 3：\n\n\n输入：nums = [0]\n输出：0\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 1000\n\n\n# 解法\n\n环状排列意味着第一个房屋和最后一个房屋中最多只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房屋子问题。\n\n\n# Python3\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        def robRange(nums, l, r):\n            a, b = 0, nums[l]\n            for num in nums[l + 1: r + 1]:\n                a, b = b, max(num + a, b)\n            return b\n\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        s1, s2 = robRange(nums, 0, n - 2), robRange(nums, 1, n - 1)\n        return max(s1, s2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\nclass Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return nums[0];\n        }\n        int s1 = robRange(nums, 0, n - 2);\n        int s2 = robRange(nums, 1, n - 1);\n        return Math.max(s1, s2);\n    }\n\n    private int robRange(int[] nums, int l, int r) {\n        int a = 0, b = nums[l];\n        for (int i = l + 1; i <= r; ++i) {\n            int c = Math.max(nums[i] + a, b);\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) return nums[0];\n        int s1 = robRange(nums, 0, n - 2);\n        int s2 = robRange(nums, 1, n - 1);\n        return max(s1, s2);\n    }\n\n    int robRange(vector<int>& nums, int l, int r) {\n        int a = 0, b = nums[l];\n        for (int i = l + 1; i <= r; ++i) {\n            int c = max(nums[i] + a, b);\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Go\n\nfunc rob(nums []int) int {\n\tn := len(nums)\n\tif n == 1 {\n\t\treturn nums[0]\n\t}\n\ts1, s2 := robRange(nums, 0, n-2), robRange(nums, 1, n-1)\n\treturn max(s1, s2)\n}\n\nfunc robRange(nums []int, l, r int) int {\n\ta, b := 0, nums[l]\n\tfor i := l + 1; i <= r; i++ {\n\t\ta, b = b, max(nums[i]+a, b)\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 213. 打家劫舍 ii\n\nenglish version\n\n\n# 题目描述\n\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\n\n \n\n示例 1：\n\n\n输入：nums = [2,3,2]\n输出：3\n解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n\n\n示例 2：\n\n\n输入：nums = [1,2,3,1]\n输出：4\n解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 3：\n\n\n输入：nums = [0]\n输出：0\n\n\n \n\n提示：\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 1000\n\n\n# 解法\n\n环状排列意味着第一个房屋和最后一个房屋中最多只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房屋子问题。\n\n\n# python3\n\nclass solution:\n    def rob(self, nums: list[int]) -> int:\n        def robrange(nums, l, r):\n            a, b = 0, nums[l]\n            for num in nums[l + 1: r + 1]:\n                a, b = b, max(num + a, b)\n            return b\n\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        s1, s2 = robrange(nums, 0, n - 2), robrange(nums, 1, n - 1)\n        return max(s1, s2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\nclass solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return nums[0];\n        }\n        int s1 = robrange(nums, 0, n - 2);\n        int s2 = robrange(nums, 1, n - 1);\n        return math.max(s1, s2);\n    }\n\n    private int robrange(int[] nums, int l, int r) {\n        int a = 0, b = nums[l];\n        for (int i = l + 1; i <= r; ++i) {\n            int c = math.max(nums[i] + a, b);\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# c++\n\nclass solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) return nums[0];\n        int s1 = robrange(nums, 0, n - 2);\n        int s2 = robrange(nums, 1, n - 1);\n        return max(s1, s2);\n    }\n\n    int robrange(vector<int>& nums, int l, int r) {\n        int a = 0, b = nums[l];\n        for (int i = l + 1; i <= r; ++i) {\n            int c = max(nums[i] + a, b);\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# go\n\nfunc rob(nums []int) int {\n\tn := len(nums)\n\tif n == 1 {\n\t\treturn nums[0]\n\t}\n\ts1, s2 := robrange(nums, 0, n-2), robrange(nums, 1, n-1)\n\treturn max(s1, s2)\n}\n\nfunc robrange(nums []int, l, r int) int {\n\ta, b := 0, nums[l]\n\tfor i := l + 1; i <= r; i++ {\n\t\ta, b = b, max(nums[i]+a, b)\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode214 Shortest Palindrome-zh",frontmatter:{title:"leetcode214 Shortest Palindrome-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d6bf9a/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode214 Shortest Palindrome-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10214.leetcode214%20Shortest%20Palindrome-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode214 Shortest Palindrome-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10214.leetcode214%20Shortest%20Palindrome-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode214 Shortest Palindrome-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10214.leetcode214%20Shortest%20Palindrome-zh.html",relativePath:"01.算法/24.leetcode/10214.leetcode214 Shortest Palindrome-zh.md",key:"v-30cdd8aa",path:"/p/d6bf9a/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:236},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:243},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:262},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:278}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 214. 最短回文串\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。\n\n \n\n示例 1：\n\n\n输入：s = "aacecaaa"\n输出："aaacecaaa"\n\n\n示例 2：\n\n\n输入：s = "abcd"\n输出："dcbabcd"\n\n\n \n\n提示：\n\n * 0 <= s.length <= 5 * 104\n * s 仅由小写英文字母组成\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 214. 最短回文串\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。\n\n \n\n示例 1：\n\n\n输入：s = "aacecaaa"\n输出："aaacecaaa"\n\n\n示例 2：\n\n\n输入：s = "abcd"\n输出："dcbabcd"\n\n\n \n\n提示：\n\n * 0 <= s.length <= 5 * 104\n * s 仅由小写英文字母组成\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode215 Kth Largest Element in an Array-zh",frontmatter:{title:"leetcode215 Kth Largest Element in an Array-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fd7454/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode215 Kth Largest Element in an Array-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10215.leetcode215%20Kth%20Largest%20Element%20in%20an%20Array-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode215 Kth Largest Element in an Array-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10215.leetcode215%20Kth%20Largest%20Element%20in%20an%20Array-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode215 Kth Largest Element in an Array-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10215.leetcode215%20Kth%20Largest%20Element%20in%20an%20Array-zh.html",relativePath:"01.算法/24.leetcode/10215.leetcode215 Kth Largest Element in an Array-zh.md",key:"v-77be7816",path:"/p/fd7454/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:40},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:237},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:264},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1152},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1993},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2774},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3400}],headersStr:"题目描述 解法 Python3 Java C++ Go ...",content:"# 215. 数组中的第K个最大元素\n\nEnglish Version\n\n\n# 题目描述\n\n在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n\n示例 1:\n\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n\n\n示例 2:\n\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n\n说明:\n\n你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n\n\n# 解法\n\n快速排序 partition 实现。\n\n\n# Python3\n\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        def quickSort(nums, left, right, k):\n            if left == right:\n                return nums[left]\n            i, j = left - 1, right + 1\n            x = nums[(left + right) >> 1]\n            while i < j:\n                while 1:\n                    i += 1\n                    if nums[i] >= x:\n                        break\n                while 1:\n                    j -= 1\n                    if nums[j] <= x:\n                        break\n                if i < j:\n                    nums[i], nums[j] = nums[j], nums[i]\n            if j < k:\n                return quickSort(nums, j + 1, right, k)\n            return quickSort(nums, left, j, k)\n\n        n = len(nums)\n        return quickSort(nums, 0, n - 1, n - k)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Java\n\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int n = nums.length;\n        return quickSort(nums, 0, n - 1, n - k);\n    }\n\n    private int quickSort(int[] nums, int left, int right, int k) {\n        if (left == right) {\n            return nums[left];\n        }\n        int i = left - 1, j = right + 1;\n        int x = nums[(left + right) >>> 1];\n        while (i < j) {\n            while (nums[++i] < x);\n            while (nums[--j] > x);\n            if (i < j) {\n                int t = nums[i];\n                nums[i] = nums[j];\n                nums[j] = t;\n            }\n        }\n        if (j < k) {\n            return quickSort(nums, j + 1, right, k);\n        }\n        return quickSort(nums, left, j, k);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        int n = nums.size();\n        return quickSort(nums, 0, n - 1, n - k);\n    }\n\n    int quickSort(vector<int>& nums, int left, int right, int k) {\n        if (left == right) {\n            return nums[left];\n        }\n        int i = left - 1, j = right + 1;\n        int x = nums[left + right >> 1];\n        while (i < j) {\n            while (nums[++i] < x);\n            while (nums[--j] > x);\n            if (i < j) {\n                swap(nums[i], nums[j]);\n            }\n        }\n        if (j < k) {\n            return quickSort(nums, j + 1, right, k);\n        }\n        return quickSort(nums, left, j, k);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Go\n\nfunc findKthLargest(nums []int, k int) int {\n\tn := len(nums)\n\treturn quickSort(nums, 0, n-1, n-k)\n}\n\nfunc quickSort(nums []int, left, right, k int) int {\n\tif left == right {\n\t\treturn nums[left]\n\t}\n\ti, j := left-1, right+1\n\tx := nums[(left+right)>>1]\n\tfor i < j {\n\t\tfor {\n\t\t\ti++\n\t\t\tif nums[i] >= x {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tfor {\n\t\t\tj--\n\t\t\tif nums[j] <= x {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif i < j {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t}\n\t}\n\tif j < k {\n\t\treturn quickSort(nums, j+1, right, k)\n\t}\n\treturn quickSort(nums, left, j, k)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 215. 数组中的第k个最大元素\n\nenglish version\n\n\n# 题目描述\n\n在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n\n示例 1:\n\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n\n\n示例 2:\n\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n\n说明:\n\n你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n\n\n# 解法\n\n快速排序 partition 实现。\n\n\n# python3\n\nclass solution:\n    def findkthlargest(self, nums: list[int], k: int) -> int:\n        def quicksort(nums, left, right, k):\n            if left == right:\n                return nums[left]\n            i, j = left - 1, right + 1\n            x = nums[(left + right) >> 1]\n            while i < j:\n                while 1:\n                    i += 1\n                    if nums[i] >= x:\n                        break\n                while 1:\n                    j -= 1\n                    if nums[j] <= x:\n                        break\n                if i < j:\n                    nums[i], nums[j] = nums[j], nums[i]\n            if j < k:\n                return quicksort(nums, j + 1, right, k)\n            return quicksort(nums, left, j, k)\n\n        n = len(nums)\n        return quicksort(nums, 0, n - 1, n - k)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# java\n\nclass solution {\n    public int findkthlargest(int[] nums, int k) {\n        int n = nums.length;\n        return quicksort(nums, 0, n - 1, n - k);\n    }\n\n    private int quicksort(int[] nums, int left, int right, int k) {\n        if (left == right) {\n            return nums[left];\n        }\n        int i = left - 1, j = right + 1;\n        int x = nums[(left + right) >>> 1];\n        while (i < j) {\n            while (nums[++i] < x);\n            while (nums[--j] > x);\n            if (i < j) {\n                int t = nums[i];\n                nums[i] = nums[j];\n                nums[j] = t;\n            }\n        }\n        if (j < k) {\n            return quicksort(nums, j + 1, right, k);\n        }\n        return quicksort(nums, left, j, k);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# c++\n\nclass solution {\npublic:\n    int findkthlargest(vector<int>& nums, int k) {\n        int n = nums.size();\n        return quicksort(nums, 0, n - 1, n - k);\n    }\n\n    int quicksort(vector<int>& nums, int left, int right, int k) {\n        if (left == right) {\n            return nums[left];\n        }\n        int i = left - 1, j = right + 1;\n        int x = nums[left + right >> 1];\n        while (i < j) {\n            while (nums[++i] < x);\n            while (nums[--j] > x);\n            if (i < j) {\n                swap(nums[i], nums[j]);\n            }\n        }\n        if (j < k) {\n            return quicksort(nums, j + 1, right, k);\n        }\n        return quicksort(nums, left, j, k);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# go\n\nfunc findkthlargest(nums []int, k int) int {\n\tn := len(nums)\n\treturn quicksort(nums, 0, n-1, n-k)\n}\n\nfunc quicksort(nums []int, left, right, k int) int {\n\tif left == right {\n\t\treturn nums[left]\n\t}\n\ti, j := left-1, right+1\n\tx := nums[(left+right)>>1]\n\tfor i < j {\n\t\tfor {\n\t\t\ti++\n\t\t\tif nums[i] >= x {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tfor {\n\t\t\tj--\n\t\t\tif nums[j] <= x {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif i < j {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t}\n\t}\n\tif j < k {\n\t\treturn quicksort(nums, j+1, right, k)\n\t}\n\treturn quicksort(nums, left, j, k)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode216 Combination Sum III-zh",frontmatter:{title:"leetcode216 Combination Sum III-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/bc08e4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode216 Combination Sum III-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10216.leetcode216%20Combination%20Sum%20III-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode216 Combination Sum III-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10216.leetcode216%20Combination%20Sum%20III-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode216 Combination Sum III-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10216.leetcode216%20Combination%20Sum%20III-zh.html",relativePath:"01.算法/24.leetcode/10216.leetcode216 Combination Sum III-zh.md",key:"v-86c3715c",path:"/p/bc08e4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:241},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:248},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:267},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:283}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 216. 组合总和 III\n\nEnglish Version\n\n\n# 题目描述\n\n找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。\n\n说明：\n\n * 所有数字都是正整数。\n * 解集不能包含重复的组合。 \n\n示例 1:\n\n输入: k = 3, n = 7\n输出: [[1,2,4]]\n\n\n示例 2:\n\n输入: k = 3, n = 9\n输出: [[1,2,6], [1,3,5], [2,3,4]]\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 216. 组合总和 iii\n\nenglish version\n\n\n# 题目描述\n\n找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。\n\n说明：\n\n * 所有数字都是正整数。\n * 解集不能包含重复的组合。 \n\n示例 1:\n\n输入: k = 3, n = 7\n输出: [[1,2,4]]\n\n\n示例 2:\n\n输入: k = 3, n = 9\n输出: [[1,2,6], [1,3,5], [2,3,4]]\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode217 Contains Duplicate-zh",frontmatter:{title:"leetcode217 Contains Duplicate-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/0b5a60/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode217 Contains Duplicate-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10217.leetcode217%20Contains%20Duplicate-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode217 Contains Duplicate-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10217.leetcode217%20Contains%20Duplicate-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode217 Contains Duplicate-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10217.leetcode217%20Contains%20Duplicate-zh.html",relativePath:"01.算法/24.leetcode/10217.leetcode217 Contains Duplicate-zh.md",key:"v-03e14d32",path:"/p/0b5a60/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:233},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:240},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:379},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:664},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:832}],headersStr:"题目描述 解法 Python3 Java TypeScript ...",content:"# 217. 存在重复元素\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数数组，判断是否存在重复元素。\n\n如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。\n\n \n\n示例 1:\n\n\n输入: [1,2,3,1]\n输出: true\n\n示例 2:\n\n\n输入: [1,2,3,4]\n输出: false\n\n示例 3:\n\n\n输入: [1,1,1,3,3,4,3,2,4,2]\n输出: true\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        return len(nums) != len(set(nums))\n\n\n1\n2\n3\n\n\n\n# Java\n\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int e : nums) {\n            if (set.contains(e)) return true;\n            set.add(e);\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# TypeScript\n\nfunction containsDuplicate(nums: number[]): boolean {\n    let unique: Set<number> = new Set(nums);\n    return unique.size != nums.length;\n};\n\n\n1\n2\n3\n4\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 217. 存在重复元素\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数数组，判断是否存在重复元素。\n\n如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。\n\n \n\n示例 1:\n\n\n输入: [1,2,3,1]\n输出: true\n\n示例 2:\n\n\n输入: [1,2,3,4]\n输出: false\n\n示例 3:\n\n\n输入: [1,1,1,3,3,4,3,2,4,2]\n输出: true\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def containsduplicate(self, nums: list[int]) -> bool:\n        return len(nums) != len(set(nums))\n\n\n1\n2\n3\n\n\n\n# java\n\nclass solution {\n    public boolean containsduplicate(int[] nums) {\n        set<integer> set = new hashset<>();\n        for (int e : nums) {\n            if (set.contains(e)) return true;\n            set.add(e);\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# typescript\n\nfunction containsduplicate(nums: number[]): boolean {\n    let unique: set<number> = new set(nums);\n    return unique.size != nums.length;\n};\n\n\n1\n2\n3\n4\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode218 The Skyline Problem-zh",frontmatter:{title:"leetcode218 The Skyline Problem-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/8f61bf/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0218.The%20Skyline%20Problem/images/merged.jpg"},{name:"twitter:title",content:"leetcode218 The Skyline Problem-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0218.The%20Skyline%20Problem/images/merged.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10218.leetcode218%20The%20Skyline%20Problem-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode218 The Skyline Problem-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0218.The%20Skyline%20Problem/images/merged.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10218.leetcode218%20The%20Skyline%20Problem-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode218 The Skyline Problem-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0218.The%20Skyline%20Problem/images/merged.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10218.leetcode218%20The%20Skyline%20Problem-zh.html",relativePath:"01.算法/24.leetcode/10218.leetcode218 The Skyline Problem-zh.md",key:"v-460671de",path:"/p/8f61bf/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:948},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:955},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:974},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:312}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 218. 天际线问题\n\nEnglish Version\n\n\n# 题目描述\n\n城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。\n\n每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：\n\n * lefti 是第 i 座建筑物左边缘的 x 坐标。\n * righti 是第 i 座建筑物右边缘的 x 坐标。\n * heighti 是第 i 座建筑物的高度。\n\n天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],...] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。\n\n注意：输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]\n\n \n\n示例 1：\n\n\n输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n解释：\n图 A 显示输入的所有建筑物的位置和高度，\n图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。\n\n示例 2：\n\n\n输入：buildings = [[0,2,3],[2,5,3]]\n输出：[[0,3],[5,0]]\n\n\n \n\n提示：\n\n * 1 <= buildings.length <= 104\n * 0 <= lefti < righti <= 231 - 1\n * 1 <= heighti <= 231 - 1\n * buildings 按 lefti 非递减排序\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 218. 天际线问题\n\nenglish version\n\n\n# 题目描述\n\n城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。\n\n每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：\n\n * lefti 是第 i 座建筑物左边缘的 x 坐标。\n * righti 是第 i 座建筑物右边缘的 x 坐标。\n * heighti 是第 i 座建筑物的高度。\n\n天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],...] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。\n\n注意：输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]\n\n \n\n示例 1：\n\n\n输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n解释：\n图 a 显示输入的所有建筑物的位置和高度，\n图 b 显示由这些建筑物形成的天际线。图 b 中的红点表示输出列表中的关键点。\n\n示例 2：\n\n\n输入：buildings = [[0,2,3],[2,5,3]]\n输出：[[0,3],[5,0]]\n\n\n \n\n提示：\n\n * 1 <= buildings.length <= 104\n * 0 <= lefti < righti <= 231 - 1\n * 1 <= heighti <= 231 - 1\n * buildings 按 lefti 非递减排序\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode219 Contains Duplicate II-zh",frontmatter:{title:"leetcode219 Contains Duplicate II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/1c26f8/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode219 Contains Duplicate II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10219.leetcode219%20Contains%20Duplicate%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode219 Contains Duplicate II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10219.leetcode219%20Contains%20Duplicate%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode219 Contains Duplicate II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10219.leetcode219%20Contains%20Duplicate%20II-zh.html",relativePath:"01.算法/24.leetcode/10219.leetcode219 Contains Duplicate II-zh.md",key:"v-c10acd60",path:"/p/1c26f8/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:277},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:284},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:587},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1095}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 219. 存在重复元素 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。\n\n \n\n示例 1:\n\n输入: nums = [1,2,3,1], k = 3\n输出: true\n\n示例 2:\n\n输入: nums = [1,0,1,1], k = 1\n输出: true\n\n示例 3:\n\n输入: nums = [1,2,3,1,2,3], k = 2\n输出: false\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        helper = {}\n        for i, v in enumerate(nums):\n            if v in helper and i - helper[v] <= k:\n                return True\n            helper[v] = i\n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Java\n\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Map<Integer, Integer> helper = new HashMap<>();\n        for (int i = 0, n = nums.length; i < n; ++i) {\n            if (helper.containsKey(nums[i])) {\n                int j = helper.get(nums[i]);\n                if (i - j <= k) {\n                    return true;\n                }\n            }\n            helper.put(nums[i], i);\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 219. 存在重复元素 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。\n\n \n\n示例 1:\n\n输入: nums = [1,2,3,1], k = 3\n输出: true\n\n示例 2:\n\n输入: nums = [1,0,1,1], k = 1\n输出: true\n\n示例 3:\n\n输入: nums = [1,2,3,1,2,3], k = 2\n输出: false\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def containsnearbyduplicate(self, nums: list[int], k: int) -> bool:\n        helper = {}\n        for i, v in enumerate(nums):\n            if v in helper and i - helper[v] <= k:\n                return true\n            helper[v] = i\n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# java\n\nclass solution {\n    public boolean containsnearbyduplicate(int[] nums, int k) {\n        map<integer, integer> helper = new hashmap<>();\n        for (int i = 0, n = nums.length; i < n; ++i) {\n            if (helper.containskey(nums[i])) {\n                int j = helper.get(nums[i]);\n                if (i - j <= k) {\n                    return true;\n                }\n            }\n            helper.put(nums[i], i);\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode220 Contains Duplicate III-zh",frontmatter:{title:"leetcode220 Contains Duplicate III-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/7fc47c/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode220 Contains Duplicate III-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10220.leetcode220%20Contains%20Duplicate%20III-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode220 Contains Duplicate III-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10220.leetcode220%20Contains%20Duplicate%20III-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode220 Contains Duplicate III-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10220.leetcode220%20Contains%20Duplicate%20III-zh.html",relativePath:"01.算法/24.leetcode/10220.leetcode220 Contains Duplicate III-zh.md",key:"v-5f117cb8",path:"/p/7fc47c/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:450},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:457},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:476},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:492}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 220. 存在重复元素 III\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) <= t ，同时又满足 abs(i - j) <= k 。\n\n如果存在则返回 true，不存在返回 false。\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,3,1], k = 3, t = 0\n输出：true\n\n示例 2：\n\n\n输入：nums = [1,0,1,1], k = 1, t = 2\n输出：true\n\n示例 3：\n\n\n输入：nums = [1,5,9,1,5,9], k = 2, t = 3\n输出：false\n\n \n\n提示：\n\n * 0 <= nums.length <= 2 * 104\n * -231 <= nums[i] <= 231 - 1\n * 0 <= k <= 104\n * 0 <= t <= 231 - 1\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 220. 存在重复元素 iii\n\nenglish version\n\n\n# 题目描述\n\n给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) <= t ，同时又满足 abs(i - j) <= k 。\n\n如果存在则返回 true，不存在返回 false。\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,3,1], k = 3, t = 0\n输出：true\n\n示例 2：\n\n\n输入：nums = [1,0,1,1], k = 1, t = 2\n输出：true\n\n示例 3：\n\n\n输入：nums = [1,5,9,1,5,9], k = 2, t = 3\n输出：false\n\n \n\n提示：\n\n * 0 <= nums.length <= 2 * 104\n * -231 <= nums[i] <= 231 - 1\n * 0 <= k <= 104\n * 0 <= t <= 231 - 1\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode221 Maximal Square-zh",frontmatter:{title:"leetcode221 Maximal Square-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/838c9a/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0221.Maximal%20Square/images/max1grid.jpg"},{name:"twitter:title",content:"leetcode221 Maximal Square-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0221.Maximal%20Square/images/max1grid.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10221.leetcode221%20Maximal%20Square-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode221 Maximal Square-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0221.Maximal%20Square/images/max1grid.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10221.leetcode221%20Maximal%20Square-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode221 Maximal Square-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0221.Maximal%20Square/images/max1grid.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10221.leetcode221%20Maximal%20Square-zh.html",relativePath:"01.算法/24.leetcode/10221.leetcode221 Maximal Square-zh.md",key:"v-95ad93e6",path:"/p/838c9a/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:401},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:408},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:427},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:443}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 221. 最大正方形\n\nEnglish Version\n\n\n# 题目描述\n\n在一个由 \'0\' 和 \'1\' 组成的二维矩阵内，找到只包含 \'1\' 的最大正方形，并返回其面积。\n\n \n\n示例 1：\n\n\n输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]\n输出：4\n\n\n示例 2：\n\n\n输入：matrix = [["0","1"],["1","0"]]\n输出：1\n\n\n示例 3：\n\n\n输入：matrix = [["0"]]\n输出：0\n\n\n \n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 300\n * matrix[i][j] 为 \'0\' 或 \'1\'\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 221. 最大正方形\n\nenglish version\n\n\n# 题目描述\n\n在一个由 \'0\' 和 \'1\' 组成的二维矩阵内，找到只包含 \'1\' 的最大正方形，并返回其面积。\n\n \n\n示例 1：\n\n\n输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]\n输出：4\n\n\n示例 2：\n\n\n输入：matrix = [["0","1"],["1","0"]]\n输出：1\n\n\n示例 3：\n\n\n输入：matrix = [["0"]]\n输出：0\n\n\n \n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 300\n * matrix[i][j] 为 \'0\' 或 \'1\'\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode222 Count Complete Tree Nodes-zh",frontmatter:{title:"leetcode222 Count Complete Tree Nodes-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/f1ccb7/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0222.Count%20Complete%20Tree%20Nodes/images/complete.jpg"},{name:"twitter:title",content:"leetcode222 Count Complete Tree Nodes-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0222.Count%20Complete%20Tree%20Nodes/images/complete.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10222.leetcode222%20Count%20Complete%20Tree%20Nodes-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode222 Count Complete Tree Nodes-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0222.Count%20Complete%20Tree%20Nodes/images/complete.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10222.leetcode222%20Count%20Complete%20Tree%20Nodes-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode222 Count Complete Tree Nodes-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0222.Count%20Complete%20Tree%20Nodes/images/complete.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10222.leetcode222%20Count%20Complete%20Tree%20Nodes-zh.html",relativePath:"01.算法/24.leetcode/10222.leetcode222 Count Complete Tree Nodes-zh.md",key:"v-0a51c005",path:"/p/f1ccb7/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:420},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:427},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1199},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:2232},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:3251},{level:3,title:"C#",slug:"c-2",normalizedTitle:"c#",charIndex:3850},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:4889}],headersStr:"题目描述 解法 Python3 Java C++ Go C# ...",content:"# 222. 完全二叉树的节点个数\n\nEnglish Version\n\n\n# 题目描述\n\n给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\n\n完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\n\n \n\n示例 1：\n\n\n输入：root = [1,2,3,4,5,6]\n输出：6\n\n\n示例 2：\n\n\n输入：root = []\n输出：0\n\n\n示例 3：\n\n\n输入：root = [1]\n输出：1\n\n\n \n\n提示：\n\n * 树中节点的数目范围是[0, 5 * 104]\n * 0 <= Node.val <= 5 * 104\n * 题目数据保证输入的树是 完全二叉树\n\n \n\n进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countNodes(self, root: TreeNode) -> int:\n        def depth(root):\n            res = 0\n            while root:\n                res += 1\n                root = root.left\n            return res\n\n        if root is None:\n            return 0\n        left_depth = depth(root.left)\n        right_depth = depth(root.right)\n        if left_depth > right_depth:\n            return (1 << right_depth) + self.countNodes(root.left)\n        return (1 << left_depth) + self.countNodes(root.right)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftDepth = depth(root.left);\n        int rightDepth = depth(root.right);\n        if (leftDepth > rightDepth) {\n            return (1 << rightDepth) + countNodes(root.left);\n        }\n        return (1 << leftDepth) + countNodes(root.right);\n    }\n\n    private int depth(TreeNode root) {\n        int res = 0;\n        while (root != null) {\n            ++res;\n            root = root.left;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# C++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        if (!root) {\n            return 0;\n        }\n        int leftDepth = depth(root->left);\n        int rightDepth = depth(root->right);\n        if (leftDepth > rightDepth) {\n            return (1 << rightDepth) + countNodes(root->left);\n        }\n        return (1 << leftDepth) + countNodes(root->right);\n    }\n\nprivate:\n    int depth(TreeNode* root) {\n        int res = 0;\n        while (root) {\n            ++res;\n            root = root->left;\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# Go\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc countNodes(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tleftDepth := depth(root.Left)\n\trightDepth := depth(root.Right)\n\tif leftDepth > rightDepth {\n\t\treturn (1 << rightDepth) + countNodes(root.Left)\n\t}\n\treturn (1 << leftDepth) + countNodes(root.Right)\n}\n\nfunc depth(root *TreeNode) int {\n\tres := 0\n\tfor root != nil {\n\t\tres++\n\t\troot = root.Left\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# C#\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int CountNodes(TreeNode root) {\n        if (root == null)\n        {\n            return 0;\n        }\n        int leftDepth = depth(root.left);\n        int rightDepth = depth(root.right);\n        if (leftDepth > rightDepth)\n        {\n            return (1 << rightDepth) + CountNodes(root.left);\n        }\n        return (1 << leftDepth) + CountNodes(root.right);\n    }\n\n    private int depth(TreeNode root) {\n        int res = 0;\n        while (root != null)\n        {\n            ++res;\n            root = root.left;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 222. 完全二叉树的节点个数\n\nenglish version\n\n\n# 题目描述\n\n给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\n\n完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\n\n \n\n示例 1：\n\n\n输入：root = [1,2,3,4,5,6]\n输出：6\n\n\n示例 2：\n\n\n输入：root = []\n输出：0\n\n\n示例 3：\n\n\n输入：root = [1]\n输出：1\n\n\n \n\n提示：\n\n * 树中节点的数目范围是[0, 5 * 104]\n * 0 <= node.val <= 5 * 104\n * 题目数据保证输入的树是 完全二叉树\n\n \n\n进阶：遍历树来统计节点是一种时间复杂度为 o(n) 的简单解决方案。你可以设计一个更快的算法吗？\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def countnodes(self, root: treenode) -> int:\n        def depth(root):\n            res = 0\n            while root:\n                res += 1\n                root = root.left\n            return res\n\n        if root is none:\n            return 0\n        left_depth = depth(root.left)\n        right_depth = depth(root.right)\n        if left_depth > right_depth:\n            return (1 << right_depth) + self.countnodes(root.left)\n        return (1 << left_depth) + self.countnodes(root.right)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public int countnodes(treenode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftdepth = depth(root.left);\n        int rightdepth = depth(root.right);\n        if (leftdepth > rightdepth) {\n            return (1 << rightdepth) + countnodes(root.left);\n        }\n        return (1 << leftdepth) + countnodes(root.right);\n    }\n\n    private int depth(treenode root) {\n        int res = 0;\n        while (root != null) {\n            ++res;\n            root = root.left;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# c++\n\n/**\n * definition for a binary tree node.\n * struct treenode {\n *     int val;\n *     treenode *left;\n *     treenode *right;\n *     treenode() : val(0), left(nullptr), right(nullptr) {}\n *     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass solution {\npublic:\n    int countnodes(treenode* root) {\n        if (!root) {\n            return 0;\n        }\n        int leftdepth = depth(root->left);\n        int rightdepth = depth(root->right);\n        if (leftdepth > rightdepth) {\n            return (1 << rightdepth) + countnodes(root->left);\n        }\n        return (1 << leftdepth) + countnodes(root->right);\n    }\n\nprivate:\n    int depth(treenode* root) {\n        int res = 0;\n        while (root) {\n            ++res;\n            root = root->left;\n        }\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# go\n\n/**\n * definition for a binary tree node.\n * type treenode struct {\n *     val int\n *     left *treenode\n *     right *treenode\n * }\n */\nfunc countnodes(root *treenode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tleftdepth := depth(root.left)\n\trightdepth := depth(root.right)\n\tif leftdepth > rightdepth {\n\t\treturn (1 << rightdepth) + countnodes(root.left)\n\t}\n\treturn (1 << leftdepth) + countnodes(root.right)\n}\n\nfunc depth(root *treenode) int {\n\tres := 0\n\tfor root != nil {\n\t\tres++\n\t\troot = root.left\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# c#\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     public int val;\n *     public treenode left;\n *     public treenode right;\n *     public treenode(int val=0, treenode left=null, treenode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class solution {\n    public int countnodes(treenode root) {\n        if (root == null)\n        {\n            return 0;\n        }\n        int leftdepth = depth(root.left);\n        int rightdepth = depth(root.right);\n        if (leftdepth > rightdepth)\n        {\n            return (1 << rightdepth) + countnodes(root.left);\n        }\n        return (1 << leftdepth) + countnodes(root.right);\n    }\n\n    private int depth(treenode root) {\n        int res = 0;\n        while (root != null)\n        {\n            ++res;\n            root = root.left;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode223 Rectangle Area-zh",frontmatter:{title:"leetcode223 Rectangle Area-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/e71170/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0223.Rectangle%20Area/images/rectangle_area.png"},{name:"twitter:title",content:"leetcode223 Rectangle Area-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0223.Rectangle%20Area/images/rectangle_area.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10223.leetcode223%20Rectangle%20Area-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode223 Rectangle Area-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0223.Rectangle%20Area/images/rectangle_area.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10223.leetcode223%20Rectangle%20Area-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode223 Rectangle Area-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0223.Rectangle%20Area/images/rectangle_area.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10223.leetcode223%20Rectangle%20Area-zh.html",relativePath:"01.算法/24.leetcode/10223.leetcode223 Rectangle Area-zh.md",key:"v-2d3e01cd",path:"/p/e71170/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:169},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:176},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:195},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:211}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 223. 矩形面积\n\nEnglish Version\n\n\n# 题目描述\n\n在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。\n\n每个矩形由其左下顶点和右上顶点坐标表示，如图所示。\n\n\n\n示例:\n\n输入: -3, 0, 3, 4, 0, -1, 9, 2\n输出: 45\n\n说明: 假设矩形面积不会超出 int 的范围。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 223. 矩形面积\n\nenglish version\n\n\n# 题目描述\n\n在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。\n\n每个矩形由其左下顶点和右上顶点坐标表示，如图所示。\n\n\n\n示例:\n\n输入: -3, 0, 3, 4, 0, -1, 9, 2\n输出: 45\n\n说明: 假设矩形面积不会超出 int 的范围。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode224 Basic Calculator-zh",frontmatter:{title:"leetcode224 Basic Calculator-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/5590ee/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode224 Basic Calculator-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10224.leetcode224%20Basic%20Calculator-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode224 Basic Calculator-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10224.leetcode224%20Basic%20Calculator-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode224 Basic Calculator-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10224.leetcode224%20Basic%20Calculator-zh.html",relativePath:"01.算法/24.leetcode/10224.leetcode224 Basic Calculator-zh.md",key:"v-4d0cd04d",path:"/p/5590ee/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:279},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:286},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:305},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:321}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 224. 基本计算器\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。\n\n \n\n示例 1：\n\n\n输入：s = \"1 + 1\"\n输出：2\n\n\n示例 2：\n\n\n输入：s = \" 2-1 + 2 \"\n输出：3\n\n\n示例 3：\n\n\n输入：s = \"(1+(4+5+2)-3)+(6+8)\"\n输出：23\n\n\n \n\n提示：\n\n * 1 <= s.length <= 3 * 105\n * s 由数字、'+'、'-'、'('、')'、和 ' ' 组成\n * s 表示一个有效的表达式\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 224. 基本计算器\n\nenglish version\n\n\n# 题目描述\n\n给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。\n\n \n\n示例 1：\n\n\n输入：s = \"1 + 1\"\n输出：2\n\n\n示例 2：\n\n\n输入：s = \" 2-1 + 2 \"\n输出：3\n\n\n示例 3：\n\n\n输入：s = \"(1+(4+5+2)-3)+(6+8)\"\n输出：23\n\n\n \n\n提示：\n\n * 1 <= s.length <= 3 * 105\n * s 由数字、'+'、'-'、'('、')'、和 ' ' 组成\n * s 表示一个有效的表达式\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode225 Implement Stack using Queues-zh",frontmatter:{title:"leetcode225 Implement Stack using Queues-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/2cde3f/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode225 Implement Stack using Queues-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10225.leetcode225%20Implement%20Stack%20using%20Queues-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode225 Implement Stack using Queues-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10225.leetcode225%20Implement%20Stack%20using%20Queues-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode225 Implement Stack using Queues-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10225.leetcode225%20Implement%20Stack%20using%20Queues-zh.html",relativePath:"01.算法/24.leetcode/10225.leetcode225 Implement Stack using Queues-zh.md",key:"v-7d5a9373",path:"/p/2cde3f/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:868},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:875},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1927},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2968}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 225. 用队列实现栈\n\nEnglish Version\n\n\n# 题目描述\n\n请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。\n\n实现 MyStack 类：\n\n * void push(int x) 将元素 x 压入栈顶。\n * int pop() 移除并返回栈顶元素。\n * int top() 返回栈顶元素。\n * boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n \n\n注意：\n\n * 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。\n * 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n\n \n\n示例：\n\n\n输入：\n["MyStack", "push", "push", "top", "pop", "empty"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 2, 2, false]\n\n解释：\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // 返回 2\nmyStack.pop(); // 返回 2\nmyStack.empty(); // 返回 False\n\n\n \n\n提示：\n\n * 1 <= x <= 9\n * 最多调用100 次 push、pop、top 和 empty\n * 每次调用 pop 和 top 都保证栈不为空\n\n \n\n进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。\n\n\n# 解法\n\n\n# Python3\n\nclass MyStack:\n\n    def __init__(self):\n        """\n        Initialize your data structure here.\n        """\n        self.q = []\n\n\n    def push(self, x: int) -> None:\n        """\n        Push element x onto stack.\n        """\n        self.q.append(x)\n        n = len(self.q)\n        for i in range(1, n):\n            self.q.append(self.q.pop(0))\n\n\n    def pop(self) -> int:\n        """\n        Removes the element on top of the stack and returns that element.\n        """\n        return self.q.pop(0)\n\n\n    def top(self) -> int:\n        """\n        Get the top element.\n        """\n        return self.q[0]\n\n\n    def empty(self) -> bool:\n        """\n        Returns whether the stack is empty.\n        """\n        return len(self.q) == 0\n\n\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# Java\n\nclass MyStack {\n\n    private Deque<Integer> q;\n\n    /** Initialize your data structure here. */\n    public MyStack() {\n        q = new ArrayDeque<>();\n    }\n\n    /** Push element x onto stack. */\n    public void push(int x) {\n        q.offerLast(x);\n        int n = q.size();\n        while (n-- > 1) {\n            q.offerLast(q.pollFirst());\n        }\n    }\n\n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        return q.pollFirst();\n    }\n\n    /** Get the top element. */\n    public int top() {\n        return q.peekFirst();\n    }\n\n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        return q.isEmpty();\n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 225. 用队列实现栈\n\nenglish version\n\n\n# 题目描述\n\n请你仅使用两个队列实现一个后入先出（lifo）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。\n\n实现 mystack 类：\n\n * void push(int x) 将元素 x 压入栈顶。\n * int pop() 移除并返回栈顶元素。\n * int top() 返回栈顶元素。\n * boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n \n\n注意：\n\n * 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。\n * 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n\n \n\n示例：\n\n\n输入：\n["mystack", "push", "push", "top", "pop", "empty"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 2, 2, false]\n\n解释：\nmystack mystack = new mystack();\nmystack.push(1);\nmystack.push(2);\nmystack.top(); // 返回 2\nmystack.pop(); // 返回 2\nmystack.empty(); // 返回 false\n\n\n \n\n提示：\n\n * 1 <= x <= 9\n * 最多调用100 次 push、pop、top 和 empty\n * 每次调用 pop 和 top 都保证栈不为空\n\n \n\n进阶：你能否实现每种操作的均摊时间复杂度为 o(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 o(n) ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。\n\n\n# 解法\n\n\n# python3\n\nclass mystack:\n\n    def __init__(self):\n        """\n        initialize your data structure here.\n        """\n        self.q = []\n\n\n    def push(self, x: int) -> none:\n        """\n        push element x onto stack.\n        """\n        self.q.append(x)\n        n = len(self.q)\n        for i in range(1, n):\n            self.q.append(self.q.pop(0))\n\n\n    def pop(self) -> int:\n        """\n        removes the element on top of the stack and returns that element.\n        """\n        return self.q.pop(0)\n\n\n    def top(self) -> int:\n        """\n        get the top element.\n        """\n        return self.q[0]\n\n\n    def empty(self) -> bool:\n        """\n        returns whether the stack is empty.\n        """\n        return len(self.q) == 0\n\n\n\n# your mystack object will be instantiated and called as such:\n# obj = mystack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# java\n\nclass mystack {\n\n    private deque<integer> q;\n\n    /** initialize your data structure here. */\n    public mystack() {\n        q = new arraydeque<>();\n    }\n\n    /** push element x onto stack. */\n    public void push(int x) {\n        q.offerlast(x);\n        int n = q.size();\n        while (n-- > 1) {\n            q.offerlast(q.pollfirst());\n        }\n    }\n\n    /** removes the element on top of the stack and returns that element. */\n    public int pop() {\n        return q.pollfirst();\n    }\n\n    /** get the top element. */\n    public int top() {\n        return q.peekfirst();\n    }\n\n    /** returns whether the stack is empty. */\n    public boolean empty() {\n        return q.isempty();\n    }\n}\n\n/**\n * your mystack object will be instantiated and called as such:\n * mystack obj = new mystack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode226 Invert Binary Tree-zh",frontmatter:{title:"leetcode226 Invert Binary Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b0dddc/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode226 Invert Binary Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10226.leetcode226%20Invert%20Binary%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode226 Invert Binary Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10226.leetcode226%20Invert%20Binary%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode226 Invert Binary Tree-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10226.leetcode226%20Invert%20Binary%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10226.leetcode226 Invert Binary Tree-zh.md",key:"v-2ec7306c",path:"/p/b0dddc/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:270},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:277},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:756},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1279},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1722},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2125}],headersStr:"题目描述 解法 Python3 Java JavaScript Go ...",content:"# 226. 翻转二叉树\n\nEnglish Version\n\n\n# 题目描述\n\n翻转一棵二叉树。\n\n示例：\n\n输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\n输出：\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n备注:\n这个问题是受到 Max Howell 的 原问题 启发的 ：\n\n> 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if root is None:\n            return None\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) return null;\n        TreeNode t = root.left;\n        root.left = root.right;\n        root.right = t;\n        invertTree(root.left);\n        invertTree(root.right);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# JavaScript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function (root) {\n  if (!root) return null;\n  [root.left, root.right] = [root.right, root.left];\n  invertTree(root.left);\n  invertTree(root.right);\n  return root;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Go\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc invertTree(root *TreeNode) *TreeNode {\n    if (root == nil) {\n        return nil\n    }\n    root.Left, root.Right = root.Right, root.Left\n    invertTree(root.Left)\n    invertTree(root.Right)\n    return root\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 226. 翻转二叉树\n\nenglish version\n\n\n# 题目描述\n\n翻转一棵二叉树。\n\n示例：\n\n输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\n输出：\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n备注:\n这个问题是受到 max howell 的 原问题 启发的 ：\n\n> 谷歌：我们90％的工程师使用您编写的软件(homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def inverttree(self, root: treenode) -> treenode:\n        if root is none:\n            return none\n        root.left, root.right = root.right, root.left\n        self.inverttree(root.left)\n        self.inverttree(root.right)\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode inverttree(treenode root) {\n        if (root == null) return null;\n        treenode t = root.left;\n        root.left = root.right;\n        root.right = t;\n        inverttree(root.left);\n        inverttree(root.right);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# javascript\n\n/**\n * definition for a binary tree node.\n * function treenode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {treenode} root\n * @return {treenode}\n */\nvar inverttree = function (root) {\n  if (!root) return null;\n  [root.left, root.right] = [root.right, root.left];\n  inverttree(root.left);\n  inverttree(root.right);\n  return root;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# go\n\n/**\n * definition for a binary tree node.\n * type treenode struct {\n *     val int\n *     left *treenode\n *     right *treenode\n * }\n */\nfunc inverttree(root *treenode) *treenode {\n    if (root == nil) {\n        return nil\n    }\n    root.left, root.right = root.right, root.left\n    inverttree(root.left)\n    inverttree(root.right)\n    return root\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode227 Basic Calculator II-zh",frontmatter:{title:"leetcode227 Basic Calculator II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/f546b9/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode227 Basic Calculator II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10227.leetcode227%20Basic%20Calculator%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode227 Basic Calculator II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10227.leetcode227%20Basic%20Calculator%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode227 Basic Calculator II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10227.leetcode227%20Basic%20Calculator%20II-zh.html",relativePath:"01.算法/24.leetcode/10227.leetcode227 Basic Calculator II-zh.md",key:"v-3427b4ec",path:"/p/f546b9/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:357},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:515},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1347},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2579}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 227. 基本计算器 II\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。\n\n整数除法仅保留整数部分。\n\n \n\n示例 1：\n\n\n输入：s = \"3+2*2\"\n输出：7\n\n\n示例 2：\n\n\n输入：s = \" 3/2 \"\n输出：1\n\n\n示例 3：\n\n\n输入：s = \" 3+5 / 2 \"\n输出：5\n\n\n \n\n提示：\n\n * 1 <= s.length <= 3 * 105\n * s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开\n * s 表示一个 有效表达式\n * 表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内\n * 题目数据保证答案是一个 32-bit 整数\n\n\n# 解法\n\n遍历字符串 s，并用变量 preSign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 preSign 来决定计算方式：\n\n * 加号：将数字压入栈；\n * 减号：将数字的相反数压入栈；\n * 乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。\n\n\n# Python3\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        num, n = 0, len(s)\n        pre_sign = '+'\n        stack = []\n        for i in range(n):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if i == n - 1 or (not s[i].isdigit() and s[i] != ' '):\n                if pre_sign == '+':\n                    stack.append(num)\n                elif pre_sign == '-':\n                    stack.append(-num)\n                elif pre_sign == '*':\n                    stack.append(stack.pop() * num)\n                else:\n                    stack.append(int(stack.pop() / num))\n                pre_sign = s[i]\n                num = 0\n        res = 0\n        while stack:\n            res += stack.pop()\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Java\n\nclass Solution {\n    public int calculate(String s) {\n        int num = 0;\n        char preSign = '+';\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            if (Character.isDigit(s.charAt(i))) {\n                num = num * 10 + (s.charAt(i) - '0');\n            }\n            if (i == n - 1 || (!Character.isDigit(s.charAt(i)) && s.charAt(i) != ' ')) {\n                switch (preSign) {\n                    case '+':\n                        stack.push(num);\n                        break;\n                    case '-':\n                        stack.push(-num);\n                        break;\n                    case '*':\n                        stack.push(stack.pop() * num);\n                        break;\n                    case '/':\n                        stack.push(stack.pop() / num);\n                        break;\n                }\n                preSign = s.charAt(i);\n                num = 0;\n            }\n        }\n\n        int res = 0;\n        while (!stack.isEmpty()) {\n            res += stack.pop();\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 227. 基本计算器 ii\n\nenglish version\n\n\n# 题目描述\n\n给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。\n\n整数除法仅保留整数部分。\n\n \n\n示例 1：\n\n\n输入：s = \"3+2*2\"\n输出：7\n\n\n示例 2：\n\n\n输入：s = \" 3/2 \"\n输出：1\n\n\n示例 3：\n\n\n输入：s = \" 3+5 / 2 \"\n输出：5\n\n\n \n\n提示：\n\n * 1 <= s.length <= 3 * 105\n * s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开\n * s 表示一个 有效表达式\n * 表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内\n * 题目数据保证答案是一个 32-bit 整数\n\n\n# 解法\n\n遍历字符串 s，并用变量 presign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 presign 来决定计算方式：\n\n * 加号：将数字压入栈；\n * 减号：将数字的相反数压入栈；\n * 乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。\n\n\n# python3\n\nclass solution:\n    def calculate(self, s: str) -> int:\n        num, n = 0, len(s)\n        pre_sign = '+'\n        stack = []\n        for i in range(n):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if i == n - 1 or (not s[i].isdigit() and s[i] != ' '):\n                if pre_sign == '+':\n                    stack.append(num)\n                elif pre_sign == '-':\n                    stack.append(-num)\n                elif pre_sign == '*':\n                    stack.append(stack.pop() * num)\n                else:\n                    stack.append(int(stack.pop() / num))\n                pre_sign = s[i]\n                num = 0\n        res = 0\n        while stack:\n            res += stack.pop()\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# java\n\nclass solution {\n    public int calculate(string s) {\n        int num = 0;\n        char presign = '+';\n        deque<integer> stack = new arraydeque<>();\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            if (character.isdigit(s.charat(i))) {\n                num = num * 10 + (s.charat(i) - '0');\n            }\n            if (i == n - 1 || (!character.isdigit(s.charat(i)) && s.charat(i) != ' ')) {\n                switch (presign) {\n                    case '+':\n                        stack.push(num);\n                        break;\n                    case '-':\n                        stack.push(-num);\n                        break;\n                    case '*':\n                        stack.push(stack.pop() * num);\n                        break;\n                    case '/':\n                        stack.push(stack.pop() / num);\n                        break;\n                }\n                presign = s.charat(i);\n                num = 0;\n            }\n        }\n\n        int res = 0;\n        while (!stack.isempty()) {\n            res += stack.pop();\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode228 Summary Ranges-zh",frontmatter:{title:"leetcode228 Summary Ranges-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/a3f9ac/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode228 Summary Ranges-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10228.leetcode228%20Summary%20Ranges-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode228 Summary Ranges-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10228.leetcode228%20Summary%20Ranges-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode228 Summary Ranges-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10228.leetcode228%20Summary%20Ranges-zh.html",relativePath:"01.算法/24.leetcode/10228.leetcode228 Summary Ranges-zh.md",key:"v-47845ccd",path:"/p/a3f9ac/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:673},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:680},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:699},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:715}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 228. 汇总区间\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个无重复元素的有序整数数组 nums 。\n\n返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。\n\n列表中的每个区间范围 [a,b] 应该按如下格式输出：\n\n * "a->b" ，如果 a != b\n * "a" ，如果 a == b\n\n \n\n示例 1：\n\n\n输入：nums = [0,1,2,4,5,7]\n输出：["0->2","4->5","7"]\n解释：区间范围是：\n[0,2] --\x3e "0->2"\n[4,5] --\x3e "4->5"\n[7,7] --\x3e "7"\n\n\n示例 2：\n\n\n输入：nums = [0,2,3,4,6,8,9]\n输出：["0","2->4","6","8->9"]\n解释：区间范围是：\n[0,0] --\x3e "0"\n[2,4] --\x3e "2->4"\n[6,6] --\x3e "6"\n[8,9] --\x3e "8->9"\n\n\n示例 3：\n\n\n输入：nums = []\n输出：[]\n\n\n示例 4：\n\n\n输入：nums = [-1]\n输出：["-1"]\n\n\n示例 5：\n\n\n输入：nums = [0]\n输出：["0"]\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 20\n * -231 <= nums[i] <= 231 - 1\n * nums 中的所有值都 互不相同\n * nums 按升序排列\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 228. 汇总区间\n\nenglish version\n\n\n# 题目描述\n\n给定一个无重复元素的有序整数数组 nums 。\n\n返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。\n\n列表中的每个区间范围 [a,b] 应该按如下格式输出：\n\n * "a->b" ，如果 a != b\n * "a" ，如果 a == b\n\n \n\n示例 1：\n\n\n输入：nums = [0,1,2,4,5,7]\n输出：["0->2","4->5","7"]\n解释：区间范围是：\n[0,2] --\x3e "0->2"\n[4,5] --\x3e "4->5"\n[7,7] --\x3e "7"\n\n\n示例 2：\n\n\n输入：nums = [0,2,3,4,6,8,9]\n输出：["0","2->4","6","8->9"]\n解释：区间范围是：\n[0,0] --\x3e "0"\n[2,4] --\x3e "2->4"\n[6,6] --\x3e "6"\n[8,9] --\x3e "8->9"\n\n\n示例 3：\n\n\n输入：nums = []\n输出：[]\n\n\n示例 4：\n\n\n输入：nums = [-1]\n输出：["-1"]\n\n\n示例 5：\n\n\n输入：nums = [0]\n输出：["0"]\n\n\n \n\n提示：\n\n * 0 <= nums.length <= 20\n * -231 <= nums[i] <= 231 - 1\n * nums 中的所有值都 互不相同\n * nums 按升序排列\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode229 Majority Element II-zh",frontmatter:{title:"leetcode229 Majority Element II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/ff53b7/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode229 Majority Element II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10229.leetcode229%20Majority%20Element%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode229 Majority Element II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10229.leetcode229%20Majority%20Element%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode229 Majority Element II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10229.leetcode229%20Majority%20Element%20II-zh.html",relativePath:"01.算法/24.leetcode/10229.leetcode229 Majority Element II-zh.md",key:"v-6971653e",path:"/p/ff53b7/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:293},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:300},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:319},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:335}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 229. 求众数 II\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。\n\n进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。\n\n \n\n示例 1：\n\n\n输入：[3,2,3]\n输出：[3]\n\n示例 2：\n\n\n输入：nums = [1]\n输出：[1]\n\n\n示例 3：\n\n\n输入：[1,1,1,3,3,2,2,2]\n输出：[1,2]\n\n \n\n提示：\n\n * 1 <= nums.length <= 5 * 104\n * -109 <= nums[i] <= 109\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 229. 求众数 ii\n\nenglish version\n\n\n# 题目描述\n\n给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。\n\n进阶：尝试设计时间复杂度为 o(n)、空间复杂度为 o(1)的算法解决此问题。\n\n \n\n示例 1：\n\n\n输入：[3,2,3]\n输出：[3]\n\n示例 2：\n\n\n输入：nums = [1]\n输出：[1]\n\n\n示例 3：\n\n\n输入：[1,1,1,3,3,2,2,2]\n输出：[1,2]\n\n \n\n提示：\n\n * 1 <= nums.length <= 5 * 104\n * -109 <= nums[i] <= 109\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode230 Kth Smallest Element in a BST-zh",frontmatter:{title:"leetcode230 Kth Smallest Element in a BST-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/2a0744/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0230.Kth%20Smallest%20Element%20in%20a%20BST/images/kthtree1.jpg"},{name:"twitter:title",content:"leetcode230 Kth Smallest Element in a BST-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0230.Kth%20Smallest%20Element%20in%20a%20BST/images/kthtree1.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10230.leetcode230%20Kth%20Smallest%20Element%20in%20a%20BST-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode230 Kth Smallest Element in a BST-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0230.Kth%20Smallest%20Element%20in%20a%20BST/images/kthtree1.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10230.leetcode230%20Kth%20Smallest%20Element%20in%20a%20BST-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode230 Kth Smallest Element in a BST-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0230.Kth%20Smallest%20Element%20in%20a%20BST/images/kthtree1.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10230.leetcode230%20Kth%20Smallest%20Element%20in%20a%20BST-zh.html",relativePath:"01.算法/24.leetcode/10230.leetcode230 Kth Smallest Element in a BST-zh.md",key:"v-d21c602e",path:"/p/2a0744/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:41},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:348},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:355},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1006},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1906}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 230. 二叉搜索树中第K小的元素\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。\n\n \n\n示例 1：\n\n\n输入：root = [3,1,4,null,2], k = 1\n输出：1\n\n\n示例 2：\n\n\n输入：root = [5,3,6,2,4,null,null,1], k = 3\n输出：3\n\n\n \n\n \n\n提示：\n\n * 树中的节点数为 n 。\n * 1 <= k <= n <= 104\n * 0 <= Node.val <= 104\n\n \n\n进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.k -= 1\n            if self.k == 0:\n                self.res = root.val\n                return\n            inorder(root.right)\n        self.k = k\n        inorder(root)\n        return self.res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int k;\n    private int res;\n\n    public int kthSmallest(TreeNode root, int k) {\n        this.k = k;\n        inorder(root);\n        return res;\n    }\n\n    private void inorder(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        inorder(root.left);\n        if (--k == 0) {\n            res = root.val;\n            return;\n        }\n        inorder(root.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 230. 二叉搜索树中第k小的元素\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。\n\n \n\n示例 1：\n\n\n输入：root = [3,1,4,null,2], k = 1\n输出：1\n\n\n示例 2：\n\n\n输入：root = [5,3,6,2,4,null,null,1], k = 3\n输出：3\n\n\n \n\n \n\n提示：\n\n * 树中的节点数为 n 。\n * 1 <= k <= n <= 104\n * 0 <= node.val <= 104\n\n \n\n进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def kthsmallest(self, root: treenode, k: int) -> int:\n        def inorder(root):\n            if root is none:\n                return\n            inorder(root.left)\n            self.k -= 1\n            if self.k == 0:\n                self.res = root.val\n                return\n            inorder(root.right)\n        self.k = k\n        inorder(root)\n        return self.res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    private int k;\n    private int res;\n\n    public int kthsmallest(treenode root, int k) {\n        this.k = k;\n        inorder(root);\n        return res;\n    }\n\n    private void inorder(treenode root) {\n        if (root == null) {\n            return;\n        }\n        inorder(root.left);\n        if (--k == 0) {\n            res = root.val;\n            return;\n        }\n        inorder(root.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode231 Power of Two-zh",frontmatter:{title:"leetcode231 Power of Two-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/1952f3/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode231 Power of Two-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10231.leetcode231%20Power%20of%20Two-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode231 Power of Two-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10231.leetcode231%20Power%20of%20Two-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode231 Power of Two-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10231.leetcode231%20Power%20of%20Two-zh.html",relativePath:"01.算法/24.leetcode/10231.leetcode231 Power of Two-zh.md",key:"v-713df3aa",path:"/p/1952f3/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:168},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:175},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:301},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:434},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:567},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:726},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:816},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:926}],headersStr:"题目描述 解法 Python3 Java C++ JavaScript Go TypeScript ...",content:"# 231. 2 的幂\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数，编写一个函数来判断它是否是 2 的幂次方。\n\n示例 1:\n\n输入: 1\n输出: true\n解释: 20 = 1\n\n示例 2:\n\n输入: 16\n输出: true\n解释: 24 = 16\n\n示例 3:\n\n输入: 218\n输出: false\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0\n\n\n1\n2\n3\n\n\n\n# Java\n\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# C++\n\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# JavaScript\n\n/**\n * @param {number} n\n * @return {boolean}\n */\nvar isPowerOfTwo = function(n) {\n    return n > 0 && (n & (n - 1)) == 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Go\n\nfunc isPowerOfTwo(n int) bool {\n    return n > 0 && (n & (n - 1)) == 0\n}\n\n\n1\n2\n3\n\n\n\n# TypeScript\n\nfunction isPowerOfTwo(n: number): boolean {\n  return n > 0 && (n & (n - 1)) == 0;\n};\n\n\n1\n2\n3\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 231. 2 的幂\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数，编写一个函数来判断它是否是 2 的幂次方。\n\n示例 1:\n\n输入: 1\n输出: true\n解释: 20 = 1\n\n示例 2:\n\n输入: 16\n输出: true\n解释: 24 = 16\n\n示例 3:\n\n输入: 218\n输出: false\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def ispoweroftwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0\n\n\n1\n2\n3\n\n\n\n# java\n\nclass solution {\n    public boolean ispoweroftwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# c++\n\nclass solution {\npublic:\n    bool ispoweroftwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# javascript\n\n/**\n * @param {number} n\n * @return {boolean}\n */\nvar ispoweroftwo = function(n) {\n    return n > 0 && (n & (n - 1)) == 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# go\n\nfunc ispoweroftwo(n int) bool {\n    return n > 0 && (n & (n - 1)) == 0\n}\n\n\n1\n2\n3\n\n\n\n# typescript\n\nfunction ispoweroftwo(n: number): boolean {\n  return n > 0 && (n & (n - 1)) == 0;\n};\n\n\n1\n2\n3\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode232 Implement Queue using Stacks-zh",frontmatter:{title:"leetcode232 Implement Queue using Stacks-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/9f96da/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode232 Implement Queue using Stacks-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10232.leetcode232%20Implement%20Queue%20using%20Stacks-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode232 Implement Queue using Stacks-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10232.leetcode232%20Implement%20Queue%20using%20Stacks-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode232 Implement Queue using Stacks-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10232.leetcode232%20Implement%20Queue%20using%20Stacks-zh.html",relativePath:"01.算法/24.leetcode/10232.leetcode232 Implement Queue using Stacks-zh.md",key:"v-614e421a",path:"/p/9f96da/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:967},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:974},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2246},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3501}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 232. 用栈实现队列\n\nEnglish Version\n\n\n# 题目描述\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 MyQueue 类：\n\n * void push(int x) 将元素 x 推到队列的末尾\n * int pop() 从队列的开头移除并返回元素\n * int peek() 返回队列开头的元素\n * boolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n \n\n说明：\n\n * 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n * 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n进阶：\n\n * 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\n\n \n\n示例：\n\n\n输入：\n["MyQueue", "push", "push", "peek", "pop", "empty"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\n \n\n提示：\n\n * 1 <= x <= 9\n * 最多调用 100 次 push、pop、peek 和 empty\n * 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n\n\n# 解法\n\n\n# Python3\n\nclass MyQueue:\n\n    def __init__(self):\n        """\n        Initialize your data structure here.\n        """\n        self.s1 = []\n        self.s2 = []\n\n\n    def push(self, x: int) -> None:\n        """\n        Push element x to the back of queue.\n        """\n        self.s1.append(x)\n\n\n    def pop(self) -> int:\n        """\n        Removes the element from in front of queue and returns that element.\n        """\n        self._move()\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        """\n        Get the front element.\n        """\n        self._move()\n        return self.s2[-1]\n\n\n    def empty(self) -> bool:\n        """\n        Returns whether the queue is empty.\n        """\n        return len(self.s1) + len(self.s2) == 0\n\n\n    def _move(self):\n        """\n        Move elements from s1 to s2.\n        """\n        if len(self.s2) == 0:\n            while len(self.s1) > 0:\n                self.s2.append(self.s1.pop())\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# Java\n\nclass MyQueue {\n\n    private Deque<Integer> s1 = new ArrayDeque<>();\n    private Deque<Integer> s2 = new ArrayDeque<>();\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        s1.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        move();\n        return s2.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        move();\n        return s2.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return s1.isEmpty() && s2.isEmpty();\n    }\n\n    /** Move elements from s1 to s2. */\n    private void move() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 232. 用栈实现队列\n\nenglish version\n\n\n# 题目描述\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 myqueue 类：\n\n * void push(int x) 将元素 x 推到队列的末尾\n * int pop() 从队列的开头移除并返回元素\n * int peek() 返回队列开头的元素\n * boolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n \n\n说明：\n\n * 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n * 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n进阶：\n\n * 你能否实现每个操作均摊时间复杂度为 o(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 o(n) ，即使其中一个操作可能花费较长时间。\n\n \n\n示例：\n\n\n输入：\n["myqueue", "push", "push", "peek", "pop", "empty"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nmyqueue myqueue = new myqueue();\nmyqueue.push(1); // queue is: [1]\nmyqueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyqueue.peek(); // return 1\nmyqueue.pop(); // return 1, queue is [2]\nmyqueue.empty(); // return false\n\n\n \n\n提示：\n\n * 1 <= x <= 9\n * 最多调用 100 次 push、pop、peek 和 empty\n * 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n\n\n# 解法\n\n\n# python3\n\nclass myqueue:\n\n    def __init__(self):\n        """\n        initialize your data structure here.\n        """\n        self.s1 = []\n        self.s2 = []\n\n\n    def push(self, x: int) -> none:\n        """\n        push element x to the back of queue.\n        """\n        self.s1.append(x)\n\n\n    def pop(self) -> int:\n        """\n        removes the element from in front of queue and returns that element.\n        """\n        self._move()\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        """\n        get the front element.\n        """\n        self._move()\n        return self.s2[-1]\n\n\n    def empty(self) -> bool:\n        """\n        returns whether the queue is empty.\n        """\n        return len(self.s1) + len(self.s2) == 0\n\n\n    def _move(self):\n        """\n        move elements from s1 to s2.\n        """\n        if len(self.s2) == 0:\n            while len(self.s1) > 0:\n                self.s2.append(self.s1.pop())\n\n\n# your myqueue object will be instantiated and called as such:\n# obj = myqueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# java\n\nclass myqueue {\n\n    private deque<integer> s1 = new arraydeque<>();\n    private deque<integer> s2 = new arraydeque<>();\n\n    /** initialize your data structure here. */\n    public myqueue() {\n\n    }\n\n    /** push element x to the back of queue. */\n    public void push(int x) {\n        s1.push(x);\n    }\n\n    /** removes the element from in front of queue and returns that element. */\n    public int pop() {\n        move();\n        return s2.pop();\n    }\n\n    /** get the front element. */\n    public int peek() {\n        move();\n        return s2.peek();\n    }\n\n    /** returns whether the queue is empty. */\n    public boolean empty() {\n        return s1.isempty() && s2.isempty();\n    }\n\n    /** move elements from s1 to s2. */\n    private void move() {\n        if (s2.isempty()) {\n            while (!s1.isempty()) {\n                s2.push(s1.pop());\n            }\n        }\n    }\n}\n\n/**\n * your myqueue object will be instantiated and called as such:\n * myqueue obj = new myqueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode104 Maximum Depth of Binary Tree-zh",frontmatter:{title:"leetcode104 Maximum Depth of Binary Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/df42dd/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode104 Maximum Depth of Binary Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10104.leetcode104%20Maximum%20Depth%20of%20Binary%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode104 Maximum Depth of Binary Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10104.leetcode104%20Maximum%20Depth%20of%20Binary%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode104 Maximum Depth of Binary Tree-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10104.leetcode104%20Maximum%20Depth%20of%20Binary%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10104.leetcode104 Maximum Depth of Binary Tree-zh.md",key:"v-5cebfd60",path:"/p/df42dd/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:206},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:241},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:692},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1336},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1571}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 104. 二叉树的最大深度\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。\n\n\n# 解法\n\n递归遍历左右子树，求左右子树的最大深度 +1 即可。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        l = self.maxDepth(root.left)\n        r = self.maxDepth(root.right)\n        return 1 + max(l, r)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        int l = maxDepth(root.left);\n        int r = maxDepth(root.right);\n        return 1 + Math.max(l, r);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        int l = maxDepth(root->left);\n        int r = maxDepth(root->right);\n        return max(l, r) + 1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 104. 二叉树的最大深度\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。\n\n\n# 解法\n\n递归遍历左右子树，求左右子树的最大深度 +1 即可。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def maxdepth(self, root: treenode) -> int:\n        if root is none:\n            return 0\n        l = self.maxdepth(root.left)\n        r = self.maxdepth(root.right)\n        return 1 + max(l, r)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public int maxdepth(treenode root) {\n        if (root == null) return 0;\n        int l = maxdepth(root.left);\n        int r = maxdepth(root.right);\n        return 1 + math.max(l, r);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# c++\n\nclass solution {\npublic:\n    int maxdepth(treenode* root) {\n        if (!root) return 0;\n        int l = maxdepth(root->left);\n        int r = maxdepth(root->right);\n        return max(l, r) + 1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode234 Palindrome Linked List-zh",frontmatter:{title:"leetcode234 Palindrome Linked List-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fe43a3/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode234 Palindrome Linked List-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10234.leetcode234%20Palindrome%20Linked%20List-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode234 Palindrome Linked List-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10234.leetcode234%20Palindrome%20Linked%20List-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode234 Palindrome Linked List-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10234.leetcode234%20Palindrome%20Linked%20List-zh.html",relativePath:"01.算法/24.leetcode/10234.leetcode234 Palindrome Linked List-zh.md",key:"v-4a789dac",path:"/p/fe43a3/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:157},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:240},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1008},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2180},{level:3,title:"C#",slug:"c",normalizedTitle:"c#",charIndex:3124},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:4351},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:5463}],headersStr:"题目描述 解法 Python3 Java JavaScript C# TypeScript ...",content:"# 234. 回文链表\n\nEnglish Version\n\n\n# 题目描述\n\n请判断一个链表是否为回文链表。\n\n示例 1:\n\n输入: 1->2\n输出: false\n\n示例 2:\n\n输入: 1->2->2->1\n输出: true\n\n\n进阶：\n你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n\n\n# 解法\n\n先用快慢指针找到链表的中点，接着反转右半部分的链表。然后同时遍历前后两段链表，若前后两段链表节点对应的值不等，说明不是回文链表，否则说明是回文链表。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def isPalindrome(self, head: ListNode) -> bool:\n        if head is None or head.next is None:\n            return True\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        pre, cur = None, slow.next\n        while cur:\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        while pre:\n            if pre.val != head.val:\n                return False\n            pre, head = pre.next, head.next\n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) {\n            return true;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode cur = slow.next;\n        slow.next = null;\n        ListNode pre = null;\n        while (cur != null) {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        while (pre != null) {\n            if (pre.val != head.val) {\n                return false;\n            }\n            pre = pre.next;\n            head = head.next;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar isPalindrome = function(head) {\n    if (!head || !head.next) {\n        return true;\n    }\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let cur = slow.next;\n    slow.next = null;\n    let pre = null;\n    while (cur) {\n        let t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    while (pre) {\n        if (pre.val !== head.val) {\n            return false;\n        }\n        pre = pre.next;\n        head = head.next;\n    }\n    return true;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# C#\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsPalindrome(ListNode head) {\n        if (head == null || head.next == null)\n        {\n            return true;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode cur = slow.next;\n        slow.next = null;\n        ListNode pre = null;\n        while (cur != null)\n        {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        while (pre != null)\n        {\n            if (pre.val != head.val)\n            {\n                return false;\n            }\n            pre = pre.next;\n            head = head.next;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# TypeScript\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction isPalindrome(head: ListNode | null): boolean {\n    if (head == null || head.next == null) return true;\n    // 快慢指针定位到中点\n    let slow: ListNode = head, fast: ListNode = head.next;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    // 翻转链表\n    let cur: ListNode = slow.next;\n    slow.next = null;\n    let prev: ListNode = null;\n    while (cur != null) {\n        let t: ListNode = cur.next;\n        cur.next = prev;\n        prev = cur;\n        cur = t;\n    }\n    // 判断回文\n    while (prev != null) {\n        if (prev.val != head.val) return false;\n        prev = prev.next;\n        head = head.next;\n    }\n    return true;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 234. 回文链表\n\nenglish version\n\n\n# 题目描述\n\n请判断一个链表是否为回文链表。\n\n示例 1:\n\n输入: 1->2\n输出: false\n\n示例 2:\n\n输入: 1->2->2->1\n输出: true\n\n\n进阶：\n你能否用 o(n) 时间复杂度和 o(1) 空间复杂度解决此题？\n\n\n# 解法\n\n先用快慢指针找到链表的中点，接着反转右半部分的链表。然后同时遍历前后两段链表，若前后两段链表节点对应的值不等，说明不是回文链表，否则说明是回文链表。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def ispalindrome(self, head: listnode) -> bool:\n        if head is none or head.next is none:\n            return true\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        pre, cur = none, slow.next\n        while cur:\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        while pre:\n            if pre.val != head.val:\n                return false\n            pre, head = pre.next, head.next\n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public boolean ispalindrome(listnode head) {\n        if (head == null || head.next == null) {\n            return true;\n        }\n        listnode slow = head;\n        listnode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        listnode cur = slow.next;\n        slow.next = null;\n        listnode pre = null;\n        while (cur != null) {\n            listnode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        while (pre != null) {\n            if (pre.val != head.val) {\n                return false;\n            }\n            pre = pre.next;\n            head = head.next;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {boolean}\n */\nvar ispalindrome = function(head) {\n    if (!head || !head.next) {\n        return true;\n    }\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let cur = slow.next;\n    slow.next = null;\n    let pre = null;\n    while (cur) {\n        let t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    while (pre) {\n        if (pre.val !== head.val) {\n            return false;\n        }\n        pre = pre.next;\n        head = head.next;\n    }\n    return true;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# c#\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     public int val;\n *     public listnode next;\n *     public listnode(int val=0, listnode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class solution {\n    public bool ispalindrome(listnode head) {\n        if (head == null || head.next == null)\n        {\n            return true;\n        }\n        listnode slow = head;\n        listnode fast = head.next;\n        while (fast != null && fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        listnode cur = slow.next;\n        slow.next = null;\n        listnode pre = null;\n        while (cur != null)\n        {\n            listnode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        while (pre != null)\n        {\n            if (pre.val != head.val)\n            {\n                return false;\n            }\n            pre = pre.next;\n            head = head.next;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# typescript\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     val: number\n *     next: listnode | null\n *     constructor(val?: number, next?: listnode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction ispalindrome(head: listnode | null): boolean {\n    if (head == null || head.next == null) return true;\n    // 快慢指针定位到中点\n    let slow: listnode = head, fast: listnode = head.next;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    // 翻转链表\n    let cur: listnode = slow.next;\n    slow.next = null;\n    let prev: listnode = null;\n    while (cur != null) {\n        let t: listnode = cur.next;\n        cur.next = prev;\n        prev = cur;\n        cur = t;\n    }\n    // 判断回文\n    while (prev != null) {\n        if (prev.val != head.val) return false;\n        prev = prev.next;\n        head = head.next;\n    }\n    return true;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode235 Lowest Common Ancestor of a Binary Search Tree-zh",frontmatter:{title:"leetcode235 Lowest Common Ancestor of a Binary Search Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/82740a/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/images/binarysearchtree_improved.png"},{name:"twitter:title",content:"leetcode235 Lowest Common Ancestor of a Binary Search Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/images/binarysearchtree_improved.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10235.leetcode235%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode235 Lowest Common Ancestor of a Binary Search Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/images/binarysearchtree_improved.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10235.leetcode235%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode235 Lowest Common Ancestor of a Binary Search Tree-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/images/binarysearchtree_improved.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10235.leetcode235%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10235.leetcode235 Lowest Common Ancestor of a Binary Search Tree-zh.md",key:"v-42a65f8d",path:"/p/82740a/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:41},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:506},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:564},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1763},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2947}],headersStr:"题目描述 解法 Python3 Java Go",content:"# 235. 二叉搜索树的最近公共祖先\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]\n\n\n\n \n\n示例 1:\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n\n\n示例 2:\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n\n \n\n说明:\n\n * 所有节点的值都是唯一的。\n * p、q 为不同节点且均存在于给定的二叉搜索树中。\n\n\n# 解法\n\n从上到下搜索，找到第一个值位于 [p, q] 之间的结点即可。既可以用迭代实现，也可以用递归实现。\n\n\n# Python3\n\n迭代：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if root.val < p.val and root.val < q.val:\n                root = root.right\n            elif root.val > p.val and root.val > q.val:\n                root = root.left\n            else:\n                return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n递归：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        if root is None:\n            return None\n        if root.val < p.val and root.val < q.val:\n            return self.lowestCommonAncestor(root.right, p, q)\n        if root.val > p.val and root.val > q.val:\n            return self.lowestCommonAncestor(root.left, p, q)\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Java\n\n迭代：\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        while (root != null) {\n            if (root.val < p.val && root.val < q.val) root = root.right;\n            else if (root.val > p.val && root.val > q.val) root = root.left;\n            else return root;\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n递归：\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null) return null;\n        if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\n        if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Go\n\n迭代：\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val   int\n *     Left  *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n\tfor root != nil {\n\t\t// 如果 p、q 的值都小于 root，说明 p、q 肯定在 root 的左子树中；\n\t\t// 如果 p、q 都大于 root，说明肯定在 root 的右子树中；\n\t\t// 如果一个在左一个在右，则说明此时的 root 记为对应的最近公共祖先。\n\t\tif root.Val > p.Val && root.Val > q.Val {\n\t\t\troot = root.Left\n\t\t} else if root.Val < p.Val && root.Val < q.Val {\n\t\t\troot = root.Right\n\t\t} else {\n\t\t\treturn root\n\t\t}\n\t}\n\treturn nil\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n递归：\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val   int\n *     Left  *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    if root == nil {\n        return root\n    }\n    if root.Val < p.Val && root.Val < q.Val {\n        return lowestCommonAncestor(root.Right, p, q)\n    }\n    if root.Val > p.Val && root.Val > q.Val {\n        return lowestCommonAncestor(root.Left, p, q)\n    }\n    return root\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# 235. 二叉搜索树的最近公共祖先\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 t 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]\n\n\n\n \n\n示例 1:\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n\n\n示例 2:\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n\n \n\n说明:\n\n * 所有节点的值都是唯一的。\n * p、q 为不同节点且均存在于给定的二叉搜索树中。\n\n\n# 解法\n\n从上到下搜索，找到第一个值位于 [p, q] 之间的结点即可。既可以用迭代实现，也可以用递归实现。\n\n\n# python3\n\n迭代：\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def lowestcommonancestor(self, root: 'treenode', p: 'treenode', q: 'treenode') -> 'treenode':\n        while root:\n            if root.val < p.val and root.val < q.val:\n                root = root.right\n            elif root.val > p.val and root.val > q.val:\n                root = root.left\n            else:\n                return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n递归：\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def lowestcommonancestor(self, root: 'treenode', p: 'treenode', q: 'treenode') -> 'treenode':\n        if root is none:\n            return none\n        if root.val < p.val and root.val < q.val:\n            return self.lowestcommonancestor(root.right, p, q)\n        if root.val > p.val and root.val > q.val:\n            return self.lowestcommonancestor(root.left, p, q)\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# java\n\n迭代：\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\n\nclass solution {\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n        while (root != null) {\n            if (root.val < p.val && root.val < q.val) root = root.right;\n            else if (root.val > p.val && root.val > q.val) root = root.left;\n            else return root;\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n递归：\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\n\nclass solution {\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n        if (root == null) return null;\n        if (root.val < p.val && root.val < q.val) return lowestcommonancestor(root.right, p, q);\n        if (root.val > p.val && root.val > q.val) return lowestcommonancestor(root.left, p, q);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# go\n\n迭代：\n\n/**\n * definition for a binary tree node.\n * type treenode struct {\n *     val   int\n *     left  *treenode\n *     right *treenode\n * }\n */\n\nfunc lowestcommonancestor(root, p, q *treenode) *treenode {\n\tfor root != nil {\n\t\t// 如果 p、q 的值都小于 root，说明 p、q 肯定在 root 的左子树中；\n\t\t// 如果 p、q 都大于 root，说明肯定在 root 的右子树中；\n\t\t// 如果一个在左一个在右，则说明此时的 root 记为对应的最近公共祖先。\n\t\tif root.val > p.val && root.val > q.val {\n\t\t\troot = root.left\n\t\t} else if root.val < p.val && root.val < q.val {\n\t\t\troot = root.right\n\t\t} else {\n\t\t\treturn root\n\t\t}\n\t}\n\treturn nil\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n递归：\n\n/**\n * definition for a binary tree node.\n * type treenode struct {\n *     val   int\n *     left  *treenode\n *     right *treenode\n * }\n */\n\nfunc lowestcommonancestor(root, p, q *treenode) *treenode {\n    if root == nil {\n        return root\n    }\n    if root.val < p.val && root.val < q.val {\n        return lowestcommonancestor(root.right, p, q)\n    }\n    if root.val > p.val && root.val > q.val {\n        return lowestcommonancestor(root.left, p, q)\n    }\n    return root\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode236 Lowest Common Ancestor of a Binary Tree-zh",frontmatter:{title:"leetcode236 Lowest Common Ancestor of a Binary Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/cd43df/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0236.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/images/binarytree.png"},{name:"twitter:title",content:"leetcode236 Lowest Common Ancestor of a Binary Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0236.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/images/binarytree.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10236.leetcode236%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode236 Lowest Common Ancestor of a Binary Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0236.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/images/binarytree.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10236.leetcode236%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode236 Lowest Common Ancestor of a Binary Tree-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0236.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/images/binarytree.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10236.leetcode236%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10236.leetcode236 Lowest Common Ancestor of a Binary Tree-zh.md",key:"v-3c52b6c0",path:"/p/cd43df/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:555},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:1027},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1678},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2315},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2915}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 236. 二叉树的最近公共祖先\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n \n\n示例 1：\n\n\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n\n\n示例 2：\n\n\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n\n\n示例 3：\n\n\n输入：root = [1,2], p = 1, q = 2\n输出：1\n\n\n \n\n提示：\n\n * 树中节点数目在范围 [2, 105] 内。\n * -109 <= Node.val <= 109\n * 所有 Node.val 互不相同 。\n * p != q\n * p 和 q 均存在于给定的二叉树中。\n\n\n# 解法\n\n根据“最近公共祖先”的定义，若 root 是 p, q 的最近公共祖先 ，则只可能为以下情况之一：\n\n * 如果 p 和 q 分别是 root 的左右节点，那么 root 就是我们要找的最近公共祖先；\n * 如果 p 和 q 都是 root 的左节点，那么返回 lowestCommonAncestor(root.left, p, q)；\n * 如果 p 和 q 都是 root 的右节点，那么返回 lowestCommonAncestor(root.right, p, q)。\n\n边界条件讨论：\n\n * 如果 root 为 null，则说明我们已经找到最底了，返回 null 表示没找到；\n * 如果 root 与 p 相等或者与 q 相等，则返回 root；\n * 如果左子树没找到，递归函数返回 null，证明 p 和 q 同在 root 的右侧，那么最终的公共祖先就是右子树找到的结点；\n * 如果右子树没找到，递归函数返回 null，证明 p 和 q 同在 root 的左侧，那么最终的公共祖先就是左子树找到的结点。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        if root is None or root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if left is None:\n            return right\n        if right is None:\n            return left\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) return root;\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left == null) return right;\n        if (right == null) return left;\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# JavaScript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function (root, p, q) {\n  if (!root || root == p || root == q) return root;\n  const left = lowestCommonAncestor(root.left, p, q);\n  const right = lowestCommonAncestor(root.right, p, q);\n  if (!left) return right;\n  if (!right) return left;\n  return root;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 236. 二叉树的最近公共祖先\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 t 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n \n\n示例 1：\n\n\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n\n\n示例 2：\n\n\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n\n\n示例 3：\n\n\n输入：root = [1,2], p = 1, q = 2\n输出：1\n\n\n \n\n提示：\n\n * 树中节点数目在范围 [2, 105] 内。\n * -109 <= node.val <= 109\n * 所有 node.val 互不相同 。\n * p != q\n * p 和 q 均存在于给定的二叉树中。\n\n\n# 解法\n\n根据“最近公共祖先”的定义，若 root 是 p, q 的最近公共祖先 ，则只可能为以下情况之一：\n\n * 如果 p 和 q 分别是 root 的左右节点，那么 root 就是我们要找的最近公共祖先；\n * 如果 p 和 q 都是 root 的左节点，那么返回 lowestcommonancestor(root.left, p, q)；\n * 如果 p 和 q 都是 root 的右节点，那么返回 lowestcommonancestor(root.right, p, q)。\n\n边界条件讨论：\n\n * 如果 root 为 null，则说明我们已经找到最底了，返回 null 表示没找到；\n * 如果 root 与 p 相等或者与 q 相等，则返回 root；\n * 如果左子树没找到，递归函数返回 null，证明 p 和 q 同在 root 的右侧，那么最终的公共祖先就是右子树找到的结点；\n * 如果右子树没找到，递归函数返回 null，证明 p 和 q 同在 root 的左侧，那么最终的公共祖先就是左子树找到的结点。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def lowestcommonancestor(self, root: 'treenode', p: 'treenode', q: 'treenode') -> 'treenode':\n        if root is none or root == p or root == q:\n            return root\n        left = self.lowestcommonancestor(root.left, p, q)\n        right = self.lowestcommonancestor(root.right, p, q)\n        if left is none:\n            return right\n        if right is none:\n            return left\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n        if (root == null || root == p || root == q) return root;\n        treenode left = lowestcommonancestor(root.left, p, q);\n        treenode right = lowestcommonancestor(root.right, p, q);\n        if (left == null) return right;\n        if (right == null) return left;\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# javascript\n\n/**\n * definition for a binary tree node.\n * function treenode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {treenode} root\n * @param {treenode} p\n * @param {treenode} q\n * @return {treenode}\n */\nvar lowestcommonancestor = function (root, p, q) {\n  if (!root || root == p || root == q) return root;\n  const left = lowestcommonancestor(root.left, p, q);\n  const right = lowestcommonancestor(root.right, p, q);\n  if (!left) return right;\n  if (!right) return left;\n  return root;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode237 Delete Node in a Linked List-zh",frontmatter:{title:"leetcode237 Delete Node in a Linked List-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/be8ce1/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0237.Delete%20Node%20in%20a%20Linked%20List/images/237_example.png"},{name:"twitter:title",content:"leetcode237 Delete Node in a Linked List-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0237.Delete%20Node%20in%20a%20Linked%20List/images/237_example.png"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10237.leetcode237%20Delete%20Node%20in%20a%20Linked%20List-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode237 Delete Node in a Linked List-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0237.Delete%20Node%20in%20a%20Linked%20List/images/237_example.png"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10237.leetcode237%20Delete%20Node%20in%20a%20Linked%20List-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode237 Delete Node in a Linked List-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0237.Delete%20Node%20in%20a%20Linked%20List/images/237_example.png"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10237.leetcode237%20Delete%20Node%20in%20a%20Linked%20List-zh.html",relativePath:"01.算法/24.leetcode/10237.leetcode237 Delete Node in a Linked List-zh.md",key:"v-d7a396b2",path:"/p/be8ce1/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:443},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:510},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:938},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1275},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1659},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1904}],headersStr:"题目描述 解法 Python3 Java JavaScript Go C++",content:'# 237. 删除链表中的节点\n\nEnglish Version\n\n\n# 题目描述\n\n请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。\n\n \n\n现有一个链表 -- head = [4,5,1,9]，它可以表示为:\n\n\n\n \n\n示例 1：\n\n输入：head = [4,5,1,9], node = 5\n输出：[4,1,9]\n解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n\n\n示例 2：\n\n输入：head = [4,5,1,9], node = 1\n输出：[4,5,9]\n解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n\n\n \n\n提示：\n\n * 链表至少包含两个节点。\n * 链表中所有节点的值都是唯一的。\n * 给定的节点为非末尾节点并且一定是链表中的一个有效节点。\n * 不要从你的函数中返回任何结果。\n\n\n# 解法\n\n将 node.next 节点的值赋给 node，然后将 node.next 指向 node.next 的下一个节点。\n\n\n# Python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def deleteNode(self, node):\n        """\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        """\n        node.val = node.next.val\n        node.next = node.next.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void deleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} node\n * @return {void} Do not return anything, modify node in-place instead.\n */\nvar deleteNode = function (node) {\n  node.val = node.next.val;\n  node.next = node.next.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc deleteNode(node *ListNode) {\n    node.Val = node.Next.Val\n    node.Next = node.Next.Next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# C++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node->val = node->next->val;\n        node->next = node->next->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'# 237. 删除链表中的节点\n\nenglish version\n\n\n# 题目描述\n\n请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。\n\n \n\n现有一个链表 -- head = [4,5,1,9]，它可以表示为:\n\n\n\n \n\n示例 1：\n\n输入：head = [4,5,1,9], node = 5\n输出：[4,1,9]\n解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n\n\n示例 2：\n\n输入：head = [4,5,1,9], node = 1\n输出：[4,5,9]\n解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n\n\n \n\n提示：\n\n * 链表至少包含两个节点。\n * 链表中所有节点的值都是唯一的。\n * 给定的节点为非末尾节点并且一定是链表中的一个有效节点。\n * 不要从你的函数中返回任何结果。\n\n\n# 解法\n\n将 node.next 节点的值赋给 node，然后将 node.next 指向 node.next 的下一个节点。\n\n\n# python3\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def deletenode(self, node):\n        """\n        :type node: listnode\n        :rtype: void do not return anything, modify node in-place instead.\n        """\n        node.val = node.next.val\n        node.next = node.next.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# java\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public void deletenode(listnode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {listnode} node\n * @return {void} do not return anything, modify node in-place instead.\n */\nvar deletenode = function (node) {\n  node.val = node.next.val;\n  node.next = node.next.next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# go\n\n/**\n * definition for singly-linked list.\n * type listnode struct {\n *     val int\n *     next *listnode\n * }\n */\nfunc deletenode(node *listnode) {\n    node.val = node.next.val\n    node.next = node.next.next\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# c++\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode(int x) : val(x), next(null) {}\n * };\n */\nclass solution {\npublic:\n    void deletenode(listnode* node) {\n        node->val = node->next->val;\n        node->next = node->next->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode238 Product of Array Except Self-zh",frontmatter:{title:"leetcode238 Product of Array Except Self-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/7eb89b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode238 Product of Array Except Self-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10238.leetcode238%20Product%20of%20Array%20Except%20Self-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode238 Product of Array Except Self-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10238.leetcode238%20Product%20of%20Array%20Except%20Self-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode238 Product of Array Except Self-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10238.leetcode238%20Product%20of%20Array%20Except%20Self-zh.html",relativePath:"01.算法/24.leetcode/10238.leetcode238 Product of Array Except Self-zh.md",key:"v-2cae356c",path:"/p/7eb89b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:323},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:330},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:739},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1192},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1612}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 238. 除自身以外数组的乘积\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n\n \n\n示例:\n\n输入: [1,2,3,4]\n输出: [24,12,8,6]\n\n \n\n提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。\n\n说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。\n\n进阶：\n你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        output = [1 for _ in nums]\n        left = right = 1\n        for i in range(n):\n            output[i] = left\n            left *= nums[i]\n        for i in range(n - 1, -1, -1):\n            output[i] *= right\n            right *= nums[i]\n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int[] output = new int[n];\n        for (int i = 0, left = 1; i < n; ++i) {\n            output[i] = left;\n            left *= nums[i];\n        }\n        for (int i = n - 1, right = 1; i >= 0; --i) {\n            output[i] *= right;\n            right *= nums[i];\n        }\n        return output;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function (nums) {\n  const n = nums.length;\n  let output = new Array(n);\n  for (let i = 0, left = 1; i < n; ++i) {\n    output[i] = left;\n    left *= nums[i];\n  }\n  for (let i = n - 1, right = 1; i >= 0; --i) {\n    output[i] *= right;\n    right *= nums[i];\n  }\n  return output;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 238. 除自身以外数组的乘积\n\nenglish version\n\n\n# 题目描述\n\n给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n\n \n\n示例:\n\n输入: [1,2,3,4]\n输出: [24,12,8,6]\n\n \n\n提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。\n\n说明: 请不要使用除法，且在 o(n) 时间复杂度内完成此题。\n\n进阶：\n你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def productexceptself(self, nums: list[int]) -> list[int]:\n        n = len(nums)\n        output = [1 for _ in nums]\n        left = right = 1\n        for i in range(n):\n            output[i] = left\n            left *= nums[i]\n        for i in range(n - 1, -1, -1):\n            output[i] *= right\n            right *= nums[i]\n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public int[] productexceptself(int[] nums) {\n        int n = nums.length;\n        int[] output = new int[n];\n        for (int i = 0, left = 1; i < n; ++i) {\n            output[i] = left;\n            left *= nums[i];\n        }\n        for (int i = n - 1, right = 1; i >= 0; --i) {\n            output[i] *= right;\n            right *= nums[i];\n        }\n        return output;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productexceptself = function (nums) {\n  const n = nums.length;\n  let output = new array(n);\n  for (let i = 0, left = 1; i < n; ++i) {\n    output[i] = left;\n    left *= nums[i];\n  }\n  for (let i = n - 1, right = 1; i >= 0; --i) {\n    output[i] *= right;\n    right *= nums[i];\n  }\n  return output;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode239 Sliding Window Maximum-zh",frontmatter:{title:"leetcode239 Sliding Window Maximum-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/624423/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode239 Sliding Window Maximum-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10239.leetcode239%20Sliding%20Window%20Maximum-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode239 Sliding Window Maximum-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10239.leetcode239%20Sliding%20Window%20Maximum-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode239 Sliding Window Maximum-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10239.leetcode239%20Sliding%20Window%20Maximum-zh.html",relativePath:"01.算法/24.leetcode/10239.leetcode239 Sliding Window Maximum-zh.md",key:"v-2ceda1ea",path:"/p/624423/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:729},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:736},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:755},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:771},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1526}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 239. 滑动窗口最大值\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口中的最大值。\n\n \n\n示例 1：\n\n\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\n\n示例 2：\n\n\n输入：nums = [1], k = 1\n输出：[1]\n\n\n示例 3：\n\n\n输入：nums = [1,-1], k = 1\n输出：[1,-1]\n\n\n示例 4：\n\n\n输入：nums = [9,11], k = 2\n输出：[11]\n\n\n示例 5：\n\n\n输入：nums = [4,-2], k = 2\n输出：[4]\n\n \n\n提示：\n\n * 1 <= nums.length <= 105\n * -104 <= nums[i] <= 104\n * 1 <= k <= nums.length\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function (nums, k) {\n    let len = nums.length;\n    if (len < k) return [];\n    let res = [], win = [];\n    for (let i = 0; i < k; i++) {\n        while (win.length > 0 && nums[i] >= nums[win[win.length - 1]])\n            win.pop();\n        win.push(i);\n    }\n    res.push(nums[win[0]]);\n    for (let i = k; i < len; i++) {\n        while (win.length > 0 && nums[i] >= nums[win[win.length - 1]])\n            win.pop();\n        if (win.length > 0 && win[0] < i - k + 1)\n            win.shift();\n        win.push(i);\n        res.push(nums[win[0]]);\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 239. 滑动窗口最大值\n\nenglish version\n\n\n# 题目描述\n\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口中的最大值。\n\n \n\n示例 1：\n\n\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\n\n示例 2：\n\n\n输入：nums = [1], k = 1\n输出：[1]\n\n\n示例 3：\n\n\n输入：nums = [1,-1], k = 1\n输出：[1,-1]\n\n\n示例 4：\n\n\n输入：nums = [9,11], k = 2\n输出：[11]\n\n\n示例 5：\n\n\n输入：nums = [4,-2], k = 2\n输出：[4]\n\n \n\n提示：\n\n * 1 <= nums.length <= 105\n * -104 <= nums[i] <= 104\n * 1 <= k <= nums.length\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxslidingwindow = function (nums, k) {\n    let len = nums.length;\n    if (len < k) return [];\n    let res = [], win = [];\n    for (let i = 0; i < k; i++) {\n        while (win.length > 0 && nums[i] >= nums[win[win.length - 1]])\n            win.pop();\n        win.push(i);\n    }\n    res.push(nums[win[0]]);\n    for (let i = k; i < len; i++) {\n        while (win.length > 0 && nums[i] >= nums[win[win.length - 1]])\n            win.pop();\n        if (win.length > 0 && win[0] < i - k + 1)\n            win.shift();\n        win.push(i);\n        res.push(nums[win[0]]);\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode240 Search a 2D Matrix II-zh",frontmatter:{title:"leetcode240 Search a 2D Matrix II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b02c03/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0240.Search%20a%202D%20Matrix%20II/images/searchgrid2.jpg"},{name:"twitter:title",content:"leetcode240 Search a 2D Matrix II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0240.Search%20a%202D%20Matrix%20II/images/searchgrid2.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10240.leetcode240%20Search%20a%202D%20Matrix%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode240 Search a 2D Matrix II-zh"},{property:"og:description",content:"English Version"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0240.Search%20a%202D%20Matrix%20II/images/searchgrid2.jpg"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10240.leetcode240%20Search%20a%202D%20Matrix%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode240 Search a 2D Matrix II-zh"},{itemprop:"description",content:"English Version"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0240.Search%20a%202D%20Matrix%20II/images/searchgrid2.jpg"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10240.leetcode240%20Search%20a%202D%20Matrix%20II-zh.html",relativePath:"01.算法/24.leetcode/10240.leetcode240 Search a 2D Matrix II-zh.md",key:"v-4b5829a4",path:"/p/b02c03/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:555},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:581},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1003},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:1497},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1911},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2419},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2721}],headersStr:"题目描述 解法 Python3 Java TypeScript C++ Go ...",content:"# 240. 搜索二维矩阵 II\n\nEnglish Version\n\n\n# 题目描述\n\n编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n\n * 每行的元素从左到右升序排列。\n * 每列的元素从上到下升序排列。\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n输出：true\n\n\n示例 2：\n\n\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n输出：false\n\n\n \n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= n, m <= 300\n * -109 <= matix[i][j] <= 109\n * 每行的所有元素从左到右升序排列\n * 每列的所有元素从上到下升序排列\n * -109 <= target <= 109\n\n\n# 解法\n\n从左下角（或右上角）开始查找即可。\n\n\n# Python3\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        i, j = m - 1, 0\n        while i >= 0 and j < n:\n            if matrix[i][j] == target:\n                return True\n            if matrix[i][j] > target:\n                i -= 1\n            else:\n                j += 1\n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length, n = matrix[0].length;\n        int i = m - 1, j = 0;\n        while (i >= 0 && j < n) {\n            if (matrix[i][j] == target) {\n                return true;\n            }\n            if (matrix[i][j] > target) {\n                --i;\n            } else {\n                ++j;\n            }\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# TypeScript\n\nfunction searchMatrix(matrix: number[][], target: number): boolean {\n    let m = matrix.length, n = matrix[0].length;\n    let i = m - 1, j = 0;\n    while (i >= 0 && j < n) {\n        let cur = matrix[i][j];\n        if (cur == target) return true;\n        if (cur > target) {\n            --i;\n        } else {\n            ++j;\n        }\n    }\n    return false;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# C++\n\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(), n = matrix[0].size();\n        int i = m - 1, j = 0;\n        while (i >= 0 && j < n) {\n            if (matrix[i][j] == target) {\n                return true;\n            }\n            if (matrix[i][j] > target) {\n                --i;\n            } else {\n                ++j;\n            }\n        }\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Go\n\nfunc searchMatrix(matrix [][]int, target int) bool {\n\tm, n := len(matrix), len(matrix[0])\n\ti, j := m-1, 0\n\tfor i >= 0 && j < n {\n\t\tif matrix[i][j] == target {\n\t\t\treturn true\n\t\t}\n\t\tif matrix[i][j] > target {\n\t\t\ti--\n\t\t} else {\n\t\t\tj++\n\t\t}\n\t}\n\treturn false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 240. 搜索二维矩阵 ii\n\nenglish version\n\n\n# 题目描述\n\n编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n\n * 每行的元素从左到右升序排列。\n * 每列的元素从上到下升序排列。\n\n \n\n示例 1：\n\n\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n输出：true\n\n\n示例 2：\n\n\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n输出：false\n\n\n \n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= n, m <= 300\n * -109 <= matix[i][j] <= 109\n * 每行的所有元素从左到右升序排列\n * 每列的所有元素从上到下升序排列\n * -109 <= target <= 109\n\n\n# 解法\n\n从左下角（或右上角）开始查找即可。\n\n\n# python3\n\nclass solution:\n    def searchmatrix(self, matrix: list[list[int]], target: int) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        i, j = m - 1, 0\n        while i >= 0 and j < n:\n            if matrix[i][j] == target:\n                return true\n            if matrix[i][j] > target:\n                i -= 1\n            else:\n                j += 1\n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public boolean searchmatrix(int[][] matrix, int target) {\n        int m = matrix.length, n = matrix[0].length;\n        int i = m - 1, j = 0;\n        while (i >= 0 && j < n) {\n            if (matrix[i][j] == target) {\n                return true;\n            }\n            if (matrix[i][j] > target) {\n                --i;\n            } else {\n                ++j;\n            }\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# typescript\n\nfunction searchmatrix(matrix: number[][], target: number): boolean {\n    let m = matrix.length, n = matrix[0].length;\n    let i = m - 1, j = 0;\n    while (i >= 0 && j < n) {\n        let cur = matrix[i][j];\n        if (cur == target) return true;\n        if (cur > target) {\n            --i;\n        } else {\n            ++j;\n        }\n    }\n    return false;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# c++\n\nclass solution {\npublic:\n    bool searchmatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(), n = matrix[0].size();\n        int i = m - 1, j = 0;\n        while (i >= 0 && j < n) {\n            if (matrix[i][j] == target) {\n                return true;\n            }\n            if (matrix[i][j] > target) {\n                --i;\n            } else {\n                ++j;\n            }\n        }\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# go\n\nfunc searchmatrix(matrix [][]int, target int) bool {\n\tm, n := len(matrix), len(matrix[0])\n\ti, j := m-1, 0\n\tfor i >= 0 && j < n {\n\t\tif matrix[i][j] == target {\n\t\t\treturn true\n\t\t}\n\t\tif matrix[i][j] > target {\n\t\t\ti--\n\t\t} else {\n\t\t\tj++\n\t\t}\n\t}\n\treturn false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode241 Different Ways to Add Parentheses-zh",frontmatter:{title:"leetcode241 Different Ways to Add Parentheses-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/f642d4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode241 Different Ways to Add Parentheses-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10241.leetcode241%20Different%20Ways%20to%20Add%20Parentheses-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode241 Different Ways to Add Parentheses-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10241.leetcode241%20Different%20Ways%20to%20Add%20Parentheses-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode241 Different Ways to Add Parentheses-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10241.leetcode241%20Different%20Ways%20to%20Add%20Parentheses-zh.html",relativePath:"01.算法/24.leetcode/10241.leetcode241 Different Ways to Add Parentheses-zh.md",key:"v-3665f0bc",path:"/p/f642d4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:40},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:355},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:362},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:381},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:397}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 241. 为运算表达式设计优先级\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n示例 1:\n\n输入: "2-1-1"\n输出: [0, 2]\n解释: \n((2-1)-1) = 0 \n(2-(1-1)) = 2\n\n示例 2:\n\n输入: "2*3-4*5"\n输出: [-34, -14, -10, -10, 10]\n解释: \n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 241. 为运算表达式设计优先级\n\nenglish version\n\n\n# 题目描述\n\n给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n示例 1:\n\n输入: "2-1-1"\n输出: [0, 2]\n解释: \n((2-1)-1) = 0 \n(2-(1-1)) = 2\n\n示例 2:\n\n输入: "2*3-4*5"\n输出: [-34, -14, -10, -10, 10]\n解释: \n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode243 Shortest Word Distance-zh",frontmatter:{title:"leetcode243 Shortest Word Distance-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/3e55e4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode243 Shortest Word Distance-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10243.leetcode243%20Shortest%20Word%20Distance-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode243 Shortest Word Distance-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10243.leetcode243%20Shortest%20Word%20Distance-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode243 Shortest Word Distance-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10243.leetcode243%20Shortest%20Word%20Distance-zh.html",relativePath:"01.算法/24.leetcode/10243.leetcode243 Shortest Word Distance-zh.md",key:"v-1e5f7a6c",path:"/p/3e55e4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:307},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:401},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:917},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1551}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 243. 最短单词距离\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个单词列表和两个单词 word1 和 word2，返回列表中这两个单词之间的最短距离。\n\n示例:\n假设 words = ["practice", "makes", "perfect", "coding", "makes"]\n\n输入: word1 = “coding”, word2 = “practice”\n输出: 3\n\n\n输入: word1 = "makes", word2 = "coding"\n输出: 1\n\n\n注意:\n你可以假设 word1 不等于 word2, 并且 word1 和 word2 都在列表里。\n\n\n# 解法\n\n用两个指针 i1, i2 保存 word1 和 word2 最近出现的位置，然后每次计算距离 Math.abs(i1 - i2) 是否比此前的记录更小，是则更新最短距离。\n\n\n# Python3\n\nclass Solution:\n    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:\n        i1 = i2 = -1\n        shortest_distance = len(wordsDict)\n        for i in range(len(wordsDict)):\n            if wordsDict[i] == word1:\n                i1 = i\n            elif wordsDict[i] == word2:\n                i2 = i\n            if i1 != -1 and i2 != -1:\n                shortest_distance = min(shortest_distance, abs(i1 - i2))\n        return shortest_distance\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Java\n\nclass Solution {\n    public int shortestDistance(String[] wordsDict, String word1, String word2) {\n        int i1 = -1, i2 = -1;\n        int shortestDistance = wordsDict.length;\n        for (int i = 0; i < wordsDict.length; ++i) {\n            if (word1.equals(wordsDict[i])) {\n                i1 = i;\n            } else if (word2.equals(wordsDict[i])) {\n                i2 = i;\n            }\n            if (i1 != -1 && i2 != -1) {\n                shortestDistance = Math.min(shortestDistance, Math.abs(i1 - i2));\n            }\n        }\n        return shortestDistance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 243. 最短单词距离\n\nenglish version\n\n\n# 题目描述\n\n给定一个单词列表和两个单词 word1 和 word2，返回列表中这两个单词之间的最短距离。\n\n示例:\n假设 words = ["practice", "makes", "perfect", "coding", "makes"]\n\n输入: word1 = “coding”, word2 = “practice”\n输出: 3\n\n\n输入: word1 = "makes", word2 = "coding"\n输出: 1\n\n\n注意:\n你可以假设 word1 不等于 word2, 并且 word1 和 word2 都在列表里。\n\n\n# 解法\n\n用两个指针 i1, i2 保存 word1 和 word2 最近出现的位置，然后每次计算距离 math.abs(i1 - i2) 是否比此前的记录更小，是则更新最短距离。\n\n\n# python3\n\nclass solution:\n    def shortestdistance(self, wordsdict: list[str], word1: str, word2: str) -> int:\n        i1 = i2 = -1\n        shortest_distance = len(wordsdict)\n        for i in range(len(wordsdict)):\n            if wordsdict[i] == word1:\n                i1 = i\n            elif wordsdict[i] == word2:\n                i2 = i\n            if i1 != -1 and i2 != -1:\n                shortest_distance = min(shortest_distance, abs(i1 - i2))\n        return shortest_distance\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# java\n\nclass solution {\n    public int shortestdistance(string[] wordsdict, string word1, string word2) {\n        int i1 = -1, i2 = -1;\n        int shortestdistance = wordsdict.length;\n        for (int i = 0; i < wordsdict.length; ++i) {\n            if (word1.equals(wordsdict[i])) {\n                i1 = i;\n            } else if (word2.equals(wordsdict[i])) {\n                i2 = i;\n            }\n            if (i1 != -1 && i2 != -1) {\n                shortestdistance = math.min(shortestdistance, math.abs(i1 - i2));\n            }\n        }\n        return shortestdistance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode242 Valid Anagram-zh",frontmatter:{title:"leetcode242 Valid Anagram-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/989be3/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode242 Valid Anagram-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10242.leetcode242%20Valid%20Anagram-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode242 Valid Anagram-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10242.leetcode242%20Valid%20Anagram-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode242 Valid Anagram-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10242.leetcode242%20Valid%20Anagram-zh.html",relativePath:"01.算法/24.leetcode/10242.leetcode242 Valid Anagram-zh.md",key:"v-b7d5d7be",path:"/p/989be3/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:236},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:266},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:699},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:1243},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:1625},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:2141},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2453}],headersStr:"题目描述 解法 Python3 Java TypeScript C++ Go ...",content:"# 242. 有效的字母异位词\n\nEnglish Version\n\n\n# 题目描述\n\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n\n示例 1:\n\n输入: s = \"anagram\", t = \"nagaram\"\n输出: true\n\n\n示例 2:\n\n输入: s = \"rat\", t = \"car\"\n输出: false\n\n说明:\n你可以假设字符串只包含小写字母。\n\n进阶:\n如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n\n\n# 解法\n\n哈希表解决。\n\n\n# Python3\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        n = len(s)\n        chars = [0] * 26\n        for i in range(n):\n            chars[ord(s[i]) - ord('a')] += 1\n            chars[ord(t[i]) - ord('a')] -= 1\n        for i in range(26):\n            if chars[i] != 0:\n                return False\n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        int n;\n        if ((n = s.length()) != t.length()) {\n            return false;\n        }\n        int[] chars = new int[26];\n        for (int i = 0; i < n; ++i) {\n            ++chars[s.charAt(i) - 'a'];\n            --chars[t.charAt(i) - 'a'];\n        }\n        for (int i = 0; i < 26; ++i) {\n            if (chars[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# TypeScript\n\nfunction isAnagram(s: string, t: string): boolean {\n    if (s.length != t.length) return false;\n    let record = new Array(26).fill(0);\n    let base = 'a'.charCodeAt(0);\n    for (let i = 0; i < s.length; ++i) {\n        ++record[s.charCodeAt(i) - base];\n        --record[t.charCodeAt(i) - base];\n    }\n    return record.every(v => v == 0);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# C++\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) {\n            return false;\n        }\n        vector<int> chars(26, 0);\n        for (int i = 0, n = s.size(); i < n; ++i) {\n            ++chars[s[i] - 'a'];\n            --chars[t[i] - 'a'];\n        }\n        for (int i = 0; i < 26; ++i) {\n            if (chars[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Go\n\nfunc isAnagram(s string, t string) bool {\n\tif len(s) != len(t) {\n\t\treturn false\n\t}\n\tvar chars [26]int\n\tfor i := 0; i < len(s); i++ {\n\t\tchars[s[i]-'a']++\n\t\tchars[t[i]-'a']--\n\t}\n\tfor i := 0; i < 26; i++ {\n\t\tif chars[i] != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 242. 有效的字母异位词\n\nenglish version\n\n\n# 题目描述\n\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n\n示例 1:\n\n输入: s = \"anagram\", t = \"nagaram\"\n输出: true\n\n\n示例 2:\n\n输入: s = \"rat\", t = \"car\"\n输出: false\n\n说明:\n你可以假设字符串只包含小写字母。\n\n进阶:\n如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n\n\n# 解法\n\n哈希表解决。\n\n\n# python3\n\nclass solution:\n    def isanagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return false\n        n = len(s)\n        chars = [0] * 26\n        for i in range(n):\n            chars[ord(s[i]) - ord('a')] += 1\n            chars[ord(t[i]) - ord('a')] -= 1\n        for i in range(26):\n            if chars[i] != 0:\n                return false\n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\nclass solution {\n    public boolean isanagram(string s, string t) {\n        int n;\n        if ((n = s.length()) != t.length()) {\n            return false;\n        }\n        int[] chars = new int[26];\n        for (int i = 0; i < n; ++i) {\n            ++chars[s.charat(i) - 'a'];\n            --chars[t.charat(i) - 'a'];\n        }\n        for (int i = 0; i < 26; ++i) {\n            if (chars[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# typescript\n\nfunction isanagram(s: string, t: string): boolean {\n    if (s.length != t.length) return false;\n    let record = new array(26).fill(0);\n    let base = 'a'.charcodeat(0);\n    for (let i = 0; i < s.length; ++i) {\n        ++record[s.charcodeat(i) - base];\n        --record[t.charcodeat(i) - base];\n    }\n    return record.every(v => v == 0);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# c++\n\nclass solution {\npublic:\n    bool isanagram(string s, string t) {\n        if (s.size() != t.size()) {\n            return false;\n        }\n        vector<int> chars(26, 0);\n        for (int i = 0, n = s.size(); i < n; ++i) {\n            ++chars[s[i] - 'a'];\n            --chars[t[i] - 'a'];\n        }\n        for (int i = 0; i < 26; ++i) {\n            if (chars[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# go\n\nfunc isanagram(s string, t string) bool {\n\tif len(s) != len(t) {\n\t\treturn false\n\t}\n\tvar chars [26]int\n\tfor i := 0; i < len(s); i++ {\n\t\tchars[s[i]-'a']++\n\t\tchars[t[i]-'a']--\n\t}\n\tfor i := 0; i < 26; i++ {\n\t\tif chars[i] != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode244 Shortest Word Distance II-zh",frontmatter:{title:"leetcode244 Shortest Word Distance II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/174423/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode244 Shortest Word Distance II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10244.leetcode244%20Shortest%20Word%20Distance%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode244 Shortest Word Distance II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10244.leetcode244%20Shortest%20Word%20Distance%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode244 Shortest Word Distance II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10244.leetcode244%20Shortest%20Word%20Distance%20II-zh.html",relativePath:"01.算法/24.leetcode/10244.leetcode244 Shortest Word Distance II-zh.md",key:"v-34b8b412",path:"/p/174423/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:364},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:371},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1282},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2492}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 244. 最短单词距离 II\n\nEnglish Version\n\n\n# 题目描述\n\n请设计一个类，使该类的构造函数能够接收一个单词列表。然后再实现一个方法，该方法能够分别接收两个单词 word1 和 word2，并返回列表中这两个单词之间的最短距离。您的方法将被以不同的参数调用 多次。\n\n示例:\n假设 words = ["practice", "makes", "perfect", "coding", "makes"]\n\n输入: word1 = “coding”, word2 = “practice”\n输出: 3\n\n\n输入: word1 = "makes", word2 = "coding"\n输出: 1\n\n注意:\n你可以假设 word1 不等于 word2, 并且 word1 和 word2 都在列表里。\n\n\n# 解法\n\n\n# Python3\n\nclass WordDistance:\n\n    def __init__(self, wordsDict: List[str]):\n        self.words = {}\n        for i, word in enumerate(wordsDict):\n            indexes = self.words.get(word, [])\n            indexes.append(i)\n            self.words[word] = indexes\n\n    def shortest(self, word1: str, word2: str) -> int:\n        idx1, idx2 = self.words[word1], self.words[word2]\n        i1 = i2 = 0\n        shortest = float(\'inf\')\n        while i1 < len(idx1) and i2 < len(idx2):\n            shortest = min(shortest, abs(idx1[i1] - idx2[i2]))\n            smaller = idx1[i1] < idx2[i2]\n            if smaller:\n                i1 += 1\n            else:\n                i2 += 1\n        return shortest\n\n\n# Your WordDistance object will be instantiated and called as such:\n# obj = WordDistance(wordsDict)\n# param_1 = obj.shortest(word1,word2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java\n\nclass WordDistance {\n    private Map<String, List<Integer>> words;\n\n    public WordDistance(String[] wordsDict) {\n        words = new HashMap<>();\n        for (int i = 0; i < wordsDict.length; ++i) {\n            List<Integer> indexes = words.getOrDefault(wordsDict[i], new ArrayList<>());\n            indexes.add(i);\n            words.put(wordsDict[i], indexes);\n        }\n    }\n\n    public int shortest(String word1, String word2) {\n        List<Integer> idx1 = words.get(word1);\n        List<Integer> idx2 = words.get(word2);\n        int i1 = 0, i2 = 0, shortest = Integer.MAX_VALUE;\n        while (i1 < idx1.size() && i2 < idx2.size()) {\n            shortest = Math.min(shortest, Math.abs(idx1.get(i1) - idx2.get(i2)));\n            boolean smaller = idx1.get(i1) < idx2.get(i2);\n            if (smaller) {\n                ++i1;\n            } else {\n                ++i2;\n            }\n        }\n        return shortest;\n    }\n}\n\n/**\n * Your WordDistance object will be instantiated and called as such:\n * WordDistance obj = new WordDistance(wordsDict);\n * int param_1 = obj.shortest(word1,word2);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 244. 最短单词距离 ii\n\nenglish version\n\n\n# 题目描述\n\n请设计一个类，使该类的构造函数能够接收一个单词列表。然后再实现一个方法，该方法能够分别接收两个单词 word1 和 word2，并返回列表中这两个单词之间的最短距离。您的方法将被以不同的参数调用 多次。\n\n示例:\n假设 words = ["practice", "makes", "perfect", "coding", "makes"]\n\n输入: word1 = “coding”, word2 = “practice”\n输出: 3\n\n\n输入: word1 = "makes", word2 = "coding"\n输出: 1\n\n注意:\n你可以假设 word1 不等于 word2, 并且 word1 和 word2 都在列表里。\n\n\n# 解法\n\n\n# python3\n\nclass worddistance:\n\n    def __init__(self, wordsdict: list[str]):\n        self.words = {}\n        for i, word in enumerate(wordsdict):\n            indexes = self.words.get(word, [])\n            indexes.append(i)\n            self.words[word] = indexes\n\n    def shortest(self, word1: str, word2: str) -> int:\n        idx1, idx2 = self.words[word1], self.words[word2]\n        i1 = i2 = 0\n        shortest = float(\'inf\')\n        while i1 < len(idx1) and i2 < len(idx2):\n            shortest = min(shortest, abs(idx1[i1] - idx2[i2]))\n            smaller = idx1[i1] < idx2[i2]\n            if smaller:\n                i1 += 1\n            else:\n                i2 += 1\n        return shortest\n\n\n# your worddistance object will be instantiated and called as such:\n# obj = worddistance(wordsdict)\n# param_1 = obj.shortest(word1,word2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java\n\nclass worddistance {\n    private map<string, list<integer>> words;\n\n    public worddistance(string[] wordsdict) {\n        words = new hashmap<>();\n        for (int i = 0; i < wordsdict.length; ++i) {\n            list<integer> indexes = words.getordefault(wordsdict[i], new arraylist<>());\n            indexes.add(i);\n            words.put(wordsdict[i], indexes);\n        }\n    }\n\n    public int shortest(string word1, string word2) {\n        list<integer> idx1 = words.get(word1);\n        list<integer> idx2 = words.get(word2);\n        int i1 = 0, i2 = 0, shortest = integer.max_value;\n        while (i1 < idx1.size() && i2 < idx2.size()) {\n            shortest = math.min(shortest, math.abs(idx1.get(i1) - idx2.get(i2)));\n            boolean smaller = idx1.get(i1) < idx2.get(i2);\n            if (smaller) {\n                ++i1;\n            } else {\n                ++i2;\n            }\n        }\n        return shortest;\n    }\n}\n\n/**\n * your worddistance object will be instantiated and called as such:\n * worddistance obj = new worddistance(wordsdict);\n * int param_1 = obj.shortest(word1,word2);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode245 Shortest Word Distance III-zh",frontmatter:{title:"leetcode245 Shortest Word Distance III-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/940bbd/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode245 Shortest Word Distance III-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10245.leetcode245%20Shortest%20Word%20Distance%20III-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode245 Shortest Word Distance III-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10245.leetcode245%20Shortest%20Word%20Distance%20III-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode245 Shortest Word Distance III-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10245.leetcode245%20Shortest%20Word%20Distance%20III-zh.html",relativePath:"01.算法/24.leetcode/10245.leetcode245 Shortest Word Distance III-zh.md",key:"v-15f36787",path:"/p/940bbd/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:39},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:333},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:340},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1149},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2199}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 245. 最短单词距离 III\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个单词列表和两个单词 word1 和 word2，返回列表中这两个单词之间的最短距离。\n\nword1 和 word2 是有可能相同的，并且它们将分别表示为列表中两个独立的单词。\n\n示例:\n假设 words = ["practice", "makes", "perfect", "coding", "makes"].\n\n输入: word1 = “makes”, word2 = “coding”\n输出: 1\n\n\n输入: word1 = "makes", word2 = "makes"\n输出: 3\n\n\n注意:\n你可以假设 word1 和 word2 都在列表里。\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:\n        i1 = i2 = -1\n        shortest_distance = len(wordsDict)\n        same = word1 == word2\n        for i in range(len(wordsDict)):\n            if same:\n                if word1 == wordsDict[i]:\n                    if i1 != -1:\n                        shortest_distance = min(shortest_distance, i - i1)\n                    i1 = i\n            else:\n                if word1 == wordsDict[i]:\n                    i1 = i\n                if word2 == wordsDict[i]:\n                    i2 = i\n                if i1 != -1 and i2 != -1:\n                    shortest_distance = min(shortest_distance, abs(i1 - i2))\n        return shortest_distance\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Java\n\nclass Solution {\n    public int shortestWordDistance(String[] wordsDict, String word1, String word2) {\n        int i1 = -1, i2 = -1;\n        int shortestDistance = wordsDict.length;\n        boolean same = word1.equals(word2);\n        for (int i = 0; i < wordsDict.length; ++i) {\n            if (same) {\n                if (word1.equals(wordsDict[i])) {\n                    if (i1 != -1) {\n                        shortestDistance = Math.min(shortestDistance, i - i1);\n                    }\n                    i1 = i;\n                }\n            } else {\n                if (word1.equals(wordsDict[i])) {\n                    i1 = i;\n                }\n                if (word2.equals(wordsDict[i])) {\n                    i2 = i;\n                }\n                if (i1 != -1 && i2 != -1) {\n                    shortestDistance = Math.min(shortestDistance, Math.abs(i1 - i2));\n                }\n            }\n        }\n        return shortestDistance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 245. 最短单词距离 iii\n\nenglish version\n\n\n# 题目描述\n\n给定一个单词列表和两个单词 word1 和 word2，返回列表中这两个单词之间的最短距离。\n\nword1 和 word2 是有可能相同的，并且它们将分别表示为列表中两个独立的单词。\n\n示例:\n假设 words = ["practice", "makes", "perfect", "coding", "makes"].\n\n输入: word1 = “makes”, word2 = “coding”\n输出: 1\n\n\n输入: word1 = "makes", word2 = "makes"\n输出: 3\n\n\n注意:\n你可以假设 word1 和 word2 都在列表里。\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def shortestworddistance(self, wordsdict: list[str], word1: str, word2: str) -> int:\n        i1 = i2 = -1\n        shortest_distance = len(wordsdict)\n        same = word1 == word2\n        for i in range(len(wordsdict)):\n            if same:\n                if word1 == wordsdict[i]:\n                    if i1 != -1:\n                        shortest_distance = min(shortest_distance, i - i1)\n                    i1 = i\n            else:\n                if word1 == wordsdict[i]:\n                    i1 = i\n                if word2 == wordsdict[i]:\n                    i2 = i\n                if i1 != -1 and i2 != -1:\n                    shortest_distance = min(shortest_distance, abs(i1 - i2))\n        return shortest_distance\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# java\n\nclass solution {\n    public int shortestworddistance(string[] wordsdict, string word1, string word2) {\n        int i1 = -1, i2 = -1;\n        int shortestdistance = wordsdict.length;\n        boolean same = word1.equals(word2);\n        for (int i = 0; i < wordsdict.length; ++i) {\n            if (same) {\n                if (word1.equals(wordsdict[i])) {\n                    if (i1 != -1) {\n                        shortestdistance = math.min(shortestdistance, i - i1);\n                    }\n                    i1 = i;\n                }\n            } else {\n                if (word1.equals(wordsdict[i])) {\n                    i1 = i;\n                }\n                if (word2.equals(wordsdict[i])) {\n                    i2 = i;\n                }\n                if (i1 != -1 && i2 != -1) {\n                    shortestdistance = math.min(shortestdistance, math.abs(i1 - i2));\n                }\n            }\n        }\n        return shortestdistance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode246 Strobogrammatic Number-zh",frontmatter:{title:"leetcode246 Strobogrammatic Number-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d1ea39/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode246 Strobogrammatic Number-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10246.leetcode246%20Strobogrammatic%20Number-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode246 Strobogrammatic Number-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10246.leetcode246%20Strobogrammatic%20Number-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode246 Strobogrammatic Number-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10246.leetcode246%20Strobogrammatic%20Number-zh.html",relativePath:"01.算法/24.leetcode/10246.leetcode246 Strobogrammatic Number-zh.md",key:"v-0a109a26",path:"/p/d1ea39/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:264},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:271},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:826},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1502}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 246. 中心对称数\n\nEnglish Version\n\n\n# 题目描述\n\n中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。\n\n请写一个函数来判断该数字是否是中心对称数，其输入将会以一个字符串的形式来表达数字。\n\n \n\n示例 1:\n\n输入: num = \"69\"\n输出: true\n\n\n示例 2:\n\n输入: num = \"88\"\n输出: true\n\n示例 3:\n\n输入: num = \"962\"\n输出: false\n\n示例 4：\n\n输入：num = \"1\"\n输出：true\n\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def isStrobogrammatic(self, num: str) -> bool:\n        def match(a, b):\n            if a in {'0', '1', '8'}:\n                return a == b\n            if a == '6':\n                return b == '9'\n            if a == '9':\n                return b == '6'\n            return False\n        n = len(num)\n        i, j = 0, n - 1\n        while i <= j:\n            if not match(num[i], num[j]):\n                return False\n            i += 1\n            j -= 1\n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Java\n\nclass Solution {\n    public boolean isStrobogrammatic(String num) {\n        int n = num.length();\n        for (int i = 0, j = n - 1; i <= j; ++i, --j) {\n            if (!match(num.charAt(i), num.charAt(j))) return false;\n        }\n        return true;\n    }\n\n    private boolean match(char a, char b) {\n        switch (a) {\n            case '0':\n            case '1':\n            case '8':\n                return a == b;\n            case '6':\n                return b == '9';\n            case '9':\n                return b == '6';\n            default:\n                return false;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 246. 中心对称数\n\nenglish version\n\n\n# 题目描述\n\n中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。\n\n请写一个函数来判断该数字是否是中心对称数，其输入将会以一个字符串的形式来表达数字。\n\n \n\n示例 1:\n\n输入: num = \"69\"\n输出: true\n\n\n示例 2:\n\n输入: num = \"88\"\n输出: true\n\n示例 3:\n\n输入: num = \"962\"\n输出: false\n\n示例 4：\n\n输入：num = \"1\"\n输出：true\n\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def isstrobogrammatic(self, num: str) -> bool:\n        def match(a, b):\n            if a in {'0', '1', '8'}:\n                return a == b\n            if a == '6':\n                return b == '9'\n            if a == '9':\n                return b == '6'\n            return false\n        n = len(num)\n        i, j = 0, n - 1\n        while i <= j:\n            if not match(num[i], num[j]):\n                return false\n            i += 1\n            j -= 1\n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# java\n\nclass solution {\n    public boolean isstrobogrammatic(string num) {\n        int n = num.length();\n        for (int i = 0, j = n - 1; i <= j; ++i, --j) {\n            if (!match(num.charat(i), num.charat(j))) return false;\n        }\n        return true;\n    }\n\n    private boolean match(char a, char b) {\n        switch (a) {\n            case '0':\n            case '1':\n            case '8':\n                return a == b;\n            case '6':\n                return b == '9';\n            case '9':\n                return b == '6';\n            default:\n                return false;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode247 Strobogrammatic Number II-zh",frontmatter:{title:"leetcode247 Strobogrammatic Number II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/74a94a/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode247 Strobogrammatic Number II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10247.leetcode247%20Strobogrammatic%20Number%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode247 Strobogrammatic Number II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10247.leetcode247%20Strobogrammatic%20Number%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode247 Strobogrammatic Number II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10247.leetcode247%20Strobogrammatic%20Number%20II-zh.html",relativePath:"01.算法/24.leetcode/10247.leetcode247 Strobogrammatic Number II-zh.md",key:"v-5d80cac8",path:"/p/74a94a/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:156},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:163},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:182},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:198}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 247. 中心对称数 II\n\nEnglish Version\n\n\n# 题目描述\n\n中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。\n\n找到所有长度为 n 的中心对称数。\n\n示例 :\n\n输入:  n = 2\n输出: ["11","69","88","96"]\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 247. 中心对称数 ii\n\nenglish version\n\n\n# 题目描述\n\n中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。\n\n找到所有长度为 n 的中心对称数。\n\n示例 :\n\n输入:  n = 2\n输出: ["11","69","88","96"]\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode248 Strobogrammatic Number III-zh",frontmatter:{title:"leetcode248 Strobogrammatic Number III-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/858535/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode248 Strobogrammatic Number III-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10248.leetcode248%20Strobogrammatic%20Number%20III-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode248 Strobogrammatic Number III-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10248.leetcode248%20Strobogrammatic%20Number%20III-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode248 Strobogrammatic Number III-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10248.leetcode248%20Strobogrammatic%20Number%20III-zh.html",relativePath:"01.算法/24.leetcode/10248.leetcode248 Strobogrammatic Number III-zh.md",key:"v-105f262a",path:"/p/858535/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:38},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:239},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:246},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:265},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:281}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 248. 中心对称数 III\n\nEnglish Version\n\n\n# 题目描述\n\n中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。\n\n写一个函数来计算范围在 [low, high] 之间中心对称数的个数。\n\n示例:\n\n输入: low = "50", high = "100"\n输出: 3 \n解释: 69，88 和 96 是三个在该范围内的中心对称数\n\n注意:\n由于范围可能很大，所以 low 和 high 都用字符串表示。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 248. 中心对称数 iii\n\nenglish version\n\n\n# 题目描述\n\n中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。\n\n写一个函数来计算范围在 [low, high] 之间中心对称数的个数。\n\n示例:\n\n输入: low = "50", high = "100"\n输出: 3 \n解释: 69，88 和 96 是三个在该范围内的中心对称数\n\n注意:\n由于范围可能很大，所以 low 和 high 都用字符串表示。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode249 Group Shifted Strings-zh",frontmatter:{title:"leetcode249 Group Shifted Strings-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/9740b7/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode249 Group Shifted Strings-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10249.leetcode249%20Group%20Shifted%20Strings-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode249 Group Shifted Strings-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10249.leetcode249%20Group%20Shifted%20Strings-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode249 Group Shifted Strings-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10249.leetcode249%20Group%20Shifted%20Strings-zh.html",relativePath:"01.算法/24.leetcode/10249.leetcode249 Group Shifted Strings-zh.md",key:"v-19d98050",path:"/p/9740b7/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:427},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:434},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:453},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:165}],headersStr:"题目描述 解法 Python3 Java ...",content:'# 249. 移位字符串分组\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个字符串，对该字符串可以进行 “移位” 的操作，也就是将字符串中每个字母都变为其在字母表中后续的字母，比如："abc" -> "bcd"。这样，我们可以持续进行 “移位” 操作，从而生成如下移位序列：\n\n"abc" -> "bcd" -> ... -> "xyz"\n\n给定一个包含仅小写字母字符串的列表，将该列表中所有满足 “移位” 操作规律的组合进行分组并返回。\n\n \n\n示例：\n\n输入：["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]\n输出：\n[\n  ["abc","bcd","xyz"],\n  ["az","ba"],\n  ["acef"],\n  ["a","z"]\n]\n解释：可以认为字母表首尾相接，所以 \'z\' 的后续为 \'a\'，所以 ["az","ba"] 也满足 “移位” 操作规律。\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 249. 移位字符串分组\n\nenglish version\n\n\n# 题目描述\n\n给定一个字符串，对该字符串可以进行 “移位” 的操作，也就是将字符串中每个字母都变为其在字母表中后续的字母，比如："abc" -> "bcd"。这样，我们可以持续进行 “移位” 操作，从而生成如下移位序列：\n\n"abc" -> "bcd" -> ... -> "xyz"\n\n给定一个包含仅小写字母字符串的列表，将该列表中所有满足 “移位” 操作规律的组合进行分组并返回。\n\n \n\n示例：\n\n输入：["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]\n输出：\n[\n  ["abc","bcd","xyz"],\n  ["az","ba"],\n  ["acef"],\n  ["a","z"]\n]\n解释：可以认为字母表首尾相接，所以 \'z\' 的后续为 \'a\'，所以 ["az","ba"] 也满足 “移位” 操作规律。\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode250 Count Univalue Subtrees-zh",frontmatter:{title:"leetcode250 Count Univalue Subtrees-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/fe02f7/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode250 Count Univalue Subtrees-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10250.leetcode250%20Count%20Univalue%20Subtrees-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode250 Count Univalue Subtrees-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10250.leetcode250%20Count%20Univalue%20Subtrees-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode250 Count Univalue Subtrees-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10250.leetcode250%20Count%20Univalue%20Subtrees-zh.html",relativePath:"01.算法/24.leetcode/10250.leetcode250 Count Univalue Subtrees-zh.md",key:"v-2ee1b1e0",path:"/p/fe02f7/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:230},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:237},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:256},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:272}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 250. 统计同值子树\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，统计该二叉树数值相同的子树个数。\n\n同值子树是指该子树的所有节点都拥有相同的数值。\n\n示例：\n\n输入: root = [5,1,5,5,5,null,5]\n\n              5\n             / \\\n            1   5\n           / \\   \\\n          5   5   5\n\n输出: 4\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 250. 统计同值子树\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，统计该二叉树数值相同的子树个数。\n\n同值子树是指该子树的所有节点都拥有相同的数值。\n\n示例：\n\n输入: root = [5,1,5,5,5,null,5]\n\n              5\n             / \\\n            1   5\n           / \\   \\\n          5   5   5\n\n输出: 4\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode251 Flatten 2D Vector-zh",frontmatter:{title:"leetcode251 Flatten 2D Vector-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/91c29b/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode251 Flatten 2D Vector-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10251.leetcode251%20Flatten%202D%20Vector-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode251 Flatten 2D Vector-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10251.leetcode251%20Flatten%202D%20Vector-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode251 Flatten 2D Vector-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10251.leetcode251%20Flatten%202D%20Vector-zh.html",relativePath:"01.算法/24.leetcode/10251.leetcode251 Flatten 2D Vector-zh.md",key:"v-7c38df78",path:"/p/91c29b/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:536},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:543},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:519},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1136}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 251. 展开二维向量\n\nEnglish Version\n\n\n# 题目描述\n\n请设计并实现一个能够展开二维向量的迭代器。该迭代器需要支持 next 和 hasNext 两种操作。\n\n \n\n示例：\n\n\nVector2D iterator = new Vector2D([[1,2],[3],[4]]);\n\niterator.next(); // 返回 1\niterator.next(); // 返回 2\niterator.next(); // 返回 3\niterator.hasNext(); // 返回 true\niterator.hasNext(); // 返回 true\niterator.next(); // 返回 4\niterator.hasNext(); // 返回 false\n\n\n \n\n注意：\n\n 1. 请记得 重置 在 Vector2D 中声明的类变量（静态变量），因为类变量会 在多个测试用例中保持不变，影响判题准确。请 查阅 这里。\n 2. 你可以假定 next() 的调用总是合法的，即当 next() 被调用时，二维向量总是存在至少一个后续元素。\n\n \n\n进阶：尝试在代码中仅使用 C++ 提供的迭代器 或 Java 提供的迭代器。\n\n\n# 解法\n\n\n# Python3\n\nclass Vector2D:\n\n    def __init__(self, vec: List[List[int]]):\n        self.flatten = []\n        for item in vec:\n            for e in item:\n                self.flatten.append(e)\n        self.cur = -1\n\n    def next(self) -> int:\n        self.cur += 1\n        return self.flatten[self.cur]\n\n    def hasNext(self) -> bool:\n        return self.cur < len(self.flatten) - 1\n\n\n# Your Vector2D object will be instantiated and called as such:\n# obj = Vector2D(vec)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 251. 展开二维向量\n\nenglish version\n\n\n# 题目描述\n\n请设计并实现一个能够展开二维向量的迭代器。该迭代器需要支持 next 和 hasnext 两种操作。\n\n \n\n示例：\n\n\nvector2d iterator = new vector2d([[1,2],[3],[4]]);\n\niterator.next(); // 返回 1\niterator.next(); // 返回 2\niterator.next(); // 返回 3\niterator.hasnext(); // 返回 true\niterator.hasnext(); // 返回 true\niterator.next(); // 返回 4\niterator.hasnext(); // 返回 false\n\n\n \n\n注意：\n\n 1. 请记得 重置 在 vector2d 中声明的类变量（静态变量），因为类变量会 在多个测试用例中保持不变，影响判题准确。请 查阅 这里。\n 2. 你可以假定 next() 的调用总是合法的，即当 next() 被调用时，二维向量总是存在至少一个后续元素。\n\n \n\n进阶：尝试在代码中仅使用 c++ 提供的迭代器 或 java 提供的迭代器。\n\n\n# 解法\n\n\n# python3\n\nclass vector2d:\n\n    def __init__(self, vec: list[list[int]]):\n        self.flatten = []\n        for item in vec:\n            for e in item:\n                self.flatten.append(e)\n        self.cur = -1\n\n    def next(self) -> int:\n        self.cur += 1\n        return self.flatten[self.cur]\n\n    def hasnext(self) -> bool:\n        return self.cur < len(self.flatten) - 1\n\n\n# your vector2d object will be instantiated and called as such:\n# obj = vector2d(vec)\n# param_1 = obj.next()\n# param_2 = obj.hasnext()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode252 Meeting Rooms-zh",frontmatter:{title:"leetcode252 Meeting Rooms-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/8386f0/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode252 Meeting Rooms-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10252.leetcode252%20Meeting%20Rooms-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode252 Meeting Rooms-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10252.leetcode252%20Meeting%20Rooms-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode252 Meeting Rooms-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10252.leetcode252%20Meeting%20Rooms-zh.html",relativePath:"01.算法/24.leetcode/10252.leetcode252 Meeting Rooms-zh.md",key:"v-4f15c9b5",path:"/p/8386f0/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:32},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:347},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:354},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:659},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1005}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 252. 会议室\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，请你判断一个人是否能够参加这里面的全部会议。\n\n \n\n示例 1：\n\n\n输入：intervals = [[0,30],[5,10],[15,20]]\n输出：false\n\n\n示例 2：\n\n\n输入：intervals = [[7,10],[2,4]]\n输出：true\n\n\n \n\n提示：\n\n * 0 <= intervals.length <= 104\n * intervals[i].length == 2\n * 0 <= starti < endi <= 106\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n        intervals.sort(key=lambda x: x[0])\n        for i in range(len(intervals) - 1):\n            if intervals[i][1] > intervals[i + 1][0]:\n                return False\n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Java\n\nclass Solution {\n    public boolean canAttendMeetings(int[][] intervals) {\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n        for (int i = 0, n = intervals.length; i < n - 1; ++i) {\n            if (intervals[i][1] > intervals[i + 1][0]) return false;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 252. 会议室\n\nenglish version\n\n\n# 题目描述\n\n给定一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，请你判断一个人是否能够参加这里面的全部会议。\n\n \n\n示例 1：\n\n\n输入：intervals = [[0,30],[5,10],[15,20]]\n输出：false\n\n\n示例 2：\n\n\n输入：intervals = [[7,10],[2,4]]\n输出：true\n\n\n \n\n提示：\n\n * 0 <= intervals.length <= 104\n * intervals[i].length == 2\n * 0 <= starti < endi <= 106\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def canattendmeetings(self, intervals: list[list[int]]) -> bool:\n        intervals.sort(key=lambda x: x[0])\n        for i in range(len(intervals) - 1):\n            if intervals[i][1] > intervals[i + 1][0]:\n                return false\n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# java\n\nclass solution {\n    public boolean canattendmeetings(int[][] intervals) {\n        arrays.sort(intervals, comparator.comparingint(a -> a[0]));\n        for (int i = 0, n = intervals.length; i < n - 1; ++i) {\n            if (intervals[i][1] > intervals[i + 1][0]) return false;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode253 Meeting Rooms II-zh",frontmatter:{title:"leetcode253 Meeting Rooms II-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/d0435a/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode253 Meeting Rooms II-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10253.leetcode253%20Meeting%20Rooms%20II-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode253 Meeting Rooms II-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10253.leetcode253%20Meeting%20Rooms%20II-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode253 Meeting Rooms II-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10253.leetcode253%20Meeting%20Rooms%20II-zh.html",relativePath:"01.算法/24.leetcode/10253.leetcode253 Meeting Rooms II-zh.md",key:"v-6b004bb0",path:"/p/d0435a/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:35},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:342},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:349},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:368},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:384}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 253. 会议室 II\n\nEnglish Version\n\n\n# 题目描述\n\n给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。\n\n \n\n示例 1：\n\n\n输入：intervals = [[0,30],[5,10],[15,20]]\n输出：2\n\n\n示例 2：\n\n\n输入：intervals = [[7,10],[2,4]]\n输出：1\n\n\n \n\n提示：\n\n * 1 <= intervals.length <= 104\n * 0 <= starti < endi <= 106\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 253. 会议室 ii\n\nenglish version\n\n\n# 题目描述\n\n给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。\n\n \n\n示例 1：\n\n\n输入：intervals = [[0,30],[5,10],[15,20]]\n输出：2\n\n\n示例 2：\n\n\n输入：intervals = [[7,10],[2,4]]\n输出：1\n\n\n \n\n提示：\n\n * 1 <= intervals.length <= 104\n * 0 <= starti < endi <= 106\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode254 Factor Combinations-zh",frontmatter:{title:"leetcode254 Factor Combinations-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/b4fea1/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode254 Factor Combinations-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10254.leetcode254%20Factor%20Combinations-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode254 Factor Combinations-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10254.leetcode254%20Factor%20Combinations-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode254 Factor Combinations-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10254.leetcode254%20Factor%20Combinations-zh.html",relativePath:"01.算法/24.leetcode/10254.leetcode254 Factor Combinations-zh.md",key:"v-0e5f7767",path:"/p/b4fea1/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:34},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:379},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:386},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:405},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:421}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 254. 因子的组合\n\nEnglish Version\n\n\n# 题目描述\n\n整数可以被看作是其因子的乘积。\n\n例如：\n\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\n请实现一个函数，该函数接收一个整数 n 并返回该整数所有的因子组合。\n\n注意：\n\n 1. 你可以假定 n 为永远为正数。\n 2. 因子必须大于 1 并且小于 n。\n\n示例 1：\n\n输入: 1\n输出: []\n\n\n示例 2：\n\n输入: 37\n输出: []\n\n示例 3：\n\n输入: 12\n输出:\n[\n  [2, 6],\n  [2, 2, 3],\n  [3, 4]\n]\n\n示例 4:\n\n输入: 32\n输出:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n  [2, 4, 4],\n  [4, 8]\n]\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 254. 因子的组合\n\nenglish version\n\n\n# 题目描述\n\n整数可以被看作是其因子的乘积。\n\n例如：\n\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\n请实现一个函数，该函数接收一个整数 n 并返回该整数所有的因子组合。\n\n注意：\n\n 1. 你可以假定 n 为永远为正数。\n 2. 因子必须大于 1 并且小于 n。\n\n示例 1：\n\n输入: 1\n输出: []\n\n\n示例 2：\n\n输入: 37\n输出: []\n\n示例 3：\n\n输入: 12\n输出:\n[\n  [2, 6],\n  [2, 2, 3],\n  [3, 4]\n]\n\n示例 4:\n\n输入: 32\n输出:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n  [2, 4, 4],\n  [4, 8]\n]\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode255 Verify Preorder Sequence in Binary Search Tree-zh",frontmatter:{title:"leetcode255 Verify Preorder Sequence in Binary Search Tree-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/8ef0f4/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode255 Verify Preorder Sequence in Binary Search Tree-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10255.leetcode255%20Verify%20Preorder%20Sequence%20in%20Binary%20Search%20Tree-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode255 Verify Preorder Sequence in Binary Search Tree-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10255.leetcode255%20Verify%20Preorder%20Sequence%20in%20Binary%20Search%20Tree-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode255 Verify Preorder Sequence in Binary Search Tree-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10255.leetcode255%20Verify%20Preorder%20Sequence%20in%20Binary%20Search%20Tree-zh.html",relativePath:"01.算法/24.leetcode/10255.leetcode255 Verify Preorder Sequence in Binary Search Tree-zh.md",key:"v-7a95866c",path:"/p/8ef0f4/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:42},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:255},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:262},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:281},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:297}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 255. 验证前序遍历序列二叉搜索树\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数数组，你需要验证它是否是一个二叉搜索树正确的先序遍历序列。\n\n你可以假定该序列中的数都是不相同的。\n\n参考以下这颗二叉搜索树：\n\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n\n示例 1：\n\n输入: [5,2,6,1,3]\n输出: false\n\n示例 2：\n\n输入: [5,2,1,3,6]\n输出: true\n\n进阶挑战：\n\n您能否使用恒定的空间复杂度来完成此题？\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 255. 验证前序遍历序列二叉搜索树\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数数组，你需要验证它是否是一个二叉搜索树正确的先序遍历序列。\n\n你可以假定该序列中的数都是不相同的。\n\n参考以下这颗二叉搜索树：\n\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n\n示例 1：\n\n输入: [5,2,6,1,3]\n输出: false\n\n示例 2：\n\n输入: [5,2,1,3,6]\n输出: true\n\n进阶挑战：\n\n您能否使用恒定的空间复杂度来完成此题？\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode256 Paint House-zh",frontmatter:{title:"leetcode256 Paint House-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/de5fb9/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode256 Paint House-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10256.leetcode256%20Paint%20House-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode256 Paint House-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10256.leetcode256%20Paint%20House-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode256 Paint House-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10256.leetcode256%20Paint%20House-zh.html",relativePath:"01.算法/24.leetcode/10256.leetcode256 Paint House-zh.md",key:"v-472abdca",path:"/p/de5fb9/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:418},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:425},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:444},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:460}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 256. 粉刷房子\n\nEnglish Version\n\n\n# 题目描述\n\n假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。\n\n当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。\n\n例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。\n\n注意：\n\n所有花费均为正整数。\n\n示例：\n\n输入: [[17,2,17],[16,16,5],[14,3,19]]\n输出: 10\n解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。\n     最少花费: 2 + 5 + 3 = 10。\n\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 256. 粉刷房子\n\nenglish version\n\n\n# 题目描述\n\n假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。\n\n当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。\n\n例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。\n\n注意：\n\n所有花费均为正整数。\n\n示例：\n\n输入: [[17,2,17],[16,16,5],[14,3,19]]\n输出: 10\n解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。\n     最少花费: 2 + 5 + 3 = 10。\n\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode257 Binary Tree Paths-zh",frontmatter:{title:"leetcode257 Binary Tree Paths-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/050274/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode257 Binary Tree Paths-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10257.leetcode257%20Binary%20Tree%20Paths-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode257 Binary Tree Paths-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10257.leetcode257%20Binary%20Tree%20Paths-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode257 Binary Tree Paths-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10257.leetcode257%20Binary%20Tree%20Paths-zh.html",relativePath:"01.算法/24.leetcode/10257.leetcode257 Binary Tree Paths-zh.md",key:"v-869db188",path:"/p/050274/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:192},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:213},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:890},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:1794},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2814}],headersStr:"题目描述 解法 Python3 Java TypeScript ...",content:'# 257. 二叉树的所有路径\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例:\n\n输入:\n\n   1\n /   \\\n2     3\n \\\n  5\n\n输出: ["1->2->5", "1->3"]\n\n解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3\n\n\n# 解法\n\n深度优先搜索+路径记录。\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\n        def dfs(root):\n            if root is None:\n                return\n            path.append(str(root.val))\n            if root.left is None and root.right is None:\n                res.append("->".join(path))\n            dfs(root.left)\n            dfs(root.right)\n            path.pop()\n        res = []\n        path = []\n        dfs(root)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private List<String> res;\n    private List<String> path;\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) return Collections.emptyList();\n        res = new ArrayList<>();\n        path = new ArrayList<>();\n        dfs(root);\n        return res;\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null) return;\n        path.add(String.valueOf(root.val));\n        if (root.left == null && root.right == null) {\n            res.add(String.join("->", path));\n        }\n        dfs(root.left);\n        dfs(root.right);\n        path.remove(path.size() - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# TypeScript\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction binaryTreePaths(root: TreeNode | null): string[] {\n    let ans = [];\n    let pre = \'\';\n    dfs(root, pre, ans);\n    return ans;\n};\n\nfunction dfs(root: TreeNode | null, pre: string, ans: string[]): void {\n    if (root == null) return;\n    let val = String(root.val);\n    pre = pre.length > 0 ? `${pre}->${val}` : pre + val;\n    // 叶子节点\n    if (root.left == null && root.right == null) {\n        ans.push(pre);\n        return;\n    }\n    dfs(root.left, pre, ans);\n    dfs(root.right, pre, ans);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n',normalizedContent:'# 257. 二叉树的所有路径\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例:\n\n输入:\n\n   1\n /   \\\n2     3\n \\\n  5\n\n输出: ["1->2->5", "1->3"]\n\n解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3\n\n\n# 解法\n\n深度优先搜索+路径记录。\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def binarytreepaths(self, root: treenode) -> list[str]:\n        def dfs(root):\n            if root is none:\n                return\n            path.append(str(root.val))\n            if root.left is none and root.right is none:\n                res.append("->".join(path))\n            dfs(root.left)\n            dfs(root.right)\n            path.pop()\n        res = []\n        path = []\n        dfs(root)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    private list<string> res;\n    private list<string> path;\n\n    public list<string> binarytreepaths(treenode root) {\n        if (root == null) return collections.emptylist();\n        res = new arraylist<>();\n        path = new arraylist<>();\n        dfs(root);\n        return res;\n    }\n\n    private void dfs(treenode root) {\n        if (root == null) return;\n        path.add(string.valueof(root.val));\n        if (root.left == null && root.right == null) {\n            res.add(string.join("->", path));\n        }\n        dfs(root.left);\n        dfs(root.right);\n        path.remove(path.size() - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# typescript\n\n/**\n * definition for a binary tree node.\n * class treenode {\n *     val: number\n *     left: treenode | null\n *     right: treenode | null\n *     constructor(val?: number, left?: treenode | null, right?: treenode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction binarytreepaths(root: treenode | null): string[] {\n    let ans = [];\n    let pre = \'\';\n    dfs(root, pre, ans);\n    return ans;\n};\n\nfunction dfs(root: treenode | null, pre: string, ans: string[]): void {\n    if (root == null) return;\n    let val = string(root.val);\n    pre = pre.length > 0 ? `${pre}->${val}` : pre + val;\n    // 叶子节点\n    if (root.left == null && root.right == null) {\n        ans.push(pre);\n        return;\n    }\n    dfs(root.left, pre, ans);\n    dfs(root.right, pre, ans);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ...\n\n\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode258 Add Digits-zh",frontmatter:{title:"leetcode258 Add Digits-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/8e0d44/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode258 Add Digits-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10258.leetcode258%20Add%20Digits-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode258 Add Digits-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10258.leetcode258%20Add%20Digits-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode258 Add Digits-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10258.leetcode258%20Add%20Digits-zh.html",relativePath:"01.算法/24.leetcode/10258.leetcode258 Add Digits-zh.md",key:"v-2fc8e5ed",path:"/p/8e0d44/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:33},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:195},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:537},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:669},{level:3,title:"C++",slug:"c",normalizedTitle:"c++",charIndex:787},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:908}],headersStr:"题目描述 解法 Python3 Java C++ ...",content:"# 258. 各位相加\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。\n\n示例:\n\n输入: 38\n输出: 2 \n解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。\n\n\n进阶:\n你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？\n\n\n# 解法\n\n题目要求的数叫做“数根”，我们把 1~30 的数根列出来：\n\n原数: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n数根: 1 2 3 4 5 6 7 8 9  1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2  3\n\n\n1\n2\n\n\n可以看到，数根 9 个为一组，循环出现。我们可以得出下面的规律：\n\n * n = 0：数根是 0\n * n 是 9 的倍数：数根是 9\n * n 不是 9 的倍数：数根是 n % 9\n\n将上面的规律用式子：(n - 1) % 9 + 1 统一表达。\n\n\n# Python3\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        return 0 if num == 0 else (num - 1) % 9 + 1\n\n\n1\n2\n3\n\n\n\n# Java\n\nclass Solution {\n    public int addDigits(int num) {\n        return (num - 1) % 9 + 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# C++\n\nclass Solution {\npublic:\n    int addDigits(int num) {\n        return (num - 1) % 9 + 1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 258. 各位相加\n\nenglish version\n\n\n# 题目描述\n\n给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。\n\n示例:\n\n输入: 38\n输出: 2 \n解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。\n\n\n进阶:\n你可以不使用循环或者递归，且在 o(1) 时间复杂度内解决这个问题吗？\n\n\n# 解法\n\n题目要求的数叫做“数根”，我们把 1~30 的数根列出来：\n\n原数: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n数根: 1 2 3 4 5 6 7 8 9  1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2  3\n\n\n1\n2\n\n\n可以看到，数根 9 个为一组，循环出现。我们可以得出下面的规律：\n\n * n = 0：数根是 0\n * n 是 9 的倍数：数根是 9\n * n 不是 9 的倍数：数根是 n % 9\n\n将上面的规律用式子：(n - 1) % 9 + 1 统一表达。\n\n\n# python3\n\nclass solution:\n    def adddigits(self, num: int) -> int:\n        return 0 if num == 0 else (num - 1) % 9 + 1\n\n\n1\n2\n3\n\n\n\n# java\n\nclass solution {\n    public int adddigits(int num) {\n        return (num - 1) % 9 + 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# c++\n\nclass solution {\npublic:\n    int adddigits(int num) {\n        return (num - 1) % 9 + 1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode259 3Sum Smaller-zh",frontmatter:{title:"leetcode259 3Sum Smaller-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/7a4e4a/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode259 3Sum Smaller-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10259.leetcode259%203Sum%20Smaller-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode259 3Sum Smaller-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10259.leetcode259%203Sum%20Smaller-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode259 3Sum Smaller-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10259.leetcode259%203Sum%20Smaller-zh.html",relativePath:"01.算法/24.leetcode/10259.leetcode259 3Sum Smaller-zh.md",key:"v-64923fa7",path:"/p/7a4e4a/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:36},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:287},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:302},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:935},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1667},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:2437}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 259. 较小的三数之和\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个长度为 n 的整数数组和一个目标值 target，寻找能够使条件 nums[i] + nums[j] + nums[k] < target 成立的三元组  i, j, k 个数（0 <= i < j < k < n）。\n\n示例：\n\n输入: nums = [-2,0,1,3], target = 2\n输出: 2 \n解释: 因为一共有两个三元组满足累加和小于 2:\n     [-2,0,1]\n     [-2,0,3]\n\n\n进阶：是否能在 O(n2) 的时间复杂度内解决？\n\n\n# 解法\n\n双指针解决。\n\n\n# Python3\n\nclass Solution:\n    def threeSumSmaller(self, nums: List[int], target: int) -> int:\n        def threeSumSmaller(nums, start, end, target):\n            count = 0\n            while start < end:\n                if nums[start] + nums[end] < target:\n                    count += (end - start)\n                    start += 1\n                else:\n                    end -= 1\n            return count\n\n        nums.sort()\n        n, count = len(nums), 0\n        for i in range(n - 2):\n            count += threeSumSmaller(nums, i + 1, n - 1, target - nums[i])\n        return count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Java\n\nclass Solution {\n    public int threeSumSmaller(int[] nums, int target) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int count = 0;\n        for (int i = 0; i < n - 2; ++i) {\n            count += threeSumSmaller(nums, i + 1, n - 1, target - nums[i]);\n        }\n        return count;\n    }\n\n    private int threeSumSmaller(int[] nums, int start, int end, int target) {\n        int count = 0;\n        while (start < end) {\n            if (nums[start] + nums[end] < target) {\n                count += (end - start);\n                ++start;\n            } else {\n                --end;\n            }\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# JavaScript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threeSumSmaller = function (nums, target) {\n    let len = nums.length;\n    if (len < 3) return 0;\n    nums.sort((a, b) => a - b)\n    let res = 0;\n    for (let i = 0; i < len - 2; i++) {\n        let left = i + 1, right = len - 1;\n        if (nums[i] + nums[left] + nums[i + 2] >= target) break;\n        while (left < right) {\n            if (nums[i] + nums[left] + nums[right] < target) {\n                res += (right - left);\n                left++;\n                continue;\n            } else {\n                right--;\n                continue;\n            }\n        }\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 259. 较小的三数之和\n\nenglish version\n\n\n# 题目描述\n\n给定一个长度为 n 的整数数组和一个目标值 target，寻找能够使条件 nums[i] + nums[j] + nums[k] < target 成立的三元组  i, j, k 个数（0 <= i < j < k < n）。\n\n示例：\n\n输入: nums = [-2,0,1,3], target = 2\n输出: 2 \n解释: 因为一共有两个三元组满足累加和小于 2:\n     [-2,0,1]\n     [-2,0,3]\n\n\n进阶：是否能在 o(n2) 的时间复杂度内解决？\n\n\n# 解法\n\n双指针解决。\n\n\n# python3\n\nclass solution:\n    def threesumsmaller(self, nums: list[int], target: int) -> int:\n        def threesumsmaller(nums, start, end, target):\n            count = 0\n            while start < end:\n                if nums[start] + nums[end] < target:\n                    count += (end - start)\n                    start += 1\n                else:\n                    end -= 1\n            return count\n\n        nums.sort()\n        n, count = len(nums), 0\n        for i in range(n - 2):\n            count += threesumsmaller(nums, i + 1, n - 1, target - nums[i])\n        return count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# java\n\nclass solution {\n    public int threesumsmaller(int[] nums, int target) {\n        arrays.sort(nums);\n        int n = nums.length;\n        int count = 0;\n        for (int i = 0; i < n - 2; ++i) {\n            count += threesumsmaller(nums, i + 1, n - 1, target - nums[i]);\n        }\n        return count;\n    }\n\n    private int threesumsmaller(int[] nums, int start, int end, int target) {\n        int count = 0;\n        while (start < end) {\n            if (nums[start] + nums[end] < target) {\n                count += (end - start);\n                ++start;\n            } else {\n                --end;\n            }\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threesumsmaller = function (nums, target) {\n    let len = nums.length;\n    if (len < 3) return 0;\n    nums.sort((a, b) => a - b)\n    let res = 0;\n    for (let i = 0; i < len - 2; i++) {\n        let left = i + 1, right = len - 1;\n        if (nums[i] + nums[left] + nums[i + 2] >= target) break;\n        while (left < right) {\n            if (nums[i] + nums[left] + nums[right] < target) {\n                res += (right - left);\n                left++;\n                continue;\n            } else {\n                right--;\n                continue;\n            }\n        }\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode260 Single Number III-zh",frontmatter:{title:"leetcode260 Single Number III-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/cb9306/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode260 Single Number III-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10260.leetcode260%20Single%20Number%20III-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode260 Single Number III-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10260.leetcode260%20Single%20Number%20III-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode260 Single Number III-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10260.leetcode260%20Single%20Number%20III-zh.html",relativePath:"01.算法/24.leetcode/10260.leetcode260 Single Number III-zh.md",key:"v-4ed6ea9a",path:"/p/cb9306/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:41},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:401},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:408},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:783},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:1246}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 260. 只出现一次的数字 III\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。\n\n \n\n进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,1,3,2,5]\n输出：[3,5]\n解释：[5, 3] 也是有效的答案。\n\n\n示例 2：\n\n\n输入：nums = [-1,0]\n输出：[-1,0]\n\n\n示例 3：\n\n\n输入：nums = [0,1]\n输出：[1,0]\n\n\n提示：\n\n * 2 <= nums.length <= 3 * 104\n * -231 <= nums[i] <= 231 - 1\n * 除两个只出现一次的整数外，nums 中的其他数字都出现两次\n\n\n# 解法\n\n\n# Python3\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        eor = 0\n        for num in nums:\n            eor ^= num\n        # 提取最右边的 1\n        diff = eor & (~eor + 1)\n        a = 0\n        for num in nums:\n            if (num & diff) == 0:\n                a ^= num\n        b = eor ^ a\n        return [a, b]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java\n\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        int eor = 0;\n        for (int num : nums) {\n            eor ^= num;\n        }\n        // 提取最右的 1\n        int diff = eor & (~eor + 1);\n        int a = 0;\n        for (int num : nums) {\n            if ((num & diff) == 0) {\n                a ^= num;\n            }\n        }\n        int b = eor ^ a;\n        return new int[]{a, b};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 260. 只出现一次的数字 iii\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。\n\n \n\n进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？\n\n \n\n示例 1：\n\n\n输入：nums = [1,2,1,3,2,5]\n输出：[3,5]\n解释：[5, 3] 也是有效的答案。\n\n\n示例 2：\n\n\n输入：nums = [-1,0]\n输出：[-1,0]\n\n\n示例 3：\n\n\n输入：nums = [0,1]\n输出：[1,0]\n\n\n提示：\n\n * 2 <= nums.length <= 3 * 104\n * -231 <= nums[i] <= 231 - 1\n * 除两个只出现一次的整数外，nums 中的其他数字都出现两次\n\n\n# 解法\n\n\n# python3\n\nclass solution:\n    def singlenumber(self, nums: list[int]) -> list[int]:\n        eor = 0\n        for num in nums:\n            eor ^= num\n        # 提取最右边的 1\n        diff = eor & (~eor + 1)\n        a = 0\n        for num in nums:\n            if (num & diff) == 0:\n                a ^= num\n        b = eor ^ a\n        return [a, b]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java\n\nclass solution {\n    public int[] singlenumber(int[] nums) {\n        int eor = 0;\n        for (int num : nums) {\n            eor ^= num;\n        }\n        // 提取最右的 1\n        int diff = eor & (~eor + 1);\n        int a = 0;\n        for (int num : nums) {\n            if ((num & diff) == 0) {\n                a ^= num;\n            }\n        }\n        int b = eor ^ a;\n        return new int[]{a, b};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"极客学长刷 LeetCode",frontmatter:{title:"极客学长刷 LeetCode",date:"2021-07-17T08:32:20.000Z",permalink:"/leetcode/",categories:["leetcode","学习笔记","算法"],tags:["leetcode"],description:"",meta:[{name:"twitter:title",content:"极客学长刷 LeetCode"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/27.LeetCode%E9%A2%98%E8%A7%A3.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"极客学长刷 LeetCode"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/27.LeetCode%E9%A2%98%E8%A7%A3.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-17T08:32:20.000Z"},{property:"article:tag",content:"leetcode"},{itemprop:"name",content:"极客学长刷 LeetCode"},{itemprop:"description",content:""}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/27.LeetCode%E9%A2%98%E8%A7%A3.html",relativePath:"01.算法/24.leetcode/27.LeetCode题解.md",key:"v-12282736",path:"/leetcode/",headers:[{level:2,title:"leetcode 刷题笔记",slug:"leetcode-刷题笔记",normalizedTitle:"leetcode 刷题笔记",charIndex:2}],headersStr:"leetcode 刷题笔记",content:"# leetcode 刷题笔记\n\n本页面是极客学长Leetcode刷题笔记的整理。",normalizedContent:"# leetcode 刷题笔记\n\n本页面是极客学长leetcode刷题笔记的整理。",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"常用meta整理",frontmatter:{feed:{enable:!0},title:"常用meta整理",date:"2020-02-21T12:20:10.000Z",permalink:"/common-used-meta.html",categories:["页面","HTML"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"常用meta整理\n&lt;meta&gt; 元素\n概要\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200221134927.jpg"},{name:"twitter:title",content:"常用meta整理"},{name:"twitter:description",content:"常用meta整理\n&lt;meta&gt; 元素\n概要\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200221134927.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/02.%E9%A1%B5%E9%9D%A2/10.HTML/10.%E5%B8%B8%E7%94%A8meta%E6%95%B4%E7%90%86.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"常用meta整理"},{property:"og:description",content:"常用meta整理\n&lt;meta&gt; 元素\n概要\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200221134927.jpg"},{property:"og:url",content:"https://dbdgs.cn/02.%E9%A1%B5%E9%9D%A2/10.HTML/10.%E5%B8%B8%E7%94%A8meta%E6%95%B4%E7%90%86.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-02-21T12:20:10.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"常用meta整理"},{itemprop:"description",content:"常用meta整理\n&lt;meta&gt; 元素\n概要\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200221134927.jpg"}]},regularPath:"/02.%E9%A1%B5%E9%9D%A2/10.HTML/10.%E5%B8%B8%E7%94%A8meta%E6%95%B4%E7%90%86.html",relativePath:"02.页面/10.HTML/10.常用meta整理.md",key:"v-7def93d5",path:"/common-used-meta.html",headers:[{level:2,title:"元素",slug:"meta-元素",normalizedTitle:"元素",charIndex:22},{level:3,title:"概要",slug:"概要",normalizedTitle:"概要",charIndex:29},{level:3,title:"网页相关",slug:"网页相关",normalizedTitle:"网页相关",charIndex:588},{level:3,title:"SEO优化",slug:"seo优化",normalizedTitle:"seo优化",charIndex:1948},{level:3,title:"移动设备",slug:"移动设备",normalizedTitle:"移动设备",charIndex:2933},{level:3,title:"一个常用的移动端页面meta设置",slug:"一个常用的移动端页面meta设置",normalizedTitle:"一个常用的移动端页面meta设置",charIndex:4976}],excerpt:'<h1 id="常用meta整理"><a class="header-anchor" href="#常用meta整理">#</a> 常用meta整理</h1>\n<h2 id="meta-元素"><a class="header-anchor" href="#meta-元素">#</a> &lt;meta&gt; 元素</h2>\n<h3 id="概要"><a class="header-anchor" href="#概要">#</a> 概要</h3>\n<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>\n',headersStr:"元素 概要 网页相关 SEO优化 移动设备 一个常用的移动端页面meta设置",content:'# 常用meta整理\n\n\n# <meta> 元素\n\n\n# 概要\n\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\n\n必要属性\n\n属性        值           描述\ncontent   some text   定义与http-equiv或name属性相关的元信息\n\n可选属性\n\n属性           值                                                         描述\nhttp-equiv   content-type / expire / refresh / set-cookie              把content属性关联到HTTP头部。\nname         author / description / keywords / generator / revised /   把 content 属性关联到一个name。\n             others\ncontent      some text                                                 定义用于翻译 content 属性值的格式。\n\n\n# 网页相关\n\n * 申明编码\n\n<meta charset=\'utf-8\' />\n\n\n1\n\n * 优先使用 IE 最新版本和 Chrome\n\n\x3c!-- 关于X-UA-Compatible --\x3e\n<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /> \x3c!-- 推荐 --\x3e\n\n<meta http-equiv="X-UA-Compatible" content="IE=6" >\x3c!-- 使用IE6 --\x3e\n<meta http-equiv="X-UA-Compatible" content="IE=7" >\x3c!-- 使用IE7 --\x3e\n<meta http-equiv="X-UA-Compatible" content="IE=8" >\x3c!-- 使用IE8 --\x3e\n\n\n1\n2\n3\n4\n5\n6\n\n * 浏览器内核控制：国内浏览器很多都是双内核（webkit和Trident），webkit内核高速浏览，IE内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。参考文档\n\n默认用极速核(Chrome)：<meta name="renderer" content="webkit"> \n默认用ie兼容内核（IE6/7）：<meta name="renderer" content="ie-comp"> \n默认用ie标准内核（IE9/IE10/IE11/取决于用户的IE）：<meta name="renderer" content="ie-stand"> \n\n\n1\n2\n3\n\n\n国内双核浏览器默认内核模式如下：\n\n 1. 搜狗高速浏览器、QQ浏览器：IE内核（兼容模式）\n 2. 360极速浏览器、遨游浏览器：Webkit内核（极速模式）\n\n * 禁止浏览器从本地计算机的缓存中访问页面内容：这样设定，访问者将无法脱机浏览。\n\n<meta http-equiv="Pragma" content="no-cache">\n\n\n1\n\n * Windows 8\n\n<meta name="msapplication-TileColor" content="#000"/> \x3c!-- Windows 8 磁贴颜色 --\x3e\n<meta name="msapplication-TileImage" content="icon.png"/> \x3c!-- Windows 8 磁贴图标 --\x3e\n\n\n1\n2\n\n * 站点适配：主要用于PC-手机页的对应关系。\n\n<meta name="mobile-agent"content="format=[wml|xhtml|html5]; url=url">\n\x3c!--\n[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；\nurl="url" 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。\n --\x3e\n\n\n1\n2\n3\n4\n5\n\n * 转码申明：用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下meta。\n\n<meta http-equiv="Cache-Control" content="no-siteapp" />\n\n\n1\n\n\n\n# SEO优化\n\n参考文档\n\n * 页面关键词，每个网页应具有描述该网页内容的一组唯一的关键字。 使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过 874 个字符。\n\n<meta name="keywords" content="your tags" />\n\n\n1\n\n * 页面描述，每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。\n\n<meta name="description" content="150 words" />\n\n\n1\n\n * 搜索引擎索引方式，robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。\n\n<meta name="robots" content="index,follow" />\n\x3c!--\n    all：文件将被检索，且页面上的链接可以被查询；\n    none：文件将不被检索，且页面上的链接不可以被查询；\n    index：文件将被检索；\n    follow：页面上的链接可以被查询；\n    noindex：文件将不被检索；\n    nofollow：页面上的链接不可以被查询。\n --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 页面重定向和刷新：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。\n\n<meta http-equiv="refresh" content="0;url=" />\n\n\n1\n\n * 其他\n\n<meta name="author" content="author name" /> \x3c!-- 定义网页作者 --\x3e\n<meta name="google" content="index,follow" />\n<meta name="googlebot" content="index,follow" />\n<meta name="verify" content="index,follow" />\n\n\n1\n2\n3\n4\n\n\n\n# 移动设备\n\n * viewport：能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。\n\n<meta name="viewport" content="width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no"/>\n\x3c!--这是常用的移动meta设置--\x3e\n\n\n1\n2\n\n 1. width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素）\n 2. height：高度（数值 / device-height）（范围从223 到10,000）\n 3. initial-scale：初始的缩放比例 （范围从>0 到10）\n 4. minimum-scale：允许用户缩放到的最小比例\n 5. maximum-scale：允许用户缩放到的最大比例\n 6. user-scalable：用户是否可以手动缩 (no,yes)\n\n注意，很多人使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染，用户需要手动移动页面或者缩放。如果和initial-scale=1同时使用user-scalable=no或maximum-scale=1，则用户将不能放大/缩小网页来看到全部的内容。\n\n * WebApp全屏模式：伪装app，离线应用。\n\n<meta name="apple-mobile-web-app-capable" content="yes" /> \x3c!-- 启用 WebApp 全屏模式 --\x3e\n\n\n1\n\n * 主题颜色\n\n<meta name="theme-color" content="#11a8cd">\n\n\n1\n\n\n\n\n * 隐藏状态栏/设置状态栏颜色：只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。\n\n<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />\n\n\n1\n\n * 添加到主屏后的标题\n\n<meta name="apple-mobile-web-app-title" content="标题">\n\n\n1\n\n * 忽略数字自动识别为电话号码\n\n<meta content="telephone=no" name="format-detection" />\n\n\n1\n\n * 忽略识别邮箱\n\n<meta content="email=no" name="format-detection" />\n\n\n1\n\n * 添加智能 App 广告条 Smart App Banner：告诉浏览器这个网站对应的app，并在页面上显示下载banner(如下图)。参考文档\n\n<meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL">\n\n\n1\n\n\n\n\n * 其他 参考文档\n\n\x3c!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --\x3e\n<meta name="HandheldFriendly" content="true">\n\x3c!-- 微软的老式浏览器 --\x3e\n<meta name="MobileOptimized" content="320">\n\x3c!-- uc强制竖屏 --\x3e\n<meta name="screen-orientation" content="portrait">\n\x3c!-- QQ强制竖屏 --\x3e\n<meta name="x5-orientation" content="portrait">\n\x3c!-- UC强制全屏 --\x3e\n<meta name="full-screen" content="yes">\n\x3c!-- QQ强制全屏 --\x3e\n<meta name="x5-fullscreen" content="true">\n\x3c!-- UC应用模式 --\x3e\n<meta name="browsermode" content="application">\n\x3c!-- QQ应用模式 --\x3e\n<meta name="x5-page-mode" content="app">\n\x3c!-- windows phone 点击无高光 --\x3e\n<meta name="msapplication-tap-highlight" content="no">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 一个常用的移动端页面meta设置\n\n<meta charset="utf-8">\n<meta http-equiv="X-UA-Compatible" content="IE=edge">\n<meta name="viewport" content="width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no">\n\n\n1\n2\n3\n',normalizedContent:'# 常用meta整理\n\n\n# <meta> 元素\n\n\n# 概要\n\nmeta标签提供关于html文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\n\n必要属性\n\n属性        值           描述\ncontent   some text   定义与http-equiv或name属性相关的元信息\n\n可选属性\n\n属性           值                                                         描述\nhttp-equiv   content-type / expire / refresh / set-cookie              把content属性关联到http头部。\nname         author / description / keywords / generator / revised /   把 content 属性关联到一个name。\n             others\ncontent      some text                                                 定义用于翻译 content 属性值的格式。\n\n\n# 网页相关\n\n * 申明编码\n\n<meta charset=\'utf-8\' />\n\n\n1\n\n * 优先使用 ie 最新版本和 chrome\n\n\x3c!-- 关于x-ua-compatible --\x3e\n<meta http-equiv="x-ua-compatible" content="ie=edge,chrome=1" /> \x3c!-- 推荐 --\x3e\n\n<meta http-equiv="x-ua-compatible" content="ie=6" >\x3c!-- 使用ie6 --\x3e\n<meta http-equiv="x-ua-compatible" content="ie=7" >\x3c!-- 使用ie7 --\x3e\n<meta http-equiv="x-ua-compatible" content="ie=8" >\x3c!-- 使用ie8 --\x3e\n\n\n1\n2\n3\n4\n5\n6\n\n * 浏览器内核控制：国内浏览器很多都是双内核（webkit和trident），webkit内核高速浏览，ie内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。参考文档\n\n默认用极速核(chrome)：<meta name="renderer" content="webkit"> \n默认用ie兼容内核（ie6/7）：<meta name="renderer" content="ie-comp"> \n默认用ie标准内核（ie9/ie10/ie11/取决于用户的ie）：<meta name="renderer" content="ie-stand"> \n\n\n1\n2\n3\n\n\n国内双核浏览器默认内核模式如下：\n\n 1. 搜狗高速浏览器、qq浏览器：ie内核（兼容模式）\n 2. 360极速浏览器、遨游浏览器：webkit内核（极速模式）\n\n * 禁止浏览器从本地计算机的缓存中访问页面内容：这样设定，访问者将无法脱机浏览。\n\n<meta http-equiv="pragma" content="no-cache">\n\n\n1\n\n * windows 8\n\n<meta name="msapplication-tilecolor" content="#000"/> \x3c!-- windows 8 磁贴颜色 --\x3e\n<meta name="msapplication-tileimage" content="icon.png"/> \x3c!-- windows 8 磁贴图标 --\x3e\n\n\n1\n2\n\n * 站点适配：主要用于pc-手机页的对应关系。\n\n<meta name="mobile-agent"content="format=[wml|xhtml|html5]; url=url">\n\x3c!--\n[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；\nurl="url" 后者代表当前pc页所对应的手机页url，两者必须是一一对应关系。\n --\x3e\n\n\n1\n2\n3\n4\n5\n\n * 转码申明：用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下meta。\n\n<meta http-equiv="cache-control" content="no-siteapp" />\n\n\n1\n\n\n\n# seo优化\n\n参考文档\n\n * 页面关键词，每个网页应具有描述该网页内容的一组唯一的关键字。 使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过 874 个字符。\n\n<meta name="keywords" content="your tags" />\n\n\n1\n\n * 页面描述，每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。\n\n<meta name="description" content="150 words" />\n\n\n1\n\n * 搜索引擎索引方式，robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。\n\n<meta name="robots" content="index,follow" />\n\x3c!--\n    all：文件将被检索，且页面上的链接可以被查询；\n    none：文件将不被检索，且页面上的链接不可以被查询；\n    index：文件将被检索；\n    follow：页面上的链接可以被查询；\n    noindex：文件将不被检索；\n    nofollow：页面上的链接不可以被查询。\n --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 页面重定向和刷新：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。\n\n<meta http-equiv="refresh" content="0;url=" />\n\n\n1\n\n * 其他\n\n<meta name="author" content="author name" /> \x3c!-- 定义网页作者 --\x3e\n<meta name="google" content="index,follow" />\n<meta name="googlebot" content="index,follow" />\n<meta name="verify" content="index,follow" />\n\n\n1\n2\n3\n4\n\n\n\n# 移动设备\n\n * viewport：能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。\n\n<meta name="viewport" content="width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no"/>\n\x3c!--这是常用的移动meta设置--\x3e\n\n\n1\n2\n\n 1. width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素）\n 2. height：高度（数值 / device-height）（范围从223 到10,000）\n 3. initial-scale：初始的缩放比例 （范围从>0 到10）\n 4. minimum-scale：允许用户缩放到的最小比例\n 5. maximum-scale：允许用户缩放到的最大比例\n 6. user-scalable：用户是否可以手动缩 (no,yes)\n\n注意，很多人使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染，用户需要手动移动页面或者缩放。如果和initial-scale=1同时使用user-scalable=no或maximum-scale=1，则用户将不能放大/缩小网页来看到全部的内容。\n\n * webapp全屏模式：伪装app，离线应用。\n\n<meta name="apple-mobile-web-app-capable" content="yes" /> \x3c!-- 启用 webapp 全屏模式 --\x3e\n\n\n1\n\n * 主题颜色\n\n<meta name="theme-color" content="#11a8cd">\n\n\n1\n\n\n\n\n * 隐藏状态栏/设置状态栏颜色：只有在开启webapp全屏模式时才生效。content的值为default | black | black-translucent 。\n\n<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />\n\n\n1\n\n * 添加到主屏后的标题\n\n<meta name="apple-mobile-web-app-title" content="标题">\n\n\n1\n\n * 忽略数字自动识别为电话号码\n\n<meta content="telephone=no" name="format-detection" />\n\n\n1\n\n * 忽略识别邮箱\n\n<meta content="email=no" name="format-detection" />\n\n\n1\n\n * 添加智能 app 广告条 smart app banner：告诉浏览器这个网站对应的app，并在页面上显示下载banner(如下图)。参考文档\n\n<meta name="apple-itunes-app" content="app-id=myappstoreid, affiliate-data=myaffiliatedata, app-argument=myurl">\n\n\n1\n\n\n\n\n * 其他 参考文档\n\n\x3c!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --\x3e\n<meta name="handheldfriendly" content="true">\n\x3c!-- 微软的老式浏览器 --\x3e\n<meta name="mobileoptimized" content="320">\n\x3c!-- uc强制竖屏 --\x3e\n<meta name="screen-orientation" content="portrait">\n\x3c!-- qq强制竖屏 --\x3e\n<meta name="x5-orientation" content="portrait">\n\x3c!-- uc强制全屏 --\x3e\n<meta name="full-screen" content="yes">\n\x3c!-- qq强制全屏 --\x3e\n<meta name="x5-fullscreen" content="true">\n\x3c!-- uc应用模式 --\x3e\n<meta name="browsermode" content="application">\n\x3c!-- qq应用模式 --\x3e\n<meta name="x5-page-mode" content="app">\n\x3c!-- windows phone 点击无高光 --\x3e\n<meta name="msapplication-tap-highlight" content="no">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 一个常用的移动端页面meta设置\n\n<meta charset="utf-8">\n<meta http-equiv="x-ua-compatible" content="ie=edge">\n<meta name="viewport" content="width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no">\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"CSS教程和技巧收藏",frontmatter:{feed:{enable:!0},title:"CSS教程和技巧收藏",date:"2020-08-11T17:13:52.000Z",permalink:"/css-tips.html",categories:["页面","CSS"],tags:[null],description:"",meta:[{name:"twitter:title",content:"CSS教程和技巧收藏"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/02.%E9%A1%B5%E9%9D%A2/20.CSS/00.CSS%E6%95%99%E7%A8%8B%E5%92%8C%E6%8A%80%E5%B7%A7%E6%94%B6%E8%97%8F.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"CSS教程和技巧收藏"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/02.%E9%A1%B5%E9%9D%A2/20.CSS/00.CSS%E6%95%99%E7%A8%8B%E5%92%8C%E6%8A%80%E5%B7%A7%E6%94%B6%E8%97%8F.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-08-11T17:13:52.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"CSS教程和技巧收藏"},{itemprop:"description",content:""}]},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/00.CSS%E6%95%99%E7%A8%8B%E5%92%8C%E6%8A%80%E5%B7%A7%E6%94%B6%E8%97%8F.html",relativePath:"02.页面/20.CSS/00.CSS教程和技巧收藏.md",key:"v-45d1bfd4",path:"/css-tips.html",headers:[{level:2,title:"Flex 布局教程：语法篇",slug:"flex-布局教程-语法篇",normalizedTitle:"flex 布局教程：语法篇",charIndex:2},{level:2,title:"CSS Grid 网格布局教程",slug:"css-grid-网格布局教程",normalizedTitle:"css grid 网格布局教程",charIndex:78},{level:2,title:"只要一行代码，实现五种 CSS 经典布局",slug:"只要一行代码-实现五种-css-经典布局",normalizedTitle:"只要一行代码，实现五种 css 经典布局",charIndex:164}],headersStr:"Flex 布局教程：语法篇 CSS Grid 网格布局教程 只要一行代码，实现五种 CSS 经典布局",content:"# Flex 布局教程：语法篇\n\nhttp://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n\n\n# CSS Grid 网格布局教程\n\nhttp://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\n\n\n# 只要一行代码，实现五种 CSS 经典布局\n\nhttp://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html\n\n * 空间居中布局\n   \n   > 不管容器的大小，项目总是占据中心点\n\n * 并列式布局\n   \n   > 多个项目并列，如果宽度不够，放不下的项目就自动折行\n\n * 两栏式布局\n   \n   > 一个边栏，一个主栏。边栏始终存在，主栏根据设备宽度，变宽或者变窄\n\n * 三明治布局\n   \n   > 页面在垂直方向上，分成三部分：页眉、内容区、页脚。\n\n * 圣杯布局\n   \n   > 最常用的布局，所以被比喻为圣杯。它将页面分成五个部分，除了页眉和页脚，内容区分成左边栏、主栏、右边栏。",normalizedContent:"# flex 布局教程：语法篇\n\nhttp://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n\n\n# css grid 网格布局教程\n\nhttp://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\n\n\n# 只要一行代码，实现五种 css 经典布局\n\nhttp://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html\n\n * 空间居中布局\n   \n   > 不管容器的大小，项目总是占据中心点\n\n * 并列式布局\n   \n   > 多个项目并列，如果宽度不够，放不下的项目就自动折行\n\n * 两栏式布局\n   \n   > 一个边栏，一个主栏。边栏始终存在，主栏根据设备宽度，变宽或者变窄\n\n * 三明治布局\n   \n   > 页面在垂直方向上，分成三部分：页眉、内容区、页脚。\n\n * 圣杯布局\n   \n   > 最常用的布局，所以被比喻为圣杯。它将页面分成五个部分，除了页眉和页脚，内容区分成左边栏、主栏、右边栏。",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"混入(Mixins)",frontmatter:{feed:{enable:!0},title:"混入(Mixins)",date:"2020-02-23T15:47:03.000Z",permalink:"/mixins.html",categories:["页面","stylus"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"stylus混入(Mixins)\n混入(Mixins)\n混入和函数定义方法一致，但是应用却大相径庭。\n一个简单的混入应用，定义一个超出显示省略号的ellipsis()方法，在需要用到的地方只需插入这个方法，其样式会扩展并复制到选择器中。",meta:[{name:"twitter:title",content:"混入(Mixins)"},{name:"twitter:description",content:"stylus混入(Mixins)\n混入(Mixins)\n混入和函数定义方法一致，但是应用却大相径庭。\n一个简单的混入应用，定义一个超出显示省略号的ellipsis()方法，在需要用到的地方只需插入这个方法，其样式会扩展并复制到选择器中。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/02.%E9%A1%B5%E9%9D%A2/25.stylus/10.%E6%B7%B7%E5%85%A5(Mixins).html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"混入(Mixins)"},{property:"og:description",content:"stylus混入(Mixins)\n混入(Mixins)\n混入和函数定义方法一致，但是应用却大相径庭。\n一个简单的混入应用，定义一个超出显示省略号的ellipsis()方法，在需要用到的地方只需插入这个方法，其样式会扩展并复制到选择器中。"},{property:"og:url",content:"https://dbdgs.cn/02.%E9%A1%B5%E9%9D%A2/25.stylus/10.%E6%B7%B7%E5%85%A5(Mixins).html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-02-23T15:47:03.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"混入(Mixins)"},{itemprop:"description",content:"stylus混入(Mixins)\n混入(Mixins)\n混入和函数定义方法一致，但是应用却大相径庭。\n一个简单的混入应用，定义一个超出显示省略号的ellipsis()方法，在需要用到的地方只需插入这个方法，其样式会扩展并复制到选择器中。"}]},regularPath:"/02.%E9%A1%B5%E9%9D%A2/25.stylus/10.%E6%B7%B7%E5%85%A5(Mixins).html",relativePath:"02.页面/25.stylus/10.混入(Mixins).md",key:"v-66fb014a",path:"/mixins.html",headers:[{level:2,title:"混入(Mixins)",slug:"混入-mixins",normalizedTitle:"混入(mixins)",charIndex:8}],excerpt:'<h1 id="stylus混入-mixins"><a class="header-anchor" href="#stylus混入-mixins">#</a> stylus混入(Mixins)</h1>\n<h2 id="混入-mixins"><a class="header-anchor" href="#混入-mixins">#</a> 混入(Mixins)</h2>\n<p>混入和函数定义方法一致，但是应用却大相径庭。</p>\n<p>一个简单的混入应用，定义一个超出显示省略号的<code>ellipsis()</code>方法，在需要用到的地方只需插入这个方法，其样式会扩展并复制到选择器中。</p>\n',headersStr:"混入(Mixins)",content:"# stylus混入(Mixins)\n\n\n# 混入(Mixins)\n\n混入和函数定义方法一致，但是应用却大相径庭。\n\n一个简单的混入应用，定义一个超出显示省略号的ellipsis()方法，在需要用到的地方只需插入这个方法，其样式会扩展并复制到选择器中。\n\nellipsis()\n  overflow hidden\n  white-space nowrap\n  text-overflow ellipsis\n\n\n1\n2\n3\n4\n\n\np\n  ellipsis()\n\n\n1\n2\n\n\n下面有定义的border-radius(n)方法，其却作为一个mixin（如，作为状态调用，而非表达式）调用。\n\n当border-radius()选择器中调用时候，属性会被扩展并复制在选择器中。\n\nborder-radius(n)\n  -webkit-border-radius n\n  -moz-border-radius n\n  border-radius n\n\nform input[type=button]\n  border-radius(5px)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n编译成：\n\nform input[type=button] {\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  border-radius: 5px;\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用混入书写，你可以完全忽略括号，提供梦幻般私有属性的支持。\n\nborder-radius(n)\n  -webkit-border-radius n\n  -moz-border-radius n\n  border-radius n\n\nform input[type=button]\n  border-radius 5px\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意到我们混合书写中的border-radius当作了属性，而不是一个递归函数调用。\n\n更进一步，我们可以利用arguments这个局部变量，传递可以包含多值的表达式。\n\nborder-radius()\n  -webkit-border-radius arguments\n  -moz-border-radius arguments\n  border-radius arguments\n\n\n1\n2\n3\n4\n\n\n现在，我们可以像这样子传值：border-radius 1px 2px / 3px 4px!\n\n另外一个很赞的应用是特定的私有前缀支持——例如IE浏览器的透明度：\n\nsupport-for-ie ?= true\n\nopacity(n)\n  opacity n\n  if support-for-ie\n    filter unquote('progid:DXImageTransform.Microsoft.Alpha(Opacity=' + round(n * 100) + ')')\n\n#logo\n  &:hover\n    opacity 0.5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n渲染为：\n\n#logo:hover {\n  opacity: 0.5;\n  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=50);\n}\n\n\n1\n2\n3\n4\n\n\n来源：https://www.zhangxinxu.com/jq/stylus/mixins.php",normalizedContent:"# stylus混入(mixins)\n\n\n# 混入(mixins)\n\n混入和函数定义方法一致，但是应用却大相径庭。\n\n一个简单的混入应用，定义一个超出显示省略号的ellipsis()方法，在需要用到的地方只需插入这个方法，其样式会扩展并复制到选择器中。\n\nellipsis()\n  overflow hidden\n  white-space nowrap\n  text-overflow ellipsis\n\n\n1\n2\n3\n4\n\n\np\n  ellipsis()\n\n\n1\n2\n\n\n下面有定义的border-radius(n)方法，其却作为一个mixin（如，作为状态调用，而非表达式）调用。\n\n当border-radius()选择器中调用时候，属性会被扩展并复制在选择器中。\n\nborder-radius(n)\n  -webkit-border-radius n\n  -moz-border-radius n\n  border-radius n\n\nform input[type=button]\n  border-radius(5px)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n编译成：\n\nform input[type=button] {\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  border-radius: 5px;\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用混入书写，你可以完全忽略括号，提供梦幻般私有属性的支持。\n\nborder-radius(n)\n  -webkit-border-radius n\n  -moz-border-radius n\n  border-radius n\n\nform input[type=button]\n  border-radius 5px\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意到我们混合书写中的border-radius当作了属性，而不是一个递归函数调用。\n\n更进一步，我们可以利用arguments这个局部变量，传递可以包含多值的表达式。\n\nborder-radius()\n  -webkit-border-radius arguments\n  -moz-border-radius arguments\n  border-radius arguments\n\n\n1\n2\n3\n4\n\n\n现在，我们可以像这样子传值：border-radius 1px 2px / 3px 4px!\n\n另外一个很赞的应用是特定的私有前缀支持——例如ie浏览器的透明度：\n\nsupport-for-ie ?= true\n\nopacity(n)\n  opacity n\n  if support-for-ie\n    filter unquote('progid:dximagetransform.microsoft.alpha(opacity=' + round(n * 100) + ')')\n\n#logo\n  &:hover\n    opacity 0.5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n渲染为：\n\n#logo:hover {\n  opacity: 0.5;\n  filter: progid:dximagetransform.microsoft.alpha(opacity=50);\n}\n\n\n1\n2\n3\n4\n\n\n来源：https://www.zhangxinxu.com/jq/stylus/mixins.php",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"npm常用命令",frontmatter:{feed:{enable:!0},title:"npm常用命令",date:"2019-12-25T14:27:01.000Z",permalink:"/npm-common-commands.html",categories:["技术","技术文档"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"npm常用命令\n简介\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n允许用户从npm服务器下载别人编写的第三方包到本地使用。\n允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n",meta:[{name:"twitter:title",content:"npm常用命令"},{name:"twitter:description",content:"npm常用命令\n简介\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n允许用户从npm服务器下载别人编写的第三方包到本地使用。\n允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/03.npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"npm常用命令"},{property:"og:description",content:"npm常用命令\n简介\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n允许用户从npm服务器下载别人编写的第三方包到本地使用。\n允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n"},{property:"og:url",content:"https://dbdgs.cn/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/03.npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2019-12-25T14:27:01.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"npm常用命令"},{itemprop:"description",content:"npm常用命令\n简介\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n允许用户从npm服务器下载别人编写的第三方包到本地使用。\n允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n"}]},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/03.npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"03.技术/01.技术文档/03.npm常用命令.md",key:"v-8e4edc24",path:"/npm-common-commands.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:14},{level:2,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:5},{level:2,title:"使用技巧",slug:"使用技巧",normalizedTitle:"使用技巧",charIndex:1761},{level:2,title:"npm发布包教程",slug:"npm发布包教程",normalizedTitle:"npm发布包教程",charIndex:1912},{level:2,title:"nrm的作用与使用",slug:"nrm的作用与使用",normalizedTitle:"nrm的作用与使用",charIndex:1935}],excerpt:'<h1 id="npm常用命令"><a class="header-anchor" href="#npm常用命令">#</a> npm常用命令</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\n<ul>\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\n</ul>\n',headersStr:"简介 常用命令 使用技巧 npm发布包教程 nrm的作用与使用",content:'# npm常用命令\n\n\n# 简介\n\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n * 允许用户从npm服务器下载别人编写的第三方包到本地使用。\n * 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n * 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n\n\n# 常用命令\n\n# 检测是否安装及版本\n\nnpm -v # 显示版本号说明已经安装相应的版本\n\n\n1\n\n\n# 生成package.json文件\n\nnpm init\n\n\n1\n\n\n> package.json用来描述项目中用到的模块和其他信息\n\n# 安装模块\n\nnpm install # 安装package.json定义好的模块，简写 npm i\n\n# 安装包指定模块\nnpm i <ModuleName>\n\n# 全局安装\nnpm i <ModuleName> -g \n\n# 安装包的同时，将信息写入到package.json中的 dependencies 配置中\nnpm i <ModuleName> --save\n\n# 安装包的同时，将信息写入到package.json中的 devDependencies 配置中\nnpm i <ModuleName> --save-dev\n\n# 安装多模块\nnpm i <ModuleName1> <ModuleName2>\n\n# 安装方式参数：\n-save # 简写-S，加入到生产依赖中\n-save-dev # 简写-D，加入到开发依赖中\n-g # 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 查看\n\n# 查看所有全局安装的包\nnpm ls -g\n\n# 查看本地项目中安装的包\nnpm ls\n\n# 查看包的 package.json文件\nnpm view <ModuleName>\n\n# 查看包的依赖关系\nnpm view <ModuleName> dependencies\n\n# 查看包的源文件地址\nnpm view <ModuleName> repository.url\n\n# 查看包所依赖的node版本\nnpm view <ModuleName> engines\n\n# 查看帮助\nnpm help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 更新模块\n\n# 更新本地模块\nnpm update <ModuleName>\n\n# 更新全局模块\nnpm update -g <ModuleName> # 更新全局软件包。\nnpm update -g # 更新所有的全局软件包。\nnpm outdated -g --depth=0 # 找出需要更新的包。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 卸载模块\n\n# 卸载本地模块\nnpm uninstall <ModuleName>\n\n# 卸载全局模块\nnpm uninstall -g <ModuleName> # 卸载全局软件包。\n\n\n1\n2\n3\n4\n5\n\n\n# 清空缓存\n\n# 清空npm缓存\nnpm cache clear\n\n\n1\n2\n\n\n# 使用淘宝镜像\n\n# 使用淘宝镜像\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n1\n2\n\n\n# 其他\n\n# 更改包内容后进行重建\nnpm rebuild <ModuleName>\n\n# 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新\nnpm outdated\n\n# 访问npm的json文件，此命令将会打开一个网页\nnpm help json\n\n# 发布一个包的时候，需要检验某个包名是否存在\nnpm search <ModuleName>\n\n# 撤销自己发布过的某个版本代码\nnpm unpublish <package> <version>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 使用技巧\n\n# 多次安装不成功尝试先清除缓存\n\nnpm cache clean -f\n\n\n1\n\n\n# 查看已安装的依赖包版本号\n\nnpm ls <ModuleName>\n\n\n1\n\n\n> 注意：用此方法才能准确的知道项目使用的版本号，查看package.json时，有“^" 符号表示大于此版本\n\n\n# npm发布包教程\n\nnpm发布包教程\n\n\n# nrm的作用与使用\n\n# nrm是什么？\n\nnrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换\n\n# nrm的安装\n\nnpm install -g nrm\n\n\n1\n\n\n# nrm命令\n\nnrm ls　#查看可用的源（有*号的表示当前所使用的源,以下<registry>表示源的名称）\nnrm use <registry> # 将npm下载源切换成指定的源\nnrm add <registry> <url> # 添加源，url为源的路径\nnrm del <registry> # 删除源\nnrm test <registry> # 测试源的响应时间，可以作为使用哪个源的参考\n\nnrm help　# 查看nrm帮助\nnrm home <registry>　# 跳转到指定源的官网\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# nrm使用\n\n如果在你的网络不太理想或者受到其他网络限制导致不能使用npm原本的源进行下载时，nrm就非常有用了，你只需要：\n\nnrm ls # 查看可用的源\nnrm use <registry>　# 切换到指定源\n\n\n1\n2\n',normalizedContent:'# npm常用命令\n\n\n# 简介\n\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n * 允许用户从npm服务器下载别人编写的第三方包到本地使用。\n * 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n * 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n\n\n# 常用命令\n\n# 检测是否安装及版本\n\nnpm -v # 显示版本号说明已经安装相应的版本\n\n\n1\n\n\n# 生成package.json文件\n\nnpm init\n\n\n1\n\n\n> package.json用来描述项目中用到的模块和其他信息\n\n# 安装模块\n\nnpm install # 安装package.json定义好的模块，简写 npm i\n\n# 安装包指定模块\nnpm i <modulename>\n\n# 全局安装\nnpm i <modulename> -g \n\n# 安装包的同时，将信息写入到package.json中的 dependencies 配置中\nnpm i <modulename> --save\n\n# 安装包的同时，将信息写入到package.json中的 devdependencies 配置中\nnpm i <modulename> --save-dev\n\n# 安装多模块\nnpm i <modulename1> <modulename2>\n\n# 安装方式参数：\n-save # 简写-s，加入到生产依赖中\n-save-dev # 简写-d，加入到开发依赖中\n-g # 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 查看\n\n# 查看所有全局安装的包\nnpm ls -g\n\n# 查看本地项目中安装的包\nnpm ls\n\n# 查看包的 package.json文件\nnpm view <modulename>\n\n# 查看包的依赖关系\nnpm view <modulename> dependencies\n\n# 查看包的源文件地址\nnpm view <modulename> repository.url\n\n# 查看包所依赖的node版本\nnpm view <modulename> engines\n\n# 查看帮助\nnpm help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 更新模块\n\n# 更新本地模块\nnpm update <modulename>\n\n# 更新全局模块\nnpm update -g <modulename> # 更新全局软件包。\nnpm update -g # 更新所有的全局软件包。\nnpm outdated -g --depth=0 # 找出需要更新的包。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 卸载模块\n\n# 卸载本地模块\nnpm uninstall <modulename>\n\n# 卸载全局模块\nnpm uninstall -g <modulename> # 卸载全局软件包。\n\n\n1\n2\n3\n4\n5\n\n\n# 清空缓存\n\n# 清空npm缓存\nnpm cache clear\n\n\n1\n2\n\n\n# 使用淘宝镜像\n\n# 使用淘宝镜像\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n1\n2\n\n\n# 其他\n\n# 更改包内容后进行重建\nnpm rebuild <modulename>\n\n# 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新\nnpm outdated\n\n# 访问npm的json文件，此命令将会打开一个网页\nnpm help json\n\n# 发布一个包的时候，需要检验某个包名是否存在\nnpm search <modulename>\n\n# 撤销自己发布过的某个版本代码\nnpm unpublish <package> <version>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 使用技巧\n\n# 多次安装不成功尝试先清除缓存\n\nnpm cache clean -f\n\n\n1\n\n\n# 查看已安装的依赖包版本号\n\nnpm ls <modulename>\n\n\n1\n\n\n> 注意：用此方法才能准确的知道项目使用的版本号，查看package.json时，有“^" 符号表示大于此版本\n\n\n# npm发布包教程\n\nnpm发布包教程\n\n\n# nrm的作用与使用\n\n# nrm是什么？\n\nnrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换\n\n# nrm的安装\n\nnpm install -g nrm\n\n\n1\n\n\n# nrm命令\n\nnrm ls　#查看可用的源（有*号的表示当前所使用的源,以下<registry>表示源的名称）\nnrm use <registry> # 将npm下载源切换成指定的源\nnrm add <registry> <url> # 添加源，url为源的路径\nnrm del <registry> # 删除源\nnrm test <registry> # 测试源的响应时间，可以作为使用哪个源的参考\n\nnrm help　# 查看nrm帮助\nnrm home <registry>　# 跳转到指定源的官网\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# nrm使用\n\n如果在你的网络不太理想或者受到其他网络限制导致不能使用npm原本的源进行下载时，nrm就非常有用了，你只需要：\n\nnrm ls # 查看可用的源\nnrm use <registry>　# 切换到指定源\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"GitHub高级搜索技巧",frontmatter:{feed:{enable:!0},title:"GitHub高级搜索技巧",date:"2019-12-25T14:27:01.000Z",permalink:"/github-adv-search-tips.html",categories:["技术","GitHub技巧"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"GitHub高级搜索技巧\nin:name &lt;关键字&gt;\n仓库名称带关键字查询\nin:description &lt;关键字&gt;\n仓库描述带关键字查询\nin:readme &lt;关键字&gt;\nREADME文件带关键字查询",meta:[{name:"twitter:title",content:"GitHub高级搜索技巧"},{name:"twitter:description",content:"GitHub高级搜索技巧\nin:name &lt;关键字&gt;\n仓库名称带关键字查询\nin:description &lt;关键字&gt;\n仓库描述带关键字查询\nin:readme &lt;关键字&gt;\nREADME文件带关键字查询"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/01.GitHub%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"GitHub高级搜索技巧"},{property:"og:description",content:"GitHub高级搜索技巧\nin:name &lt;关键字&gt;\n仓库名称带关键字查询\nin:description &lt;关键字&gt;\n仓库描述带关键字查询\nin:readme &lt;关键字&gt;\nREADME文件带关键字查询"},{property:"og:url",content:"https://dbdgs.cn/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/01.GitHub%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2019-12-25T14:27:01.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"GitHub高级搜索技巧"},{itemprop:"description",content:"GitHub高级搜索技巧\nin:name &lt;关键字&gt;\n仓库名称带关键字查询\nin:description &lt;关键字&gt;\n仓库描述带关键字查询\nin:readme &lt;关键字&gt;\nREADME文件带关键字查询"}]},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/01.GitHub%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html",relativePath:"03.技术/02.GitHub技巧/01.GitHub高级搜索技巧.md",key:"v-4798fbce",path:"/github-adv-search-tips.html",excerpt:'<h1 id="github高级搜索技巧"><a class="header-anchor" href="#github高级搜索技巧">#</a> GitHub高级搜索技巧</h1>\n<p><code>in:name &lt;关键字&gt;</code>\n仓库名称带关键字查询</p>\n<p><code>in:description &lt;关键字&gt;</code>\n仓库描述带关键字查询</p>\n<p><code>in:readme &lt;关键字&gt;</code>\nREADME文件带关键字查询</p>\n',headersStr:null,content:'# GitHub高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> README文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000K的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> LICENSE为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为Java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n1\n2\n3\n4\n5\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',normalizedContent:'# github高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> readme文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000k的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> license为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n1\n2\n3\n4\n5\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"nodejs递归读取所有文件",frontmatter:{feed:{enable:!0},title:"nodejs递归读取所有文件",date:"2019-12-26T15:57:32.000Z",permalink:"/nodejs-recursive.html",categories:["技术","Nodejs"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"`js",meta:[{name:"twitter:title",content:"nodejs递归读取所有文件"},{name:"twitter:description",content:"`js"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/03.%E6%8A%80%E6%9C%AF/03.Nodejs/01.nodejs%E9%80%92%E5%BD%92%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"nodejs递归读取所有文件"},{property:"og:description",content:"`js"},{property:"og:url",content:"https://dbdgs.cn/03.%E6%8A%80%E6%9C%AF/03.Nodejs/01.nodejs%E9%80%92%E5%BD%92%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2019-12-26T15:57:32.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"nodejs递归读取所有文件"},{itemprop:"description",content:"`js"}]},regularPath:"/03.%E6%8A%80%E6%9C%AF/03.Nodejs/01.nodejs%E9%80%92%E5%BD%92%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6.html",relativePath:"03.技术/03.Nodejs/01.nodejs递归读取所有文件.md",key:"v-14dd923c",path:"/nodejs-recursive.html",headersStr:null,content:"# nodejs递归读取所有文件\n\n\nvar fs = require('fs');\nvar path = require('path');\n \nfunction readFileList(dir, filesList = []) {\n    const files = fs.readdirSync(dir);\n    console.log(files);\n    files.forEach((item, index) => {\n        var fullPath = path.join(dir, item);\n        const stat = fs.statSync(fullPath);\n        if (stat.isDirectory()) {      \n            readFileList(path.join(dir, item), filesList);  //递归读取文件\n        } else {                \n            filesList.push(fullPath);                     \n        }        \n    });\n    return filesList;\n}\n \nvar filesList = [];\nreadFileList(__dirname,filesList);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# nodejs递归读取所有文件\n\n\nvar fs = require('fs');\nvar path = require('path');\n \nfunction readfilelist(dir, fileslist = []) {\n    const files = fs.readdirsync(dir);\n    console.log(files);\n    files.foreach((item, index) => {\n        var fullpath = path.join(dir, item);\n        const stat = fs.statsync(fullpath);\n        if (stat.isdirectory()) {      \n            readfilelist(path.join(dir, item), fileslist);  //递归读取文件\n        } else {                \n            fileslist.push(fullpath);                     \n        }        \n    });\n    return fileslist;\n}\n \nvar fileslist = [];\nreadfilelist(__dirname,fileslist);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"解决百度无法收录搭建在GitHub上的个人博客的问题",frontmatter:{feed:{enable:!0},title:"解决百度无法收录搭建在GitHub上的个人博客的问题",date:"2019-12-25T14:27:01.000Z",permalink:"/baidu-shoulu-github.html",categories:["技术","博客搭建"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"解决百度无法收录搭建在GitHub上的静态博客的问题\n注意\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\n\n背景\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 Forbidden的错误。",meta:[{name:"twitter:title",content:"解决百度无法收录搭建在GitHub上的个人博客的问题"},{name:"twitter:description",content:"解决百度无法收录搭建在GitHub上的静态博客的问题\n注意\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\n\n背景\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 Forbidden的错误。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/01.%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E6%97%A0%E6%B3%95%E6%94%B6%E5%BD%95%E6%90%AD%E5%BB%BA%E5%9C%A8GitHub%E4%B8%8A%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"解决百度无法收录搭建在GitHub上的个人博客的问题"},{property:"og:description",content:"解决百度无法收录搭建在GitHub上的静态博客的问题\n注意\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\n\n背景\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 Forbidden的错误。"},{property:"og:url",content:"https://dbdgs.cn/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/01.%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E6%97%A0%E6%B3%95%E6%94%B6%E5%BD%95%E6%90%AD%E5%BB%BA%E5%9C%A8GitHub%E4%B8%8A%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2019-12-25T14:27:01.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"解决百度无法收录搭建在GitHub上的个人博客的问题"},{itemprop:"description",content:"解决百度无法收录搭建在GitHub上的静态博客的问题\n注意\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\n\n背景\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 Forbidden的错误。"}]},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/01.%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E6%97%A0%E6%B3%95%E6%94%B6%E5%BD%95%E6%90%AD%E5%BB%BA%E5%9C%A8GitHub%E4%B8%8A%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98.html",relativePath:"03.技术/04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.md",key:"v-38983e24",path:"/baidu-shoulu-github.html",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:74},{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:172},{level:3,title:"如何知道百度有没有收录？",slug:"如何知道百度有没有收录",normalizedTitle:"如何知道百度有没有收录？",charIndex:1215},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:1277}],excerpt:'<h1 id="解决百度无法收录搭建在github上的静态博客的问题"><a class="header-anchor" href="#解决百度无法收录搭建在github上的静态博客的问题">#</a> 解决百度无法收录搭建在GitHub上的静态博客的问题</h1>\n<div class="custom-block warning"><p class="custom-block-title">注意</p>\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href="https://github.com/dbdgs/dbdgs.github.io" target="_blank" rel="nofollow noopener noreferrer">README<OutboundLink/></a>。</p>\n</div>\n<h2 id="背景"><a class="header-anchor" href="#背景">#</a> 背景</h2>\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\n',headersStr:"背景 解决方案 如何知道百度有没有收录？ 相关文章",content:"# 解决百度无法收录搭建在GitHub上的静态博客的问题\n\n注意\n\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\n\n\n# 背景\n\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 Forbidden的错误。\n\n\n# 解决方案\n\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\n\n步骤：\n\n1、注册coding账号，创建仓库，把代码推送到coding仓库，并开启pages服务。\n\n> git 操作部分和使用github的差不多，不了解git操作的可以看我的另一篇文章：Git使用手册\n\n2、我的博客项目使用vuepress搭建的，使用的是如下自动部署脚本，同时将代码推送到github和conding。\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# github\necho 'b.dbdgs.cn' > CNAME\ngit init\ngit add -A\ngit commit -m 'deploy'\ngit push -f git@github.com:xugaoyi/blog.git master:gh-pages # 发布到github\n\n# coding\necho 'dbdgs.cn' > CNAME\ngit add -A\ngit commit -m 'deploy'\ngit push -f git@git.dev.tencent.com:xugaoyi/xugaoyi.git master # 发布到coding\n\ncd - # 退回开始所在目录\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 因为我想给两个平台上绑定不同的自定义域名，因此我分开创建了CNAME文件。\n\n3、有自定义域名的，也可以在coding pages绑定自定义域名，域名DNS解析中添加CNAME记录指向coding pages的站点地址即可。（没有自定义域名的可忽略，同时把自动部署脚本中的创建CNAME文件的脚本去掉）\n\n最后，使用百度站长的抓取诊断，发现抓取成功啦，再使用百度站长的链接提交功能，把链接提交给百度，过一段时间就可能在百度搜索中搜索到啦。\n\n\n# 如何知道百度有没有收录？\n\n在百度搜索框中使用site:<链接地址>，如：\n\nsite:dbdgs.cn\n\n\n1\n\n\n\n# 相关文章\n\n《GitHub Actions 定时运行代码：每天定时百度链接推送》",normalizedContent:"# 解决百度无法收录搭建在github上的静态博客的问题\n\n注意\n\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的readme。\n\n\n# 背景\n\n由于github禁止百度爬虫访问，造成托管在github pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 forbidden的错误。\n\n\n# 解决方案\n\n同时将博客同时同步托管到github pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\n\n步骤：\n\n1、注册coding账号，创建仓库，把代码推送到coding仓库，并开启pages服务。\n\n> git 操作部分和使用github的差不多，不了解git操作的可以看我的另一篇文章：git使用手册\n\n2、我的博客项目使用vuepress搭建的，使用的是如下自动部署脚本，同时将代码推送到github和conding。\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# github\necho 'b.dbdgs.cn' > cname\ngit init\ngit add -a\ngit commit -m 'deploy'\ngit push -f git@github.com:xugaoyi/blog.git master:gh-pages # 发布到github\n\n# coding\necho 'dbdgs.cn' > cname\ngit add -a\ngit commit -m 'deploy'\ngit push -f git@git.dev.tencent.com:xugaoyi/xugaoyi.git master # 发布到coding\n\ncd - # 退回开始所在目录\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 因为我想给两个平台上绑定不同的自定义域名，因此我分开创建了cname文件。\n\n3、有自定义域名的，也可以在coding pages绑定自定义域名，域名dns解析中添加cname记录指向coding pages的站点地址即可。（没有自定义域名的可忽略，同时把自动部署脚本中的创建cname文件的脚本去掉）\n\n最后，使用百度站长的抓取诊断，发现抓取成功啦，再使用百度站长的链接提交功能，把链接提交给百度，过一段时间就可能在百度搜索中搜索到啦。\n\n\n# 如何知道百度有没有收录？\n\n在百度搜索框中使用site:<链接地址>，如：\n\nsite:dbdgs.cn\n\n\n1\n\n\n\n# 相关文章\n\n《github actions 定时运行代码：每天定时百度链接推送》",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"new命令原理",frontmatter:{feed:{enable:!0},title:"new命令原理",date:"2019-12-25T14:27:01.000Z",permalink:"/p/new-commands-principles.html",categories:["前端","JavaScript文章"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"new命令原理\n使用new命令时，它后面的函数依次执行下面的步骤：\n\n创建一个空对象，作为将要返回的实例对象。\n将这个空对象的原型，指向构造函数的prototype属性。\n将这个空对象赋值给函数内部的this关键字。\n开始执行构造函数内部的代码。\n如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\n",meta:[{name:"twitter:title",content:"new命令原理"},{name:"twitter:description",content:"new命令原理\n使用new命令时，它后面的函数依次执行下面的步骤：\n\n创建一个空对象，作为将要返回的实例对象。\n将这个空对象的原型，指向构造函数的prototype属性。\n将这个空对象赋值给函数内部的this关键字。\n开始执行构造函数内部的代码。\n如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\n"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/04.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/02.new%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"new命令原理"},{property:"og:description",content:"new命令原理\n使用new命令时，它后面的函数依次执行下面的步骤：\n\n创建一个空对象，作为将要返回的实例对象。\n将这个空对象的原型，指向构造函数的prototype属性。\n将这个空对象赋值给函数内部的this关键字。\n开始执行构造函数内部的代码。\n如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\n"},{property:"og:url",content:"https://dbdgs.cn/04.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/02.new%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2019-12-25T14:27:01.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"new命令原理"},{itemprop:"description",content:"new命令原理\n使用new命令时，它后面的函数依次执行下面的步骤：\n\n创建一个空对象，作为将要返回的实例对象。\n将这个空对象的原型，指向构造函数的prototype属性。\n将这个空对象赋值给函数内部的this关键字。\n开始执行构造函数内部的代码。\n如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\n"}]},regularPath:"/04.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/02.new%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86.html",relativePath:"04.前端/25.JavaScript文章/02.new命令原理.md",key:"v-34c996ae",path:"/p/new-commands-principles.html",excerpt:'<h1 id="new命令原理"><a class="header-anchor" href="#new命令原理">#</a> new命令原理</h1>\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\n<ol>\n<li>创建一个空对象，作为将要返回的实例对象。</li>\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\n<li>将这个空对象赋值给函数内部的this关键字。</li>\n<li>开始执行构造函数内部的代码。</li>\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\n</ol>\n',headersStr:null,content:"# new命令原理\n\n使用new命令时，它后面的函数依次执行下面的步骤：\n\n 1. 创建一个空对象，作为将要返回的实例对象。\n 2. 将这个空对象的原型，指向构造函数的prototype属性。\n 3. 将这个空对象赋值给函数内部的this关键字。\n 4. 开始执行构造函数内部的代码。\n 5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\n\n// 构造函数\nfunction Person(name,age){\n    this.name = name\n    this.age = age\n}\n\n// 自定义_new\nfunction _new() {\n  // 将 arguments 对象转为数组\n  var args = [].slice.call(arguments);\n  // 取出构造函数\n  var constructor = args.shift();\n  // 创建一个空对象，继承构造函数的 prototype 属性\n  var context = Object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, args);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n}\n\n// 自定义_new2\nfunction _new2(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {\n  // 创建一个空对象，并继承构造函数的 prototype 属性\n  var context = Object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, params);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n  // （当用户在构造函数内部自定义返回对象的话则使用该对象，否则返回context）\n}\n\n\n// 通过自定义_new 返回实例\nvar actor = _new(Person, '张三', 28);\nconsole.log(actor.name) // 张三\n\n// 通过自定义_new2 返回实例\nvar actor2 = _new2(Person, ['李四', 29]);\nconsole.log(actor2.name) // 李四\n\n// 通过new命令 返回实例\nvar actor3 = new Person('王五',30)\nconsole.log(actor3.name) // 王五\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n",normalizedContent:"# new命令原理\n\n使用new命令时，它后面的函数依次执行下面的步骤：\n\n 1. 创建一个空对象，作为将要返回的实例对象。\n 2. 将这个空对象的原型，指向构造函数的prototype属性。\n 3. 将这个空对象赋值给函数内部的this关键字。\n 4. 开始执行构造函数内部的代码。\n 5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\n\n// 构造函数\nfunction person(name,age){\n    this.name = name\n    this.age = age\n}\n\n// 自定义_new\nfunction _new() {\n  // 将 arguments 对象转为数组\n  var args = [].slice.call(arguments);\n  // 取出构造函数\n  var constructor = args.shift();\n  // 创建一个空对象，继承构造函数的 prototype 属性\n  var context = object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, args);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n}\n\n// 自定义_new2\nfunction _new2(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {\n  // 创建一个空对象，并继承构造函数的 prototype 属性\n  var context = object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, params);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n  // （当用户在构造函数内部自定义返回对象的话则使用该对象，否则返回context）\n}\n\n\n// 通过自定义_new 返回实例\nvar actor = _new(person, '张三', 28);\nconsole.log(actor.name) // 张三\n\n// 通过自定义_new2 返回实例\nvar actor2 = _new2(person, ['李四', 29]);\nconsole.log(actor2.name) // 李四\n\n// 通过new命令 返回实例\nvar actor3 = new person('王五',30)\nconsole.log(actor3.name) // 王五\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"Vue项目开发前的一些准备工作",frontmatter:{feed:{enable:!0},title:"Vue项目开发前的一些准备工作",date:"2020-02-21T14:40:19.000Z",permalink:"/vue-dev-prepare.html",categories:["前端","Vue文章"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"Vue项目开发前的一些准备工作\n在使用Vue CLi创建一个项目之后，正式进入开发前可能需要做一些工作，比如引入重置样式表、解决移动端点击300ms延迟等等。",meta:[{name:"twitter:title",content:"Vue项目开发前的一些准备工作"},{name:"twitter:description",content:"Vue项目开发前的一些准备工作\n在使用Vue CLi创建一个项目之后，正式进入开发前可能需要做一些工作，比如引入重置样式表、解决移动端点击300ms延迟等等。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/04.%E5%89%8D%E7%AB%AF/30.Vue%E6%96%87%E7%AB%A0/10.Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"Vue项目开发前的一些准备工作"},{property:"og:description",content:"Vue项目开发前的一些准备工作\n在使用Vue CLi创建一个项目之后，正式进入开发前可能需要做一些工作，比如引入重置样式表、解决移动端点击300ms延迟等等。"},{property:"og:url",content:"https://dbdgs.cn/04.%E5%89%8D%E7%AB%AF/30.Vue%E6%96%87%E7%AB%A0/10.Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-02-21T14:40:19.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"Vue项目开发前的一些准备工作"},{itemprop:"description",content:"Vue项目开发前的一些准备工作\n在使用Vue CLi创建一个项目之后，正式进入开发前可能需要做一些工作，比如引入重置样式表、解决移动端点击300ms延迟等等。"}]},regularPath:"/04.%E5%89%8D%E7%AB%AF/30.Vue%E6%96%87%E7%AB%A0/10.Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html",relativePath:"04.前端/30.Vue文章/10.Vue项目开发前的一些准备工作.md",key:"v-30404e92",path:"/vue-dev-prepare.html",headers:[{level:2,title:"修改",slug:"meta-修改",normalizedTitle:"修改",charIndex:93},{level:2,title:"重置样式表",slug:"重置样式表",normalizedTitle:"重置样式表",charIndex:59},{level:2,title:"解决移动端点击300ms延迟",slug:"解决移动端点击300ms延迟",normalizedTitle:"解决移动端点击300ms延迟",charIndex:65}],excerpt:'<h1 id="vue项目开发前的一些准备工作"><a class="header-anchor" href="#vue项目开发前的一些准备工作">#</a> Vue项目开发前的一些准备工作</h1>\n<p>在使用Vue CLi创建一个项目之后，正式进入开发前可能需要做一些工作，比如引入重置样式表、解决移动端点击300ms延迟等等。</p>\n',headersStr:"修改 重置样式表 解决移动端点击300ms延迟",content:'# Vue项目开发前的一些准备工作\n\n在使用Vue CLi创建一个项目之后，正式进入开发前可能需要做一些工作，比如引入重置样式表、解决移动端点击300ms延迟等等。\n\n\n# <meta>修改\n\n根据项目需要看情况是否需要修改meta\n\n<meta name="viewport" content="width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no">\n\n\n1\n\n\n\n# 重置样式表\n\n为了统一每个浏览器的样式，以及去掉一些浏览器默认样式，需要加载引入重置样式表，常用的有 normalize.css。或使用如下reset.css（可根据项目需要作修改）。\n\n@charset "utf-8";html{background-color:#fff;color:#000;font-size:12px}\nbody,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,figure,form,fieldset,legend,input,textarea,button,p,blockquote,th,td,pre,xmp{margin:0;padding:0}\nbody,input,textarea,button,select,pre,xmp,tt,code,kbd,samp{line-height:1.5;font-family:tahoma,arial,"Hiragino Sans GB",simsun,sans-serif}\nh1,h2,h3,h4,h5,h6,small,big,input,textarea,button,select{font-size:100%}\nh1,h2,h3,h4,h5,h6{font-family:tahoma,arial,"Hiragino Sans GB","微软雅黑",simsun,sans-serif}\nh1,h2,h3,h4,h5,h6,b,strong{font-weight:normal}\naddress,cite,dfn,em,i,optgroup,var{font-style:normal}\ntable{border-collapse:collapse;border-spacing:0;text-align:left}\ncaption,th{text-align:inherit}\nul,ol,menu{list-style:none}\nfieldset,img{border:0}\nimg,object,input,textarea,button,select{vertical-align:middle}\narticle,aside,footer,header,section,nav,figure,figcaption,hgroup,details,menu{display:block}\naudio,canvas,video{display:inline-block;*display:inline;*zoom:1}\nblockquote:before,blockquote:after,q:before,q:after{content:"\\0020"}\ntextarea{overflow:auto;resize:vertical}\ninput,textarea,button,select,a{outline:0 none;border: none;}\nbutton::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}\nmark{background-color:transparent}\na,ins,s,u,del{text-decoration:none}\nsup,sub{vertical-align:baseline}\nhtml {overflow-x: hidden;height: 100%;font-size: 50px;-webkit-tap-highlight-color: transparent;}\nbody {font-family: Arial, "Microsoft Yahei", "Helvetica Neue", Helvetica, sans-serif;color: #333;font-size: .28em;line-height: 1;-webkit-text-size-adjust: none;}\nhr {height: .02rem;margin: .1rem 0;border: medium none;border-top: .02rem solid #cacaca;}\na {color: #25a4bb;text-decoration: none;}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n在main.js引入样式\n\nimport \'./assets/styles/reset.css\'\n\n\n1\n\n\n\n# 解决移动端点击300ms延迟\n\n通过npm安装 fastclick\n\nnpm install fastclick -S\n\n\n1\n\n\n在main.js导入和使用\n\nimport fastClick from \'fastclick\'\nfastClick.attach(document.body)\n\n\n1\n2\n',normalizedContent:'# vue项目开发前的一些准备工作\n\n在使用vue cli创建一个项目之后，正式进入开发前可能需要做一些工作，比如引入重置样式表、解决移动端点击300ms延迟等等。\n\n\n# <meta>修改\n\n根据项目需要看情况是否需要修改meta\n\n<meta name="viewport" content="width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no">\n\n\n1\n\n\n\n# 重置样式表\n\n为了统一每个浏览器的样式，以及去掉一些浏览器默认样式，需要加载引入重置样式表，常用的有 normalize.css。或使用如下reset.css（可根据项目需要作修改）。\n\n@charset "utf-8";html{background-color:#fff;color:#000;font-size:12px}\nbody,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,figure,form,fieldset,legend,input,textarea,button,p,blockquote,th,td,pre,xmp{margin:0;padding:0}\nbody,input,textarea,button,select,pre,xmp,tt,code,kbd,samp{line-height:1.5;font-family:tahoma,arial,"hiragino sans gb",simsun,sans-serif}\nh1,h2,h3,h4,h5,h6,small,big,input,textarea,button,select{font-size:100%}\nh1,h2,h3,h4,h5,h6{font-family:tahoma,arial,"hiragino sans gb","微软雅黑",simsun,sans-serif}\nh1,h2,h3,h4,h5,h6,b,strong{font-weight:normal}\naddress,cite,dfn,em,i,optgroup,var{font-style:normal}\ntable{border-collapse:collapse;border-spacing:0;text-align:left}\ncaption,th{text-align:inherit}\nul,ol,menu{list-style:none}\nfieldset,img{border:0}\nimg,object,input,textarea,button,select{vertical-align:middle}\narticle,aside,footer,header,section,nav,figure,figcaption,hgroup,details,menu{display:block}\naudio,canvas,video{display:inline-block;*display:inline;*zoom:1}\nblockquote:before,blockquote:after,q:before,q:after{content:"\\0020"}\ntextarea{overflow:auto;resize:vertical}\ninput,textarea,button,select,a{outline:0 none;border: none;}\nbutton::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}\nmark{background-color:transparent}\na,ins,s,u,del{text-decoration:none}\nsup,sub{vertical-align:baseline}\nhtml {overflow-x: hidden;height: 100%;font-size: 50px;-webkit-tap-highlight-color: transparent;}\nbody {font-family: arial, "microsoft yahei", "helvetica neue", helvetica, sans-serif;color: #333;font-size: .28em;line-height: 1;-webkit-text-size-adjust: none;}\nhr {height: .02rem;margin: .1rem 0;border: medium none;border-top: .02rem solid #cacaca;}\na {color: #25a4bb;text-decoration: none;}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n在main.js引入样式\n\nimport \'./assets/styles/reset.css\'\n\n\n1\n\n\n\n# 解决移动端点击300ms延迟\n\n通过npm安装 fastclick\n\nnpm install fastclick -s\n\n\n1\n\n\n在main.js导入和使用\n\nimport fastclick from \'fastclick\'\nfastclick.attach(document.body)\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"小程序笔记",frontmatter:{feed:{enable:!0},title:"小程序笔记",date:"2019-12-25T14:27:01.000Z",permalink:"/note/wx-miniprogram",tags:[null],categories:["前端","学习笔记"],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"",meta:[{name:"twitter:title",content:"小程序笔记"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/04.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/22.%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"小程序笔记"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/04.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/22.%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2019-12-25T14:27:01.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"小程序笔记"},{itemprop:"description",content:""}]},regularPath:"/04.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/22.%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0.html",relativePath:"04.前端/40.学习笔记/22.小程序笔记.md",key:"v-1165f877",path:"/note/wx-miniprogram/",headers:[{level:2,title:"基础课程部分",slug:"基础课程部分",normalizedTitle:"基础课程部分",charIndex:12},{level:2,title:"实战课程部分",slug:"实战课程部分",normalizedTitle:"实战课程部分",charIndex:2769},{level:2,title:"《发现》页面",slug:"《发现》页面",normalizedTitle:"《发现》页面",charIndex:17269},{level:2,title:"《我的》页面",slug:"《我的》页面",normalizedTitle:"《我的》页面",charIndex:32330},{level:3,title:"版本更新检测",slug:"版本更新检测",normalizedTitle:"版本更新检测",charIndex:35362},{level:3,title:"性能优化",slug:"性能优化",normalizedTitle:"性能优化",charIndex:35957},{level:3,title:"场景值scene的作用与应用场景",slug:"场景值scene的作用与应用场景",normalizedTitle:"场景值scene的作用与应用场景",charIndex:36016},{level:3,title:'小程序的"SEO"---页面收录sitemap',slug:"小程序的-seo-页面收录sitemap",normalizedTitle:"小程序的&quot;seo&quot;---页面收录sitemap",charIndex:null},{level:3,title:"小程序上线审核流程",slug:"小程序上线审核流程",normalizedTitle:"小程序上线审核流程",charIndex:37059},{level:2,title:"后台管理系统",slug:"后台管理系统",normalizedTitle:"后台管理系统",charIndex:37105}],headersStr:'基础课程部分 实战课程部分 《发现》页面 《我的》页面 版本更新检测 性能优化 场景值scene的作用与应用场景 小程序的"SEO"---页面收录sitemap 小程序上线审核流程 后台管理系统',content:'# 小程序笔记\n\n\n# 基础课程部分\n\n# 微信公众平台\n\nhttps://mp.weixin.qq.com/\n\n注册时可选择类型：订阅号、服务号、小程序、企业微信\n\n每个邮箱仅能注册一个小程序。\n\n个人类型小程序：无法使用微信支付、无法使用卡包功能\n\n# 小程序文档API\n\n小程序开发文档\n\n# 微信开放社区\n\n微信开发社区\n\n# 目录说明\n\n默认目录\n\npages-----------------------页面相关\n\nindex ----------------- 首页文件夹\n\nindex.js ------------首页js\n\nindex.json---------首页配置\n\nindex.wxml-------首页html\n\nindex.wxss--------首页css\n\nutils------------------------工具相关\n\napp.js ----------------------项目总js\n\napp.json-------------------全局配置( 页面路由以及头部、底部导航的配置等)\n\napp.wxss -----------------项目总样式css\n\nproject.config.json ----项目配置\n\n代码构成\n\n.json ：配置文件，以json格式存储配置\n\n项目中有三种配置：项目配置（project.config.json）、全局配置（app.json）、页面配置（index.json）\n\n.wxml: 相当于html文件\n\n.wxss: 相当于css\n\n.js : 就是js\n\n# 文件说明\n\nproject.config.json项目配置 部分代码说明\n\nsetting：{\n\nurlCheck 是否检测安全的域名\n\nes6 是否把es6转es5\n\npostcss 是否把css样式自动补全\n\nminified 是否压缩\n\n}\n\napp.json 全局配置\n\n全局配置API\n\nwxml 相关介绍\n\nwxmlAPI\n\n<view>{{motto}}</view>\n\n循环渲染\n<view wx:for="{{list}}" wx:key="{{index}}">\n      {{index}} {{item}}\n</view>\n\n改变for循环item和index的名称\n<block wx:for="{{list}}" wx:for-item="data" wx:for-index="inx">\n\t{{inx}} {{data}}\n</block>\n\n条件渲染 (类似vue的v-if、v-else)\n<view wx:if="{{isLogin}}">已登录</view>\n<view wx:else>请登录</view>\n\n条件显示（类似vue的v-show）\n<view hidden="{{isLogin}}">显示内容</view>\n\n绑定点击事件\n<button bindtap=“tapName”>按钮</button>\n\nPage({\n  tapName: function(event) {\n    console.log(event)\n  }\n})\n...\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nwxss 相关介绍\n\nwxssAPI\n\n尺寸单位：rpx，根据屏幕宽度自适应。\n\n引入外部wxss：@import ’...‘\n\njs相关介绍\n\nWXS（WeiXin Script）是小程序的一套脚本语言\n\nwxsAPI\n\n绑定点击事件\n\n<button bindtap=“onTapHandler”>点我+1</button>\n<view>{{count}}</view>\n\n\n1\n2\n\n\nPage({\n  data: {\n    count: 0\n  },\n  onTapHandler: function() {\n  \tthis.setData({\n  \t\tcount: this.data.count++\n  \t})\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 阻止事件冒泡\n\n把绑定方式 bindtap 换成 catchtap 即可。\n\n# 第三方库\n\nWeUI\n\nweUI是一套同微信原生视觉体验一致的基础样式库\n\niView Weapp\n\n一套高质量的微信小程序UI组件库\n\nVant Weapp\n\n轻量、可靠的小程序UI组件库\n\n# 云开发\n\n小程序传统开发模式\n\n客户端 -----\x3e 服务端（后端代码、数据库）------\x3e 运维（DB维护、文件存储、内容加速、网络防护、容器服务、负载均衡、安全加固等...）\n\n小程序云开发模式\n\n客户端 -----\x3e 云开发（云函数、云数据库、云存储）\n\n传统开发 VS 云开发\n\n开发效率低 Serverless（无服务）\n\n运维成本高 开发者更关注业务逻辑\n\n无服务（Serverless）开发是未来的发展趋势\n\n# 云开发三大基础能力\n\n# 云函数\n\n（相当于传统开发中的后台接口）\n\n获取appid、获取openid、生成分享图、调用腾讯云SDK ...\n\n# 云数据库\n\n数据的增、删、改、查 ...\n\n# 云存储\n\n管理文件、上传文件、下载文件、分享文件 ...\n\n每个小程序账号可免费创建两个环境，建议：开发环境、生成环境\n\n# 云数据库能力\n\n云开发提供了一个json数据库，提供2GB免费存储空间。\n\n# 数据类型\n\nString 字符串\n\nNumber 数字\n\nObject 对象\n\nArray 数组\n\nBoolean 布尔值\n\nGeoPoint 地理位置点\n\nDate 时间 （精确到毫秒ms，客户端时间）\n\nNull 空\n\n# 操作云数据库\n\n小程序控制（读写数据库受权限限制）\n\n云函数控制（拥有所有读写数据库的权限）\n\n控制台控制（拥有所有读写数据库的权限）\n\n# 云数据库权限管理\n\n仅创建者可写，所有人可读 （适合于文章）\n\n仅创建者可读写 (适用于私密内容)\n\n仅管理端可写，所有人可读（适用于商品信息）\n\n仅管理端可读写（适用于后台敏感数据）\n\n# 操作云数据库\n\n//初始化数据库\nconst db = wx.cloud.database() // 小程序端初始化数据库，如果在云函数端不需要加wx\n\n//切换环境(开发环境/生产环境)\nconst testDB = wx.cloud.database({\n\tenv: \'test\'\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 实战课程部分\n\n# serverless（无服务）\n\n概念：函数即服务，当需要后端服务的时候，不需要关心后端的IP地址、域名，只需要像调用普通函数一样既可以实现调用。\n\n# 云开发优势\n\n快速上线、专注核心业务、独立开发一个完整的微信小程序、不需要学习新的语言，只需要会javascript、无需运维， 节约成本、数据安全、\n\n# 云开发提供能力\n\n云函数：在云端运行的代码，微信私有协议天然鉴权 （理解：相当于后端部分）\n\n云数据库：一个既可以在小程序端操作又可以在云函数中操作的JSON数据库\n\n云存储：在云端存储文件，可以在云端控制台可视化管理\n\n云调用：基于云函数免鉴权使用小程序开放接口的能力（比如说给用户推送消息等）\n\nHTTP API：使用HTTP API开发者可在已有服务器上访问云资源，实现与云开发的互通（作用：对原有传统模式下开发的小程序，可以与云开发进行互通）\n\n# appID\n\n每个小程序唯一的id\n\n# 云开发项目默认目录结构\n\ncloudfunctions ----------------------------云函数\n\ncallback ---------------------------------- 回调函数\n\nconfig.json ---------------------------\n\nindex.js --------------------------------\n\npackage.json ------------------------\n\necho ----------------------------------------\n\nlogin ----------------------------------------\n\nopenapi -----------------------------------\n\nminiprogram ------------------------------- 小程序\n\nimages ------------------------------------- 图片\n\npages --------------------------------------- 页面\n\nstyle ----------------------------------------- 样式\n\napp.js --------------------------------------- 项目js\n\napp.json ----------------------------------- 全局配置\n\napp.wxss ---------------------------------- 项目样式\n\nsitemap.json ----------------------------- （小程序SEO相关）\n\nproject.config.json ----------------------- 项目配置\n\n# 云开发环境\n\n云开发可创建两个环境，建议一个为开发环境，一个为生产环境\n\n# 开发前的准备\n\n开发工具 > 右上角详情 > 本地设置 > 调试基础库 设置为最新版本\n\napp.js > wx.cloud.init > env 设置环境ID\n\n# project.config.json 文件说明\n\nminiprogramRoot 小程序前端代码目录\n\ncloudfunctionRoot 云函数代码目录\n\n# app.json\n\npages 设置页面 ，设置后会自动在pages目录下生成相应的目录和文件\n\n设置底部导航按钮：\n\n"tabBar": {\n    "color": "#474747", // 文字颜色\n    "selectedColor": "#d43c43", // 文字选中颜色\n    "list": [{ // 按钮列表，2-5项\n      "pagePath": "p/playlist/playlist", // 按钮对应页面\n      "text": "音乐", // 文字\n      "iconPath": "images/music.png", // 图标路径\n      "selectedIconPath": "images/music-actived.png" // 选中图标的路径\n    },\n    {\n      "pagePath": "p/blog/blog",\n      "text": "发现",\n      "iconPath": "images/blog.png",\n      "selectedIconPath": "images/blog-actived.png"\n    },\n    {\n      "pagePath": "p/profile/profile",\n      "text": "我的",\n      "iconPath": "images/profile.png",\n      "selectedIconPath": "images/profile-actived.png"\n    }]\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 图标来自于 https://www.iconfont.cn\n> \n> 阿里巴巴图标库，包含矢量图标、字体图标、字体等\n\n# 代码规范\n\n很多公司借鉴的代码规范：https://github.com/airbnb/javascript\n\n# 《音乐》页面开发\n\n \x3c!-- 轮播图组件 参数：indicator-dots 小圆点，autoplay 自动播放, interval 间隔时间，duration 动画时长 --\x3e\n<swiper indicator-dots="true" circular="true" interval="3000" duration="500">\n  <block wx:for="{{swiperImgUrls}}" wx:key="{{index}}"> \x3c!-- 空节点 --\x3e\n    <swiper-item>\n      <image src="{{item.url}}" mode="widthFix" class="img"></image>\n    </swiper-item>\n  </block>\n</swiper>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 自定义组件\n\n创建组件\n\n创建目录 components > 组件目录名称 > 右键 新建Component\n\n# 引入组件\n\n在page的json文件中：\n\n{\n  "usingComponents": {\n    "x-playlist":"/components/playlist/playlist"\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n在page的wxml中：\n\n<x-playlist> </x-playlist>\n\n\n1\n\n\n页面引入组件以及组件内部在引用子组件的方法是一样的，同样需要设置json文件。\n\n# 组件传值\n\n父组件中：在引入组件的时候自定义属性名称，并把数据传入子组件\n\n\x3c!-- 参数：playlist 自定义名称，传入组件的数据 --\x3e\n<x-playlist playlist="{{传入的数据}}"></x-playlist>\n\n\n1\n2\n\n\n子组件中： 子组件的js文件：\n\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    playlist:{ // 接收父组件传输的数据\n      type: Object // 数据类型\n    }\n   },\n       \n //子组件的wxml文件可直接引入数据{{playlist}}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# wx:key 的使用\n\nkey的值不建议使用index，因为当数据发生变化会dom结构产生变化时，使用index的地方不会随之变化。\n\n可以使用数据内部每项不一样的一个数值，如id\n\n<block wx:for="{{swiperImgUrls}}" wx:key="url"> 这里url不需要双大括号，如使用index则需要{{}}\n    <view>\n      <image src="{{item.url}}" mode="widthFix" class="img"></image>\n    </view>\n</block>\n \n<view class="playlist-container">\n  <block wx:for="{{playlist}}" wx:key="_id">\n    \x3c!-- 参数：playlist 自定义名称，传入组件的数据 --\x3e\n    <x-playlist playlist="{{item}}"></x-playlist>\n  </block>\n</view>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# async/await 语法\n\n目前，在云函数里，由于 Node 版本最低是 8.9，因此是天然支持 async/await 语法的。而在小程序端则不然。在微信开发者工具里，以及 Android 端手机（浏览器内核是 QQ浏览器的 X5），async/await是天然支持的，但 iOS 端手机在较低版本则不支持，因此需要引入额外的 文件。\n\n可把这个 runtime.js 文件引用到有使用 async/await 的文件当中。\n\n// 注意，必须命名为 regeneratorRuntime\nimport regeneratorRuntime from \'../../utils/runtime.js\'\n\n\n1\n2\n\n\n# 云函数的使用\n\ncloudfunctions目录 右键 新建 Node.js 云函数 > 输入目录名 getPlaylist\n\n在云函数中向第三方服务器发送请求要依赖第三方库\n\n安装依赖包\n\n云函数目录 getPlaylist 右键 在终端打开 打开命令行 输入命令：\n\nnpm install --save request\nnpm install --save request-promise\n\n\n1\n2\n\n\ngithub request-promise：https://github.com/request/request-promise\n\n然后写相应代码\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst rp = require(\'request-promise\') // 需安装依赖包\n\nconst URL = \'http://musicapi.xiecheng.live/personalized\'\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const playlist = await rp(URL).then((res) => {\n    return JSON.parse(res).result\n  })\n  console.log(playlist)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n写完代码，云函数目录 getPlaylist 右键 上传并部署：云端安装依赖（不上传node_modules） 进行上传部署代码到云端，等待上传成功，打开云开发控制台即可看到已经上传的云函数，并可对云函数进行测试。\n\n# 数据库操作\n\n数据库> 创建集合 > playlist\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst db = cloud.database() // 初始化数据库,如果在小程序端初始化数据库需要在前面加wx.\n\nconst rp = require(\'request-promise\') // 需安装依赖包\n\nconst URL = \'http://musicapi.xiecheng.live/personalized\' // 第三方服务器地址（老师从网易云获取的数据部署在其服务器，每天的数据会更新）\n\nconst playlistCollection = db.collection(\'playlist\') // 获取到数据库playlist集合\n\nconst MAX_LIMIT = 10 // 定义常量，获取数据库条数最大的限制\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  /**\n   * 注：\n   * - 关于数据库的操作都是异步操作，都需添加await关键字\n   * - console.log 打印在云开发控制台 云函数测试内查看\n   * - 单次获取数据库数据有条数限制，云函数端最多获取100条，小程序端最多获取20条\n   */\n\n  // const list = await playlistCollection.get() // 获取数据库集合的数据 （因为有条数限制，不直接用此方法）\n  \n  // 突破条数限制 （为了读取到全部数据然后与第三方服务器获取的数据进行对比去重）\n  const countResult = await playlistCollection.count() // 获取数据总条数 返回为对象\n  const total = countResult.total // 取得总条数\n  const batchTimes = Math.ceil(total / MAX_LIMIT)\n  const tasks = []\n  for(let i = 0; i < batchTimes; i++) {\n    let promise = playlistCollection.skip(i * MAX_LIMIT).limit(MAX_LIMIT).get() // 从第 skip 条开始取，最多取 limit 条数据\n    tasks.push(promise)\n  }\n  let list = {\n    data: []\n  }\n  if (tasks.length > 0) {\n    list = (await Promise.all(tasks)).reduce((acc, cur) => { // reduce数组方法 累积拼接\n      return {\n        data: acc.data.concat(cur.data)\n      }\n    })\n  }\n \n  // 获取第三方服务器端数据\n  const playlist = await rp(URL).then((res) => {\n    return JSON.parse(res).result\n  })\n\n  // 数据库与服务器数据对比去重（数据已存在数据库的无需再重复添加）\n  const newData = []\n  for(let i = 0, len1 = playlist.length; i < len1; i++) {\n    let flag = true\n    for(let j = 0, len2 = list.data.length; j < len2; j++) {\n      if(playlist[i].id === list.data[j].id){\n        flag = false\n        break\n      }\n    }\n    if(flag){\n      newData.push(playlist[i])\n    }\n  }\n\n  // 把数据插入数据库，需要单条插入\n  for (let i = 0, len = newData.length; i < len; i++) {\n    await playlistCollection.add({ // 给数据库集合添加数据\n      data: {\n        ...newData[i],\n        createTime: db.serverDate(), // db.serverDate() 获取服务器时间\n      }\n    }).then((res) => { // 数据添加成功\n      console.log(\'数据添加成功\')\n    }).catch((err) => { // 失败\n      console.error(err)\n    })\n  }\n  return newData.length // 插入多少条数据\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n# 查询数据库\n\n//云函数中查询数据库的例子：\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst TcbRouter = require(\'tcb-router\')\nconst db = cloud.database() // 初始化数据库\nconst blogCollection = db.collection(\'blog\') // 博客的数据库集合\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const app = new TcbRouter({ event }) // 初始化TcbRouter\n\n  app.router(\'list\', async (ctx, next) => {\n    // skip 从第几条开始查，limit 查几条数据，orderBy(排序字段，排序方式) 排序，排序方式desc降序/asc升序\n    ctx.body =  await blogCollection.skip(event.start).limit(event.count)\n    .orderBy(\'createTime\', \'desc\').get().then((res) => {\n      return res.data\n    })\n    \n  })\n  \n\n  return app.serve() // 必需返回\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 云函数调试\n\n云控制台中可会云函数进行云端测试\n\n在小程序调用云函数后，可查看云函数日志\n\n# 定时触发云函数\n\n如果云函数需要定时 / 定期执行，也就是定时触发，我们可以使用云函数定时触发器。配置了定时触发器的云函数，会在相应时间点被自动触发，函数的返回结果不会返回给调用方\n\n云函数目录下新建 config.json\n\nAPI\n\n{\n  "triggers": [\n    {\n      "name": "myTriggers",\n      "type": "timer",\n      "config":"0 0 10,14,16,20 * * * *" //表示每天的10点、14点、16点、20点触发一次\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n编辑好触发器之后，要在云函数目录 > 右键 > 上传触发器\n\n# 配置云函数超时时间\n\n当云函数比较复杂的时候，默认的超时时间3秒可能不能够满足需求，可以适当的设置更为合理的时间\n\n云开发控制台 > 云函数 > 配置 > 超时时间\n\n# 上拉加载与下拉刷新\n\npage页面json中：\n"enablePullDownRefresh": true\n\n\npage页面js中有这两个函数：\n\n /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh: function() {\n\t this.setData({\n      playlist: []\n    })\n    this._getPlaylist()\n  },\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom: function() {\n    this._getPlaylist()\n  },\n \n \n \n 下拉刷新请求完数据后\n wx.stopPullDownRefresh() // 停止下拉刷新动画\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 云函数路由优化tcb-router\n\n一个用户在一个云环境只能创建50个云函数\n\n假如小程序非常复杂，50个云函数不能够满足业务需求怎么办？\n\n相似的请求归类到同一个云函数处理\n\ntcb-router是一个koa风格的云函数路由库\n\n通俗理解就是可以把很多个接口归类到同一个云函数内。\n\ngithub-tcb-router: https://github.com/TencentCloudBase/tcb-router\n\nkoa洋葱模型...\n\n安装：\n\n在使用到tcb-router的云函数目录下打开命令行，输入命令进行安装\nnpm install --save tcb-router\n\n\n1\n2\n\n\n// 云函数的 index.js\nconst TcbRouter = require(\'router\'); // 必需\n\nexports.main = (event, context) => {\n    const app = new TcbRouter({ event });// 必需\n  \n    // app.use 表示该中间件会适用于所有的路由(全局中间件) 非必需\n    app.use(async (ctx, next) => { // 这个中间件表示所有路由都会调用到，而路由中间件为单独调用\n        ctx.data = {}; // 获取要传给小程序端的数据\n        ctx.data.openId = event.userInfo.openId // 这里获取到的openId将分布到所有路由\n        await next(); // 执行下一中间件\n    });\n\n    // 路由为数组表示，该中间件适用于 user 和 timer 两个路由\n    app.router([\'user\', \'timer\'], async (ctx, next) => {\n        ctx.data.company = \'Tencent\'; // 这里获取到的数据将分布到 user 和 timer 两个路由\n        await next(); // 执行下一中间件\n    });\n\n    // 路由为字符串，该中间件只适用于 user 路由\n    app.router(\'user\', async (ctx, next) => {\n        ctx.data.name = \'heyli\';  // 获取要传给小程序端的数据\n        await next(); // 执行下一中间件\n    }, async (ctx, next) => {\n        ctx.data.sex = \'male\'; // 获取要传给小程序端的数据\n        await next(); // 执行下一中间件\n    }, async (ctx) => {\n        ctx.data.city = \'Foshan\'; // 获取要传给小程序端的数据\n        // ctx.body 返回数据到小程序端\n        ctx.body = { code: 0, data: ctx.data};  // 要传给小程序端的数据\n    });\n\n    // 路由为字符串，该中间件只适用于 timer 路由\n    app.router(\'timer\', async (ctx, next) => {\n        ctx.data.name = \'flytam\';\n        await next(); // 执行下一中间件\n    }, async (ctx, next) => {\n        ctx.data.sex = await new Promise(resolve => {\n        // 等待500ms，再执行下一中间件\n        setTimeout(() => {\n            resolve(\'male\');\n        }, 500);\n        });\n        await next(); // 执行下一中间件\n    }, async (ctx)=>  {\n        ctx.data.city = \'Taishan\';\n\n        // ctx.body 返回数据到小程序端\n        ctx.body = { code: 0, data: ctx.data };\n    });\n\n    return app.serve(); // 必需\n\n}\n\n\n小程序端：\n\n// 调用名为 router 的云函数，路由名为 user\nwx.cloud.callFunction({\n    // 要调用的云函数名称\n    name: "router",\n    // 传递给云函数的参数\n    data: {\n        $url: "user", // 要调用的路由的路径，传入准确路径或者通配符*\n        other: "xxx"\n    }\n}).then((res) => {\n\tconsole.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n上面tcb-router代码会按照洋葱模型执行，即先从上往下逐个进入中间件，再从下往上逐个退出中间件。\n\n# 本地存储（缓存）\n\n// 存储：\nwx.setStorageSync(key, data) // 同步存储（存储成功再继续下一步操作）\nwx.setStorage(key, data) // 异步存储（即使存储没成功也会执行下一步代码）、\n\n// 读取：\nwx.getStorageSync(key) // 同步 （读取到数据在进行下一步操作）\nwx.setStorage(key) // 异步\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# api设置title\n\nwx.setNavigationBarTitle({\n      title: \'\',\n})\n\n\n1\n2\n3\n\n\n# 背景播放音\n\nBackgroundAudioManager 全局唯一的背景音频管理器\n\n// 需要在app.json配置，才能使用后台音乐播放的能力 \n\n"requiredBackgroundModes": ["audio", "location"]\n\n\n1\n2\n3\n\n\n// 获取全局唯一的背景音频管理器\nconst backgroundAudioManager = wx.getBackgroundAudioManager()\n\n\nbackgroundAudioManager.src = 音频链接\nbackgroundAudioManager.title = 音频标题\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# createSelectorQuery查询节点信息\n\ncreateSelectorQuery 小程序的方法，用于查询节点等操作\n\nconst query = wx.createSelectorQuery()\nquery.select(\'#the-id\').boundingClientRect() // 节点的布局信息\nquery.selectViewport().scrollOffset()\nquery.exec(function(res){\n  res[0].top       // #the-id节点的上边界坐标\n  res[1].scrollTop // 显示区域的竖直滚动位置\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 组件内的方法\n\nComponent(Object object)\n\n# 组件生命周期\n\nlifetimes\n\n// 生命周期\nlifetimes: {\n    ready() { // 在组件在视图层布局完成后执行\n   \t ...\n    }\n},\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 组件所在页面的生命周期\n\nComponent({\n  pageLifetimes: {\n    show: function() {\n      // 页面被展示\n    },\n    hide: function() {\n      // 页面被隐藏\n    },\n    resize: function(size) {\n      // 页面尺寸变化\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 组件对数据的监听\n\nobservers\n\nobservers: { // 对数据的监听(数据初次加载完成也会执行)\n    监听的数据对象(newData){\n      console.log(newData)\n    }\n},\n\n\n1\n2\n3\n4\n5\n\n\n# 子组件自定义事件传递给父组件\n\n子组件js：\n// 触发自定义事件 向父组件传值， 参数x（可选，传递给父组件的参数，可以是对象或其他）\nthis.triggerEvent(\'自定义事件名\', 参数x)\n\n\n父组件wxml：\n<子组件标签 bind:自定义事件名="执行的事件" />\n\n父组件js：\n执行的事件(event) {\n\tconsole.log(event.detil.参数)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 父组件自定义事件传递给子组件\n\n父组件wxml：\n<子组件标签 class="子组件类名">\n\n父组件JS：\n// 选择组件，并传入事件和参数\nthis.selectComponent(\'.子组件类名\').自定义事件名(传入参数)\n\n子组件js：\nmethods: {\n\t自定义事件名(参数x){\n\t\tconsole.log(参数x)\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 兄弟组件间传递事件和传值\n\n例子：子组件1向子组件2传递参数\n\n父组件wxml中：\n<子组件标签1 bind:自定义事件名1="执行的事件">\n<子组件标签2 class="子组件2类名">\n\n父组件js：\n执行的事件(event) {\n\tthis.selectComponent(\'.子组件2类名\').自定义事件名2(event.detil.参数x) // 向子组件2传值\n}\n\n子组件1js：\n// 触发自定义事件 向父组件传值， 参数x（可选，传递给父组件的参数，可以是对象或其他）\nthis.triggerEvent(\'自定义事件名1\', 参数x)\n\t\n\n\n子组件2js：\nmethods: {\n\t自定义事件名2(参数x){\n\t\tconsole.log(参数x)  // 接收父组件传入的值\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 获取手机信息\n\nwx.getSystemInfo(Object object)\n\nwx.getSystemInfo({\n\tsuccess(res){\n\t\tconsole.log(res) //手机信息\n\t}\n})\n\n\n1\n2\n3\n4\n5\n\n\n# 滚动组件\n\nscroll-view\n\n<scroll-view scroll-y scroll-top="{{scrollTop}}" scroll-with-animation="true">\n</scroll-view>\n\n\n1\n2\n\n\n# 全局属性、方法（类似vuex）\n\n在app.js中：\n\nonLaunch: function () {\n\tthis.globalData = {// 设置全局属性、方法\n\t\ttest: 0\n\t} \n},\nsetGlobalData(dataItem, val) { // 设置全局属性\n\tthis.globalData[dataItem] = val\n},\ngetGlobalData(dataItem) { // 获取全局属性\n\treturn this.globalData[dataItem]\n}\n\n\n在需要调用的页面js中：\nconst app = getApp() // 在最顶部先调用app方法\n\n// 设置全局属性\napp.setGlobalData(\'test\', 1)\n\n// 获取全局属性\napp.getGlobalData(\'test\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 消息提示框\n\nshowToast\n\nwx.showToast({\n  title: \'成功\',\n  icon: \'success\', //图标： success 成功、loading 加载中、none 无\n  duration: 2000\n})\n\n\n1\n2\n3\n4\n5\n\n\n\n# 《发现》页面\n\n# 调用组件外部的样式\n\ncomponents内部的组件无法直接调用外部的样式。可通过以下方式调用组件外部样式：\n\n方法一：\n\n父组件wxml：\n\x3c!-- iconfont 和 icon-sousuo 是传入组件内部的样式名称，iconfont（自定义名称）="iconfont（外部样式文件中定义的样式名）"  --\x3e\n<x-search iconfont="iconfont" icon-sousuo="icon-sousuo"/>\n\n\n子组件js:\n// 组件外部样式\n  externalClasses: [\n    \'iconfont\', // 对应的是上面等号前面的名称\n    \'icon-sousuo\'\n  ],\n  \n 子组件wxml： 即可实现调用组件外的样式\n <i class="iconfont icon-sousuo" />\n  \n  \n  注意：如果想在组件内部再次修改样式，不能够引用外部传进来的class名称进行修改，可以另起一个class名称进行修改。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n方法二：\n\n消除样式隔离\n\n组件内:\nComponent({\n  options: {\n    styleIsolation: \'apply-shared\'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 组件插槽slot\n\n单个插槽\n\n父组件调用传入插槽内容:\n<组件标签>\n    <view>\n      <view>插槽内容</view>\n      <view>插槽内容</view>\n    </view>\n</组件标签>\n  \n 组件内部定义slot标签:\n <view>\n    \x3c!-- slot插槽 --\x3e\n    <slot></slot>\n</view>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果需要实现多个插槽\n\n  \n父组件调用传入插槽内容:\n<组件标签>\n    <view slot="slot2">\n      <view>插槽1内容</view>\n      <view>插槽1内容</view>\n    </view>\n\n     <view slot="slot1">\n      <view>插槽2内容</view>\n      <view>插槽2内容</view>\n    </view>\n</组件标签>\n\n组件js :\noptions: {// 设置\n    multipleSlots: true // 打开多个插槽功能\n},\n  \n  \n组件内部定义slot标签:\n<view>\n    \x3c!-- slot插槽 具名插槽--\x3e\n    <slot name="slot1"></slot>\n    <slot name="slot2"></slot>\n</view>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 判断用户授权\n\n授权\n\n// 判断用户是否授权\n    wx.getSetting({\n      success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n        console.log(res)\n        if (res.authSetting[\'scope.userInfo\']) { // 已授权\n         wx.getUserInfo({ // 获取用户信息\n           success(res) {\n             console.log(res)\n           }\n         })\n        } else { // 未授权\n        \n        }\n      }\n    })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# button的开发能力（获取用户信息）1\n\n<button class="login"\n    open-type="getUserInfo"\n    bindgetuserinfo="onGetUserInfo"     // bindgetuserinfo 为固定的\n>\n\t获取微信授权信息\n</button>\n\n\nbindgetuserinfo 事件会询问用户是否同意授权\n\n\njs中：\n    onGetUserInfo(event) { // 获取用户信息\n      const userInfo = event.detail.userInfo\n      if (userInfo) { // 用户允许授权\n        this.setData({\n          modalShow: false\n        })\n        this.triggerEvent(\'loginSuccess\', userInfo) // 给父组件传用户数据\n      } else { // 用户拒绝授权\n        this.triggerEvent(\'loginFail\')\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 原生组件\n\n原生组件\n\n\nauto-focus 自动获取焦点\n\n<textarea\n    class="content"\n    placeholder="分享新鲜事..."\n    maxlength="140"\n    auto-focus\n    bindinput="onInput"\n    bindfocus="onFocus"\n    bindblur="onBlur"\n  ></textarea>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 选择上传图片\n\n上传图片\n\nlet max = 9 - this.data.images.length // 还能再选几张图片\nwx.chooseImage({\n      count: max, // 还能再选几张图片\n      sizeType: [\'original\', \'compressed\'], // 初始值 and 压缩过的\n      sourceType: [\'album\', \'camera\'], // 手机相册选择 and 拍照选择\n      success: (res) => { // 箭头函数改变this指向\n        console.log(res)\n      },\n    })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 图片裁剪\n\n图片裁剪\n\n\x3c!-- mode 图片裁剪 aspectFill 保证短边完整显示 --\x3e\n<image class="image" src="{{item}}" mode="aspectFill"></image>\n\n\n1\n2\n\n\n# 获取标签自定义属性data-* （删除图片的实现）\n\n\x3c!-- 显示图片 --\x3e\n    <block wx:for="{{images}}" wx:key="*this">\n      <view class="image-wrap">\n        \x3c!-- mode 图片裁剪 aspectFill 保证短边完整显示 --\x3e\n        <image class="image" src="{{item}}" mode="aspectFill"></image>\n        <icon class="iconfont icon-shanchu" bindtap="onDelImage" data-index="{{index}}"></icon>\n      </view>\n    </block>\n    \n    \n    // 删除图片\n  onDelImage(event) {\n  \t// event.target.dataset.index 获取标签属性data-index的值\n    this.data.images.splice(event.target.dataset.index, 1) // splice会改变原有数组\n    this.setData({\n      images: this.data.images\n    })\n  },\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 全屏预览图片(点击图片放大预览)\n\n全屏预览图片\n\n// 全屏预览图片\n  onPreviewImage(event) {\n    wx.previewImage({\n      urls: this.data.images, // 图片地址列表\n      current: event.target.dataset.imgsrc // 当前预览图片地址\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 文件上传云存储（发布博客例子）\n\n文件上传云存储\n\n //  结合\'发布\'的例子：\n  send() {\n    // 验证是否输入内容\n    if (content.trim() === \'\') { // trim() 去掉字符串空格\n      wx.showToast({\n        title: \'请输入内容\',\n        icon: \'none\'\n      })\n      return\n    }\n    wx.showLoading({\n      title: \'发布中\',\n    })\n    /**\n     * 实现思路及步骤：\n     * 1、图片 -> 上传 云存储  -> 生成 图片fineID（云文件ID） \n     * 2、数据 -> 录入 云数据库\n     *    数据包括：文字内容、图片fineID、昵称、头像、发布时间、openId(用户唯一标识，在插入数据库是系统会自动添加_openId字段，不需要另外插入)\n     */\n    let promiseArr = []\n    let fileIds = []\n    // 图片上传云存储\n    this.data.images.forEach((item) => {\n      let p = new Promise((resolve, reject) => {\n        let suffix = /\\.\\w+$/.exec(item)[0] // 文件扩展名(文件后缀)\n        wx.cloud.uploadFile({ // 每次只能上传一个文件\n          /**\n           * cloudPath 云路径。如果路径相同，后上传的文件会覆盖原文件\n           * 路径：blog/云存储中的文件夹 + Date.now()时间戳 + Math.random()*1000000随机数 + 文件后缀\n           */\n          cloudPath: \'blog/\' + Date.now() + \'-\' + Math.random() * 1000000 + suffix,\n          filePath: item, // 文件本地临时路径\n          success: (res) => {\n            fileIds.push(res.fileID)\n            resolve()\n          },\n          fail: (err) => {\n            console.error(err)\n            reject()\n          }\n        })\n      })\n      promiseArr.push(p)\n    })\n    \n    // 存入云数据库\n    Promise.all(promiseArr).then((res) => {\n      db.collection(\'blog\').add({\n        data: {\n          ...userInfo, // 昵称、头像\n          content, // 内容\n          img: fileIds, // 图片fileID列表\n          createTime: db.serverDate() // 创建时间，取服务端时间\n        }\n      }).then((res) => {\n        wx.hideLoading()\n        wx.showToast({\n          title: \'发布成功\',\n        })\n        // 返回博客页面，并刷新\n        wx.navigateBack()\n\n      })\n    }).catch((err) => {\n      wx.hideLoading()\n      wx.showToast({\n        title: \'抱歉，发布失败\',\n        icon: \'none\'\n      })\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n# js模块化 （时间格式化）\n\n在目录utils 中新建formatTime.js文件\n\n// 时间格式化 模块封装\nmodule.exports = (date) => { // date 数据格式为 date\n  let fmt = \'yyyy-MM-dd hh:mm:ss\' // 预定格式\n  const o = {\n    // + 正则中的1个或多个\n    \'M+\': date.getMonth() + 1,\n    \'d+\': date.getDate(),\n    \'h+\': date.getHours(),\n    \'m+\': date.getMinutes(),\n    \'s+\': date.getSeconds()\n  }\n\n  if (/(y+)/.test(fmt)) {\n    // $1 表示正则中的第一个，即(y+)\n    fmt = fmt.replace(RegExp.$1, date.getFullYear()) // replace 替换\n  }\n\n  for (let k in o) {\n    if (new RegExp(\'(\'+ k +\')\').test(fmt)) {\n      fmt = fmt.replace(RegExp.$1, o[k].toString().length === 1 ? \'0\' + o[k] : o[k])\n    }\n  }\n\n  return fmt\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n在组件引入js模块\n\nimport formatTime from \'../../utils/formatTime.js\'\n\n使用：\nformatTime(new Date(\'Wed Aug 28 2019 16:23:06 GMT+0800 (中国标准时间)\'))\n\n\n1\n2\n3\n4\n\n\n# 阻止事件冒泡\n\nbind 和 catch 都可以绑定事件，它们的区别是 bind 有事件冒泡，而 catch 没有\n\n# 返回上一个页面并执行方法\n\nAPI\n\n // 返回博客页面，并刷新\n wx.navigateBack()\n const pages = getCurrentPages() // 获取当前页面栈\n const prevPage = pages[pages.length - 2]  // 取到上一个页面\n prevPage.onPullDownRefresh() // 执行上一个页面的方法 onPullDownRefresh\n\n\n1\n2\n3\n4\n5\n\n\n# 图片懒加载\n\nAPI\n\n给image标签设置 lazy-load 为 true\n<image class="img" src="{{item}}" lazy-load="true"></image>\n\n.img {\n  background: #eee;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n懒加载占位图可以给image设置背景图或背景色\n\n# 模糊查询\n\n// 获取博客列表\n  app.router(\'blogList\', async (ctx, next) => {\n    const keyword = event.keyword // 搜索关键字 调用接口时传递来的数据\n    let w = {}\n    if (keyword.trim() != \'\') {\n      w = {\n        content: db.RegExp({ // 正则\n          regexp: keyword,\n          options: \'i\' // i表示忽略大小写\n        })\n      }\n    }\n\n    // where查询条件 skip 从第几条开始查，limit 查几条数据，orderBy(排序字段，排序方式) 排序，排序方式desc降序/asc升序\n    ctx.body =  await blogCollection.where(w).skip(event.start).limit(event.count)\n    .orderBy(\'createTime\', \'desc\').get().then((res) => {\n      return res.data\n    })\n    \n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 提升模糊查询的效率 （添加索引，对数据量大的查询效果明显）\n\n云开发控制台 > 数据库相应的集合 > 索引管理 > 添加索引 > 输入自定义索引名称、该字段的值是否唯一、被查询的字段名、升序/降序 > ok\n\n# 小程序端调用云数据库\n\n一般调用云数据库的操作都写在云函数内，其实小程序端也可以对数据库进行操作。\n\n小程序端一次最多只能查询20条数据，云函数端最多可查询100条数据，可使用多次查询拼接的方式突破限制。\n\n// 小程序端调用云数据库示例\n    const db = wx.cloud.database() // 初始化数据库\n    db.collection(\'blog\').orderBy(\'createTime\',\'deac\').get().then((res) => {\n      console.log(res)\n    })\n\n\n1\n2\n3\n4\n5\n\n\n# 云数据库权限管理\n\n注意：云控制台和服务端（云函数）始终有所有数据读写权限，\n\n但权限的管理仅对小程序端发起的请求有效。\n\n * 仅创建者可写，所有人可读 （适合于文章）\n\n * 仅创建者可读写 (适用于私密内容)\n\n * 仅管理端可写，所有人可读（适用于商品信息）\n\n * 仅管理端可读写（适用于后台敏感数据）\n\n# 数据库中1对N关系的三种设计方式\n\n# 第一种：N的数量较少 几十个以内\n\n1 条记录存储 N 个子数据\n\n如一条博客中，最多有9张图片，这9张图片可和其他数据放在一个记录中。\n\n[\n\t{\n\t\tid:...\n\t\timg:[\n\t\t\'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\'\n\t\t]\n\t}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 第二种：N的数量较多 几十到几百个\n\n1 存储 每个N的 id\n\n可分两个数据库集合，\n\n一个为 \'目录\' 集合，存放 \'详情\' 集合下的每条数据的 id 目录\n\n一个为 \'详情\' 集合，每条数据对应一个单独的 id 和 详细数据\n\n目录集合：\n[\n\t{\n\t\t\'id\':"11",\n\t\t\'name\': \'产品1\',\n\t\t\'xqs\': [\'111\',\'222\',\'333\', ... ]  // 存放 详情集合 中的每条数据 id\n\t}\n]\n\n\n\n详情集合：\n[\n{\'id\':"111",name:\'零件1\',title:\'...\' ...},\n{\'id\':"222",name:\'零件2\',title:\'...\' ...},\n{\'id\':"333",name:\'零件3\',title:\'...\' ...},\n...\n]\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如歌单列表，与歌曲详情的数据组合设计。\n\n# 第三种：N的数量巨大 几百成千上万个\n\n每个 N 都存储 1 的 id\n\n如新浪博客中的一条博客下面有几千条评论\n\n一条新浪博客：\n[{\n\t\'id\':\'11\',\n\t\'content\':\'博客内容\'\n\t...\n}]\n\n\n上千条评价：\n[\n{\n\t\'id\':\'111111\'\n\t\'blogId\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容1\'\n},\n{\n\t\'id\':\'222222\'\n\t\'blogId\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容2\'\n},\n{\n\t\'id\':\'33333\'\n\t\'blogId\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容3\'\n},\n...\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 云调用\n\n通过云函数调用服务端的开发接口\n\n这些接口如：模板消息推送、生成小程序码...\n\n# 模板消息推送\n\n1、使用from表单才能触发消息推送，并设置report-submit="true"\n\n\n<form slot="modal-content" report-submit="true" bind:submit="onSend">\n    <textarea name="content" class="comment-content" placeholder="写评论" value="{{content}}" fixed="true"></textarea>\n    <button class="send" form-type="submit">发送</button>\n  </form>\n\n\n1\n2\n3\n4\n5\n\n\n2、需要到微信公众平台做相应的设置：\n\n微信公众平台 > 功能 > 模板消息 > 添加模板 > 选择相应的模板> 添加成功后会有一个模板ID\n\n3、新建一个云函数，用于云调用。在该云函数下新建配置文件：config.json ，用于配置权限\n\nconfig.json ：\n\n{\n  "permissions": {\n    "openapi": [\n      "templateMessage.send"\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n云函数设置消息推送：\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  // 获取openid\n  const { OPENID } = cloud.getWXContext()\n\n  // 模板推送消息\n  const result = await cloud.openapi.templateMessage.send({\n    touser: OPENID,\n    page: `/p/blog-comment/blog-comment?blogId=${event.blogId}`, // 用户点击推送消息打开的页面\n    data: { // 模板的内容，keyword为在公众平台设置模板时对应的字段\n      keyword1: { // 评价内容\n        value: event.context \n      },\n      keyword2: { // 评价时间\n        value: event.time\n      }\n    },\n    templateId: \'LNwKMcYwlz-0HabgBhmZi6CWZrlNSBiNJ2h0SMorcxQ\', // 模板id，到公众平台模板消息上获取\n    formId: event.formId // 触发消息推送的form表单的id\n  })\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n4、在提交表单事件完成后调用消息推送云函数\n\n wx.cloud.callFunction({\n          name: \'sendMessage\',\n          data: {\n            content,\n            formId,\n            blogId: this.properties.blogId\n          }\n        }).then((res) => {\n          console.log(res)\n        })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 云函数多集合查询数据库\n\n// 博客详情(博客内容、评论)\n  app.router(\'blogDetail\', async(ctx, next) => {\n    let blogId = event.blogId\n\n    // 博客内容\n    let detail = await blogCollection.where({\n      _id: blogId\n    }).get().then((res) => {\n      return res.data\n    })\n\n    // 评论查询\n    const countResult = await blogCollection.count()\n    const total = countResult.total\n    let commentList = {\n      data: []\n    }\n    if (total > 0) {\n      // 突破100条限制\n      const batchTimes = Math.ceil(total / MAX_LIMIT)\n      const tasks = []\n      for (let i = 0; i < batchTimes; i++) {\n        let promise = db.collection(\'blog-comment\').skip(i * MAX_LIMIT)\n          .limit(MAX_LIMIT).where({\n            blogId\n          }).orderBy(\'createTime\', \'desc\').get()\n        tasks.push(promise)\n      }\n      if (tasks.length > 0) {\n        commentList = (await Promise.all(tasks)).reduce((acc, cur) => {\n          return {\n            data: acc.data.concat(cur.data)\n          }\n        })\n      }\n\n    }\n    ctx.body = {\n      detail,\n      commentList\n    }\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n# 分享功能\n\n分享功能需要button标签，设置open-type="share"\n\n\n<button open-type="share" data-blogid="{{blogId}}" data-blog="{{blog}}" class="share-btn" hover-class="share-hover">\n      <i class="iconfont icon-fenxiang icon"></i>\n      <text>分享</text>\n    </button>\n\n\n1\n2\n3\n4\n5\n\n\n在js中有onShareAppMessage方法，点击button会自动执行此方法\n\nonShareAppMessage: function (event) {\n    console.log(event)\n\n    // 对分享卡片的设置\n    let blogObj = event.target.dataset.blog\n    return {\n      title: blogObj.content,\n      path: `/p/blog-comment/blog-comment?blogId=${blogObj._id}`,\n      // imageUrl: \'\' // 自定义图片，不支持云存储的图片\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 不同场景获取用户信息的方式\n\n# 场景一：只想在界面上显示自己的昵称和头像\n\n以组件的方式：根据type类型获取不同用户数据\n\n该方式不需要授权，只能用于在wxml显示自己的信息\n\nopen-data\n\n<open-data type="userAvatarUrl"></open-data>\n<open-data type="userNickName"></open-data>\n...\n\n\n1\n2\n3\n\n\n# 场景二：在JS中获取用户信息\n\n该方式要在用户授权以后才能获取用户信息\n\nwx.getUserInfo\n\nwx.getUserInfo({\n      success: (res) => {\n        console.log(res)\n      }\n    })\n\n\n1\n2\n3\n4\n5\n\n\n在未授权的情况下需要用户先授权：\n\n// 判断用户是否授权\n      wx.getSetting({\n        success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n          if (res.authSetting[\'scope.userInfo\']) { // 已授权\n            wx.getUserInfo({ // 获取用户信息\n              success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n\n                app.setGlobalData(\'userInfo\', res.userInfo) // 设置app全局属性\n\n                this.onLoginSuccess({\n                  detail: res.userInfo\n                })\n              }\n            })\n          } else { // 未授权\n            this.setData({ // 打开弹出层，显示获取用户信息按钮\n              modalShow: true\n            })\n          }\n        }\n      })\n      \n      \n  授权按钮\n <button class="login" open-type="getUserInfo" bindgetuserinfo="onGetUserInfo">获取微信授权信息</button>\n    \n    \n    onGetUserInfo(event) { // 获取用户信息\n      const userInfo = event.detail.userInfo\n      if (userInfo) { // 用户允许授权\n        this.setData({\n          modalShow: false\n        })\n        this.triggerEvent(\'loginSuccess\', userInfo) // 给父组件传用户数据\n      } else { // 用户拒绝授权\n        this.triggerEvent(\'loginFail\')\n      }\n    }\n  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n> 注意：上面这种方式没有获取到openId\n\n# 场景三：获取openId\n\n获取openId不需要用户授权\n\n1、传统开发方式获取openId，后台服务器由自己开发，没使用云开发\n\n小程序端 微信服务器 后端服务器\n\n步骤：\n\n小程序端 调用 wx.login 向微信服务器 获取code\n\n小程序端 调用 wx.request 将 code 传递给 后端服务器\n\n后端服务器 使用code 向微信服务器 换取openid和session_key\n\n后端服务器 将openid 发送给 小程序端\n\n2、云开发方式获取openId\n\n云函数login中\n\n// 获取 WX Context (微信调用上下文)，包括 OPENID、APPID、及 UNIONID（需满足 UNIONID 获取条件）\n  const wxContext = cloud.getWXContext()\n\n  return {\n    event,\n    openid: wxContext.OPENID,\n    appid: wxContext.APPID,\n    unionid: wxContext.UNIONID,\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n普通按钮\n<button bindtap="getOpenid">获取openid</button>\n\ngetOpenid() {\n\twx.cloud.callFunction({\n\t\tname: \'login\'\n\t}).then((res) => {\n\t\tconsole.log(res)\n\t})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> openid 在小程序和公众号下是不一样的\n> \n> unionid 在小程序和公众号下都是一样的\n\n\n# 《我的》页面\n\njson文件\n\n"navigationBarTitleText": "我的",\n  "disableScroll": true  // 使页面无法滚动\n\n\n1\n2\n\n\n# 导航页面链接跳转\n\nnavigator\n\n# 背景图片\n\nwxss背景图片不支持本地相对路径的图片，只支持网络图片和base64图片\n\n建议使用base64图片，图片文件最好不要太大。\n\n# 每个页面都有的page标签\n\npage {\n  background-color: #f1f1f1;\n}\n\n\n1\n2\n3\n\n\n# 播放历史与本地存储\n\n方案一：播放历史存储在数据库当中，这样在不同设备访问都可查看播放历史。读取速度相对较慢\n\n方案二：播放历史存储在本地，仅当前设备可查看播放历史。读取速度较快\n\n本项目采用本地存储：\n\n使用openid作为本地存储的key，播放历史存入value\n\n在app.js中获取openid，即打开小程序就获取openid。\n\n// app.js\nonLaunch: function () {\n\tthis.getOpenid() // 获取openid并存储\n},\ngetOpenid() { // 获取openid并存储\n    wx.cloud.callFunction({\n      name: \'login\'\n    }).then((res) => {\n      const openid = res.result.openid\n      this.globalData.openid = openid // 保存到全局变量\n      if (wx.getStorageSync(openid) == \'\') { // 该用户从未打开过小程序，未存储过openid在本地\n        wx.setStorageSync(openid, []) // 存储openid到本地\n      }\n    })\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n歌曲播放时\n\n// 保存播放历史到本地存储\n  savePlayHistory() {\n    const currentSong = musiclist[nowPlayingIndex] // 当前播放歌曲\n    const openid = app.globalData.openid // 从全局属性获取openid\n    const playHistory = wx.getStorageSync(openid) // 从本地存储获取播放历史数组\n\n    for (let i = 0, len = playHistory.length; i < len; i++) {\n      if (playHistory[i].id === currentSong.id) { // 当前播放歌曲已存在播放历史中\n        playHistory.splice(i, 1) // 删除原纪录\n        break\n      }\n    }\n\n    playHistory.unshift(currentSong) // 在数组开头插入\n    wx.setStorage({ // 存入本地\n      key: openid,\n      data: playHistory\n    })\n\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n播放历史页面获取\n\nonLoad: function (options) {\n\n    const openid = app.globalData.openid //从全局属性获取openid\n    const playHistory = wx.getStorageSync(openid) // 读取本地播放历史数据\n\n    if (playHistory.length !== 0) { // 有播放历史\n      this.setData({\n        playHistory\n      })\n      wx.setStorage({ // storage里把musiclist（播放列表）的内容换成播放历史的列表\n        key: \'musiclist\',\n        data: playHistory,\n      })\n    }\n\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 我的发现\n\n代码分别演示了从云函数和小程序端获取数据，从小程序端获取数据享有权限管理的能力，不需要传openid。\n\n# 小程序码\n\n获取小程序码\n\n本项目演示使用接口 B：适用于需要的码数量极多的业务场景 云调用 的方式。\n\n步骤：\n\n * 创建云函数 gteQRCode\n\n * gteQRCode云函数下创建config.json配置权限，代码如下：\n\n{\n  "permissions":{\n    "openapi":[\n      "wxacode.getUnlimited"\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const wxContext = cloud.getWXContext()\n\n  const result = await cloud.openapi.wxacode.getUnlimited({\n    scene: wxContext.OPENID, // 链接参数 不一定传openid，可传其他任意数据，然后通过此数据，在别人扫码进入时就可用于判断\n    // page: "p/blog/blog" // 默认进入主页\n    // lineColor: { // 线条颜色\n    //   \'r\': 211,\n    //   \'g\': 60,\n    //   \'b\': 57\n    // },\n    // isHyaline: true // 是否透明\n  })\n  \n  // result为二进制数据, 先上传到云存储\n\n  // 上传云存储\n  const upload = await cloud.uploadFile({\n    cloudPath: \'qrcode/qrcode\' + Date.now() + Math.random() + \'.png\',\n    fileContent: result.buffer\n  })\n\n  return upload.fileID\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 判断是从扫码小程序码进入，以及参数获取\n\n// 在从小程序码进入的页面js，onLoad方法中，\n\nonLoad: function (options) {\n\tconsole.log(options.scene) // 获取到小程序码进入的参数\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 版本更新检测\n\n// app.js\nonLaunch: function(options) {\n    this.checkUpate()\n},\ncheckUpate(){\n    const updateManager = wx.getUpdateManager()\n    // 检测版本更新\n    updateManager.onCheckForUpdate((res)=>{\n      if (res.hasUpdate){\n        updateManager.onUpdateReady(()=>{\n          wx.showModal({\n            title: \'更新提示\',\n            content: \'新版本已经准备好，是否重启应用\',\n            success(res){\n              if(res.confirm){\n                updateManager.applyUpdate()\n              }\n            }\n          })\n        })\n      }\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 性能优化\n\n官网文档优化建议\n\n使用开发者工具的调试器，Audits进行评分，然后根据提示针对项目进行优化。\n\n\n# 场景值scene的作用与应用场景\n\n场景值\n\n场景值用来描述用户进入小程序的路径。完整场景值的含义请查看场景值列表。\n\n可根据不同场景进入实现不同业务处理，比如一个点餐小程序，店家内贴了小程序码，用户通过扫码进入，可立即进入点餐页面，等等\n\n在app.js中的onLaunch(options) 、onShow(options)，options包含scene场景值\n\n开发者工具中，切后台，可模拟进入场景。\n\n\n# 小程序的"SEO"---页面收录sitemap\n\n在app.js的同级目录下有sitemap.json文件，用于配置收录规则\n\nstiemap配置\n\n作用：\n\n使小程序搜索可根据小程序的内容进行搜索到\n\n使用方法：\n\n1、在微信公众平台，小程序信息 > 页面收录设置 > 打开 (默认是已开启)\n\n2、打开sitemap.json文件，配置收录规则\n\n{\n  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",\n  "rules": [{ // 收录规则\n  "action": "allow",// 是否被收录，allow允许被收录，disallow不允许\n  "page": "*" // *星号表示所有页面都被收录\n  }]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n{\n  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",\n  "rules": [{ // 收录规则，可添加多条\n  "action": "allow", // 是否被收录\n  "page":"p/player/player",  // 页面\n  "params": ["musicId","index"], // 链接的动态参数\n   "matching":\'exact\' // 表示params的参数是否要准确的匹配\n  }，{\n  "action": "disallow", // 是否被收录\n  "page":"*",  /\n  }]\n}\n\n// 上面配置规则表示除了player页面被收录外，其他页面不被收录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 小程序上线审核流程\n\n微信公众平台，版本管理>把小程序上传为体验版》提交审核》上线\n\n\n# 后台管理系统\n\n# 架构示意图\n\n前端 后台 小程序云开发\n\nvue-admin-template <---通过ajax--\x3e 基于Koa2；HTTP API 或 tcb-admin-node ----\x3e云函数、云数据库、云存储\n\n\n\n# vue-admin-template构建管理系统前端\n\nvue-element-admin 基于element的后台管理系统模板\n\nvue-admin-template 是 vue-element-admin的简化版\n\n使用方法查看官方文档。\n\n# Koa2构建管理系统后端\n\n官网： https://koa.bootcss.com/\n\n新建空文件夹wx-music-admin-backend，打开终端：\n\n# 生成package.json文件，-y 表示默认的配置\nnpm init -y\n\n# 安装koa\nnpm install koa\n\n# 新建app.js文件 (win10系统命令)，作为项目入口文件\ntype nul > app.js\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\napp.js:\n\nconst Koa = require(\'koa\')\nconst chalk = require(\'chalk\') // 使console.log打印文字有颜色的插件，需: npm i chalk\nconst app = new Koa()\n\napp.use(async (ctx) => {\n  ctx.body = \'Hello Wolrd\'\n})\nconst port = 3000\napp.listen(port, () => { // 端口号，开启服务后的回调函数\n  console.log(chalk.green(`> 服务已开启，访问：http://localhost:${port}`))\n}) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n终端：\n\n# node启动项目\nnode app.js\n\n# 访问：http://localhost:3000\n\n\n1\n2\n3\n4\n\n\n# 接口调用凭证 access_token 的缓存与更新\n\naccess_token，微信的接口调用凭证，详情：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\n\n回到项目wx-music-admin-backend，打开终端：\n\n# HTTP 请求 插件\nnpm i request\nnpm i request-promise\n\n\n1\n2\n3\n\n\n/**\n * 获取微信接口调用凭证\n * 详情：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\n */\n\n\nconst rp = require(\'request-promise\') // node发送http请求的插件\nconst fs = require(\'fs\') // node文件模块\nconst path = require(\'path\') // node 路径模块\n\n//fileName = __dirname 当前文件所在目录的绝对路径, 加上 \'./access_token.json\'\nconst fileName = path.resolve(__dirname, \'./access_token.json\')\n\n// 这两个参数的获取：微信公众平台>开发>开发设置\nconst APPID = \'wxc4e0b2d98063b103\'\nconst APPSECRET = \'xxx\' //小程序密钥，注意保密!\n\n// 微信 access_token 请求地址\nconst URL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`\n\n// 发送请求获取AccessToken\nconst updateAccessToken = async () => {\n  const resStr = await rp(URL)\n  const res = JSON.parse(resStr)\n\n  if (res.access_token) {\n    // node写文件,参数：1 文件路径，2 文件内容, 首次写文件为新建，往后为覆盖\n    fs.writeFileSync(fileName, JSON.stringify({\n      access_token: res.access_token,\n      createTime: new Date()\n    }))\n  } else { // 如获取不到，再次获取\n    await updateAccessToken()\n  }\n}\n\n// 读取access_token\nconst getAccessToken = async () => {\n  try {\n     // node读取文件,参数：1 读取的文件，2 字符集\n    const readRes = fs.readFileSync(fileName, \'utf8\')\n    const readObj = JSON.parse(readRes)\n\n    // 如果服务器宕机导致setInterval无法定时更新，这里需要再次判断access_token的有效性\n    const createTime = new Date(readObj.createTime).getTime()\n    const nowTime = new Date().getTime()\n    if((nowTime - createTime) / 1000 / 60 / 60 >= 2) {\n      await updateAccessToken()\n      await getAccessToken()\n      return\n    }\n    return readObj.access_token\n\n  } catch (error) { //捕获异常，在未创建文件时，先创建文件\n    await updateAccessToken()\n    await getAccessToken()\n  }\n}\n\n// access_token有效期为2个小时，定时更新\nsetInterval(async () => {\n  await updateAccessToken()\n}, (7200 - 300) * 1000)\n\nmodule.exports = getAccessToken\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 后端代码通过HTTP API 触发云函数获取数据\n\nHTTP API 触发云函数\n\n# 产生跨域和后端解决跨域问题\n\n管理系统前端向管理系统后端请求数据，产生了跨域问题\n\n  // 产生跨域的几种情况\n  // http://www.a.com  https://www.a.com 协议不同\n  // http://www.a.com  http://www.b.com 域名不同\n  // http://www.a.com  http://news.a.com 主域与子域不同\n  // http://www.a.com:8080  http://www.a.com:3000 端口不同\n\n// 解决跨域的几种方法\n// jsonp\n// iframe\n// postMessage跨域\n// 跨域资源共享（CORS）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n管理系统后端，安装\n\n// 解决跨域问题的koa包\nnpm i koa2-cors\n\n\n1\n2\n\n\napp.js\n\n//处理跨域\napp.use(cors({\n  origin: [\'http://localhost:9528\'], // 允许访问本服务的域\n  credentials: true\n}))\n\n\n1\n2\n3\n4\n5\n\n\n# 云数据库的增删改查接口\n\n数据库查询记录\n\n# 后端获取前端post请求传来的数据\n\nget请求可以直接通过ctx.request.query获取，但是post请求需要安装koa-body\n\nnpm i koa-body\n\n\n1\n\n\napp.js\n\nconst koaBody = require(\'koa-body\') // 对post请求前端传来的数据的获取，需要此依赖\n\n// 接收post参数解析\napp.use(koaBody({\n  multipart: true\n}))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接口.js\n\nrouter.post(\'/updatePlaylist\', async (ctx, next) => {\n    \n  const params = ctx.request.body // post请求获取前端传来的数据，需安装和配置koa-body\n  \n})\n\n\n1\n2\n3\n4\n5\n\n\n# 后端获取云存储图片\n\n云存储中上传图片，云数据库中新建图片的集合，并添加数据字段，字段包含云文件的fileid。\n\n后端项目通过调用云数据库的方式获取数据\n\nrouter.get(\'/list\', async (ctx, next) => {\n  // 接口中读取数据库默认最多10条数据\n  const query = `db.collection(\'swiper\').get()`\n  const res = await callCloudDB(ctx, \'databasequery\', query)\n  console.log(res)\n  \n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但获取到的数据为fileid，并不能用于显示图片，需要通过微信HTTP API获取云存储的接口来获取图片地址\n\n获取云存储\n\n# 后端上传图片到云存储\n\n文件上传',normalizedContent:'# 小程序笔记\n\n\n# 基础课程部分\n\n# 微信公众平台\n\nhttps://mp.weixin.qq.com/\n\n注册时可选择类型：订阅号、服务号、小程序、企业微信\n\n每个邮箱仅能注册一个小程序。\n\n个人类型小程序：无法使用微信支付、无法使用卡包功能\n\n# 小程序文档api\n\n小程序开发文档\n\n# 微信开放社区\n\n微信开发社区\n\n# 目录说明\n\n默认目录\n\npages-----------------------页面相关\n\nindex ----------------- 首页文件夹\n\nindex.js ------------首页js\n\nindex.json---------首页配置\n\nindex.wxml-------首页html\n\nindex.wxss--------首页css\n\nutils------------------------工具相关\n\napp.js ----------------------项目总js\n\napp.json-------------------全局配置( 页面路由以及头部、底部导航的配置等)\n\napp.wxss -----------------项目总样式css\n\nproject.config.json ----项目配置\n\n代码构成\n\n.json ：配置文件，以json格式存储配置\n\n项目中有三种配置：项目配置（project.config.json）、全局配置（app.json）、页面配置（index.json）\n\n.wxml: 相当于html文件\n\n.wxss: 相当于css\n\n.js : 就是js\n\n# 文件说明\n\nproject.config.json项目配置 部分代码说明\n\nsetting：{\n\nurlcheck 是否检测安全的域名\n\nes6 是否把es6转es5\n\npostcss 是否把css样式自动补全\n\nminified 是否压缩\n\n}\n\napp.json 全局配置\n\n全局配置api\n\nwxml 相关介绍\n\nwxmlapi\n\n<view>{{motto}}</view>\n\n循环渲染\n<view wx:for="{{list}}" wx:key="{{index}}">\n      {{index}} {{item}}\n</view>\n\n改变for循环item和index的名称\n<block wx:for="{{list}}" wx:for-item="data" wx:for-index="inx">\n\t{{inx}} {{data}}\n</block>\n\n条件渲染 (类似vue的v-if、v-else)\n<view wx:if="{{islogin}}">已登录</view>\n<view wx:else>请登录</view>\n\n条件显示（类似vue的v-show）\n<view hidden="{{islogin}}">显示内容</view>\n\n绑定点击事件\n<button bindtap=“tapname”>按钮</button>\n\npage({\n  tapname: function(event) {\n    console.log(event)\n  }\n})\n...\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nwxss 相关介绍\n\nwxssapi\n\n尺寸单位：rpx，根据屏幕宽度自适应。\n\n引入外部wxss：@import ’...‘\n\njs相关介绍\n\nwxs（weixin script）是小程序的一套脚本语言\n\nwxsapi\n\n绑定点击事件\n\n<button bindtap=“ontaphandler”>点我+1</button>\n<view>{{count}}</view>\n\n\n1\n2\n\n\npage({\n  data: {\n    count: 0\n  },\n  ontaphandler: function() {\n  \tthis.setdata({\n  \t\tcount: this.data.count++\n  \t})\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 阻止事件冒泡\n\n把绑定方式 bindtap 换成 catchtap 即可。\n\n# 第三方库\n\nweui\n\nweui是一套同微信原生视觉体验一致的基础样式库\n\niview weapp\n\n一套高质量的微信小程序ui组件库\n\nvant weapp\n\n轻量、可靠的小程序ui组件库\n\n# 云开发\n\n小程序传统开发模式\n\n客户端 -----\x3e 服务端（后端代码、数据库）------\x3e 运维（db维护、文件存储、内容加速、网络防护、容器服务、负载均衡、安全加固等...）\n\n小程序云开发模式\n\n客户端 -----\x3e 云开发（云函数、云数据库、云存储）\n\n传统开发 vs 云开发\n\n开发效率低 serverless（无服务）\n\n运维成本高 开发者更关注业务逻辑\n\n无服务（serverless）开发是未来的发展趋势\n\n# 云开发三大基础能力\n\n# 云函数\n\n（相当于传统开发中的后台接口）\n\n获取appid、获取openid、生成分享图、调用腾讯云sdk ...\n\n# 云数据库\n\n数据的增、删、改、查 ...\n\n# 云存储\n\n管理文件、上传文件、下载文件、分享文件 ...\n\n每个小程序账号可免费创建两个环境，建议：开发环境、生成环境\n\n# 云数据库能力\n\n云开发提供了一个json数据库，提供2gb免费存储空间。\n\n# 数据类型\n\nstring 字符串\n\nnumber 数字\n\nobject 对象\n\narray 数组\n\nboolean 布尔值\n\ngeopoint 地理位置点\n\ndate 时间 （精确到毫秒ms，客户端时间）\n\nnull 空\n\n# 操作云数据库\n\n小程序控制（读写数据库受权限限制）\n\n云函数控制（拥有所有读写数据库的权限）\n\n控制台控制（拥有所有读写数据库的权限）\n\n# 云数据库权限管理\n\n仅创建者可写，所有人可读 （适合于文章）\n\n仅创建者可读写 (适用于私密内容)\n\n仅管理端可写，所有人可读（适用于商品信息）\n\n仅管理端可读写（适用于后台敏感数据）\n\n# 操作云数据库\n\n//初始化数据库\nconst db = wx.cloud.database() // 小程序端初始化数据库，如果在云函数端不需要加wx\n\n//切换环境(开发环境/生产环境)\nconst testdb = wx.cloud.database({\n\tenv: \'test\'\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 实战课程部分\n\n# serverless（无服务）\n\n概念：函数即服务，当需要后端服务的时候，不需要关心后端的ip地址、域名，只需要像调用普通函数一样既可以实现调用。\n\n# 云开发优势\n\n快速上线、专注核心业务、独立开发一个完整的微信小程序、不需要学习新的语言，只需要会javascript、无需运维， 节约成本、数据安全、\n\n# 云开发提供能力\n\n云函数：在云端运行的代码，微信私有协议天然鉴权 （理解：相当于后端部分）\n\n云数据库：一个既可以在小程序端操作又可以在云函数中操作的json数据库\n\n云存储：在云端存储文件，可以在云端控制台可视化管理\n\n云调用：基于云函数免鉴权使用小程序开放接口的能力（比如说给用户推送消息等）\n\nhttp api：使用http api开发者可在已有服务器上访问云资源，实现与云开发的互通（作用：对原有传统模式下开发的小程序，可以与云开发进行互通）\n\n# appid\n\n每个小程序唯一的id\n\n# 云开发项目默认目录结构\n\ncloudfunctions ----------------------------云函数\n\ncallback ---------------------------------- 回调函数\n\nconfig.json ---------------------------\n\nindex.js --------------------------------\n\npackage.json ------------------------\n\necho ----------------------------------------\n\nlogin ----------------------------------------\n\nopenapi -----------------------------------\n\nminiprogram ------------------------------- 小程序\n\nimages ------------------------------------- 图片\n\npages --------------------------------------- 页面\n\nstyle ----------------------------------------- 样式\n\napp.js --------------------------------------- 项目js\n\napp.json ----------------------------------- 全局配置\n\napp.wxss ---------------------------------- 项目样式\n\nsitemap.json ----------------------------- （小程序seo相关）\n\nproject.config.json ----------------------- 项目配置\n\n# 云开发环境\n\n云开发可创建两个环境，建议一个为开发环境，一个为生产环境\n\n# 开发前的准备\n\n开发工具 > 右上角详情 > 本地设置 > 调试基础库 设置为最新版本\n\napp.js > wx.cloud.init > env 设置环境id\n\n# project.config.json 文件说明\n\nminiprogramroot 小程序前端代码目录\n\ncloudfunctionroot 云函数代码目录\n\n# app.json\n\npages 设置页面 ，设置后会自动在pages目录下生成相应的目录和文件\n\n设置底部导航按钮：\n\n"tabbar": {\n    "color": "#474747", // 文字颜色\n    "selectedcolor": "#d43c43", // 文字选中颜色\n    "list": [{ // 按钮列表，2-5项\n      "pagepath": "p/playlist/playlist", // 按钮对应页面\n      "text": "音乐", // 文字\n      "iconpath": "images/music.png", // 图标路径\n      "selectediconpath": "images/music-actived.png" // 选中图标的路径\n    },\n    {\n      "pagepath": "p/blog/blog",\n      "text": "发现",\n      "iconpath": "images/blog.png",\n      "selectediconpath": "images/blog-actived.png"\n    },\n    {\n      "pagepath": "p/profile/profile",\n      "text": "我的",\n      "iconpath": "images/profile.png",\n      "selectediconpath": "images/profile-actived.png"\n    }]\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 图标来自于 https://www.iconfont.cn\n> \n> 阿里巴巴图标库，包含矢量图标、字体图标、字体等\n\n# 代码规范\n\n很多公司借鉴的代码规范：https://github.com/airbnb/javascript\n\n# 《音乐》页面开发\n\n \x3c!-- 轮播图组件 参数：indicator-dots 小圆点，autoplay 自动播放, interval 间隔时间，duration 动画时长 --\x3e\n<swiper indicator-dots="true" circular="true" interval="3000" duration="500">\n  <block wx:for="{{swiperimgurls}}" wx:key="{{index}}"> \x3c!-- 空节点 --\x3e\n    <swiper-item>\n      <image src="{{item.url}}" mode="widthfix" class="img"></image>\n    </swiper-item>\n  </block>\n</swiper>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 自定义组件\n\n创建组件\n\n创建目录 components > 组件目录名称 > 右键 新建component\n\n# 引入组件\n\n在page的json文件中：\n\n{\n  "usingcomponents": {\n    "x-playlist":"/components/playlist/playlist"\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n在page的wxml中：\n\n<x-playlist> </x-playlist>\n\n\n1\n\n\n页面引入组件以及组件内部在引用子组件的方法是一样的，同样需要设置json文件。\n\n# 组件传值\n\n父组件中：在引入组件的时候自定义属性名称，并把数据传入子组件\n\n\x3c!-- 参数：playlist 自定义名称，传入组件的数据 --\x3e\n<x-playlist playlist="{{传入的数据}}"></x-playlist>\n\n\n1\n2\n\n\n子组件中： 子组件的js文件：\n\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    playlist:{ // 接收父组件传输的数据\n      type: object // 数据类型\n    }\n   },\n       \n //子组件的wxml文件可直接引入数据{{playlist}}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# wx:key 的使用\n\nkey的值不建议使用index，因为当数据发生变化会dom结构产生变化时，使用index的地方不会随之变化。\n\n可以使用数据内部每项不一样的一个数值，如id\n\n<block wx:for="{{swiperimgurls}}" wx:key="url"> 这里url不需要双大括号，如使用index则需要{{}}\n    <view>\n      <image src="{{item.url}}" mode="widthfix" class="img"></image>\n    </view>\n</block>\n \n<view class="playlist-container">\n  <block wx:for="{{playlist}}" wx:key="_id">\n    \x3c!-- 参数：playlist 自定义名称，传入组件的数据 --\x3e\n    <x-playlist playlist="{{item}}"></x-playlist>\n  </block>\n</view>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# async/await 语法\n\n目前，在云函数里，由于 node 版本最低是 8.9，因此是天然支持 async/await 语法的。而在小程序端则不然。在微信开发者工具里，以及 android 端手机（浏览器内核是 qq浏览器的 x5），async/await是天然支持的，但 ios 端手机在较低版本则不支持，因此需要引入额外的 文件。\n\n可把这个 runtime.js 文件引用到有使用 async/await 的文件当中。\n\n// 注意，必须命名为 regeneratorruntime\nimport regeneratorruntime from \'../../utils/runtime.js\'\n\n\n1\n2\n\n\n# 云函数的使用\n\ncloudfunctions目录 右键 新建 node.js 云函数 > 输入目录名 getplaylist\n\n在云函数中向第三方服务器发送请求要依赖第三方库\n\n安装依赖包\n\n云函数目录 getplaylist 右键 在终端打开 打开命令行 输入命令：\n\nnpm install --save request\nnpm install --save request-promise\n\n\n1\n2\n\n\ngithub request-promise：https://github.com/request/request-promise\n\n然后写相应代码\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst rp = require(\'request-promise\') // 需安装依赖包\n\nconst url = \'http://musicapi.xiecheng.live/personalized\'\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const playlist = await rp(url).then((res) => {\n    return json.parse(res).result\n  })\n  console.log(playlist)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n写完代码，云函数目录 getplaylist 右键 上传并部署：云端安装依赖（不上传node_modules） 进行上传部署代码到云端，等待上传成功，打开云开发控制台即可看到已经上传的云函数，并可对云函数进行测试。\n\n# 数据库操作\n\n数据库> 创建集合 > playlist\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst db = cloud.database() // 初始化数据库,如果在小程序端初始化数据库需要在前面加wx.\n\nconst rp = require(\'request-promise\') // 需安装依赖包\n\nconst url = \'http://musicapi.xiecheng.live/personalized\' // 第三方服务器地址（老师从网易云获取的数据部署在其服务器，每天的数据会更新）\n\nconst playlistcollection = db.collection(\'playlist\') // 获取到数据库playlist集合\n\nconst max_limit = 10 // 定义常量，获取数据库条数最大的限制\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  /**\n   * 注：\n   * - 关于数据库的操作都是异步操作，都需添加await关键字\n   * - console.log 打印在云开发控制台 云函数测试内查看\n   * - 单次获取数据库数据有条数限制，云函数端最多获取100条，小程序端最多获取20条\n   */\n\n  // const list = await playlistcollection.get() // 获取数据库集合的数据 （因为有条数限制，不直接用此方法）\n  \n  // 突破条数限制 （为了读取到全部数据然后与第三方服务器获取的数据进行对比去重）\n  const countresult = await playlistcollection.count() // 获取数据总条数 返回为对象\n  const total = countresult.total // 取得总条数\n  const batchtimes = math.ceil(total / max_limit)\n  const tasks = []\n  for(let i = 0; i < batchtimes; i++) {\n    let promise = playlistcollection.skip(i * max_limit).limit(max_limit).get() // 从第 skip 条开始取，最多取 limit 条数据\n    tasks.push(promise)\n  }\n  let list = {\n    data: []\n  }\n  if (tasks.length > 0) {\n    list = (await promise.all(tasks)).reduce((acc, cur) => { // reduce数组方法 累积拼接\n      return {\n        data: acc.data.concat(cur.data)\n      }\n    })\n  }\n \n  // 获取第三方服务器端数据\n  const playlist = await rp(url).then((res) => {\n    return json.parse(res).result\n  })\n\n  // 数据库与服务器数据对比去重（数据已存在数据库的无需再重复添加）\n  const newdata = []\n  for(let i = 0, len1 = playlist.length; i < len1; i++) {\n    let flag = true\n    for(let j = 0, len2 = list.data.length; j < len2; j++) {\n      if(playlist[i].id === list.data[j].id){\n        flag = false\n        break\n      }\n    }\n    if(flag){\n      newdata.push(playlist[i])\n    }\n  }\n\n  // 把数据插入数据库，需要单条插入\n  for (let i = 0, len = newdata.length; i < len; i++) {\n    await playlistcollection.add({ // 给数据库集合添加数据\n      data: {\n        ...newdata[i],\n        createtime: db.serverdate(), // db.serverdate() 获取服务器时间\n      }\n    }).then((res) => { // 数据添加成功\n      console.log(\'数据添加成功\')\n    }).catch((err) => { // 失败\n      console.error(err)\n    })\n  }\n  return newdata.length // 插入多少条数据\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n# 查询数据库\n\n//云函数中查询数据库的例子：\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst tcbrouter = require(\'tcb-router\')\nconst db = cloud.database() // 初始化数据库\nconst blogcollection = db.collection(\'blog\') // 博客的数据库集合\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const app = new tcbrouter({ event }) // 初始化tcbrouter\n\n  app.router(\'list\', async (ctx, next) => {\n    // skip 从第几条开始查，limit 查几条数据，orderby(排序字段，排序方式) 排序，排序方式desc降序/asc升序\n    ctx.body =  await blogcollection.skip(event.start).limit(event.count)\n    .orderby(\'createtime\', \'desc\').get().then((res) => {\n      return res.data\n    })\n    \n  })\n  \n\n  return app.serve() // 必需返回\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 云函数调试\n\n云控制台中可会云函数进行云端测试\n\n在小程序调用云函数后，可查看云函数日志\n\n# 定时触发云函数\n\n如果云函数需要定时 / 定期执行，也就是定时触发，我们可以使用云函数定时触发器。配置了定时触发器的云函数，会在相应时间点被自动触发，函数的返回结果不会返回给调用方\n\n云函数目录下新建 config.json\n\napi\n\n{\n  "triggers": [\n    {\n      "name": "mytriggers",\n      "type": "timer",\n      "config":"0 0 10,14,16,20 * * * *" //表示每天的10点、14点、16点、20点触发一次\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n编辑好触发器之后，要在云函数目录 > 右键 > 上传触发器\n\n# 配置云函数超时时间\n\n当云函数比较复杂的时候，默认的超时时间3秒可能不能够满足需求，可以适当的设置更为合理的时间\n\n云开发控制台 > 云函数 > 配置 > 超时时间\n\n# 上拉加载与下拉刷新\n\npage页面json中：\n"enablepulldownrefresh": true\n\n\npage页面js中有这两个函数：\n\n /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onpulldownrefresh: function() {\n\t this.setdata({\n      playlist: []\n    })\n    this._getplaylist()\n  },\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onreachbottom: function() {\n    this._getplaylist()\n  },\n \n \n \n 下拉刷新请求完数据后\n wx.stoppulldownrefresh() // 停止下拉刷新动画\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 云函数路由优化tcb-router\n\n一个用户在一个云环境只能创建50个云函数\n\n假如小程序非常复杂，50个云函数不能够满足业务需求怎么办？\n\n相似的请求归类到同一个云函数处理\n\ntcb-router是一个koa风格的云函数路由库\n\n通俗理解就是可以把很多个接口归类到同一个云函数内。\n\ngithub-tcb-router: https://github.com/tencentcloudbase/tcb-router\n\nkoa洋葱模型...\n\n安装：\n\n在使用到tcb-router的云函数目录下打开命令行，输入命令进行安装\nnpm install --save tcb-router\n\n\n1\n2\n\n\n// 云函数的 index.js\nconst tcbrouter = require(\'router\'); // 必需\n\nexports.main = (event, context) => {\n    const app = new tcbrouter({ event });// 必需\n  \n    // app.use 表示该中间件会适用于所有的路由(全局中间件) 非必需\n    app.use(async (ctx, next) => { // 这个中间件表示所有路由都会调用到，而路由中间件为单独调用\n        ctx.data = {}; // 获取要传给小程序端的数据\n        ctx.data.openid = event.userinfo.openid // 这里获取到的openid将分布到所有路由\n        await next(); // 执行下一中间件\n    });\n\n    // 路由为数组表示，该中间件适用于 user 和 timer 两个路由\n    app.router([\'user\', \'timer\'], async (ctx, next) => {\n        ctx.data.company = \'tencent\'; // 这里获取到的数据将分布到 user 和 timer 两个路由\n        await next(); // 执行下一中间件\n    });\n\n    // 路由为字符串，该中间件只适用于 user 路由\n    app.router(\'user\', async (ctx, next) => {\n        ctx.data.name = \'heyli\';  // 获取要传给小程序端的数据\n        await next(); // 执行下一中间件\n    }, async (ctx, next) => {\n        ctx.data.sex = \'male\'; // 获取要传给小程序端的数据\n        await next(); // 执行下一中间件\n    }, async (ctx) => {\n        ctx.data.city = \'foshan\'; // 获取要传给小程序端的数据\n        // ctx.body 返回数据到小程序端\n        ctx.body = { code: 0, data: ctx.data};  // 要传给小程序端的数据\n    });\n\n    // 路由为字符串，该中间件只适用于 timer 路由\n    app.router(\'timer\', async (ctx, next) => {\n        ctx.data.name = \'flytam\';\n        await next(); // 执行下一中间件\n    }, async (ctx, next) => {\n        ctx.data.sex = await new promise(resolve => {\n        // 等待500ms，再执行下一中间件\n        settimeout(() => {\n            resolve(\'male\');\n        }, 500);\n        });\n        await next(); // 执行下一中间件\n    }, async (ctx)=>  {\n        ctx.data.city = \'taishan\';\n\n        // ctx.body 返回数据到小程序端\n        ctx.body = { code: 0, data: ctx.data };\n    });\n\n    return app.serve(); // 必需\n\n}\n\n\n小程序端：\n\n// 调用名为 router 的云函数，路由名为 user\nwx.cloud.callfunction({\n    // 要调用的云函数名称\n    name: "router",\n    // 传递给云函数的参数\n    data: {\n        $url: "user", // 要调用的路由的路径，传入准确路径或者通配符*\n        other: "xxx"\n    }\n}).then((res) => {\n\tconsole.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n上面tcb-router代码会按照洋葱模型执行，即先从上往下逐个进入中间件，再从下往上逐个退出中间件。\n\n# 本地存储（缓存）\n\n// 存储：\nwx.setstoragesync(key, data) // 同步存储（存储成功再继续下一步操作）\nwx.setstorage(key, data) // 异步存储（即使存储没成功也会执行下一步代码）、\n\n// 读取：\nwx.getstoragesync(key) // 同步 （读取到数据在进行下一步操作）\nwx.setstorage(key) // 异步\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# api设置title\n\nwx.setnavigationbartitle({\n      title: \'\',\n})\n\n\n1\n2\n3\n\n\n# 背景播放音\n\nbackgroundaudiomanager 全局唯一的背景音频管理器\n\n// 需要在app.json配置，才能使用后台音乐播放的能力 \n\n"requiredbackgroundmodes": ["audio", "location"]\n\n\n1\n2\n3\n\n\n// 获取全局唯一的背景音频管理器\nconst backgroundaudiomanager = wx.getbackgroundaudiomanager()\n\n\nbackgroundaudiomanager.src = 音频链接\nbackgroundaudiomanager.title = 音频标题\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# createselectorquery查询节点信息\n\ncreateselectorquery 小程序的方法，用于查询节点等操作\n\nconst query = wx.createselectorquery()\nquery.select(\'#the-id\').boundingclientrect() // 节点的布局信息\nquery.selectviewport().scrolloffset()\nquery.exec(function(res){\n  res[0].top       // #the-id节点的上边界坐标\n  res[1].scrolltop // 显示区域的竖直滚动位置\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 组件内的方法\n\ncomponent(object object)\n\n# 组件生命周期\n\nlifetimes\n\n// 生命周期\nlifetimes: {\n    ready() { // 在组件在视图层布局完成后执行\n   \t ...\n    }\n},\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 组件所在页面的生命周期\n\ncomponent({\n  pagelifetimes: {\n    show: function() {\n      // 页面被展示\n    },\n    hide: function() {\n      // 页面被隐藏\n    },\n    resize: function(size) {\n      // 页面尺寸变化\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 组件对数据的监听\n\nobservers\n\nobservers: { // 对数据的监听(数据初次加载完成也会执行)\n    监听的数据对象(newdata){\n      console.log(newdata)\n    }\n},\n\n\n1\n2\n3\n4\n5\n\n\n# 子组件自定义事件传递给父组件\n\n子组件js：\n// 触发自定义事件 向父组件传值， 参数x（可选，传递给父组件的参数，可以是对象或其他）\nthis.triggerevent(\'自定义事件名\', 参数x)\n\n\n父组件wxml：\n<子组件标签 bind:自定义事件名="执行的事件" />\n\n父组件js：\n执行的事件(event) {\n\tconsole.log(event.detil.参数)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 父组件自定义事件传递给子组件\n\n父组件wxml：\n<子组件标签 class="子组件类名">\n\n父组件js：\n// 选择组件，并传入事件和参数\nthis.selectcomponent(\'.子组件类名\').自定义事件名(传入参数)\n\n子组件js：\nmethods: {\n\t自定义事件名(参数x){\n\t\tconsole.log(参数x)\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 兄弟组件间传递事件和传值\n\n例子：子组件1向子组件2传递参数\n\n父组件wxml中：\n<子组件标签1 bind:自定义事件名1="执行的事件">\n<子组件标签2 class="子组件2类名">\n\n父组件js：\n执行的事件(event) {\n\tthis.selectcomponent(\'.子组件2类名\').自定义事件名2(event.detil.参数x) // 向子组件2传值\n}\n\n子组件1js：\n// 触发自定义事件 向父组件传值， 参数x（可选，传递给父组件的参数，可以是对象或其他）\nthis.triggerevent(\'自定义事件名1\', 参数x)\n\t\n\n\n子组件2js：\nmethods: {\n\t自定义事件名2(参数x){\n\t\tconsole.log(参数x)  // 接收父组件传入的值\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 获取手机信息\n\nwx.getsysteminfo(object object)\n\nwx.getsysteminfo({\n\tsuccess(res){\n\t\tconsole.log(res) //手机信息\n\t}\n})\n\n\n1\n2\n3\n4\n5\n\n\n# 滚动组件\n\nscroll-view\n\n<scroll-view scroll-y scroll-top="{{scrolltop}}" scroll-with-animation="true">\n</scroll-view>\n\n\n1\n2\n\n\n# 全局属性、方法（类似vuex）\n\n在app.js中：\n\nonlaunch: function () {\n\tthis.globaldata = {// 设置全局属性、方法\n\t\ttest: 0\n\t} \n},\nsetglobaldata(dataitem, val) { // 设置全局属性\n\tthis.globaldata[dataitem] = val\n},\ngetglobaldata(dataitem) { // 获取全局属性\n\treturn this.globaldata[dataitem]\n}\n\n\n在需要调用的页面js中：\nconst app = getapp() // 在最顶部先调用app方法\n\n// 设置全局属性\napp.setglobaldata(\'test\', 1)\n\n// 获取全局属性\napp.getglobaldata(\'test\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 消息提示框\n\nshowtoast\n\nwx.showtoast({\n  title: \'成功\',\n  icon: \'success\', //图标： success 成功、loading 加载中、none 无\n  duration: 2000\n})\n\n\n1\n2\n3\n4\n5\n\n\n\n# 《发现》页面\n\n# 调用组件外部的样式\n\ncomponents内部的组件无法直接调用外部的样式。可通过以下方式调用组件外部样式：\n\n方法一：\n\n父组件wxml：\n\x3c!-- iconfont 和 icon-sousuo 是传入组件内部的样式名称，iconfont（自定义名称）="iconfont（外部样式文件中定义的样式名）"  --\x3e\n<x-search iconfont="iconfont" icon-sousuo="icon-sousuo"/>\n\n\n子组件js:\n// 组件外部样式\n  externalclasses: [\n    \'iconfont\', // 对应的是上面等号前面的名称\n    \'icon-sousuo\'\n  ],\n  \n 子组件wxml： 即可实现调用组件外的样式\n <i class="iconfont icon-sousuo" />\n  \n  \n  注意：如果想在组件内部再次修改样式，不能够引用外部传进来的class名称进行修改，可以另起一个class名称进行修改。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n方法二：\n\n消除样式隔离\n\n组件内:\ncomponent({\n  options: {\n    styleisolation: \'apply-shared\'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 组件插槽slot\n\n单个插槽\n\n父组件调用传入插槽内容:\n<组件标签>\n    <view>\n      <view>插槽内容</view>\n      <view>插槽内容</view>\n    </view>\n</组件标签>\n  \n 组件内部定义slot标签:\n <view>\n    \x3c!-- slot插槽 --\x3e\n    <slot></slot>\n</view>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果需要实现多个插槽\n\n  \n父组件调用传入插槽内容:\n<组件标签>\n    <view slot="slot2">\n      <view>插槽1内容</view>\n      <view>插槽1内容</view>\n    </view>\n\n     <view slot="slot1">\n      <view>插槽2内容</view>\n      <view>插槽2内容</view>\n    </view>\n</组件标签>\n\n组件js :\noptions: {// 设置\n    multipleslots: true // 打开多个插槽功能\n},\n  \n  \n组件内部定义slot标签:\n<view>\n    \x3c!-- slot插槽 具名插槽--\x3e\n    <slot name="slot1"></slot>\n    <slot name="slot2"></slot>\n</view>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 判断用户授权\n\n授权\n\n// 判断用户是否授权\n    wx.getsetting({\n      success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n        console.log(res)\n        if (res.authsetting[\'scope.userinfo\']) { // 已授权\n         wx.getuserinfo({ // 获取用户信息\n           success(res) {\n             console.log(res)\n           }\n         })\n        } else { // 未授权\n        \n        }\n      }\n    })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# button的开发能力（获取用户信息）1\n\n<button class="login"\n    open-type="getuserinfo"\n    bindgetuserinfo="ongetuserinfo"     // bindgetuserinfo 为固定的\n>\n\t获取微信授权信息\n</button>\n\n\nbindgetuserinfo 事件会询问用户是否同意授权\n\n\njs中：\n    ongetuserinfo(event) { // 获取用户信息\n      const userinfo = event.detail.userinfo\n      if (userinfo) { // 用户允许授权\n        this.setdata({\n          modalshow: false\n        })\n        this.triggerevent(\'loginsuccess\', userinfo) // 给父组件传用户数据\n      } else { // 用户拒绝授权\n        this.triggerevent(\'loginfail\')\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 原生组件\n\n原生组件\n\n\nauto-focus 自动获取焦点\n\n<textarea\n    class="content"\n    placeholder="分享新鲜事..."\n    maxlength="140"\n    auto-focus\n    bindinput="oninput"\n    bindfocus="onfocus"\n    bindblur="onblur"\n  ></textarea>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 选择上传图片\n\n上传图片\n\nlet max = 9 - this.data.images.length // 还能再选几张图片\nwx.chooseimage({\n      count: max, // 还能再选几张图片\n      sizetype: [\'original\', \'compressed\'], // 初始值 and 压缩过的\n      sourcetype: [\'album\', \'camera\'], // 手机相册选择 and 拍照选择\n      success: (res) => { // 箭头函数改变this指向\n        console.log(res)\n      },\n    })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 图片裁剪\n\n图片裁剪\n\n\x3c!-- mode 图片裁剪 aspectfill 保证短边完整显示 --\x3e\n<image class="image" src="{{item}}" mode="aspectfill"></image>\n\n\n1\n2\n\n\n# 获取标签自定义属性data-* （删除图片的实现）\n\n\x3c!-- 显示图片 --\x3e\n    <block wx:for="{{images}}" wx:key="*this">\n      <view class="image-wrap">\n        \x3c!-- mode 图片裁剪 aspectfill 保证短边完整显示 --\x3e\n        <image class="image" src="{{item}}" mode="aspectfill"></image>\n        <icon class="iconfont icon-shanchu" bindtap="ondelimage" data-index="{{index}}"></icon>\n      </view>\n    </block>\n    \n    \n    // 删除图片\n  ondelimage(event) {\n  \t// event.target.dataset.index 获取标签属性data-index的值\n    this.data.images.splice(event.target.dataset.index, 1) // splice会改变原有数组\n    this.setdata({\n      images: this.data.images\n    })\n  },\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 全屏预览图片(点击图片放大预览)\n\n全屏预览图片\n\n// 全屏预览图片\n  onpreviewimage(event) {\n    wx.previewimage({\n      urls: this.data.images, // 图片地址列表\n      current: event.target.dataset.imgsrc // 当前预览图片地址\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 文件上传云存储（发布博客例子）\n\n文件上传云存储\n\n //  结合\'发布\'的例子：\n  send() {\n    // 验证是否输入内容\n    if (content.trim() === \'\') { // trim() 去掉字符串空格\n      wx.showtoast({\n        title: \'请输入内容\',\n        icon: \'none\'\n      })\n      return\n    }\n    wx.showloading({\n      title: \'发布中\',\n    })\n    /**\n     * 实现思路及步骤：\n     * 1、图片 -> 上传 云存储  -> 生成 图片fineid（云文件id） \n     * 2、数据 -> 录入 云数据库\n     *    数据包括：文字内容、图片fineid、昵称、头像、发布时间、openid(用户唯一标识，在插入数据库是系统会自动添加_openid字段，不需要另外插入)\n     */\n    let promisearr = []\n    let fileids = []\n    // 图片上传云存储\n    this.data.images.foreach((item) => {\n      let p = new promise((resolve, reject) => {\n        let suffix = /\\.\\w+$/.exec(item)[0] // 文件扩展名(文件后缀)\n        wx.cloud.uploadfile({ // 每次只能上传一个文件\n          /**\n           * cloudpath 云路径。如果路径相同，后上传的文件会覆盖原文件\n           * 路径：blog/云存储中的文件夹 + date.now()时间戳 + math.random()*1000000随机数 + 文件后缀\n           */\n          cloudpath: \'blog/\' + date.now() + \'-\' + math.random() * 1000000 + suffix,\n          filepath: item, // 文件本地临时路径\n          success: (res) => {\n            fileids.push(res.fileid)\n            resolve()\n          },\n          fail: (err) => {\n            console.error(err)\n            reject()\n          }\n        })\n      })\n      promisearr.push(p)\n    })\n    \n    // 存入云数据库\n    promise.all(promisearr).then((res) => {\n      db.collection(\'blog\').add({\n        data: {\n          ...userinfo, // 昵称、头像\n          content, // 内容\n          img: fileids, // 图片fileid列表\n          createtime: db.serverdate() // 创建时间，取服务端时间\n        }\n      }).then((res) => {\n        wx.hideloading()\n        wx.showtoast({\n          title: \'发布成功\',\n        })\n        // 返回博客页面，并刷新\n        wx.navigateback()\n\n      })\n    }).catch((err) => {\n      wx.hideloading()\n      wx.showtoast({\n        title: \'抱歉，发布失败\',\n        icon: \'none\'\n      })\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n# js模块化 （时间格式化）\n\n在目录utils 中新建formattime.js文件\n\n// 时间格式化 模块封装\nmodule.exports = (date) => { // date 数据格式为 date\n  let fmt = \'yyyy-mm-dd hh:mm:ss\' // 预定格式\n  const o = {\n    // + 正则中的1个或多个\n    \'m+\': date.getmonth() + 1,\n    \'d+\': date.getdate(),\n    \'h+\': date.gethours(),\n    \'m+\': date.getminutes(),\n    \'s+\': date.getseconds()\n  }\n\n  if (/(y+)/.test(fmt)) {\n    // $1 表示正则中的第一个，即(y+)\n    fmt = fmt.replace(regexp.$1, date.getfullyear()) // replace 替换\n  }\n\n  for (let k in o) {\n    if (new regexp(\'(\'+ k +\')\').test(fmt)) {\n      fmt = fmt.replace(regexp.$1, o[k].tostring().length === 1 ? \'0\' + o[k] : o[k])\n    }\n  }\n\n  return fmt\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n在组件引入js模块\n\nimport formattime from \'../../utils/formattime.js\'\n\n使用：\nformattime(new date(\'wed aug 28 2019 16:23:06 gmt+0800 (中国标准时间)\'))\n\n\n1\n2\n3\n4\n\n\n# 阻止事件冒泡\n\nbind 和 catch 都可以绑定事件，它们的区别是 bind 有事件冒泡，而 catch 没有\n\n# 返回上一个页面并执行方法\n\napi\n\n // 返回博客页面，并刷新\n wx.navigateback()\n const pages = getcurrentpages() // 获取当前页面栈\n const prevpage = pages[pages.length - 2]  // 取到上一个页面\n prevpage.onpulldownrefresh() // 执行上一个页面的方法 onpulldownrefresh\n\n\n1\n2\n3\n4\n5\n\n\n# 图片懒加载\n\napi\n\n给image标签设置 lazy-load 为 true\n<image class="img" src="{{item}}" lazy-load="true"></image>\n\n.img {\n  background: #eee;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n懒加载占位图可以给image设置背景图或背景色\n\n# 模糊查询\n\n// 获取博客列表\n  app.router(\'bloglist\', async (ctx, next) => {\n    const keyword = event.keyword // 搜索关键字 调用接口时传递来的数据\n    let w = {}\n    if (keyword.trim() != \'\') {\n      w = {\n        content: db.regexp({ // 正则\n          regexp: keyword,\n          options: \'i\' // i表示忽略大小写\n        })\n      }\n    }\n\n    // where查询条件 skip 从第几条开始查，limit 查几条数据，orderby(排序字段，排序方式) 排序，排序方式desc降序/asc升序\n    ctx.body =  await blogcollection.where(w).skip(event.start).limit(event.count)\n    .orderby(\'createtime\', \'desc\').get().then((res) => {\n      return res.data\n    })\n    \n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 提升模糊查询的效率 （添加索引，对数据量大的查询效果明显）\n\n云开发控制台 > 数据库相应的集合 > 索引管理 > 添加索引 > 输入自定义索引名称、该字段的值是否唯一、被查询的字段名、升序/降序 > ok\n\n# 小程序端调用云数据库\n\n一般调用云数据库的操作都写在云函数内，其实小程序端也可以对数据库进行操作。\n\n小程序端一次最多只能查询20条数据，云函数端最多可查询100条数据，可使用多次查询拼接的方式突破限制。\n\n// 小程序端调用云数据库示例\n    const db = wx.cloud.database() // 初始化数据库\n    db.collection(\'blog\').orderby(\'createtime\',\'deac\').get().then((res) => {\n      console.log(res)\n    })\n\n\n1\n2\n3\n4\n5\n\n\n# 云数据库权限管理\n\n注意：云控制台和服务端（云函数）始终有所有数据读写权限，\n\n但权限的管理仅对小程序端发起的请求有效。\n\n * 仅创建者可写，所有人可读 （适合于文章）\n\n * 仅创建者可读写 (适用于私密内容)\n\n * 仅管理端可写，所有人可读（适用于商品信息）\n\n * 仅管理端可读写（适用于后台敏感数据）\n\n# 数据库中1对n关系的三种设计方式\n\n# 第一种：n的数量较少 几十个以内\n\n1 条记录存储 n 个子数据\n\n如一条博客中，最多有9张图片，这9张图片可和其他数据放在一个记录中。\n\n[\n\t{\n\t\tid:...\n\t\timg:[\n\t\t\'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\'\n\t\t]\n\t}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 第二种：n的数量较多 几十到几百个\n\n1 存储 每个n的 id\n\n可分两个数据库集合，\n\n一个为 \'目录\' 集合，存放 \'详情\' 集合下的每条数据的 id 目录\n\n一个为 \'详情\' 集合，每条数据对应一个单独的 id 和 详细数据\n\n目录集合：\n[\n\t{\n\t\t\'id\':"11",\n\t\t\'name\': \'产品1\',\n\t\t\'xqs\': [\'111\',\'222\',\'333\', ... ]  // 存放 详情集合 中的每条数据 id\n\t}\n]\n\n\n\n详情集合：\n[\n{\'id\':"111",name:\'零件1\',title:\'...\' ...},\n{\'id\':"222",name:\'零件2\',title:\'...\' ...},\n{\'id\':"333",name:\'零件3\',title:\'...\' ...},\n...\n]\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如歌单列表，与歌曲详情的数据组合设计。\n\n# 第三种：n的数量巨大 几百成千上万个\n\n每个 n 都存储 1 的 id\n\n如新浪博客中的一条博客下面有几千条评论\n\n一条新浪博客：\n[{\n\t\'id\':\'11\',\n\t\'content\':\'博客内容\'\n\t...\n}]\n\n\n上千条评价：\n[\n{\n\t\'id\':\'111111\'\n\t\'blogid\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容1\'\n},\n{\n\t\'id\':\'222222\'\n\t\'blogid\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容2\'\n},\n{\n\t\'id\':\'33333\'\n\t\'blogid\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容3\'\n},\n...\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 云调用\n\n通过云函数调用服务端的开发接口\n\n这些接口如：模板消息推送、生成小程序码...\n\n# 模板消息推送\n\n1、使用from表单才能触发消息推送，并设置report-submit="true"\n\n\n<form slot="modal-content" report-submit="true" bind:submit="onsend">\n    <textarea name="content" class="comment-content" placeholder="写评论" value="{{content}}" fixed="true"></textarea>\n    <button class="send" form-type="submit">发送</button>\n  </form>\n\n\n1\n2\n3\n4\n5\n\n\n2、需要到微信公众平台做相应的设置：\n\n微信公众平台 > 功能 > 模板消息 > 添加模板 > 选择相应的模板> 添加成功后会有一个模板id\n\n3、新建一个云函数，用于云调用。在该云函数下新建配置文件：config.json ，用于配置权限\n\nconfig.json ：\n\n{\n  "permissions": {\n    "openapi": [\n      "templatemessage.send"\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n云函数设置消息推送：\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  // 获取openid\n  const { openid } = cloud.getwxcontext()\n\n  // 模板推送消息\n  const result = await cloud.openapi.templatemessage.send({\n    touser: openid,\n    page: `/p/blog-comment/blog-comment?blogid=${event.blogid}`, // 用户点击推送消息打开的页面\n    data: { // 模板的内容，keyword为在公众平台设置模板时对应的字段\n      keyword1: { // 评价内容\n        value: event.context \n      },\n      keyword2: { // 评价时间\n        value: event.time\n      }\n    },\n    templateid: \'lnwkmcywlz-0habgbhmzi6cwzrlnsbinj2h0smorcxq\', // 模板id，到公众平台模板消息上获取\n    formid: event.formid // 触发消息推送的form表单的id\n  })\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n4、在提交表单事件完成后调用消息推送云函数\n\n wx.cloud.callfunction({\n          name: \'sendmessage\',\n          data: {\n            content,\n            formid,\n            blogid: this.properties.blogid\n          }\n        }).then((res) => {\n          console.log(res)\n        })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 云函数多集合查询数据库\n\n// 博客详情(博客内容、评论)\n  app.router(\'blogdetail\', async(ctx, next) => {\n    let blogid = event.blogid\n\n    // 博客内容\n    let detail = await blogcollection.where({\n      _id: blogid\n    }).get().then((res) => {\n      return res.data\n    })\n\n    // 评论查询\n    const countresult = await blogcollection.count()\n    const total = countresult.total\n    let commentlist = {\n      data: []\n    }\n    if (total > 0) {\n      // 突破100条限制\n      const batchtimes = math.ceil(total / max_limit)\n      const tasks = []\n      for (let i = 0; i < batchtimes; i++) {\n        let promise = db.collection(\'blog-comment\').skip(i * max_limit)\n          .limit(max_limit).where({\n            blogid\n          }).orderby(\'createtime\', \'desc\').get()\n        tasks.push(promise)\n      }\n      if (tasks.length > 0) {\n        commentlist = (await promise.all(tasks)).reduce((acc, cur) => {\n          return {\n            data: acc.data.concat(cur.data)\n          }\n        })\n      }\n\n    }\n    ctx.body = {\n      detail,\n      commentlist\n    }\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n# 分享功能\n\n分享功能需要button标签，设置open-type="share"\n\n\n<button open-type="share" data-blogid="{{blogid}}" data-blog="{{blog}}" class="share-btn" hover-class="share-hover">\n      <i class="iconfont icon-fenxiang icon"></i>\n      <text>分享</text>\n    </button>\n\n\n1\n2\n3\n4\n5\n\n\n在js中有onshareappmessage方法，点击button会自动执行此方法\n\nonshareappmessage: function (event) {\n    console.log(event)\n\n    // 对分享卡片的设置\n    let blogobj = event.target.dataset.blog\n    return {\n      title: blogobj.content,\n      path: `/p/blog-comment/blog-comment?blogid=${blogobj._id}`,\n      // imageurl: \'\' // 自定义图片，不支持云存储的图片\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 不同场景获取用户信息的方式\n\n# 场景一：只想在界面上显示自己的昵称和头像\n\n以组件的方式：根据type类型获取不同用户数据\n\n该方式不需要授权，只能用于在wxml显示自己的信息\n\nopen-data\n\n<open-data type="useravatarurl"></open-data>\n<open-data type="usernickname"></open-data>\n...\n\n\n1\n2\n3\n\n\n# 场景二：在js中获取用户信息\n\n该方式要在用户授权以后才能获取用户信息\n\nwx.getuserinfo\n\nwx.getuserinfo({\n      success: (res) => {\n        console.log(res)\n      }\n    })\n\n\n1\n2\n3\n4\n5\n\n\n在未授权的情况下需要用户先授权：\n\n// 判断用户是否授权\n      wx.getsetting({\n        success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n          if (res.authsetting[\'scope.userinfo\']) { // 已授权\n            wx.getuserinfo({ // 获取用户信息\n              success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n\n                app.setglobaldata(\'userinfo\', res.userinfo) // 设置app全局属性\n\n                this.onloginsuccess({\n                  detail: res.userinfo\n                })\n              }\n            })\n          } else { // 未授权\n            this.setdata({ // 打开弹出层，显示获取用户信息按钮\n              modalshow: true\n            })\n          }\n        }\n      })\n      \n      \n  授权按钮\n <button class="login" open-type="getuserinfo" bindgetuserinfo="ongetuserinfo">获取微信授权信息</button>\n    \n    \n    ongetuserinfo(event) { // 获取用户信息\n      const userinfo = event.detail.userinfo\n      if (userinfo) { // 用户允许授权\n        this.setdata({\n          modalshow: false\n        })\n        this.triggerevent(\'loginsuccess\', userinfo) // 给父组件传用户数据\n      } else { // 用户拒绝授权\n        this.triggerevent(\'loginfail\')\n      }\n    }\n  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n> 注意：上面这种方式没有获取到openid\n\n# 场景三：获取openid\n\n获取openid不需要用户授权\n\n1、传统开发方式获取openid，后台服务器由自己开发，没使用云开发\n\n小程序端 微信服务器 后端服务器\n\n步骤：\n\n小程序端 调用 wx.login 向微信服务器 获取code\n\n小程序端 调用 wx.request 将 code 传递给 后端服务器\n\n后端服务器 使用code 向微信服务器 换取openid和session_key\n\n后端服务器 将openid 发送给 小程序端\n\n2、云开发方式获取openid\n\n云函数login中\n\n// 获取 wx context (微信调用上下文)，包括 openid、appid、及 unionid（需满足 unionid 获取条件）\n  const wxcontext = cloud.getwxcontext()\n\n  return {\n    event,\n    openid: wxcontext.openid,\n    appid: wxcontext.appid,\n    unionid: wxcontext.unionid,\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n普通按钮\n<button bindtap="getopenid">获取openid</button>\n\ngetopenid() {\n\twx.cloud.callfunction({\n\t\tname: \'login\'\n\t}).then((res) => {\n\t\tconsole.log(res)\n\t})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> openid 在小程序和公众号下是不一样的\n> \n> unionid 在小程序和公众号下都是一样的\n\n\n# 《我的》页面\n\njson文件\n\n"navigationbartitletext": "我的",\n  "disablescroll": true  // 使页面无法滚动\n\n\n1\n2\n\n\n# 导航页面链接跳转\n\nnavigator\n\n# 背景图片\n\nwxss背景图片不支持本地相对路径的图片，只支持网络图片和base64图片\n\n建议使用base64图片，图片文件最好不要太大。\n\n# 每个页面都有的page标签\n\npage {\n  background-color: #f1f1f1;\n}\n\n\n1\n2\n3\n\n\n# 播放历史与本地存储\n\n方案一：播放历史存储在数据库当中，这样在不同设备访问都可查看播放历史。读取速度相对较慢\n\n方案二：播放历史存储在本地，仅当前设备可查看播放历史。读取速度较快\n\n本项目采用本地存储：\n\n使用openid作为本地存储的key，播放历史存入value\n\n在app.js中获取openid，即打开小程序就获取openid。\n\n// app.js\nonlaunch: function () {\n\tthis.getopenid() // 获取openid并存储\n},\ngetopenid() { // 获取openid并存储\n    wx.cloud.callfunction({\n      name: \'login\'\n    }).then((res) => {\n      const openid = res.result.openid\n      this.globaldata.openid = openid // 保存到全局变量\n      if (wx.getstoragesync(openid) == \'\') { // 该用户从未打开过小程序，未存储过openid在本地\n        wx.setstoragesync(openid, []) // 存储openid到本地\n      }\n    })\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n歌曲播放时\n\n// 保存播放历史到本地存储\n  saveplayhistory() {\n    const currentsong = musiclist[nowplayingindex] // 当前播放歌曲\n    const openid = app.globaldata.openid // 从全局属性获取openid\n    const playhistory = wx.getstoragesync(openid) // 从本地存储获取播放历史数组\n\n    for (let i = 0, len = playhistory.length; i < len; i++) {\n      if (playhistory[i].id === currentsong.id) { // 当前播放歌曲已存在播放历史中\n        playhistory.splice(i, 1) // 删除原纪录\n        break\n      }\n    }\n\n    playhistory.unshift(currentsong) // 在数组开头插入\n    wx.setstorage({ // 存入本地\n      key: openid,\n      data: playhistory\n    })\n\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n播放历史页面获取\n\nonload: function (options) {\n\n    const openid = app.globaldata.openid //从全局属性获取openid\n    const playhistory = wx.getstoragesync(openid) // 读取本地播放历史数据\n\n    if (playhistory.length !== 0) { // 有播放历史\n      this.setdata({\n        playhistory\n      })\n      wx.setstorage({ // storage里把musiclist（播放列表）的内容换成播放历史的列表\n        key: \'musiclist\',\n        data: playhistory,\n      })\n    }\n\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 我的发现\n\n代码分别演示了从云函数和小程序端获取数据，从小程序端获取数据享有权限管理的能力，不需要传openid。\n\n# 小程序码\n\n获取小程序码\n\n本项目演示使用接口 b：适用于需要的码数量极多的业务场景 云调用 的方式。\n\n步骤：\n\n * 创建云函数 gteqrcode\n\n * gteqrcode云函数下创建config.json配置权限，代码如下：\n\n{\n  "permissions":{\n    "openapi":[\n      "wxacode.getunlimited"\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const wxcontext = cloud.getwxcontext()\n\n  const result = await cloud.openapi.wxacode.getunlimited({\n    scene: wxcontext.openid, // 链接参数 不一定传openid，可传其他任意数据，然后通过此数据，在别人扫码进入时就可用于判断\n    // page: "p/blog/blog" // 默认进入主页\n    // linecolor: { // 线条颜色\n    //   \'r\': 211,\n    //   \'g\': 60,\n    //   \'b\': 57\n    // },\n    // ishyaline: true // 是否透明\n  })\n  \n  // result为二进制数据, 先上传到云存储\n\n  // 上传云存储\n  const upload = await cloud.uploadfile({\n    cloudpath: \'qrcode/qrcode\' + date.now() + math.random() + \'.png\',\n    filecontent: result.buffer\n  })\n\n  return upload.fileid\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 判断是从扫码小程序码进入，以及参数获取\n\n// 在从小程序码进入的页面js，onload方法中，\n\nonload: function (options) {\n\tconsole.log(options.scene) // 获取到小程序码进入的参数\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 版本更新检测\n\n// app.js\nonlaunch: function(options) {\n    this.checkupate()\n},\ncheckupate(){\n    const updatemanager = wx.getupdatemanager()\n    // 检测版本更新\n    updatemanager.oncheckforupdate((res)=>{\n      if (res.hasupdate){\n        updatemanager.onupdateready(()=>{\n          wx.showmodal({\n            title: \'更新提示\',\n            content: \'新版本已经准备好，是否重启应用\',\n            success(res){\n              if(res.confirm){\n                updatemanager.applyupdate()\n              }\n            }\n          })\n        })\n      }\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 性能优化\n\n官网文档优化建议\n\n使用开发者工具的调试器，audits进行评分，然后根据提示针对项目进行优化。\n\n\n# 场景值scene的作用与应用场景\n\n场景值\n\n场景值用来描述用户进入小程序的路径。完整场景值的含义请查看场景值列表。\n\n可根据不同场景进入实现不同业务处理，比如一个点餐小程序，店家内贴了小程序码，用户通过扫码进入，可立即进入点餐页面，等等\n\n在app.js中的onlaunch(options) 、onshow(options)，options包含scene场景值\n\n开发者工具中，切后台，可模拟进入场景。\n\n\n# 小程序的"seo"---页面收录sitemap\n\n在app.js的同级目录下有sitemap.json文件，用于配置收录规则\n\nstiemap配置\n\n作用：\n\n使小程序搜索可根据小程序的内容进行搜索到\n\n使用方法：\n\n1、在微信公众平台，小程序信息 > 页面收录设置 > 打开 (默认是已开启)\n\n2、打开sitemap.json文件，配置收录规则\n\n{\n  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",\n  "rules": [{ // 收录规则\n  "action": "allow",// 是否被收录，allow允许被收录，disallow不允许\n  "page": "*" // *星号表示所有页面都被收录\n  }]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n{\n  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",\n  "rules": [{ // 收录规则，可添加多条\n  "action": "allow", // 是否被收录\n  "page":"p/player/player",  // 页面\n  "params": ["musicid","index"], // 链接的动态参数\n   "matching":\'exact\' // 表示params的参数是否要准确的匹配\n  }，{\n  "action": "disallow", // 是否被收录\n  "page":"*",  /\n  }]\n}\n\n// 上面配置规则表示除了player页面被收录外，其他页面不被收录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 小程序上线审核流程\n\n微信公众平台，版本管理>把小程序上传为体验版》提交审核》上线\n\n\n# 后台管理系统\n\n# 架构示意图\n\n前端 后台 小程序云开发\n\nvue-admin-template <---通过ajax--\x3e 基于koa2；http api 或 tcb-admin-node ----\x3e云函数、云数据库、云存储\n\n\n\n# vue-admin-template构建管理系统前端\n\nvue-element-admin 基于element的后台管理系统模板\n\nvue-admin-template 是 vue-element-admin的简化版\n\n使用方法查看官方文档。\n\n# koa2构建管理系统后端\n\n官网： https://koa.bootcss.com/\n\n新建空文件夹wx-music-admin-backend，打开终端：\n\n# 生成package.json文件，-y 表示默认的配置\nnpm init -y\n\n# 安装koa\nnpm install koa\n\n# 新建app.js文件 (win10系统命令)，作为项目入口文件\ntype nul > app.js\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\napp.js:\n\nconst koa = require(\'koa\')\nconst chalk = require(\'chalk\') // 使console.log打印文字有颜色的插件，需: npm i chalk\nconst app = new koa()\n\napp.use(async (ctx) => {\n  ctx.body = \'hello wolrd\'\n})\nconst port = 3000\napp.listen(port, () => { // 端口号，开启服务后的回调函数\n  console.log(chalk.green(`> 服务已开启，访问：http://localhost:${port}`))\n}) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n终端：\n\n# node启动项目\nnode app.js\n\n# 访问：http://localhost:3000\n\n\n1\n2\n3\n4\n\n\n# 接口调用凭证 access_token 的缓存与更新\n\naccess_token，微信的接口调用凭证，详情：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getaccesstoken.html\n\n回到项目wx-music-admin-backend，打开终端：\n\n# http 请求 插件\nnpm i request\nnpm i request-promise\n\n\n1\n2\n3\n\n\n/**\n * 获取微信接口调用凭证\n * 详情：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getaccesstoken.html\n */\n\n\nconst rp = require(\'request-promise\') // node发送http请求的插件\nconst fs = require(\'fs\') // node文件模块\nconst path = require(\'path\') // node 路径模块\n\n//filename = __dirname 当前文件所在目录的绝对路径, 加上 \'./access_token.json\'\nconst filename = path.resolve(__dirname, \'./access_token.json\')\n\n// 这两个参数的获取：微信公众平台>开发>开发设置\nconst appid = \'wxc4e0b2d98063b103\'\nconst appsecret = \'xxx\' //小程序密钥，注意保密!\n\n// 微信 access_token 请求地址\nconst url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${appsecret}`\n\n// 发送请求获取accesstoken\nconst updateaccesstoken = async () => {\n  const resstr = await rp(url)\n  const res = json.parse(resstr)\n\n  if (res.access_token) {\n    // node写文件,参数：1 文件路径，2 文件内容, 首次写文件为新建，往后为覆盖\n    fs.writefilesync(filename, json.stringify({\n      access_token: res.access_token,\n      createtime: new date()\n    }))\n  } else { // 如获取不到，再次获取\n    await updateaccesstoken()\n  }\n}\n\n// 读取access_token\nconst getaccesstoken = async () => {\n  try {\n     // node读取文件,参数：1 读取的文件，2 字符集\n    const readres = fs.readfilesync(filename, \'utf8\')\n    const readobj = json.parse(readres)\n\n    // 如果服务器宕机导致setinterval无法定时更新，这里需要再次判断access_token的有效性\n    const createtime = new date(readobj.createtime).gettime()\n    const nowtime = new date().gettime()\n    if((nowtime - createtime) / 1000 / 60 / 60 >= 2) {\n      await updateaccesstoken()\n      await getaccesstoken()\n      return\n    }\n    return readobj.access_token\n\n  } catch (error) { //捕获异常，在未创建文件时，先创建文件\n    await updateaccesstoken()\n    await getaccesstoken()\n  }\n}\n\n// access_token有效期为2个小时，定时更新\nsetinterval(async () => {\n  await updateaccesstoken()\n}, (7200 - 300) * 1000)\n\nmodule.exports = getaccesstoken\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 后端代码通过http api 触发云函数获取数据\n\nhttp api 触发云函数\n\n# 产生跨域和后端解决跨域问题\n\n管理系统前端向管理系统后端请求数据，产生了跨域问题\n\n  // 产生跨域的几种情况\n  // http://www.a.com  https://www.a.com 协议不同\n  // http://www.a.com  http://www.b.com 域名不同\n  // http://www.a.com  http://news.a.com 主域与子域不同\n  // http://www.a.com:8080  http://www.a.com:3000 端口不同\n\n// 解决跨域的几种方法\n// jsonp\n// iframe\n// postmessage跨域\n// 跨域资源共享（cors）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n管理系统后端，安装\n\n// 解决跨域问题的koa包\nnpm i koa2-cors\n\n\n1\n2\n\n\napp.js\n\n//处理跨域\napp.use(cors({\n  origin: [\'http://localhost:9528\'], // 允许访问本服务的域\n  credentials: true\n}))\n\n\n1\n2\n3\n4\n5\n\n\n# 云数据库的增删改查接口\n\n数据库查询记录\n\n# 后端获取前端post请求传来的数据\n\nget请求可以直接通过ctx.request.query获取，但是post请求需要安装koa-body\n\nnpm i koa-body\n\n\n1\n\n\napp.js\n\nconst koabody = require(\'koa-body\') // 对post请求前端传来的数据的获取，需要此依赖\n\n// 接收post参数解析\napp.use(koabody({\n  multipart: true\n}))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接口.js\n\nrouter.post(\'/updateplaylist\', async (ctx, next) => {\n    \n  const params = ctx.request.body // post请求获取前端传来的数据，需安装和配置koa-body\n  \n})\n\n\n1\n2\n3\n4\n5\n\n\n# 后端获取云存储图片\n\n云存储中上传图片，云数据库中新建图片的集合，并添加数据字段，字段包含云文件的fileid。\n\n后端项目通过调用云数据库的方式获取数据\n\nrouter.get(\'/list\', async (ctx, next) => {\n  // 接口中读取数据库默认最多10条数据\n  const query = `db.collection(\'swiper\').get()`\n  const res = await callclouddb(ctx, \'databasequery\', query)\n  console.log(res)\n  \n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但获取到的数据为fileid，并不能用于显示图片，需要通过微信http api获取云存储的接口来获取图片地址\n\n获取云存储\n\n# 后端上传图片到云存储\n\n文件上传',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"TypeScript笔记",frontmatter:{title:"TypeScript笔记",date:"2020-10-08T13:02:48.000Z",permalink:"/typescript/",categories:["前端","学习笔记"],tags:[null],description:"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。",meta:[{name:"twitter:title",content:"TypeScript笔记"},{name:"twitter:description",content:"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/04.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/23.TypeScript%E7%AC%94%E8%AE%B0.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"TypeScript笔记"},{property:"og:description",content:"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。"},{property:"og:url",content:"https://dbdgs.cn/04.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/23.TypeScript%E7%AC%94%E8%AE%B0.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-10-08T13:02:48.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"TypeScript笔记"},{itemprop:"description",content:"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。"}]},regularPath:"/04.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/23.TypeScript%E7%AC%94%E8%AE%B0.html",relativePath:"04.前端/40.学习笔记/23.TypeScript笔记.md",key:"v-a4e897ee",path:"/typescript/",headers:[{level:2,title:"类型注解",slug:"类型注解",normalizedTitle:"类型注解",charIndex:61},{level:3,title:"有哪些基础类型注解？",slug:"有哪些基础类型注解",normalizedTitle:"有哪些基础类型注解？",charIndex:221},{level:3,title:"什么是类型注解和类型推断、类型断言？",slug:"什么是类型注解和类型推断、类型断言",normalizedTitle:"什么是类型注解和类型推断、类型断言？",charIndex:507},{level:3,title:"对象的类型",slug:"对象的类型",normalizedTitle:"对象的类型",charIndex:878},{level:3,title:"函数的类型注解",slug:"函数的类型注解",normalizedTitle:"函数的类型注解",charIndex:1335},{level:3,title:"数组的类型注解",slug:"数组的类型注解",normalizedTitle:"数组的类型注解",charIndex:1826},{level:2,title:"元组",slug:"元组",normalizedTitle:"元组",charIndex:2476},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:350},{level:2,title:"ES6 class类中应用TS",slug:"es6-class类中应用ts",normalizedTitle:"es6 class类中应用ts",charIndex:4154},{level:3,title:"class类的修饰器",slug:"class类的修饰器",normalizedTitle:"class类的修饰器",charIndex:4174},{level:3,title:"class类的构造函数中使用类型校验",slug:"class类的构造函数中使用类型校验",normalizedTitle:"class类的构造函数中使用类型校验",charIndex:4798},{level:3,title:"class类的getter、setter和static",slug:"class类的getter、setter和static",normalizedTitle:"class类的getter、setter和static",charIndex:5176},{level:3,title:"class类的只读属性",slug:"class类的只读属性",normalizedTitle:"class类的只读属性",charIndex:5703},{level:3,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:5972},{level:2,title:"联合类型和类型保护",slug:"联合类型和类型保护",normalizedTitle:"联合类型和类型保护",charIndex:6363},{level:2,title:"枚举",slug:"枚举",normalizedTitle:"枚举",charIndex:7258},{level:2,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:7931},{level:3,title:"函数中的泛型使用",slug:"函数中的泛型使用",normalizedTitle:"函数中的泛型使用",charIndex:7969},{level:3,title:"class类中使用泛型",slug:"class类中使用泛型",normalizedTitle:"class类中使用泛型",charIndex:8733},{level:2,title:"配置文件tsconfig.json",slug:"配置文件tsconfig-json",normalizedTitle:"配置文件tsconfig.json",charIndex:9802}],headersStr:"类型注解 有哪些基础类型注解？ 什么是类型注解和类型推断、类型断言？ 对象的类型 函数的类型注解 数组的类型注解 元组 接口 ES6 class类中应用TS class类的修饰器 class类的构造函数中使用类型校验 class类的getter、setter和static class类的只读属性 抽象类 联合类型和类型保护 枚举 泛型 函数中的泛型使用 class类中使用泛型 配置文件tsconfig.json",content:"# TypeScript 学习笔记\n\nTypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\n\n\n# 类型注解\n\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值 \n    ///...\n}\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\n\nconst test:number = 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 有哪些基础类型注解？\n\n// 基础类型\n:string\n:number\n:boolean\n\n:null  // 只能是null值\n:undefined // 只能是undefined值\n\n:symbol\n\n// 引用类型\n:object // 不常用，多使用接口来给对象进行类型注解\n\n// 其他\n:any  // 任意类型\n:void  // 空，用于函数的无返回值的注解\n:never // 用于标注函数代码永远执行不完（如抛出错误的函数，死循环函数）\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 什么是类型注解和类型推断、类型断言？\n\n类型注解 是显式的标注类型\n\n类型推断 是编辑器根据值来自动推断出类型 (编辑器中鼠标移到变量会显示类型的提示)。\n\n类型断言 是告诉编译器，“相信我，它就是这个类型”。\n\n// 类型注解就是显式的写出类型\nconst myNumber: number = 123\n\n// 类型推断是根据值来推断类型 (鼠标移到变量会显示类型(或直接显示值)的提示)\nconst myString = 'test'\n\n// 类型断言（开发者明确知道是什么类型）\nconst someValue:any = 'abc'\nconst strLength:number = (someValue as string).length // 断言someValue是字符串类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 对象的类型\n\n// 对象字面量的类型检查\nconst xiaojiejie: {\n  name: string,\n  age: number\n} = {\n  name: '小红',\n  age: 18\n}\n\n// 标注:object\nconst obj:object = {}\n\n// 使用接口\ninterface Person{\n    name: string\n    age: number\n}\nconst xjj: Person = {\n    name: 'xh',\n    age: 18\n}\n\n// class类的类型检查\nclass Parson { }\nconst xiaobai: Parson = new Parson()\n\n// 函数和返回值的类型检查\nconst fn: ()=> string = () => '123'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 函数的类型注解\n\n// 函数返回值的类型注解 fn(): number {}\nfunction getTotal2(one: number, two: number): number {\n  return one + two\n}\ngetTotal2(1,2)\n\n\n// 无返回值: void\nfunction sayHello(): void {\n  console.log(\"Hello\")\n}\n\n// 永远执行不玩的函数\nfunction setTimer():never {\n  throw new Error()\n  console.log(123)\n}\n\n// 参数是对象时的注解 （也可以用接口）\nfunction add({ one, two }: {one: number, two: number}) {\n  return  one + two\n}\n\nconst total = add({one: 1, two: 2})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 数组的类型注解\n\nconst numberArr: number[] = [1, 2, 3] \nconst stringArr: string[] = ['a', 'b']\nconst undefinedArr: undefined[] = [undefined, undefined]\nconst arr: (number | string | boolean)[] = [1, 'a', true, false] // 用到联合类型\n\n// 类型别名 type alias\ntype lady = { name: string, age: number }\n\nconst xiaojj: lady[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n// 或用类的方式\nclass Ady2 {\n  name: string;\n  age: number;\n}\n\nconst xiaojj2: Ady2[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 元组\n\n元组，可以理解为：已知元素数量和类型的数组\n\n// 联合类型\nconst xjj:(string | number)[] = ['a',22,'b'] // 规定整个数组当中可以有string或number\n\n// 元组注解 注意这里的注解只有一个中括号\nconst xjj1: [string, number, number] = ['a', 22, 33] // 规定了数组每个元素对应位置的类型\n\n// Note: 在开发中元祖的使用在相对少\n\n\n// CSV的方式定义数据格式； （二维数组时需要多加一个中括号）\nconst xjj2: [string, number, number][] = [\n  ['a', 22, 33],\n  ['a', 22, 33]\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 接口\n\n接口，可以理解为对象属性的类型描述。和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如type Girl = string\n\ninterface Girl { // 接口 （理解：对象属性的类型描述）\n  readonly name: string; // 只读属性 （定义之后不能再修改）\n  age: number;\n  waistline?: number; // 加个问号表示是可选值\n  [propname: string]: any; // 表示可以有不限制属性名的属性，但属性名需要是字符串，值可以是任意类型\n  say(): string; // 函数类型，返回值是string (如无返回值时是 void)。  say()也可以加入参数类型检查，如say(p:number)\n}\n// 和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如 type Girl = string\n\n// 接口的继承\ninterface Teacher extends Girl {\n  teach(): string;\n}\n\n\nconst girl = {\n  name: '大脚',\n  age: 18,\n  sex: '女',\n  say() {\n    return '欢迎光临'\n  },\n  teach() {\n    return '教'\n  }\n}\n\n\nconst screenResume = ({ name, age, bust, sex }: Girl) => {\n  console.log(name, age, bust, sex)\n}\nconst getResume = ({ name, age, bust, teach}: Teacher) => {\n  teach();\n  console.log(name, age, bust)\n}\nscreenResume(girl)\ngetResume(girl)\n\n\n// 接口在class类中的使用\nclass xiaojjj implements Girl {\n  name = \"xiaojj\"\n  age = 18\n  bust = 98\n  sex = '女'\n  say() {\n    return '欢迎光临'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n可索引的类型\n\ninterface Arr {\n    [index: number]:string   // 表示通过索引访问数据时返回的类型是string\n}\n\nconst myArr:Arr = ['1','2','3']\nconst myStr:string = myArr[1]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# ES6 class类中应用TS\n\n\n# class类的修饰器\n\n// 类的修饰器：\n// public (公共) 允许内外部使用\n// protected (受保护的) 允许在内部和继承内使用\n// private (私有) 允许在内部使用，但不能在继承中使用\n\n// 类的内部和外部，{}内属于内部，外面是外部\nclass Person {\n   // public 内外都可以使用，可省略，不写时默认public。 protected只允许内部使用\n  name: string // 这里的string注释是TS使用的\n  private age: 18\n  public sayHello() {\n    console.log(this.name + this.age + 'say hello')\n  }\n}\n\nclass Teacher2 extends Person {\n  public sayBye() {\n    console.log(this.name + ' say bye') // protected 可以在继承中使用到\n  }\n}\n\nconst person = new Person();\nperson.name = 'test' // 在类的外部定义\nconsole.log(person.name)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# class类的构造函数中使用类型校验\n\nclass Person2 {\n  constructor(public name: string) {\n    this.name = name\n  }\n}\n\nclass Teacher3 extends Person2{\n  constructor(public age: number) {\n    super('test-name') // 这里传的值是给Person2的构造函数。即使父类没有构造函数，子类的构造函数内也要写super()\n  }\n}\nconst teacher3 = new Teacher3(18)\nconsole.log(teacher3.name)\nconsole.log(teacher3.age)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# class类的getter、setter和static\n\nclass Xjj {\n  constructor(private _age: number) { }\n  get age() {\n    return this._age - 10;\n  }  // 访问器属性，以属性的形式访问age，并可以对属性进行包装\n  set age(age: number) {\n    this._age = age+3;\n   }\n}\n\nconst dj = new Xjj(28);\ndj.age = 25\n\nconsole.log(dj.age)\n\n\n// 静态属性 static。  静态属性指不需要通过实例化，直接通过Girl.prop的方式就可以访问到属性\nclass Girl {\n  static sayLove() {\n    return 'I love you'\n  }\n}\n\n// const girl = new Girl()\nconsole.log(Girl.sayLove())\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# class类的只读属性\n\n// 只读属性\nclass Person {\n  public readonly _name: string // 只读属性\n  constructor(name: string) {\n    this._name = name;\n  }\n}\n\nconst person = new Person('testName');\n// person._name = '222'; // 不能修改只读属性\nconsole.log(person._name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 抽象类\n\n/ 抽象类\nabstract class Girls {\n  abstract skill(); // 注意这里只是定义抽象方法，而不具有方法的实现\n}\n\nclass Waiter extends Girls{ // 继承了抽象类之后要 实现抽象类内的成员\n  skill() {\n    console.log('大爷1')\n  }\n}\n\nclass BaseTeacher extends Girls{\n  skill() {\n    console.log('大爷2')\n  }\n}\n\nclass SeniorTeacher extends Girls{\n  skill() {\n    console.log('大爷3')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 联合类型和类型保护\n\n联合类型 指某个参数可以是多种类型。\n\n类型保护 指参数属于某个类型才有相应的操作。\n\ninterface Waiter {\n  anjiao: boolean\n  say: () => {}\n}\n\ninterface Teacher {\n  anjiao: boolean\n  skill: () => {}\n}\n\nfunction judgeWho(animal: (Waiter | Teacher)) { // 联合类型\n  // 第一种断言方法\n  if (animal.anjiao) {\n    // (animal as Teacher) 的意思是：断言 animal 是 Teacher类型\n    (animal as Teacher).skill()\n  } else {\n    (animal as Waiter).say()\n  }\n\n  // 第二种断言方法\n  if ('skill' in animal) {\n    animal.skill()\n  } else {\n    animal.say()\n  }\n    \n  // 第三种类型保护方法是使用typeof来判断 (代码省略)\n}\n\n\nclass NumberObj {\n  count: number\n}\nfunction addObj(first: object | NumberObj, second: object | NumberObj) { // 联合类型\n  if (first instanceof NumberObj && second instanceof NumberObj) { // 类型保护\n    return first.count + second.count;\n  }\n  return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 枚举\n\n// Enum枚举类型   (个人理解枚举：约定一组可选的常量。 使用常量名表示某个值的含义，增强可读性。)\n\n// js写法\n// const Status = {\n//   MASSAGE: 0,\n//   SPA: 1,\n//   DABAOJIAN: 2\n// }\n\n// ts写法\nenum Status {\n  MASSAGE,  // 如果想从1开始，给MASSAGE = 1, 即可\n  SPA,\n  DABAOJIAN\n} // 默认赋值 0 、1、2\n\nconsole.log(Status.MASSAGE, Status[0]) // 0, MASSAGE  可以通过下标反查\n\nfunction getStatus(status: any) {\n  if (status === Status.MASSAGE) {\n    return 'massage'\n  } else if (status === Status.SPA) {\n    return 'spa'\n  } else if (status === Status.DABAOJIAN) {\n    return 'dabaojian'\n  }\n}\n\nconst result = getStatus(Status.SPA)\nconsole.log(result)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 泛型\n\n泛型，最简单的理解：泛指的类型。（类似函数中的形参与实参）\n\n\n# 函数中的泛型使用\n\n\n// function join(first: string | number, second: string | number) {\n//   return `${first}${second}`\n// }\n// join('jspang', 1); // 如果我想第一个参数是字符串，第二个也必须是字符串，这么就用到泛型\n\n\n// 泛型使用，如同定义形参，在调用时指定类型\nfunction join<JSPang>(first: JSPang, second: JSPang) {\n  return `${first}${second}`\n}\n\njoin<string>('jspang', '123');\njoin<number>(11, 22);\n\n// 泛型中数组的使用\nfunction myFun<ANY>(params:ANY[]) { // ANY[] or Array<ANY>\n  return params\n}\nmyFun<string>(['a', 'b'])\n\n\n// 两个类型参数的使用（工作中，常用T表示泛型）\nfunction join2<T,P>(first: T, second: P) {\n  return `${first}${second}`\n}\n\njoin2<string,number>('jspang', 123);\njoin2<number, string>(11, '22');\njoin2(11, '22'); // 泛型也支持类型推断 （鼠标移到函数名有提示）\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# class类中使用泛型\n\n// class SelectGirl {\n//   constructor(private girls: string[] | number[]) { } // private 私有的参数，外部无法修改\n//   getGirl(index: number): string | number {\n//     return this.girls[index]\n//   }\n// }\n\n// 使用泛型\nclass SelectGirl<T> {   // 泛型的约束: <T extends number | string>\n  constructor(private girls: T[]) { } // private 私有的参数，外部无法修改\n  getGirl(index: number): T {\n    return this.girls[index]\n  }\n}\n\n// const selectGirl = new SelectGirl<string>(['大脚', 'xiaohong', 'xiaobai'])\nconst selectGirl = new SelectGirl<number>([101, 102, 103])\nconsole.log(selectGirl.getGirl(1))\n\n\n// 泛型中的继承\ninterface Girl {\n  name: string\n}\nclass SelectGirl2<T extends Girl> { // 泛型T中必须有一个name属性，继承自Girl接口\n  constructor(private girls: T[]) { } // private 私有的参数，外部无法修改\n  getGirl(index: number): string {\n    return this.girls[index].name\n  }\n}\n\nconst selectGirl2 = new SelectGirl2([\n  {name: '大脚1'},\n  {name: '大脚2'},\n  {name: '大脚3'}\n])\n\nconsole.log(selectGirl2.getGirl(1))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 配置文件tsconfig.json\n\n// 此文件由命令 tsc -init 生成\n// 直接运行 tsc 命令就会运用此配置文件\n// 选项详解：https://www.tslang.cn/docs/handbook/compiler-options.html\n{\n  // \"include\": [\"demo15-1.ts\"], // 要编译的指定文件，不配置此项时运行tsc默认编译全部\n  // \"files\": [\"demo15-1.ts\"], // 和include类似\n  // \"exclude\": [\"demo15-3.ts\"], // 要排除编译的指定文件\n  \"compilerOptions\": { // 编译选项\n    /* 基本选项 */\n    // \"incremental\": true,                   /* Enable incremental compilation */\n    \"target\": \"es5\",                          /* 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */\n    \"module\": \"commonjs\",                     /* 指定模块代码生成: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */\n    // \"lib\": [],                             /* Specify library files to be included in the compilation. */\n    // \"allowJs\": true,                       /* Allow javascript files to be compiled. */\n    // \"checkJs\": true,                       /* Report errors in .js files. */\n    // \"jsx\": \"preserve\",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */\n    // \"declaration\": true,                   /* Generates corresponding '.d.ts' file. */\n    // \"declarationMap\": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */\n    \"sourceMap\": true,                     /* 源文件与输出文件的映射关系文件。Generates corresponding '.map' file. */\n    // \"outFile\": \"./\",                       /* Concatenate and emit output to single file. */\n    \"outDir\": \"./build\",                        /* 输出的js文件目录。Redirect output structure to the directory. */\n    \"rootDir\": \"./src\",                       /* ts源文件目录。Specify the root directory of input files. Use to control the output directory structure with --outDir. */\n    // \"composite\": true,                     /* Enable project compilation */\n    // \"tsBuildInfoFile\": \"./\",               /* Specify file to store incremental compilation information */\n    // \"removeComments\": true,                /* 不输出注释到编译结果. */\n    // \"noEmit\": true,                        /* Do not emit outputs. */\n    // \"importHelpers\": true,                 /* Import emit helpers from 'tslib'. */\n    // \"downlevelIteration\": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */\n    // \"isolatedModules\": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                           /* 启用所有严格类型检查选项。 打开此选项后，下面这些选项就不需要单独设置*/\n    // \"noImplicitAny\": true,                 /* Raise error on expressions and declarations with an implied 'any' type. 为false时允许any不用特意声明。*/\n    // \"strictNullChecks\": true,              /* Enable strict null checks. 为false时允许赋值为null*/\n    // \"strictFunctionTypes\": true,           /* Enable strict checking of function types. */\n    // \"strictBindCallApply\": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */\n    // \"strictPropertyInitialization\": true,  /* Enable strict checking of property initialization in classes. */\n    // \"noImplicitThis\": true,                /* Raise error on 'this' expressions with an implied 'any' type. */\n    // \"alwaysStrict\": true,                  /* Parse in strict mode and emit \"use strict\" for each source file. */\n\n    /* 附加检查。Additional Checks  */\n    // \"noUnusedLocals\": true,                /* Report errors on unused locals. 报告未使用的本地变量 */\n    // \"noUnusedParameters\": true,            /* Report errors on unused parameters. */\n    // \"noImplicitReturns\": true,             /* Report error when not all code paths in function return a value. */\n    // \"noFallthroughCasesInSwitch\": true,    /* Report errors for fallthrough cases in switch statement. */\n\n    /* Module Resolution Options */\n    // \"moduleResolution\": \"node\",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */\n    // \"baseUrl\": \"./\",                       /* Base directory to resolve non-absolute module names. */\n    // \"paths\": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */\n    // \"rootDirs\": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */\n    // \"typeRoots\": [],                       /* List of folders to include type definitions from. */\n    // \"types\": [],                           /* Type declaration files to be included in compilation. */\n    // \"allowSyntheticDefaultImports\": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */\n    \"esModuleInterop\": true                   /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */\n    // \"preserveSymlinks\": true,              /* Do not resolve the real path of symlinks. */\n    // \"allowUmdGlobalAccess\": true,          /* Allow accessing UMD globals from modules. */\n\n    /* Source Map Options */\n    // \"sourceRoot\": \"\",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */\n    // \"mapRoot\": \"\",                         /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,               /* Emit a single file with source maps instead of having a separate file. */\n    // \"inlineSources\": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */\n\n    /* Experimental Options */\n    // \"experimentalDecorators\": true,        /* Enables experimental support for ES7 decorators. */\n    // \"emitDecoratorMetadata\": true,         /* Enables experimental support for emitting type metadata for decorators. */\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n",normalizedContent:"# typescript 学习笔记\n\ntypescript 的类型校验是给程序员看的，在编译后不会存在ts代码。\n\n\n# 类型注解\n\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值 \n    ///...\n}\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\n\nconst test:number = 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 有哪些基础类型注解？\n\n// 基础类型\n:string\n:number\n:boolean\n\n:null  // 只能是null值\n:undefined // 只能是undefined值\n\n:symbol\n\n// 引用类型\n:object // 不常用，多使用接口来给对象进行类型注解\n\n// 其他\n:any  // 任意类型\n:void  // 空，用于函数的无返回值的注解\n:never // 用于标注函数代码永远执行不完（如抛出错误的函数，死循环函数）\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 什么是类型注解和类型推断、类型断言？\n\n类型注解 是显式的标注类型\n\n类型推断 是编辑器根据值来自动推断出类型 (编辑器中鼠标移到变量会显示类型的提示)。\n\n类型断言 是告诉编译器，“相信我，它就是这个类型”。\n\n// 类型注解就是显式的写出类型\nconst mynumber: number = 123\n\n// 类型推断是根据值来推断类型 (鼠标移到变量会显示类型(或直接显示值)的提示)\nconst mystring = 'test'\n\n// 类型断言（开发者明确知道是什么类型）\nconst somevalue:any = 'abc'\nconst strlength:number = (somevalue as string).length // 断言somevalue是字符串类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 对象的类型\n\n// 对象字面量的类型检查\nconst xiaojiejie: {\n  name: string,\n  age: number\n} = {\n  name: '小红',\n  age: 18\n}\n\n// 标注:object\nconst obj:object = {}\n\n// 使用接口\ninterface person{\n    name: string\n    age: number\n}\nconst xjj: person = {\n    name: 'xh',\n    age: 18\n}\n\n// class类的类型检查\nclass parson { }\nconst xiaobai: parson = new parson()\n\n// 函数和返回值的类型检查\nconst fn: ()=> string = () => '123'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 函数的类型注解\n\n// 函数返回值的类型注解 fn(): number {}\nfunction gettotal2(one: number, two: number): number {\n  return one + two\n}\ngettotal2(1,2)\n\n\n// 无返回值: void\nfunction sayhello(): void {\n  console.log(\"hello\")\n}\n\n// 永远执行不玩的函数\nfunction settimer():never {\n  throw new error()\n  console.log(123)\n}\n\n// 参数是对象时的注解 （也可以用接口）\nfunction add({ one, two }: {one: number, two: number}) {\n  return  one + two\n}\n\nconst total = add({one: 1, two: 2})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 数组的类型注解\n\nconst numberarr: number[] = [1, 2, 3] \nconst stringarr: string[] = ['a', 'b']\nconst undefinedarr: undefined[] = [undefined, undefined]\nconst arr: (number | string | boolean)[] = [1, 'a', true, false] // 用到联合类型\n\n// 类型别名 type alias\ntype lady = { name: string, age: number }\n\nconst xiaojj: lady[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n// 或用类的方式\nclass ady2 {\n  name: string;\n  age: number;\n}\n\nconst xiaojj2: ady2[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 元组\n\n元组，可以理解为：已知元素数量和类型的数组\n\n// 联合类型\nconst xjj:(string | number)[] = ['a',22,'b'] // 规定整个数组当中可以有string或number\n\n// 元组注解 注意这里的注解只有一个中括号\nconst xjj1: [string, number, number] = ['a', 22, 33] // 规定了数组每个元素对应位置的类型\n\n// note: 在开发中元祖的使用在相对少\n\n\n// csv的方式定义数据格式； （二维数组时需要多加一个中括号）\nconst xjj2: [string, number, number][] = [\n  ['a', 22, 33],\n  ['a', 22, 33]\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 接口\n\n接口，可以理解为对象属性的类型描述。和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如type girl = string\n\ninterface girl { // 接口 （理解：对象属性的类型描述）\n  readonly name: string; // 只读属性 （定义之后不能再修改）\n  age: number;\n  waistline?: number; // 加个问号表示是可选值\n  [propname: string]: any; // 表示可以有不限制属性名的属性，但属性名需要是字符串，值可以是任意类型\n  say(): string; // 函数类型，返回值是string (如无返回值时是 void)。  say()也可以加入参数类型检查，如say(p:number)\n}\n// 和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如 type girl = string\n\n// 接口的继承\ninterface teacher extends girl {\n  teach(): string;\n}\n\n\nconst girl = {\n  name: '大脚',\n  age: 18,\n  sex: '女',\n  say() {\n    return '欢迎光临'\n  },\n  teach() {\n    return '教'\n  }\n}\n\n\nconst screenresume = ({ name, age, bust, sex }: girl) => {\n  console.log(name, age, bust, sex)\n}\nconst getresume = ({ name, age, bust, teach}: teacher) => {\n  teach();\n  console.log(name, age, bust)\n}\nscreenresume(girl)\ngetresume(girl)\n\n\n// 接口在class类中的使用\nclass xiaojjj implements girl {\n  name = \"xiaojj\"\n  age = 18\n  bust = 98\n  sex = '女'\n  say() {\n    return '欢迎光临'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n可索引的类型\n\ninterface arr {\n    [index: number]:string   // 表示通过索引访问数据时返回的类型是string\n}\n\nconst myarr:arr = ['1','2','3']\nconst mystr:string = myarr[1]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# es6 class类中应用ts\n\n\n# class类的修饰器\n\n// 类的修饰器：\n// public (公共) 允许内外部使用\n// protected (受保护的) 允许在内部和继承内使用\n// private (私有) 允许在内部使用，但不能在继承中使用\n\n// 类的内部和外部，{}内属于内部，外面是外部\nclass person {\n   // public 内外都可以使用，可省略，不写时默认public。 protected只允许内部使用\n  name: string // 这里的string注释是ts使用的\n  private age: 18\n  public sayhello() {\n    console.log(this.name + this.age + 'say hello')\n  }\n}\n\nclass teacher2 extends person {\n  public saybye() {\n    console.log(this.name + ' say bye') // protected 可以在继承中使用到\n  }\n}\n\nconst person = new person();\nperson.name = 'test' // 在类的外部定义\nconsole.log(person.name)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# class类的构造函数中使用类型校验\n\nclass person2 {\n  constructor(public name: string) {\n    this.name = name\n  }\n}\n\nclass teacher3 extends person2{\n  constructor(public age: number) {\n    super('test-name') // 这里传的值是给person2的构造函数。即使父类没有构造函数，子类的构造函数内也要写super()\n  }\n}\nconst teacher3 = new teacher3(18)\nconsole.log(teacher3.name)\nconsole.log(teacher3.age)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# class类的getter、setter和static\n\nclass xjj {\n  constructor(private _age: number) { }\n  get age() {\n    return this._age - 10;\n  }  // 访问器属性，以属性的形式访问age，并可以对属性进行包装\n  set age(age: number) {\n    this._age = age+3;\n   }\n}\n\nconst dj = new xjj(28);\ndj.age = 25\n\nconsole.log(dj.age)\n\n\n// 静态属性 static。  静态属性指不需要通过实例化，直接通过girl.prop的方式就可以访问到属性\nclass girl {\n  static saylove() {\n    return 'i love you'\n  }\n}\n\n// const girl = new girl()\nconsole.log(girl.saylove())\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# class类的只读属性\n\n// 只读属性\nclass person {\n  public readonly _name: string // 只读属性\n  constructor(name: string) {\n    this._name = name;\n  }\n}\n\nconst person = new person('testname');\n// person._name = '222'; // 不能修改只读属性\nconsole.log(person._name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 抽象类\n\n/ 抽象类\nabstract class girls {\n  abstract skill(); // 注意这里只是定义抽象方法，而不具有方法的实现\n}\n\nclass waiter extends girls{ // 继承了抽象类之后要 实现抽象类内的成员\n  skill() {\n    console.log('大爷1')\n  }\n}\n\nclass baseteacher extends girls{\n  skill() {\n    console.log('大爷2')\n  }\n}\n\nclass seniorteacher extends girls{\n  skill() {\n    console.log('大爷3')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 联合类型和类型保护\n\n联合类型 指某个参数可以是多种类型。\n\n类型保护 指参数属于某个类型才有相应的操作。\n\ninterface waiter {\n  anjiao: boolean\n  say: () => {}\n}\n\ninterface teacher {\n  anjiao: boolean\n  skill: () => {}\n}\n\nfunction judgewho(animal: (waiter | teacher)) { // 联合类型\n  // 第一种断言方法\n  if (animal.anjiao) {\n    // (animal as teacher) 的意思是：断言 animal 是 teacher类型\n    (animal as teacher).skill()\n  } else {\n    (animal as waiter).say()\n  }\n\n  // 第二种断言方法\n  if ('skill' in animal) {\n    animal.skill()\n  } else {\n    animal.say()\n  }\n    \n  // 第三种类型保护方法是使用typeof来判断 (代码省略)\n}\n\n\nclass numberobj {\n  count: number\n}\nfunction addobj(first: object | numberobj, second: object | numberobj) { // 联合类型\n  if (first instanceof numberobj && second instanceof numberobj) { // 类型保护\n    return first.count + second.count;\n  }\n  return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 枚举\n\n// enum枚举类型   (个人理解枚举：约定一组可选的常量。 使用常量名表示某个值的含义，增强可读性。)\n\n// js写法\n// const status = {\n//   massage: 0,\n//   spa: 1,\n//   dabaojian: 2\n// }\n\n// ts写法\nenum status {\n  massage,  // 如果想从1开始，给massage = 1, 即可\n  spa,\n  dabaojian\n} // 默认赋值 0 、1、2\n\nconsole.log(status.massage, status[0]) // 0, massage  可以通过下标反查\n\nfunction getstatus(status: any) {\n  if (status === status.massage) {\n    return 'massage'\n  } else if (status === status.spa) {\n    return 'spa'\n  } else if (status === status.dabaojian) {\n    return 'dabaojian'\n  }\n}\n\nconst result = getstatus(status.spa)\nconsole.log(result)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 泛型\n\n泛型，最简单的理解：泛指的类型。（类似函数中的形参与实参）\n\n\n# 函数中的泛型使用\n\n\n// function join(first: string | number, second: string | number) {\n//   return `${first}${second}`\n// }\n// join('jspang', 1); // 如果我想第一个参数是字符串，第二个也必须是字符串，这么就用到泛型\n\n\n// 泛型使用，如同定义形参，在调用时指定类型\nfunction join<jspang>(first: jspang, second: jspang) {\n  return `${first}${second}`\n}\n\njoin<string>('jspang', '123');\njoin<number>(11, 22);\n\n// 泛型中数组的使用\nfunction myfun<any>(params:any[]) { // any[] or array<any>\n  return params\n}\nmyfun<string>(['a', 'b'])\n\n\n// 两个类型参数的使用（工作中，常用t表示泛型）\nfunction join2<t,p>(first: t, second: p) {\n  return `${first}${second}`\n}\n\njoin2<string,number>('jspang', 123);\njoin2<number, string>(11, '22');\njoin2(11, '22'); // 泛型也支持类型推断 （鼠标移到函数名有提示）\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# class类中使用泛型\n\n// class selectgirl {\n//   constructor(private girls: string[] | number[]) { } // private 私有的参数，外部无法修改\n//   getgirl(index: number): string | number {\n//     return this.girls[index]\n//   }\n// }\n\n// 使用泛型\nclass selectgirl<t> {   // 泛型的约束: <t extends number | string>\n  constructor(private girls: t[]) { } // private 私有的参数，外部无法修改\n  getgirl(index: number): t {\n    return this.girls[index]\n  }\n}\n\n// const selectgirl = new selectgirl<string>(['大脚', 'xiaohong', 'xiaobai'])\nconst selectgirl = new selectgirl<number>([101, 102, 103])\nconsole.log(selectgirl.getgirl(1))\n\n\n// 泛型中的继承\ninterface girl {\n  name: string\n}\nclass selectgirl2<t extends girl> { // 泛型t中必须有一个name属性，继承自girl接口\n  constructor(private girls: t[]) { } // private 私有的参数，外部无法修改\n  getgirl(index: number): string {\n    return this.girls[index].name\n  }\n}\n\nconst selectgirl2 = new selectgirl2([\n  {name: '大脚1'},\n  {name: '大脚2'},\n  {name: '大脚3'}\n])\n\nconsole.log(selectgirl2.getgirl(1))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 配置文件tsconfig.json\n\n// 此文件由命令 tsc -init 生成\n// 直接运行 tsc 命令就会运用此配置文件\n// 选项详解：https://www.tslang.cn/docs/handbook/compiler-options.html\n{\n  // \"include\": [\"demo15-1.ts\"], // 要编译的指定文件，不配置此项时运行tsc默认编译全部\n  // \"files\": [\"demo15-1.ts\"], // 和include类似\n  // \"exclude\": [\"demo15-3.ts\"], // 要排除编译的指定文件\n  \"compileroptions\": { // 编译选项\n    /* 基本选项 */\n    // \"incremental\": true,                   /* enable incremental compilation */\n    \"target\": \"es5\",                          /* 指定 ecmascript 目标版本: 'es3' (default), 'es5', 'es2015', 'es2016', 'es2017', 'es2018', 'es2019' or 'esnext'. */\n    \"module\": \"commonjs\",                     /* 指定模块代码生成: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'esnext'. */\n    // \"lib\": [],                             /* specify library files to be included in the compilation. */\n    // \"allowjs\": true,                       /* allow javascript files to be compiled. */\n    // \"checkjs\": true,                       /* report errors in .js files. */\n    // \"jsx\": \"preserve\",                     /* specify jsx code generation: 'preserve', 'react-native', or 'react'. */\n    // \"declaration\": true,                   /* generates corresponding '.d.ts' file. */\n    // \"declarationmap\": true,                /* generates a sourcemap for each corresponding '.d.ts' file. */\n    \"sourcemap\": true,                     /* 源文件与输出文件的映射关系文件。generates corresponding '.map' file. */\n    // \"outfile\": \"./\",                       /* concatenate and emit output to single file. */\n    \"outdir\": \"./build\",                        /* 输出的js文件目录。redirect output structure to the directory. */\n    \"rootdir\": \"./src\",                       /* ts源文件目录。specify the root directory of input files. use to control the output directory structure with --outdir. */\n    // \"composite\": true,                     /* enable project compilation */\n    // \"tsbuildinfofile\": \"./\",               /* specify file to store incremental compilation information */\n    // \"removecomments\": true,                /* 不输出注释到编译结果. */\n    // \"noemit\": true,                        /* do not emit outputs. */\n    // \"importhelpers\": true,                 /* import emit helpers from 'tslib'. */\n    // \"downleveliteration\": true,            /* provide full support for iterables in 'for-of', spread, and destructuring when targeting 'es5' or 'es3'. */\n    // \"isolatedmodules\": true,               /* transpile each file as a separate module (similar to 'ts.transpilemodule'). */\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                           /* 启用所有严格类型检查选项。 打开此选项后，下面这些选项就不需要单独设置*/\n    // \"noimplicitany\": true,                 /* raise error on expressions and declarations with an implied 'any' type. 为false时允许any不用特意声明。*/\n    // \"strictnullchecks\": true,              /* enable strict null checks. 为false时允许赋值为null*/\n    // \"strictfunctiontypes\": true,           /* enable strict checking of function types. */\n    // \"strictbindcallapply\": true,           /* enable strict 'bind', 'call', and 'apply' methods on functions. */\n    // \"strictpropertyinitialization\": true,  /* enable strict checking of property initialization in classes. */\n    // \"noimplicitthis\": true,                /* raise error on 'this' expressions with an implied 'any' type. */\n    // \"alwaysstrict\": true,                  /* parse in strict mode and emit \"use strict\" for each source file. */\n\n    /* 附加检查。additional checks  */\n    // \"nounusedlocals\": true,                /* report errors on unused locals. 报告未使用的本地变量 */\n    // \"nounusedparameters\": true,            /* report errors on unused parameters. */\n    // \"noimplicitreturns\": true,             /* report error when not all code paths in function return a value. */\n    // \"nofallthroughcasesinswitch\": true,    /* report errors for fallthrough cases in switch statement. */\n\n    /* module resolution options */\n    // \"moduleresolution\": \"node\",            /* specify module resolution strategy: 'node' (node.js) or 'classic' (typescript pre-1.6). */\n    // \"baseurl\": \"./\",                       /* base directory to resolve non-absolute module names. */\n    // \"paths\": {},                           /* a series of entries which re-map imports to lookup locations relative to the 'baseurl'. */\n    // \"rootdirs\": [],                        /* list of root folders whose combined content represents the structure of the project at runtime. */\n    // \"typeroots\": [],                       /* list of folders to include type definitions from. */\n    // \"types\": [],                           /* type declaration files to be included in compilation. */\n    // \"allowsyntheticdefaultimports\": true,  /* allow default imports from modules with no default export. this does not affect code emit, just typechecking. */\n    \"esmoduleinterop\": true                   /* enables emit interoperability between commonjs and es modules via creation of namespace objects for all imports. implies 'allowsyntheticdefaultimports'. */\n    // \"preservesymlinks\": true,              /* do not resolve the real path of symlinks. */\n    // \"allowumdglobalaccess\": true,          /* allow accessing umd globals from modules. */\n\n    /* source map options */\n    // \"sourceroot\": \"\",                      /* specify the location where debugger should locate typescript files instead of source locations. */\n    // \"maproot\": \"\",                         /* specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlinesourcemap\": true,               /* emit a single file with source maps instead of having a separate file. */\n    // \"inlinesources\": true,                 /* emit the source alongside the sourcemaps within a single file; requires '--inlinesourcemap' or '--sourcemap' to be set. */\n\n    /* experimental options */\n    // \"experimentaldecorators\": true,        /* enables experimental support for es7 decorators. */\n    // \"emitdecoratormetadata\": true,         /* enables experimental support for emitting type metadata for decorators. */\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"关于",frontmatter:{feed:{enable:!0},title:"关于",date:"2019-12-25T14:27:01.000Z",permalink:"/about",sidebar:!1,article:!1,description:"这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客&主题欢迎到GitHub点个Star，或者交换友链 ( •̀ ω •́ )✧",meta:[{name:"image",content:"https://github-readme-stats.vercel.app/api/pin/?username=xugaoyi&repo=vuepress-theme-vdoing"},{name:"twitter:title",content:"关于"},{name:"twitter:description",content:"这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客&主题欢迎到GitHub点个Star，或者交换友链 ( •̀ ω •́ )✧"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://github-readme-stats.vercel.app/api/pin/?username=xugaoyi&repo=vuepress-theme-vdoing"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"关于"},{property:"og:description",content:"这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客&主题欢迎到GitHub点个Star，或者交换友链 ( •̀ ω •́ )✧"},{property:"og:image",content:"https://github-readme-stats.vercel.app/api/pin/?username=xugaoyi&repo=vuepress-theme-vdoing"},{property:"og:url",content:"https://dbdgs.cn/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2019-12-25T14:27:01.000Z"},{itemprop:"name",content:"关于"},{itemprop:"description",content:"这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客&主题欢迎到GitHub点个Star，或者交换友链 ( •̀ ω •́ )✧"},{itemprop:"image",content:"https://github-readme-stats.vercel.app/api/pin/?username=xugaoyi&repo=vuepress-theme-vdoing"}]},regularPath:"/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"05.关于/01.关于.md",key:"v-c67a5246",path:"/about/",headers:[{level:3,title:"📚Blog",slug:"📚blog",normalizedTitle:"📚blog",charIndex:2},{level:3,title:"🎨Theme",slug:"🎨theme",normalizedTitle:"🎨theme",charIndex:140},{level:3,title:"🐼Me",slug:"🐼me",normalizedTitle:"🐼me",charIndex:274},{level:2,title:"✉️ 联系",slug:"联系",normalizedTitle:"✉️ 联系",charIndex:422},{level:2,title:"前端学习",slug:"前端学习",normalizedTitle:"前端学习",charIndex:615}],headersStr:"📚Blog 🎨Theme 🐼Me ✉️ 联系 前端学习",content:"# 📚Blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客&主题欢迎到GitHub点个Star，或者交换友链 ( •̀ ω •́ )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n更新日志\n\n\n# 🎨Theme\n\n\n\n本站主题是 Vdoing，这是一款简洁高效的VuePress 知识管理&博客 主题。旨在轻松打造一个结构化与碎片化并存的个人在线知识库&博客，让你的知识海洋像一本本书一样清晰易读。配合多维索引，让每一个知识点都可以快速定位！ 更多详情。\n\n\n# 🐼Me\n\nweb前端小学生\n\n# 技能\n\n * 熟悉 JavaScript、HTML、CSS、Vue 的拼写\n * 了解 Linux、windows、macOS 的开关机方式\n * 精通 Git 的 pull 和 push，并注册了 GitHub 帐号刷了一些 star\n\n本人↓↓↓\n\n\n# ✉️ 联系\n\n * WeChat or QQ: 894072666\n * Email: 894072666@qq.com\n * GitHub: https://github.com/xugaoyi\n * Vdoing主题文档：https://doc.xugaoyi.com/vuepress-theme-vdoing-doc/\n * Vdoing交流QQ群：694387113\n\n\n# 前端学习\n\n🎉🎉✨与我 联系↑ 获取前端 学习资源",normalizedContent:"# 📚blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是web前端技术。如果你喜欢这个博客&主题欢迎到github点个star，或者交换友链 ( • ω • )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n更新日志\n\n\n# 🎨theme\n\n\n\n本站主题是 vdoing，这是一款简洁高效的vuepress 知识管理&博客 主题。旨在轻松打造一个结构化与碎片化并存的个人在线知识库&博客，让你的知识海洋像一本本书一样清晰易读。配合多维索引，让每一个知识点都可以快速定位！ 更多详情。\n\n\n# 🐼me\n\nweb前端小学生\n\n# 技能\n\n * 熟悉 javascript、html、css、vue 的拼写\n * 了解 linux、windows、macos 的开关机方式\n * 精通 git 的 pull 和 push，并注册了 github 帐号刷了一些 star\n\n本人↓↓↓\n\n\n# ✉️ 联系\n\n * wechat or qq: 894072666\n * email: 894072666@qq.com\n * github: https://github.com/xugaoyi\n * vdoing主题文档：https://doc.xugaoyi.com/vuepress-theme-vdoing-doc/\n * vdoing交流qq群：694387113\n\n\n# 前端学习\n\n🎉🎉✨与我 联系↑ 获取前端 学习资源",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"费曼学习法",frontmatter:{feed:{enable:!0},title:"费曼学习法",date:"2020-07-16T10:04:14.000Z",permalink:"/feynman-method.html",categories:["更多","学习"],tags:["学习方法"],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。\n可以说是在通过向别讲解过程中来对自身的 查缺补漏。",meta:[{name:"twitter:title",content:"费曼学习法"},{name:"twitter:description",content:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。\n可以说是在通过向别讲解过程中来对自身的 查缺补漏。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/00.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"费曼学习法"},{property:"og:description",content:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。\n可以说是在通过向别讲解过程中来对自身的 查缺补漏。"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/00.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-07-16T10:04:14.000Z"},{property:"article:tag",content:"学习方法"},{itemprop:"name",content:"费曼学习法"},{itemprop:"description",content:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。\n可以说是在通过向别讲解过程中来对自身的 查缺补漏。"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/00.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95.html",relativePath:"05.更多/01.学习/00.费曼学习法.md",key:"v-18cd99be",path:"/feynman-method.html",headers:[{level:3,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:102}],headersStr:"步骤",content:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。 可以说是在通过向别讲解过程中来对自身的 查缺补漏。\n\n\n# 步骤\n\n费曼学习法分为4个步骤:\n\n 1. 确定学习目标\n\n你想学习的概念、内容、主题是什么。\n\n 2. 模拟教学学习法\n\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\n\n 3. 回顾\n\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\n\n 4. 简化\n\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\n\n> 参考：\n> \n> 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\n> \n> 《费曼学习法》",normalizedContent:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。 可以说是在通过向别讲解过程中来对自身的 查缺补漏。\n\n\n# 步骤\n\n费曼学习法分为4个步骤:\n\n 1. 确定学习目标\n\n你想学习的概念、内容、主题是什么。\n\n 2. 模拟教学学习法\n\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\n\n 3. 回顾\n\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\n\n 4. 简化\n\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\n\n> 参考：\n> \n> 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\n> \n> 《费曼学习法》",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"笔记方法",frontmatter:{feed:{enable:!0},title:"笔记方法",date:"2020-07-16T11:00:55.000Z",permalink:"/note-methods.html",categories:["更多","学习"],tags:["笔记方法"],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"::: center",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200716105752.jpg"},{name:"twitter:title",content:"笔记方法"},{name:"twitter:description",content:"::: center"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200716105752.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/01.%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"笔记方法"},{property:"og:description",content:"::: center"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200716105752.jpg"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/01.%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-07-16T11:00:55.000Z"},{property:"article:tag",content:"笔记方法"},{itemprop:"name",content:"笔记方法"},{itemprop:"description",content:"::: center"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200716105752.jpg"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/01.%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95.html",relativePath:"05.更多/01.学习/01.笔记方法.md",key:"v-94956944",path:"/note-methods.html",headers:[{level:2,title:"康奈尔笔记法",slug:"康奈尔笔记法",normalizedTitle:"康奈尔笔记法",charIndex:2},{level:2,title:"思维导图法",slug:"思维导图法",normalizedTitle:"思维导图法",charIndex:15},{level:2,title:"金三角笔记法",slug:"金三角笔记法",normalizedTitle:"金三角笔记法",charIndex:27},{level:2,title:"曼陀罗九宫格笔记法",slug:"曼陀罗九宫格笔记法",normalizedTitle:"曼陀罗九宫格笔记法",charIndex:40},{level:2,title:"记号记录法",slug:"记号记录法",normalizedTitle:"记号记录法",charIndex:56},{level:2,title:"六色笔记法",slug:"六色笔记法",normalizedTitle:"六色笔记法",charIndex:68},{level:2,title:"加工笔记法",slug:"加工笔记法",normalizedTitle:"加工笔记法",charIndex:80},{level:2,title:"整理笔记要点1-科学标记重点",slug:"整理笔记要点1-科学标记重点",normalizedTitle:"整理笔记要点1-科学标记重点",charIndex:92},{level:2,title:"整理笔记要点2-修改不涂改",slug:"整理笔记要点2-修改不涂改",normalizedTitle:"整理笔记要点2-修改不涂改",charIndex:113}],headersStr:"康奈尔笔记法 思维导图法 金三角笔记法 曼陀罗九宫格笔记法 记号记录法 六色笔记法 加工笔记法 整理笔记要点1-科学标记重点 整理笔记要点2-修改不涂改",content:"# 康奈尔笔记法\n\n\n\n\n# 思维导图法\n\n\n\n\n# 金三角笔记法\n\n\n\n\n# 曼陀罗九宫格笔记法\n\n\n\n\n# 记号记录法\n\n\n\n\n# 六色笔记法\n\n\n\n\n# 加工笔记法\n\n\n\n\n# 整理笔记要点1-科学标记重点\n\n\n\n\n# 整理笔记要点2-修改不涂改\n\n",normalizedContent:"# 康奈尔笔记法\n\n\n\n\n# 思维导图法\n\n\n\n\n# 金三角笔记法\n\n\n\n\n# 曼陀罗九宫格笔记法\n\n\n\n\n# 记号记录法\n\n\n\n\n# 六色笔记法\n\n\n\n\n# 加工笔记法\n\n\n\n\n# 整理笔记要点1-科学标记重点\n\n\n\n\n# 整理笔记要点2-修改不涂改\n\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"提高学习效率的策略",frontmatter:{feed:{enable:!0},title:"提高学习效率的策略",date:"2020-01-04T11:54:14.000Z",permalink:"/strategy-for-efficient-learn.html",categories:["更多","学习"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"提高学习效率的策略\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。",meta:[{name:"image",content:"https://dbdgs.cn/https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103144032.png '认知天性'"},{name:"twitter:title",content:"提高学习效率的策略"},{name:"twitter:description",content:"提高学习效率的策略\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://dbdgs.cn/https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103144032.png '认知天性'"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/02.%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"提高学习效率的策略"},{property:"og:description",content:"提高学习效率的策略\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。"},{property:"og:image",content:"https://dbdgs.cn/https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103144032.png '认知天性'"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/02.%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-01-04T11:54:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"提高学习效率的策略"},{itemprop:"description",content:"提高学习效率的策略\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。"},{itemprop:"image",content:"https://dbdgs.cn/https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103144032.png '认知天性'"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/02.%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5.html",relativePath:"05.更多/01.学习/02.提高学习效率的策略.md",key:"v-4b1784ae",path:"/strategy-for-efficient-learn.html",headers:[{level:3,title:"检索式学习",slug:"检索式学习",normalizedTitle:"检索式学习",charIndex:222},{level:3,title:"频繁的集中练习只会产生短期记忆",slug:"频繁的集中练习只会产生短期记忆",normalizedTitle:"频繁的集中练习只会产生短期记忆",charIndex:634},{level:3,title:"间隔练习使知识存储更牢固",slug:"间隔练习使知识存储更牢固",normalizedTitle:"间隔练习使知识存储更牢固",charIndex:958},{level:3,title:"穿插练习有助于长期记忆",slug:"穿插练习有助于长期记忆",normalizedTitle:"穿插练习有助于长期记忆",charIndex:1346},{level:3,title:"多样化练习促进知识的活学活用",slug:"多样化练习促进知识的活学活用",normalizedTitle:"多样化练习促进知识的活学活用",charIndex:1728},{level:3,title:"小总结",slug:"小总结",normalizedTitle:"小总结",charIndex:1918},{level:3,title:"知识的“滚雪球”效应",slug:"知识的-滚雪球-效应",normalizedTitle:"知识的“滚雪球”效应",charIndex:2183}],excerpt:'<h1 id="提高学习效率的策略"><a class="header-anchor" href="#提高学习效率的策略">#</a> 提高学习效率的策略</h1>\n<p>推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的<strong>检索练习</strong>——例如小的测试和自测，<strong>间隔练习</strong>、<strong>穿插</strong>不同但相关科目或技能的练习（<strong>多样化练习</strong>），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。</p>\n',headersStr:"检索式学习 频繁的集中练习只会产生短期记忆 间隔练习使知识存储更牢固 穿插练习有助于长期记忆 多样化练习促进知识的活学活用 小总结 知识的“滚雪球”效应",content:"# 提高学习效率的策略\n\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。\n\n\n# 检索式学习\n\n练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。\n\n那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。\n\n努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。\n\n反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。\n\n\n# 频繁的集中练习只会产生短期记忆\n\n人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。\n\n\n# 间隔练习使知识存储更牢固\n\n把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。 要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你\n\n\n# 穿插练习有助于长期记忆\n\n穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。\n\n\n# 多样化练习促进知识的活学活用\n\n与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。\n\n\n# 小总结\n\n有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）\n\n\n# 知识的“滚雪球”效应\n\n学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的编码。这时信息还没有被巩固成长期记忆中坚实的知识表征。巩固会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。检索会更新所学的东西，并让你做到学以致用。\n\n学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。\n\n长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。\n\n由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。\n\n阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。\n\n当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。\n\n重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。\n\n练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、\n\n试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。\n\n——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。\n\n",normalizedContent:"# 提高学习效率的策略\n\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。\n\n\n# 检索式学习\n\n练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。\n\n那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。\n\n努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。\n\n反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。\n\n\n# 频繁的集中练习只会产生短期记忆\n\n人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。\n\n\n# 间隔练习使知识存储更牢固\n\n把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。 要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你\n\n\n# 穿插练习有助于长期记忆\n\n穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。\n\n\n# 多样化练习促进知识的活学活用\n\n与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。\n\n\n# 小总结\n\n有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）\n\n\n# 知识的“滚雪球”效应\n\n学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的编码。这时信息还没有被巩固成长期记忆中坚实的知识表征。巩固会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。检索会更新所学的东西，并让你做到学以致用。\n\n学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。\n\n长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。\n\n由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。\n\n阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。\n\n当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。\n\n重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。\n\n练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、\n\n试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。\n\n——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。\n\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"提高记忆的技巧",frontmatter:{feed:{enable:!0},title:"提高记忆的技巧",date:"2020-01-03T14:34:48.000Z",permalink:"/memory-tips.html",categories:["更多","学习"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"提高记忆的技巧\n\n多个感官并用\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n",meta:[{name:"twitter:title",content:"提高记忆的技巧"},{name:"twitter:description",content:"提高记忆的技巧\n\n多个感官并用\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/03.%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"提高记忆的技巧"},{property:"og:description",content:"提高记忆的技巧\n\n多个感官并用\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/03.%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-01-03T14:34:48.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"提高记忆的技巧"},{itemprop:"description",content:"提高记忆的技巧\n\n多个感官并用\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/03.%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7.html",relativePath:"05.更多/01.学习/03.提高记忆的技巧.md",key:"v-2c01a8f7",path:"/memory-tips.html",excerpt:'<h1 id="提高记忆的技巧"><a class="header-anchor" href="#提高记忆的技巧">#</a> 提高记忆的技巧</h1>\n<ol>\n<li><strong>多个感官并用</strong>\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\n</ol>\n',headersStr:null,content:"# 提高记忆的技巧\n\n 1. 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n\n 2. 重复记忆 每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\n\n 3. 建立关联 把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\n\n 4. 场景记忆 把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\n\n 5. 提出问题 每学习一个知识点，试着提问，然后给出答案。用了就记住了。",normalizedContent:"# 提高记忆的技巧\n\n 1. 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n\n 2. 重复记忆 每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\n\n 3. 建立关联 把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\n\n 4. 场景记忆 把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\n\n 5. 提出问题 每学习一个知识点，试着提问，然后给出答案。用了就记住了。",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"自律小建议",frontmatter:{feed:{enable:!0},title:"自律小建议",date:"2020-01-03T14:35:18.000Z",permalink:"/autonomy-suggestions.html",categories:["更多","学习"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"自律小建议\n\n培养专注\n\n练习冥想、瑜伽等\n\n排除外界干扰\n\n手机调到勿扰，在图书馆学习等\n",meta:[{name:"twitter:title",content:"自律小建议"},{name:"twitter:description",content:"自律小建议\n\n培养专注\n\n练习冥想、瑜伽等\n\n排除外界干扰\n\n手机调到勿扰，在图书馆学习等\n"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/04.%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"自律小建议"},{property:"og:description",content:"自律小建议\n\n培养专注\n\n练习冥想、瑜伽等\n\n排除外界干扰\n\n手机调到勿扰，在图书馆学习等\n"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/04.%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-01-03T14:35:18.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"自律小建议"},{itemprop:"description",content:"自律小建议\n\n培养专注\n\n练习冥想、瑜伽等\n\n排除外界干扰\n\n手机调到勿扰，在图书馆学习等\n"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/04.%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE.html",relativePath:"05.更多/01.学习/04.自律小建议.md",key:"v-4cc41921",path:"/autonomy-suggestions.html",excerpt:'<h1 id="自律小建议"><a class="header-anchor" href="#自律小建议">#</a> 自律小建议</h1>\n<ul>\n<li><strong>培养专注</strong>\n<ul>\n<li>练习冥想、瑜伽等</li>\n</ul>\n</li>\n<li><strong>排除外界干扰</strong>\n<ul>\n<li>手机调到勿扰，在图书馆学习等</li>\n</ul>\n</li>\n</ul>\n',headersStr:null,content:"# 自律小建议\n\n * 培养专注\n   * 练习冥想、瑜伽等\n * 排除外界干扰\n   * 手机调到勿扰，在图书馆学习等\n\n * 规定学习时间\n   \n   * 番茄时间管理——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n     \n     > 人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。\n     > \n     > 推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...\n     > \n     > 有好的身体可以使大脑更清醒哟~\n\n * 限制娱乐时间\n   \n   * 减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）\n   \n   * 推荐观看>B站某位UP主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》\n\n * 戒网瘾（特别是游戏）\n   \n   * 除了手机、游戏以外，周围有很多美好的事物值得我们去关注。\n\n * 设定目标\n   \n   * 想要更好的薪水和职位？多花点时间在学习上吧~\n   * 潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标\n\n * 优秀的人仍在不断努力\n   \n   * 且看大神 阮一峰github 提交记录",normalizedContent:"# 自律小建议\n\n * 培养专注\n   * 练习冥想、瑜伽等\n * 排除外界干扰\n   * 手机调到勿扰，在图书馆学习等\n\n * 规定学习时间\n   \n   * 番茄时间管理——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n     \n     > 人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。\n     > \n     > 推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...\n     > \n     > 有好的身体可以使大脑更清醒哟~\n\n * 限制娱乐时间\n   \n   * 减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）\n   \n   * 推荐观看>b站某位up主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》\n\n * 戒网瘾（特别是游戏）\n   \n   * 除了手机、游戏以外，周围有很多美好的事物值得我们去关注。\n\n * 设定目标\n   \n   * 想要更好的薪水和职位？多花点时间在学习上吧~\n   * 潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标\n\n * 优秀的人仍在不断努力\n   \n   * 且看大神 阮一峰github 提交记录",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"处理问题的思路",frontmatter:{feed:{enable:!0},title:"处理问题的思路",date:"2020-01-03T14:36:02.000Z",permalink:"/solve-problems-mind.html",categories:["更多","学习"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢",meta:[{name:"twitter:title",content:"处理问题的思路"},{name:"twitter:description",content:"遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/05.%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"处理问题的思路"},{property:"og:description",content:"遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/05.%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-01-03T14:36:02.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"处理问题的思路"},{itemprop:"description",content:"遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/05.%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF.html",relativePath:"05.更多/01.学习/05.处理问题的思路.md",key:"v-fa4af0ea",path:"/solve-problems-mind.html",headers:[{level:2,title:"工作中遇到问题？",slug:"工作中遇到问题",normalizedTitle:"工作中遇到问题？",charIndex:14},{level:2,title:"这个问题我该怎么解决呢？",slug:"这个问题我该怎么解决呢",normalizedTitle:"这个问题我该怎么解决呢？",charIndex:86}],headersStr:"工作中遇到问题？ 这个问题我该怎么解决呢？",content:"# 处理问题的思路\n\n\n# 工作中遇到问题？\n\n遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢\n\n\n# 这个问题我该怎么解决呢？\n\n 1. 学会搜索\n    \n    * 关键词\n    \n    * 多关键词\n    \n    * 加入时间\n    \n    * 加入特定的社区\n    \n    * site用法\n\n 2. 高阶搜索方法\n    \n    * 英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）\n    * 视频站搜索（http://www.youtube.com/、http://egghead.io）\n    * 百度盘搜索\n    * 指定文件后缀\n\n 3. 寻求帮助\n    \n    * 找同学\n    \n    * 找同事\n    \n    * 找朋友\n    \n    * 找社区\n\n 4. 开拓思路——发散性解决问题\n    \n    * 去问问原作者？\n    * 去发个邮件/twitter/facebook?\n    * 去找Boss要资源？\n    * 加入公共社区参与讨论?\n    * ...",normalizedContent:"# 处理问题的思路\n\n\n# 工作中遇到问题？\n\n遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢\n\n\n# 这个问题我该怎么解决呢？\n\n 1. 学会搜索\n    \n    * 关键词\n    \n    * 多关键词\n    \n    * 加入时间\n    \n    * 加入特定的社区\n    \n    * site用法\n\n 2. 高阶搜索方法\n    \n    * 英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）\n    * 视频站搜索（http://www.youtube.com/、http://egghead.io）\n    * 百度盘搜索\n    * 指定文件后缀\n\n 3. 寻求帮助\n    \n    * 找同学\n    \n    * 找同事\n    \n    * 找朋友\n    \n    * 找社区\n\n 4. 开拓思路——发散性解决问题\n    \n    * 去问问原作者？\n    * 去发个邮件/twitter/facebook?\n    * 去找boss要资源？\n    * 加入公共社区参与讨论?\n    * ...",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"搜索引擎使用技巧",frontmatter:{feed:{enable:!0},title:"搜索引擎使用技巧",date:"2020-05-24T11:44:19.000Z",permalink:"/search-engine-tips.html",categories:["更多","学习"],tags:["搜索技巧"],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）",meta:[{name:"twitter:title",content:"搜索引擎使用技巧"},{name:"twitter:description",content:"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/10.%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"搜索引擎使用技巧"},{property:"og:description",content:"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/10.%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-05-24T11:44:19.000Z"},{property:"article:tag",content:"搜索技巧"},{itemprop:"name",content:"搜索引擎使用技巧"},{itemprop:"description",content:"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/10.%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html",relativePath:"05.更多/01.学习/10.搜索引擎使用技巧.md",key:"v-159f52b8",path:"/search-engine-tips.html",headers:[{level:3,title:"技巧1：排除干扰项",slug:"技巧1-排除干扰项",normalizedTitle:"技巧1：排除干扰项",charIndex:117},{level:3,title:"技巧2：精确搜索",slug:"技巧2-精确搜索",normalizedTitle:"技巧2：精确搜索",charIndex:263},{level:3,title:"技巧3：指定网站内搜索",slug:"技巧3-指定网站内搜索",normalizedTitle:"技巧3：指定网站内搜索",charIndex:354},{level:3,title:"技巧4：指定文件格式",slug:"技巧4-指定文件格式",normalizedTitle:"技巧4：指定文件格式",charIndex:458},{level:3,title:"技巧5：指定在标题搜索",slug:"技巧5-指定在标题搜索",normalizedTitle:"技巧5：指定在标题搜索",charIndex:544},{level:3,title:"技巧6：指定在内容中搜索",slug:"技巧6-指定在内容中搜索",normalizedTitle:"技巧6：指定在内容中搜索",charIndex:595},{level:3,title:"技巧7：多种搜索技巧叠加使用",slug:"技巧7-多种搜索技巧叠加使用",normalizedTitle:"技巧7：多种搜索技巧叠加使用",charIndex:658},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:739}],headersStr:"技巧1：排除干扰项 技巧2：精确搜索 技巧3：指定网站内搜索 技巧4：指定文件格式 技巧5：指定在标题搜索 技巧6：指定在内容中搜索 技巧7：多种搜索技巧叠加使用 注意事项",content:'搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（\'妈~我真的是在找学习资料\'）\n\n\n# 技巧1：排除干扰项\n\n方式：关键词1+空格+减号+关键词2，即 关键词1 -关键词2\n\n功能：排除一些不想要的关键词\n\n示例：\n\n锤子 -锤子手机\n\n\n1\n\n\n示例中将在搜索结果排除与锤子手机相关的，只显示锤子本来的样子。\n\n> 经过百度搜索的测试，有的关键词能排除掉，有的并不好使\n\n\n# 技巧2：精确搜索\n\n方式：给关键词加双引号，"关键词"\n\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\n\n示例：\n\n"达拉不崩吧"\n\n\n1\n\n\n> 注意是英文的双引号\n\n\n# 技巧3：指定网站内搜索\n\n方式：site:域名 关键词\n\n功能：只搜索指定域名的内容\n\n示例：\n\nsite:zhihu.com 前端\n\n\n1\n\n\n有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。\n\n\n# 技巧4：指定文件格式\n\n方式：filetype:文件格式 关键词\n\n示例：\n\nfiletype:avi 你懂的\n\n\n1\n\n\n常见文件格式有doc、pdf、ppt等\n\n\n# 技巧5：指定在标题搜索\n\n方式：intitle:关键词\n\n功能：搜索的关键词要出现在标题当中\n\n\n# 技巧6：指定在内容中搜索\n\n方式：intext:关键词、allintext:关键词1 关键词2、inurl:关键词2\n\n\n# 技巧7：多种搜索技巧叠加使用\n\n示例：\n\nsite:zhihu.com 前端 intitle:js\n\n\n1\n\n\n多种技巧和关键词叠加使用，中间空格隔开。\n\n\n# 注意事项\n\n以上搜索技巧使用的符号均是英文符号。',normalizedContent:'搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（\'妈~我真的是在找学习资料\'）\n\n\n# 技巧1：排除干扰项\n\n方式：关键词1+空格+减号+关键词2，即 关键词1 -关键词2\n\n功能：排除一些不想要的关键词\n\n示例：\n\n锤子 -锤子手机\n\n\n1\n\n\n示例中将在搜索结果排除与锤子手机相关的，只显示锤子本来的样子。\n\n> 经过百度搜索的测试，有的关键词能排除掉，有的并不好使\n\n\n# 技巧2：精确搜索\n\n方式：给关键词加双引号，"关键词"\n\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\n\n示例：\n\n"达拉不崩吧"\n\n\n1\n\n\n> 注意是英文的双引号\n\n\n# 技巧3：指定网站内搜索\n\n方式：site:域名 关键词\n\n功能：只搜索指定域名的内容\n\n示例：\n\nsite:zhihu.com 前端\n\n\n1\n\n\n有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。\n\n\n# 技巧4：指定文件格式\n\n方式：filetype:文件格式 关键词\n\n示例：\n\nfiletype:avi 你懂的\n\n\n1\n\n\n常见文件格式有doc、pdf、ppt等\n\n\n# 技巧5：指定在标题搜索\n\n方式：intitle:关键词\n\n功能：搜索的关键词要出现在标题当中\n\n\n# 技巧6：指定在内容中搜索\n\n方式：intext:关键词、allintext:关键词1 关键词2、inurl:关键词2\n\n\n# 技巧7：多种搜索技巧叠加使用\n\n示例：\n\nsite:zhihu.com 前端 intitle:js\n\n\n1\n\n\n多种技巧和关键词叠加使用，中间空格隔开。\n\n\n# 注意事项\n\n以上搜索技巧使用的符号均是英文符号。',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"面试问题集锦",frontmatter:{feed:{enable:!0},title:"面试问题集锦",date:"2019-12-25T14:27:01.000Z",permalink:"/interviews-qa-list.html",categories:["更多","面试"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。",meta:[{name:"twitter:title",content:"面试问题集锦"},{name:"twitter:description",content:"回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/03.%E9%9D%A2%E8%AF%95/01.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"面试问题集锦"},{property:"og:description",content:"回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/03.%E9%9D%A2%E8%AF%95/01.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2019-12-25T14:27:01.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"面试问题集锦"},{itemprop:"description",content:"回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/03.%E9%9D%A2%E8%AF%95/01.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6.html",relativePath:"05.更多/03.面试/01.面试问题集锦.md",key:"v-3c880437",path:"/interviews-qa-list.html",headers:[{level:2,title:"请做一下自我介绍",slug:"请做一下自我介绍",normalizedTitle:"请做一下自我介绍",charIndex:13},{level:2,title:"你最大的优点是什么？",slug:"你最大的优点是什么",normalizedTitle:"你最大的优点是什么？",charIndex:166},{level:2,title:"说说你最大的缺点？",slug:"说说你最大的缺点",normalizedTitle:"说说你最大的缺点？",charIndex:252},{level:2,title:"说说你对加班的看法？",slug:"说说你对加班的看法",normalizedTitle:"说说你对加班的看法？",charIndex:378},{level:2,title:"说说你对薪资的要求？",slug:"说说你对薪资的要求",normalizedTitle:"说说你对薪资的要求？",charIndex:513},{level:2,title:"在五年内，你的职业规划？",slug:"在五年内-你的职业规划",normalizedTitle:"在五年内，你的职业规划？",charIndex:903},{level:2,title:"你朋友对你的评价?",slug:"你朋友对你的评价",normalizedTitle:"你朋友对你的评价?",charIndex:1081},{level:2,title:"你还有什么问题要问吗?",slug:"你还有什么问题要问吗",normalizedTitle:"你还有什么问题要问吗?",charIndex:1241},{level:2,title:"录用后发现不适合这个职位，怎么办?",slug:"录用后发现不适合这个职位-怎么办",normalizedTitle:"录用后发现不适合这个职位，怎么办?",charIndex:1424},{level:2,title:"工作时跟领导意见不同怎么办?",slug:"工作时跟领导意见不同怎么办",normalizedTitle:"工作时跟领导意见不同怎么办?",charIndex:1601},{level:2,title:"工作出现失误并造成损失，你会怎么做?",slug:"工作出现失误并造成损失-你会怎么做",normalizedTitle:"工作出现失误并造成损失，你会怎么做?",charIndex:1779},{level:2,title:"谈谈你对跳槽的看法?",slug:"谈谈你对跳槽的看法",normalizedTitle:"谈谈你对跳槽的看法?",charIndex:2028},{level:2,title:"和同事、上司难以相处，你怎么办?",slug:"和同事、上司难以相处-你怎么办",normalizedTitle:"和同事、上司难以相处，你怎么办?",charIndex:2098},{level:2,title:"上级领导抢了你的功劳怎么办?",slug:"上级领导抢了你的功劳怎么办",normalizedTitle:"上级领导抢了你的功劳怎么办?",charIndex:2311},{level:2,title:"同事孤立你，你怎么办?",slug:"同事孤立你-你怎么办",normalizedTitle:"同事孤立你，你怎么办?",charIndex:2485},{level:2,title:"你最近是否参加了培训课程?",slug:"你最近是否参加了培训课程",normalizedTitle:"你最近是否参加了培训课程?",charIndex:2582},{level:2,title:"你对于我们公司了解多少?",slug:"你对于我们公司了解多少",normalizedTitle:"你对于我们公司了解多少?",charIndex:2636},{level:2,title:"你最擅长的技术方向是什么?",slug:"你最擅长的技术方向是什么",normalizedTitle:"你最擅长的技术方向是什么?",charIndex:2727},{level:2,title:"请说出你选择这份工作的动机?",slug:"请说出你选择这份工作的动机",normalizedTitle:"请说出你选择这份工作的动机?",charIndex:2784},{level:2,title:"你能为我们公司带来什么呢?",slug:"你能为我们公司带来什么呢",normalizedTitle:"你能为我们公司带来什么呢?",charIndex:2912},{level:2,title:"最能概括你自己的三个词?",slug:"最能概括你自己的三个词",normalizedTitle:"最能概括你自己的三个词?",charIndex:3159},{level:2,title:"作为被面试者给我打一下分?",slug:"作为被面试者给我打一下分",normalizedTitle:"作为被面试者给我打一下分?",charIndex:3225},{level:2,title:"你怎么理解你应聘的职位?",slug:"你怎么理解你应聘的职位",normalizedTitle:"你怎么理解你应聘的职位?",charIndex:3302},{level:2,title:"喜欢这份工作的哪一点?",slug:"喜欢这份工作的哪一点",normalizedTitle:"喜欢这份工作的哪一点?",charIndex:3346},{level:2,title:"为什么要离职?",slug:"为什么要离职",normalizedTitle:"为什么要离职?",charIndex:3497},{level:2,title:"说说你对行业、技术发展趋势的看法?",slug:"说说你对行业、技术发展趋势的看法",normalizedTitle:"说说你对行业、技术发展趋势的看法?",charIndex:3739},{level:2,title:"对工作的期望与目标何在?",slug:"对工作的期望与目标何在",normalizedTitle:"对工作的期望与目标何在?",charIndex:3923},{level:2,title:"谈谈你的家庭?",slug:"谈谈你的家庭",normalizedTitle:"谈谈你的家庭?",charIndex:4183},{level:2,title:"你认为自己申请这个职位还欠缺什么?",slug:"你认为自己申请这个职位还欠缺什么",normalizedTitle:"你认为自己申请这个职位还欠缺什么?",charIndex:4413},{level:2,title:"你欣赏哪种性格的人?",slug:"你欣赏哪种性格的人",normalizedTitle:"你欣赏哪种性格的人?",charIndex:4580},{level:2,title:"你通常如何处理别人的批评?",slug:"你通常如何处理别人的批评",normalizedTitle:"你通常如何处理别人的批评?",charIndex:4633},{level:2,title:"怎样对待自己的失败?",slug:"怎样对待自己的失败",normalizedTitle:"怎样对待自己的失败?",charIndex:4705},{level:2,title:"什么会让你有成就感?",slug:"什么会让你有成就感",normalizedTitle:"什么会让你有成就感?",charIndex:4761},{level:2,title:"眼下你生活中最重要的是什么?",slug:"眼下你生活中最重要的是什么",normalizedTitle:"眼下你生活中最重要的是什么?",charIndex:4805},{level:2,title:"你为什么愿意到我们公司来工作?",slug:"你为什么愿意到我们公司来工作",normalizedTitle:"你为什么愿意到我们公司来工作?",charIndex:4867},{level:2,title:"你和别人发生过争执吗?",slug:"你和别人发生过争执吗",normalizedTitle:"你和别人发生过争执吗?",charIndex:5043},{level:2,title:"你做过的哪件事最令自己感到骄傲?",slug:"你做过的哪件事最令自己感到骄傲",normalizedTitle:"你做过的哪件事最令自己感到骄傲?",charIndex:5234},{level:2,title:"对这项工作，你有哪些可预见的困难?",slug:"对这项工作-你有哪些可预见的困难",normalizedTitle:"对这项工作，你有哪些可预见的困难?",charIndex:5366},{level:2,title:"录用后你将怎样开展工作?",slug:"录用后你将怎样开展工作",normalizedTitle:"录用后你将怎样开展工作?",charIndex:5512},{level:2,title:"你希望与什么样的上级共事?",slug:"你希望与什么样的上级共事",normalizedTitle:"你希望与什么样的上级共事?",charIndex:5657},{level:2,title:"你工作经验欠缺，如何能胜任这项工作?",slug:"你工作经验欠缺-如何能胜任这项工作",normalizedTitle:"你工作经验欠缺，如何能胜任这项工作?",charIndex:5813},{level:2,title:"你会怎样获得同事的帮助?",slug:"你会怎样获得同事的帮助",normalizedTitle:"你会怎样获得同事的帮助?",charIndex:6093},{level:2,title:"如果你没被录用，你怎么打算?",slug:"如果你没被录用-你怎么打算",normalizedTitle:"如果你没被录用，你怎么打算?",charIndex:6229},{level:2,title:"最令你沮丧的事情?",slug:"最令你沮丧的事情",normalizedTitle:"最令你沮丧的事情?",charIndex:6671},{level:2,title:"想过创业吗?",slug:"想过创业吗",normalizedTitle:"想过创业吗?",charIndex:6868},{level:2,title:"为什么我们要在众多的面试者中选择你?",slug:"为什么我们要在众多的面试者中选择你",normalizedTitle:"为什么我们要在众多的面试者中选择你?",charIndex:6941},{level:2,title:"除了本公司外，还应聘了哪些公司?",slug:"除了本公司外-还应聘了哪些公司",normalizedTitle:"除了本公司外，还应聘了哪些公司?",charIndex:7126},{level:2,title:"你并非毕业于名牌院校?",slug:"你并非毕业于名牌院校",normalizedTitle:"你并非毕业于名牌院校?",charIndex:7255},{level:2,title:"怎样看待学历和能力?",slug:"怎样看待学历和能力",normalizedTitle:"怎样看待学历和能力?",charIndex:7379},{level:2,title:"谈谈如何适应办公室工作的新环境?",slug:"谈谈如何适应办公室工作的新环境",normalizedTitle:"谈谈如何适应办公室工作的新环境?",charIndex:7605},{level:2,title:"谈谈对这个职务的期许?",slug:"谈谈对这个职务的期许",normalizedTitle:"谈谈对这个职务的期许?",charIndex:7742},{level:2,title:"何时可以到职?",slug:"何时可以到职",normalizedTitle:"何时可以到职?",charIndex:7882}],headersStr:"请做一下自我介绍 你最大的优点是什么？ 说说你最大的缺点？ 说说你对加班的看法？ 说说你对薪资的要求？ 在五年内，你的职业规划？ 你朋友对你的评价? 你还有什么问题要问吗? 录用后发现不适合这个职位，怎么办? 工作时跟领导意见不同怎么办? 工作出现失误并造成损失，你会怎么做? 谈谈你对跳槽的看法? 和同事、上司难以相处，你怎么办? 上级领导抢了你的功劳怎么办? 同事孤立你，你怎么办? 你最近是否参加了培训课程? 你对于我们公司了解多少? 你最擅长的技术方向是什么? 请说出你选择这份工作的动机? 你能为我们公司带来什么呢? 最能概括你自己的三个词? 作为被面试者给我打一下分? 你怎么理解你应聘的职位? 喜欢这份工作的哪一点? 为什么要离职? 说说你对行业、技术发展趋势的看法? 对工作的期望与目标何在? 谈谈你的家庭? 你认为自己申请这个职位还欠缺什么? 你欣赏哪种性格的人? 你通常如何处理别人的批评? 怎样对待自己的失败? 什么会让你有成就感? 眼下你生活中最重要的是什么? 你为什么愿意到我们公司来工作? 你和别人发生过争执吗? 你做过的哪件事最令自己感到骄傲? 对这项工作，你有哪些可预见的困难? 录用后你将怎样开展工作? 你希望与什么样的上级共事? 你工作经验欠缺，如何能胜任这项工作? 你会怎样获得同事的帮助? 如果你没被录用，你怎么打算? 最令你沮丧的事情? 想过创业吗? 为什么我们要在众多的面试者中选择你? 除了本公司外，还应聘了哪些公司? 你并非毕业于名牌院校? 怎样看待学历和能力? 谈谈如何适应办公室工作的新环境? 谈谈对这个职务的期许? 何时可以到职?",content:"# 面试问题集锦\n\n\n# 请做一下自我介绍\n\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n\n# 你最大的优点是什么？\n\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n\n# 说说你最大的缺点？\n\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n\n# 说说你对加班的看法？\n\n回答提示： 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n回答样本： 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n\n# 说说你对薪资的要求？\n\n回答提示： 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n回答样本：\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n\n# 在五年内，你的职业规划？\n\n回答提示： 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n\n# 你朋友对你的评价?\n\n回答提示： 想从侧面了解一下你的性格及与人相处的问题。\n\n回答样本：\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n\n# 你还有什么问题要问吗?\n\n回答提示： 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n\n# 录用后发现不适合这个职位，怎么办?\n\n回答提示： 工作一段时间发现工作不适合，有两种情况：①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n\n# 工作时跟领导意见不同怎么办?\n\n回答样本： ①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n\n# 工作出现失误并造成损失，你会怎么做?\n\n回答样本： ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n\n# 谈谈你对跳槽的看法?\n\n回答样本： ①正常的“跳槽”能够促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n\n# 和同事、上司难以相处，你怎么办?\n\n回答样本： ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n\n# 上级领导抢了你的功劳怎么办?\n\n回答样本： 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n\n# 同事孤立你，你怎么办?\n\n回答样本： ①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。②工作中，切勿伤害别人的自尊心。③不在领导前拨弄是非。\n\n\n# 你最近是否参加了培训课程?\n\n回答提示： 自费参加，就是XX的培训课程（可以多谈谈自己学的技术）。\n\n\n# 你对于我们公司了解多少?\n\n回答提示： 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。\n\n\n# 你最擅长的技术方向是什么?\n\n回答提示： 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n\n# 请说出你选择这份工作的动机?\n\n回答提示： 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n回答样本： 因为我很热爱这个工作，很想从事这方面的工作。\n\n\n# 你能为我们公司带来什么呢?\n\n回答提示： ①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过XX近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n\n# 最能概括你自己的三个词?\n\n回答样本： 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n\n# 作为被面试者给我打一下分?\n\n回答提示： 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n\n# 你怎么理解你应聘的职位?\n\n回答提示： 可以把岗位职责和任务及工作态度阐述下。\n\n\n# 喜欢这份工作的哪一点?\n\n回答提示： 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n\n# 为什么要离职?\n\n回答提示： ①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n\n# 说说你对行业、技术发展趋势的看法?\n\n回答提示： 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n\n# 对工作的期望与目标何在?\n\n回答提示： 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n\n# 谈谈你的家庭?\n\n回答提示： 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n回答样本： 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n\n# 你认为自己申请这个职位还欠缺什么?\n\n回答提示： 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n回答样本： 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n\n# 你欣赏哪种性格的人?\n\n回答提示： 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n\n# 你通常如何处理别人的批评?\n\n回答提示： ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论。\n\n\n# 怎样对待自己的失败?\n\n回答提示： 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n\n# 什么会让你有成就感?\n\n回答提示： 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n\n# 眼下你生活中最重要的是什么?\n\n回答提示： 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n\n# 你为什么愿意到我们公司来工作?\n\n回答提示： 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n回答样本： ①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n\n# 你和别人发生过争执吗?\n\n回答提示： 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n\n# 你做过的哪件事最令自己感到骄傲?\n\n回答提示： 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n\n# 对这项工作，你有哪些可预见的困难?\n\n回答提示： ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n\n# 录用后你将怎样开展工作?\n\n回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n\n# 你希望与什么样的上级共事?\n\n回答提示： ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n\n# 你工作经验欠缺，如何能胜任这项工作?\n\n回答提示： ①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n回答样本： 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n\n# 你会怎样获得同事的帮助?\n\n回答提示： 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n\n# 如果你没被录用，你怎么打算?\n\n回答样本： 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n\n# 最令你沮丧的事情?\n\n回答样本： 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n\n# 想过创业吗?\n\n回答提示： 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n\n# 为什么我们要在众多的面试者中选择你?\n\n回答提示： 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n回答样本： 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、EQ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n\n# 除了本公司外，还应聘了哪些公司?\n\n回答提示： 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n\n# 你并非毕业于名牌院校?\n\n回答样本： 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了XX的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n\n# 怎样看待学历和能力?\n\n回答样本： 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n\n# 谈谈如何适应办公室工作的新环境?\n\n回答样本： ①办公室里每个人都有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n\n# 谈谈对这个职务的期许?\n\n回答提示： 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n回答样本： 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n\n# 何时可以到职?\n\n回答提示： 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。",normalizedContent:"# 面试问题集锦\n\n\n# 请做一下自我介绍\n\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n\n# 你最大的优点是什么？\n\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在xx经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n\n# 说说你最大的缺点？\n\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n\n# 说说你对加班的看法？\n\n回答提示： 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n回答样本： 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n\n# 说说你对薪资的要求？\n\n回答提示： 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n回答样本：\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n\n# 在五年内，你的职业规划？\n\n回答提示： 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n\n# 你朋友对你的评价?\n\n回答提示： 想从侧面了解一下你的性格及与人相处的问题。\n\n回答样本：\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n\n# 你还有什么问题要问吗?\n\n回答提示： 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n\n# 录用后发现不适合这个职位，怎么办?\n\n回答提示： 工作一段时间发现工作不适合，有两种情况：①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n\n# 工作时跟领导意见不同怎么办?\n\n回答样本： ①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n\n# 工作出现失误并造成损失，你会怎么做?\n\n回答样本： ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n\n# 谈谈你对跳槽的看法?\n\n回答样本： ①正常的“跳槽”能够促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n\n# 和同事、上司难以相处，你怎么办?\n\n回答样本： ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n\n# 上级领导抢了你的功劳怎么办?\n\n回答样本： 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n\n# 同事孤立你，你怎么办?\n\n回答样本： ①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。②工作中，切勿伤害别人的自尊心。③不在领导前拨弄是非。\n\n\n# 你最近是否参加了培训课程?\n\n回答提示： 自费参加，就是xx的培训课程（可以多谈谈自己学的技术）。\n\n\n# 你对于我们公司了解多少?\n\n回答提示： 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的oem合作，自有品牌的部分则透过海外经销商。\n\n\n# 你最擅长的技术方向是什么?\n\n回答提示： 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n\n# 请说出你选择这份工作的动机?\n\n回答提示： 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n回答样本： 因为我很热爱这个工作，很想从事这方面的工作。\n\n\n# 你能为我们公司带来什么呢?\n\n回答提示： ①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过xx近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n\n# 最能概括你自己的三个词?\n\n回答样本： 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n\n# 作为被面试者给我打一下分?\n\n回答提示： 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n\n# 你怎么理解你应聘的职位?\n\n回答提示： 可以把岗位职责和任务及工作态度阐述下。\n\n\n# 喜欢这份工作的哪一点?\n\n回答提示： 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n\n# 为什么要离职?\n\n回答提示： ①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n\n# 说说你对行业、技术发展趋势的看法?\n\n回答提示： 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n\n# 对工作的期望与目标何在?\n\n回答提示： 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n\n# 谈谈你的家庭?\n\n回答提示： 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n回答样本： 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n\n# 你认为自己申请这个职位还欠缺什么?\n\n回答提示： 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n回答样本： 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n\n# 你欣赏哪种性格的人?\n\n回答提示： 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n\n# 你通常如何处理别人的批评?\n\n回答提示： ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论。\n\n\n# 怎样对待自己的失败?\n\n回答提示： 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n\n# 什么会让你有成就感?\n\n回答提示： 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n\n# 眼下你生活中最重要的是什么?\n\n回答提示： 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n\n# 你为什么愿意到我们公司来工作?\n\n回答提示： 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n回答样本： ①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n\n# 你和别人发生过争执吗?\n\n回答提示： 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n\n# 你做过的哪件事最令自己感到骄傲?\n\n回答提示： 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n\n# 对这项工作，你有哪些可预见的困难?\n\n回答提示： ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n\n# 录用后你将怎样开展工作?\n\n回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n\n# 你希望与什么样的上级共事?\n\n回答提示： ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n\n# 你工作经验欠缺，如何能胜任这项工作?\n\n回答提示： ①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n回答样本： 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n\n# 你会怎样获得同事的帮助?\n\n回答提示： 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n\n# 如果你没被录用，你怎么打算?\n\n回答样本： 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n\n# 最令你沮丧的事情?\n\n回答样本： 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n\n# 想过创业吗?\n\n回答提示： 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n\n# 为什么我们要在众多的面试者中选择你?\n\n回答提示： 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n回答样本： 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、eq上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n\n# 除了本公司外，还应聘了哪些公司?\n\n回答提示： 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n\n# 你并非毕业于名牌院校?\n\n回答样本： 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了xx的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n\n# 怎样看待学历和能力?\n\n回答样本： 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n\n# 谈谈如何适应办公室工作的新环境?\n\n回答样本： ①办公室里每个人都有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n\n# 谈谈对这个职务的期许?\n\n回答提示： 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n回答样本： 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n\n# 何时可以到职?\n\n回答提示： 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"一个完美主义者的自我救赎",frontmatter:{feed:{enable:!0},title:"一个完美主义者的自我救赎",date:"2020-01-16T15:15:27.000Z",permalink:"/perfectionist-comprehend.html",categories:["更多","心情杂货"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"一个完美主义者的自我救赎\n最近，看到一个心理测试题是测试你是否有完美主义：\n\n（1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？\n（2）当一件事件做得不够好时，你是否有再试一次的想法？\n（3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？\n（4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？\n（5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？\n\n如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。",meta:[{name:"twitter:title",content:"一个完美主义者的自我救赎"},{name:"twitter:description",content:"一个完美主义者的自我救赎\n最近，看到一个心理测试题是测试你是否有完美主义：\n\n（1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？\n（2）当一件事件做得不够好时，你是否有再试一次的想法？\n（3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？\n（4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？\n（5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？\n\n如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/01.%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"一个完美主义者的自我救赎"},{property:"og:description",content:"一个完美主义者的自我救赎\n最近，看到一个心理测试题是测试你是否有完美主义：\n\n（1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？\n（2）当一件事件做得不够好时，你是否有再试一次的想法？\n（3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？\n（4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？\n（5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？\n\n如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/01.%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-01-16T15:15:27.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"一个完美主义者的自我救赎"},{itemprop:"description",content:"一个完美主义者的自我救赎\n最近，看到一个心理测试题是测试你是否有完美主义：\n\n（1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？\n（2）当一件事件做得不够好时，你是否有再试一次的想法？\n（3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？\n（4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？\n（5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？\n\n如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/01.%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E.html",relativePath:"05.更多/05.心情杂货/01.一个完美主义者的自我救赎.md",key:"v-4648f725",path:"/perfectionist-comprehend.html",excerpt:'<h1 id="一个完美主义者的自我救赎"><a class="header-anchor" href="#一个完美主义者的自我救赎">#</a> 一个完美主义者的自我救赎</h1>\n<p>最近，看到一个心理测试题是测试你是否有完美主义：</p>\n<blockquote>\n<p>（1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？</p>\n<p>（2）当一件事件做得不够好时，你是否有再试一次的想法？</p>\n<p>（3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？</p>\n<p>（4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？</p>\n<p>（5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？</p>\n</blockquote>\n<p>如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。</p>\n',headersStr:null,content:'# 一个完美主义者的自我救赎\n\n最近，看到一个心理测试题是测试你是否有完美主义：\n\n> （1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？\n> \n> （2）当一件事件做得不够好时，你是否有再试一次的想法？\n> \n> （3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？\n> \n> （4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？\n> \n> （5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？\n\n如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。\n\n对照自身，我就是那个完美主义者，时常会因为某件事做得不够好而感到痛苦，给我带来的后果就是：为了一件事想要达到“完美”的标准，付出了更多的成本，从而忽略真正需要优先处理的其他事情。最后，即使付出了成本，得到的结果也不一定是想要的"完美"。\n\n看过一篇文章，里面说到：\n\n> 完美主义是一种压力，它让你为自己创造不切实际的期望。你明明做到了正常水平，但是因为设定的目标太高，所以看上去距离目的地仍然很遥远。你的心态变成了：这一切还不够好，依然可以改进。\n> \n> 完美主义消耗了我们最宝贵的资源和时间，让你将注意力从真正的优先事项上移开。\n\n完美主义就是追求一个较高水平的目标，不接受一个较低水平的，但可用的结果。我一直告诫自己，改掉追求完美的毛病。\n\n完美主义已经对我造成了一些压力，还会妨碍我开始进入某些事情，总想着万事俱备之后才开始，结果是没有万事俱备，也没有东风，这事就搁置了。\n\n某个军事文章里说，他们特种部队的射击理念是：绝对快，相对准！\n\n> 玩吃鸡游戏似乎也是这样，需要你有快速的反应能力，不管打不打到人，先开枪再说，即使打不到也可以吓到敌人啊，哈哈哈\n\n这个理念似乎也适用于我这样的完美主义者，“做得快”比“做得好”要好，不要太执着于“完美”，就好像我开始写博客，我知道自己的写作水平并不好，但这并不妨碍我开始写博客，相信我会越写越好的~\n\n最后，心理医生也说过追求完美并不利于身心健康，不要追求完美，随心所欲地生活吧！',normalizedContent:'# 一个完美主义者的自我救赎\n\n最近，看到一个心理测试题是测试你是否有完美主义：\n\n> （1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？\n> \n> （2）当一件事件做得不够好时，你是否有再试一次的想法？\n> \n> （3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？\n> \n> （4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？\n> \n> （5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？\n\n如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。\n\n对照自身，我就是那个完美主义者，时常会因为某件事做得不够好而感到痛苦，给我带来的后果就是：为了一件事想要达到“完美”的标准，付出了更多的成本，从而忽略真正需要优先处理的其他事情。最后，即使付出了成本，得到的结果也不一定是想要的"完美"。\n\n看过一篇文章，里面说到：\n\n> 完美主义是一种压力，它让你为自己创造不切实际的期望。你明明做到了正常水平，但是因为设定的目标太高，所以看上去距离目的地仍然很遥远。你的心态变成了：这一切还不够好，依然可以改进。\n> \n> 完美主义消耗了我们最宝贵的资源和时间，让你将注意力从真正的优先事项上移开。\n\n完美主义就是追求一个较高水平的目标，不接受一个较低水平的，但可用的结果。我一直告诫自己，改掉追求完美的毛病。\n\n完美主义已经对我造成了一些压力，还会妨碍我开始进入某些事情，总想着万事俱备之后才开始，结果是没有万事俱备，也没有东风，这事就搁置了。\n\n某个军事文章里说，他们特种部队的射击理念是：绝对快，相对准！\n\n> 玩吃鸡游戏似乎也是这样，需要你有快速的反应能力，不管打不打到人，先开枪再说，即使打不到也可以吓到敌人啊，哈哈哈\n\n这个理念似乎也适用于我这样的完美主义者，“做得快”比“做得好”要好，不要太执着于“完美”，就好像我开始写博客，我知道自己的写作水平并不好，但这并不妨碍我开始写博客，相信我会越写越好的~\n\n最后，心理医生也说过追求完美并不利于身心健康，不要追求完美，随心所欲地生活吧！',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"反向拆解让人上瘾的套路，找回自律",frontmatter:{feed:{enable:!0},title:"反向拆解让人上瘾的套路，找回自律",date:"2020-07-22T13:05:49.000Z",permalink:"/why-being-addicted.html",categories:["更多","心情杂货"],tags:["心理","自律"],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"反向拆解让人上瘾的套路，找回自律\n当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&amp;AR体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？",meta:[{name:"twitter:title",content:"反向拆解让人上瘾的套路，找回自律"},{name:"twitter:description",content:"反向拆解让人上瘾的套路，找回自律\n当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&amp;AR体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/10.%E5%8F%8D%E5%90%91%E6%8B%86%E8%A7%A3%E8%AE%A9%E4%BA%BA%E4%B8%8A%E7%98%BE%E7%9A%84%E5%A5%97%E8%B7%AF%EF%BC%8C%E6%89%BE%E5%9B%9E%E8%87%AA%E5%BE%8B.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"反向拆解让人上瘾的套路，找回自律"},{property:"og:description",content:"反向拆解让人上瘾的套路，找回自律\n当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&amp;AR体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/10.%E5%8F%8D%E5%90%91%E6%8B%86%E8%A7%A3%E8%AE%A9%E4%BA%BA%E4%B8%8A%E7%98%BE%E7%9A%84%E5%A5%97%E8%B7%AF%EF%BC%8C%E6%89%BE%E5%9B%9E%E8%87%AA%E5%BE%8B.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-07-22T13:05:49.000Z"},{property:"article:tag",content:"心理"},{property:"article:tag",content:"自律"},{itemprop:"name",content:"反向拆解让人上瘾的套路，找回自律"},{itemprop:"description",content:"反向拆解让人上瘾的套路，找回自律\n当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&amp;AR体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/10.%E5%8F%8D%E5%90%91%E6%8B%86%E8%A7%A3%E8%AE%A9%E4%BA%BA%E4%B8%8A%E7%98%BE%E7%9A%84%E5%A5%97%E8%B7%AF%EF%BC%8C%E6%89%BE%E5%9B%9E%E8%87%AA%E5%BE%8B.html",relativePath:"05.更多/05.心情杂货/10.反向拆解让人上瘾的套路，找回自律.md",key:"v-3d488047",path:"/why-being-addicted.html",headers:[{level:3,title:"1.诱人的目标",slug:"_1-诱人的目标",normalizedTitle:"1.诱人的目标",charIndex:451},{level:3,title:"2.无法抵挡无法预知的积极反馈",slug:"_2-无法抵挡无法预知的积极反馈",normalizedTitle:"2.无法抵挡无法预知的积极反馈",charIndex:505},{level:3,title:"3.渐进式的进步和改善的感觉",slug:"_3-渐进式的进步和改善的感觉",normalizedTitle:"3.渐进式的进步和改善的感觉",charIndex:678},{level:3,title:"4.随着时间的推移越来越困难的任务",slug:"_4-随着时间的推移越来越困难的任务",normalizedTitle:"4.随着时间的推移越来越困难的任务",charIndex:718},{level:3,title:"5.需要解决却又暂未解决的紧张感",slug:"_5-需要解决却又暂未解决的紧张感",normalizedTitle:"5.需要解决却又暂未解决的紧张感",charIndex:760},{level:3,title:"6.强大的社会联系",slug:"_6-强大的社会联系",normalizedTitle:"6.强大的社会联系",charIndex:836},{level:2,title:"找回自律，收获积极而长久的快乐",slug:"找回自律-收获积极而长久的快乐",normalizedTitle:"找回自律，收获积极而长久的快乐",charIndex:909}],excerpt:'<h1 id="反向拆解让人上瘾的套路-找回自律"><a class="header-anchor" href="#反向拆解让人上瘾的套路-找回自律">#</a> 反向拆解让人上瘾的套路，找回自律</h1>\n<p>当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&amp;AR体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？</p>\n',headersStr:"1.诱人的目标 2.无法抵挡无法预知的积极反馈 3.渐进式的进步和改善的感觉 4.随着时间的推移越来越困难的任务 5.需要解决却又暂未解决的紧张感 6.强大的社会联系 找回自律，收获积极而长久的快乐",content:"# 反向拆解让人上瘾的套路，找回自律\n\n当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&AR体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？\n\n《欲罢不能》\n\n数字时代比人类历史上的任何时代都更容易上瘾...Facebook、Instagram、网络色情、网购在下钩... 问题不出在人缺乏意志力上，而在于“屏幕那边有数千人在努力工作，为的就是破坏你的自律”\n\n来自《欲罢不能-刷屏时代如何摆脱行为上瘾》一书\n\n我们正在被一个算法和娱乐所包裹的电子'海洛因'中却不自知，想要摆脱这些上瘾行为，第一步就是反向拆解那些让我们上瘾的产品的套路。《欲罢不能》书中总结了六个让人上瘾的钩子：\n\n\n# 1.诱人的目标\n\n * 色情片\n * 游戏中成为\"王者\"、层出不穷的高颜值皮肤...\n * ...\n\n\n# 2.无法抵挡无法预知的积极反馈\n\n * 社交中的点赞功能\n * 某音十几秒一条的视频，不需要你动脑就可以轻轻松松获得哈哈大笑的快感，有时候还有一种我学习到了的感觉，你永远猜不到下一条将会出现什么惊喜。你刷的越多算法就越精准，越知道你的情绪G点在哪里，你就越容易被俘获。\n * 直播中的打赏被主播表示的感谢和送上的'么么哒'\n * ...\n\n\n# 3.渐进式的进步和改善的感觉\n\n * 游戏中的升级策略\n\n * ...\n\n\n# 4.随着时间的推移越来越困难的任务\n\n * 游戏中的升级策略\n * ...\n\n\n# 5.需要解决却又暂未解决的紧张感\n\n * 电影或电视剧结尾有意制造的一个悬念，给你一种未完成的紧张感，你迫切想知道后面会发生什么\n * ...\n\n\n# 6.强大的社会联系\n\n * 与队友相约开黑\n\n * 游戏中能彰显地位、财富、能力等的装备（如：吃鸡游戏中的玛莎拉蒂皮肤）\n\n * ...\n\n\n# 找回自律，收获积极而长久的快乐\n\n获得快乐的方式，你可以选择沉迷在你的手机里刷视频、打游戏、煲剧，毫不费力的收货大把的快乐。你还可以选择一条更难的路：选择自律、选择延迟满足、选择会让你不那么舒服的努力和成长。\n\n收获快乐的方式没有绝对的对与错，但是，如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。过后还可能让你浪费了大把时间，该做的正事没有完成，你感觉空虚、焦躁、自责... 既然如此，我们一起选择那条更难的路吧！\n\n上瘾的案例收集\n\n想想你生活中让你上瘾的案例，对照上面让人上瘾的钩子，看看是哪个钩子吧~~欢迎留言哦~",normalizedContent:"# 反向拆解让人上瘾的套路，找回自律\n\n当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&ar体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？\n\n《欲罢不能》\n\n数字时代比人类历史上的任何时代都更容易上瘾...facebook、instagram、网络色情、网购在下钩... 问题不出在人缺乏意志力上，而在于“屏幕那边有数千人在努力工作，为的就是破坏你的自律”\n\n来自《欲罢不能-刷屏时代如何摆脱行为上瘾》一书\n\n我们正在被一个算法和娱乐所包裹的电子'海洛因'中却不自知，想要摆脱这些上瘾行为，第一步就是反向拆解那些让我们上瘾的产品的套路。《欲罢不能》书中总结了六个让人上瘾的钩子：\n\n\n# 1.诱人的目标\n\n * 色情片\n * 游戏中成为\"王者\"、层出不穷的高颜值皮肤...\n * ...\n\n\n# 2.无法抵挡无法预知的积极反馈\n\n * 社交中的点赞功能\n * 某音十几秒一条的视频，不需要你动脑就可以轻轻松松获得哈哈大笑的快感，有时候还有一种我学习到了的感觉，你永远猜不到下一条将会出现什么惊喜。你刷的越多算法就越精准，越知道你的情绪g点在哪里，你就越容易被俘获。\n * 直播中的打赏被主播表示的感谢和送上的'么么哒'\n * ...\n\n\n# 3.渐进式的进步和改善的感觉\n\n * 游戏中的升级策略\n\n * ...\n\n\n# 4.随着时间的推移越来越困难的任务\n\n * 游戏中的升级策略\n * ...\n\n\n# 5.需要解决却又暂未解决的紧张感\n\n * 电影或电视剧结尾有意制造的一个悬念，给你一种未完成的紧张感，你迫切想知道后面会发生什么\n * ...\n\n\n# 6.强大的社会联系\n\n * 与队友相约开黑\n\n * 游戏中能彰显地位、财富、能力等的装备（如：吃鸡游戏中的玛莎拉蒂皮肤）\n\n * ...\n\n\n# 找回自律，收获积极而长久的快乐\n\n获得快乐的方式，你可以选择沉迷在你的手机里刷视频、打游戏、煲剧，毫不费力的收货大把的快乐。你还可以选择一条更难的路：选择自律、选择延迟满足、选择会让你不那么舒服的努力和成长。\n\n收获快乐的方式没有绝对的对与错，但是，如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。过后还可能让你浪费了大把时间，该做的正事没有完成，你感觉空虚、焦躁、自责... 既然如此，我们一起选择那条更难的路吧！\n\n上瘾的案例收集\n\n想想你生活中让你上瘾的案例，对照上面让人上瘾的钩子，看看是哪个钩子吧~~欢迎留言哦~",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"2分钟规则",frontmatter:{feed:{enable:!0},title:"2分钟规则",date:"2020-11-09T11:05:29.000Z",permalink:"/two-minutes-rule.html",categories:["更多","实用技巧"],tags:["实用技巧","文摘"],description:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n看一本书 → 看一页书\n写一篇文章 → 写一句话\n跑10公里 → 穿上跑鞋\n做100次俯卧撑 → 做1次俯卧撑\n多吃蔬菜水果 → 吃一个水果\n编写一个程序 → 编写一个函数 → 编写一行代码\n",meta:[{name:"twitter:title",content:"2分钟规则"},{name:"twitter:description",content:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n看一本书 → 看一页书\n写一篇文章 → 写一句话\n跑10公里 → 穿上跑鞋\n做100次俯卧撑 → 做1次俯卧撑\n多吃蔬菜水果 → 吃一个水果\n编写一个程序 → 编写一个函数 → 编写一行代码\n"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/10.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/01.2%E5%88%86%E9%92%9F%E8%A7%84%E5%88%99.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"2分钟规则"},{property:"og:description",content:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n看一本书 → 看一页书\n写一篇文章 → 写一句话\n跑10公里 → 穿上跑鞋\n做100次俯卧撑 → 做1次俯卧撑\n多吃蔬菜水果 → 吃一个水果\n编写一个程序 → 编写一个函数 → 编写一行代码\n"},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/10.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/01.2%E5%88%86%E9%92%9F%E8%A7%84%E5%88%99.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-11-09T11:05:29.000Z"},{property:"article:tag",content:"实用技巧"},{property:"article:tag",content:"文摘"},{itemprop:"name",content:"2分钟规则"},{itemprop:"description",content:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n看一本书 → 看一页书\n写一篇文章 → 写一句话\n跑10公里 → 穿上跑鞋\n做100次俯卧撑 → 做1次俯卧撑\n多吃蔬菜水果 → 吃一个水果\n编写一个程序 → 编写一个函数 → 编写一行代码\n"}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/10.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/01.2%E5%88%86%E9%92%9F%E8%A7%84%E5%88%99.html",relativePath:"05.更多/10.实用技巧/01.2分钟规则.md",key:"v-b8aed80e",path:"/two-minutes-rule.html",excerpt:"<p>每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。</p>\n<ul>\n<li>看一本书 → 看一页书</li>\n<li>写一篇文章 → 写一句话</li>\n<li>跑10公里 → 穿上跑鞋</li>\n<li>做100次俯卧撑 → 做1次俯卧撑</li>\n<li>多吃蔬菜水果 → 吃一个水果</li>\n<li>编写一个程序 → 编写一个函数 → 编写一行代码</li>\n</ul>\n",headersStr:null,content:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n * 看一本书 → 看一页书\n * 写一篇文章 → 写一句话\n * 跑10公里 → 穿上跑鞋\n * 做100次俯卧撑 → 做1次俯卧撑\n * 多吃蔬菜水果 → 吃一个水果\n * 编写一个程序 → 编写一个函数 → 编写一行代码\n\n这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。\n\n * 阅读一页 → 阅读10页 → 读完第一章\n * 写一个句子 → 写文章的开头 → 写出正文\n * 穿上跑鞋 → 步行5分钟 → 跑步5分钟\n\n一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。\n\n> 本文摘录自 https://hoanhan.co/2-minute-rule",normalizedContent:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n * 看一本书 → 看一页书\n * 写一篇文章 → 写一句话\n * 跑10公里 → 穿上跑鞋\n * 做100次俯卧撑 → 做1次俯卧撑\n * 多吃蔬菜水果 → 吃一个水果\n * 编写一个程序 → 编写一个函数 → 编写一行代码\n\n这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。\n\n * 阅读一页 → 阅读10页 → 读完第一章\n * 写一个句子 → 写文章的开头 → 写出正文\n * 穿上跑鞋 → 步行5分钟 → 跑步5分钟\n\n一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。\n\n> 本文摘录自 https://hoanhan.co/2-minute-rule",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"友情链接",frontmatter:{feed:{enable:!0},title:"友情链接",date:"2020-11-25T20:27:01.000Z",permalink:"/friends",article:!1,sidebar:!1,autometa:{author:{name:"Bravo Yeung",twitter:"yanglr"},site:{name:"Bravo Yeung",twitter:"yanglr"},canonical_base:"https://dbdgs.cn",enable:!0,image:!0,twitter:!0,og:!0,schema:!0,description_sources:["frontmatter","excerpt",{},{}],image_sources:["frontmatter",{},{}]},tags:["VuePress","auto meta tags","meta tag"],description:"desc: '极客玩家大白的技术分享博客'\n  avatar: https://cdn.jsdelivr.net/gh/yanglr/yanglr.github.io/assets/images/authors/byavatar.jpg\n  link: https://geekplayers.com\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'",meta:[{name:"image",content:'https://dbdgs.cn/https://cdn.jsdelivr.net/gh/dbdgs/images@main/dabai.jpg "dbdgs.cn"'},{name:"twitter:title",content:"友情链接"},{name:"twitter:description",content:"desc: '极客玩家大白的技术分享博客'\n  avatar: https://cdn.jsdelivr.net/gh/yanglr/yanglr.github.io/assets/images/authors/byavatar.jpg\n  link: https://geekplayers.com\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:'https://dbdgs.cn/https://cdn.jsdelivr.net/gh/dbdgs/images@main/dabai.jpg "dbdgs.cn"'},{name:"twitter:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/3000.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5.html"},{name:"twitter:creator",content:"@yanglr"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"友情链接"},{property:"og:description",content:"desc: '极客玩家大白的技术分享博客'\n  avatar: https://cdn.jsdelivr.net/gh/yanglr/yanglr.github.io/assets/images/authors/byavatar.jpg\n  link: https://geekplayers.com\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'"},{property:"og:image",content:'https://dbdgs.cn/https://cdn.jsdelivr.net/gh/dbdgs/images@main/dabai.jpg "dbdgs.cn"'},{property:"og:url",content:"https://dbdgs.cn/05.%E6%9B%B4%E5%A4%9A/3000.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:author",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-11-25T20:27:01.000Z"},{property:"article:tag",content:"VuePress"},{property:"article:tag",content:"auto meta tags"},{property:"article:tag",content:"meta tag"},{itemprop:"name",content:"友情链接"},{itemprop:"description",content:"desc: '极客玩家大白的技术分享博客'\n  avatar: https://cdn.jsdelivr.net/gh/yanglr/yanglr.github.io/assets/images/authors/byavatar.jpg\n  link: https://geekplayers.com\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'"},{itemprop:"image",content:'https://dbdgs.cn/https://cdn.jsdelivr.net/gh/dbdgs/images@main/dabai.jpg "dbdgs.cn"'}]},regularPath:"/05.%E6%9B%B4%E5%A4%9A/3000.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5.html",relativePath:"05.更多/3000.友情链接.md",key:"v-d294c11a",path:"/friends/",headers:[{level:3,title:"友链申请",slug:"友链申请",normalizedTitle:"友链申请",charIndex:538}],headersStr:"友链申请",content:"极客中心\n\n极客中心-极客技术笔记\n\n极客玩家大白\n\n极客玩家大白的技术分享博客\n\n- name: 极客中心\n  desc: 极客中心-极客技术笔记\n  avatar: https://cdn.jsdelivr.net/gh/dbdgs/images@main/geekzl.png # 可选\n  link: https://www.geekzl.com # 可选\n  bgColor: '#CBEAFA' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n- name: 极客玩家大白\n  desc: '极客玩家大白的技术分享博客'\n  avatar: https://cdn.jsdelivr.net/gh/yanglr/yanglr.github.io/assets/images/authors/byavatar.jpg\n  link: https://geekplayers.com\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: 大白的故事 # 昵称\n  desc: 积跬步以至千里，喜欢学习喜欢你。 # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像\n  link: https://dbdgs.cn/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~",normalizedContent:"极客中心\n\n极客中心-极客技术笔记\n\n极客玩家大白\n\n极客玩家大白的技术分享博客\n\n- name: 极客中心\n  desc: 极客中心-极客技术笔记\n  avatar: https://cdn.jsdelivr.net/gh/dbdgs/images@main/geekzl.png # 可选\n  link: https://www.geekzl.com # 可选\n  bgcolor: '#cbeafa' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n- name: 极客玩家大白\n  desc: '极客玩家大白的技术分享博客'\n  avatar: https://cdn.jsdelivr.net/gh/yanglr/yanglr.github.io/assets/images/authors/byavatar.jpg\n  link: https://geekplayers.com\n  bgcolor: '#b9d59c'\n  textcolor: '#3b551f'\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: 大白的故事 # 昵称\n  desc: 积跬步以至千里，喜欢学习喜欢你。 # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像\n  link: https://dbdgs.cn/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"网站",frontmatter:{feed:{enable:!0},title:"网站",permalink:"/sites.html",date:"2020-04-19T11:33:04.000Z",article:!1,description:"个人收藏夹\n一位大佬的收藏夹\n码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...",meta:[{name:"twitter:title",content:"网站"},{name:"twitter:description",content:"个人收藏夹\n一位大佬的收藏夹\n码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源..."},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/06.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"网站"},{property:"og:description",content:"个人收藏夹\n一位大佬的收藏夹\n码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源..."},{property:"og:url",content:"https://dbdgs.cn/06.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-04-19T11:33:04.000Z"},{itemprop:"name",content:"网站"},{itemprop:"description",content:"个人收藏夹\n一位大佬的收藏夹\n码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源..."}]},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html",relativePath:"06.收藏夹/01.网站.md",key:"v-7e7f13b0",path:"/sites.html",headers:[{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:61},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:236},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:386},{level:2,title:"电子书",slug:"电子书",normalizedTitle:"电子书",charIndex:533},{level:2,title:"文章",slug:"文章",normalizedTitle:"文章",charIndex:379},{level:2,title:"科学上网",slug:"科学上网",normalizedTitle:"科学上网",charIndex:598},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:658},{level:3,title:"电视直播",slug:"电视直播",normalizedTitle:"电视直播",charIndex:791},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:243},{level:2,title:"在线工具",slug:"在线工具",normalizedTitle:"在线工具",charIndex:912},{level:3,title:"开发",slug:"开发",normalizedTitle:"开发",charIndex:35},{level:3,title:"代码编辑",slug:"代码编辑",normalizedTitle:"代码编辑",charIndex:990},{level:3,title:"UI",slug:"ui",normalizedTitle:"ui",charIndex:1051},{level:3,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1267},{level:3,title:"图片压缩",slug:"图片压缩",normalizedTitle:"图片压缩",charIndex:1367},{level:3,title:"作图",slug:"作图",normalizedTitle:"作图",charIndex:1427},{level:3,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:492},{level:3,title:"CDN加速",slug:"cdn加速",normalizedTitle:"cdn加速",charIndex:1609},{level:3,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:1669},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1686},{level:2,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:39},{level:3,title:"图库",slug:"图库",normalizedTitle:"图库",charIndex:2443},{level:2,title:"有趣",slug:"有趣",normalizedTitle:"有趣",charIndex:2604},{level:2,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:1821},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:112},{level:2,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:3338},{level:2,title:"实用",slug:"实用",normalizedTitle:"实用",charIndex:3387},{level:2,title:"Talk",slug:"talk",normalizedTitle:"talk",charIndex:3667},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:1759}],excerpt:'<h1 id="个人收藏夹"><a class="header-anchor" href="#个人收藏夹">#</a> 个人收藏夹</h1>\n<p><a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="nofollow noopener noreferrer">一位大佬的收藏夹<OutboundLink/></a></p>\n<p><a href="https://maliquankai.com/designnav/" target="_blank" rel="nofollow noopener noreferrer">码力全开资源库<OutboundLink/></a> 很全很强大，独立开发者/设计干货/优质利器/工具资源...</p>\n',headersStr:"文档 社区 博客 电子书 文章 科学上网 视频 电视直播 Github 在线工具 开发 代码编辑 UI Emoji表情 图片压缩 作图 CSS CDN加速 正则 其他 设计 图库 有趣 交互 教程 产品 实用 Talk 算法",content:"# 个人收藏夹\n\n一位大佬的收藏夹\n\n码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 文档\n\n * MDN | MDN-JS标准内置对象 Web技术权威文档\n * 现代JavaScript教程 以最新标准为基准的JS教程\n * ES5教程 阮一峰的JS教程\n * ES6教程 阮一峰的ES6教程\n * Bash 脚本教程 阮一峰编写\n * ECMA ECMA官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ\n * V2EX\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具\n\n\n# 电子书\n\n * 前端电子书收集\n * SoBooks 免费的电子书资源网站\n\n\n# 文章\n\n * 灵活运用CSS开发技巧\n\n\n# 科学上网\n\n * 谷歌chrome商店访问助手\n\n * 谷歌云(GCP)一键搭建 V2Ray 让你畅快科学上网\n\n\n# 视频\n\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * bilibili B站，上面也有一些可供学习的免费视频\n * egghead 质量还不错的短视频教程，外网\n\n\n# 电视直播\n\n * CCTV、卫视高清直播\n\n\n# Github\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 在线工具\n\n\n# 开发\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# UI\n\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> windows系统下按Win+.快速打开表情选择框\n\n\n# 图片压缩\n\n * tinypng图片压缩 压缩png很有用\n * Squoosh 谷歌出品在线免费图片压缩工具\n\n\n# 作图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n\n\n# CSS\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 正则\n\n * 正则可视化\n\n\n# 其他\n\n * Linux命令手册\n * 代码图片生成器\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷\n * 花瓣\n * 虎克 Ps 学习教程\n * beTheme\n * UI 中国\n\n\n# 有趣\n\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * wallhaven 壁纸网站-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 诺基亚短信图片生成器\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n * Little Big Details 同上，一个国外微交互汇集网站\n * cruip 登录页的各种页面设计，可以免费下载模板\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode",normalizedContent:"# 个人收藏夹\n\n一位大佬的收藏夹\n\n码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 文档\n\n * mdn | mdn-js标准内置对象 web技术权威文档\n * 现代javascript教程 以最新标准为基准的js教程\n * es5教程 阮一峰的js教程\n * es6教程 阮一峰的es6教程\n * bash 脚本教程 阮一峰编写\n * ecma ecma官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq\n * v2ex\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具\n\n\n# 电子书\n\n * 前端电子书收集\n * sobooks 免费的电子书资源网站\n\n\n# 文章\n\n * 灵活运用css开发技巧\n\n\n# 科学上网\n\n * 谷歌chrome商店访问助手\n\n * 谷歌云(gcp)一键搭建 v2ray 让你畅快科学上网\n\n\n# 视频\n\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * bilibili b站，上面也有一些可供学习的免费视频\n * egghead 质量还不错的短视频教程，外网\n\n\n# 电视直播\n\n * cctv、卫视高清直播\n\n\n# github\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 在线工具\n\n\n# 开发\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# ui\n\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> windows系统下按win+.快速打开表情选择框\n\n\n# 图片压缩\n\n * tinypng图片压缩 压缩png很有用\n * squoosh 谷歌出品在线免费图片压缩工具\n\n\n# 作图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n\n\n# css\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 正则\n\n * 正则可视化\n\n\n# 其他\n\n * linux命令手册\n * 代码图片生成器\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n\n\n# 有趣\n\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * wallhaven 壁纸网站-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 诺基亚短信图片生成器\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n * little big details 同上，一个国外微交互汇集网站\n * cruip 登录页的各种页面设计，可以免费下载模板\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"资源",frontmatter:{feed:{enable:!0},title:"资源",date:"2020-04-12T08:58:56.000Z",permalink:"/resources.html",article:!1,description:"::: tip\n收集一些常用的库、插件等资源，正在整理中...\n:::",meta:[{name:"twitter:title",content:"资源"},{name:"twitter:description",content:"::: tip\n收集一些常用的库、插件等资源，正在整理中...\n:::"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/06.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E8%B5%84%E6%BA%90.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"资源"},{property:"og:description",content:"::: tip\n收集一些常用的库、插件等资源，正在整理中...\n:::"},{property:"og:url",content:"https://dbdgs.cn/06.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E8%B5%84%E6%BA%90.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-04-12T08:58:56.000Z"},{itemprop:"name",content:"资源"},{itemprop:"description",content:"::: tip\n收集一些常用的库、插件等资源，正在整理中...\n:::"}]},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E8%B5%84%E6%BA%90.html",relativePath:"06.收藏夹/02.资源.md",key:"v-50c4c17c",path:"/resources.html",headers:[{level:2,title:"前端常用",slug:"前端常用",normalizedTitle:"前端常用",charIndex:41},{level:2,title:"Vue",slug:"vue",normalizedTitle:"vue",charIndex:57},{level:2,title:"移动端",slug:"移动端",normalizedTitle:"移动端",charIndex:89},{level:2,title:"工具 & 插件",slug:"工具-插件",normalizedTitle:"工具 &amp; 插件",charIndex:null},{level:2,title:"Node",slug:"node",normalizedTitle:"node",charIndex:195},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:302}],headersStr:"前端常用 Vue 移动端 工具 & 插件 Node 博客",content:"# 个人收藏夹\n\n提示\n\n收集一些常用的库、插件等资源，正在整理中...\n\n\n# 前端常用\n\n> 待整理\n\n\n# Vue\n\n * Vuesax 一个优质的vue的组件库\n\n\n# 移动端\n\n * fastclick 解决移动端点击延迟300ms问题\n * better-scroll 移动端滚动插件\n\n\n# 工具 & 插件\n\n * codota AI代码智能提示（应用于代码编辑器）\n\n\n# Node\n\n * commander 提供了用户命令行输入和参数解析的强大功能\n * inquirer 与命令行进行交互\n * chalk 美化命令行打印样式\n\n文章\n\n * 跟着老司机玩转Node命令行\n\n\n# 博客\n\n * Gitalk | Valine | Vssue 静态博客评论插件",normalizedContent:"# 个人收藏夹\n\n提示\n\n收集一些常用的库、插件等资源，正在整理中...\n\n\n# 前端常用\n\n> 待整理\n\n\n# vue\n\n * vuesax 一个优质的vue的组件库\n\n\n# 移动端\n\n * fastclick 解决移动端点击延迟300ms问题\n * better-scroll 移动端滚动插件\n\n\n# 工具 & 插件\n\n * codota ai代码智能提示（应用于代码编辑器）\n\n\n# node\n\n * commander 提供了用户命令行输入和参数解析的强大功能\n * inquirer 与命令行进行交互\n * chalk 美化命令行打印样式\n\n文章\n\n * 跟着老司机玩转node命令行\n\n\n# 博客\n\n * gitalk | valine | vssue 静态博客评论插件",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"Vue资源",frontmatter:{feed:{enable:!0},title:"Vue资源",date:"2020-04-19T11:39:43.000Z",permalink:"/vue-resources.html",article:!1,description:"工具提示/弹出窗口",meta:[{name:"twitter:title",content:"Vue资源"},{name:"twitter:description",content:"工具提示/弹出窗口"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/06.%E6%94%B6%E8%97%8F%E5%A4%B9/03.Vue%E8%B5%84%E6%BA%90.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"Vue资源"},{property:"og:description",content:"工具提示/弹出窗口"},{property:"og:url",content:"https://dbdgs.cn/06.%E6%94%B6%E8%97%8F%E5%A4%B9/03.Vue%E8%B5%84%E6%BA%90.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-04-19T11:39:43.000Z"},{itemprop:"name",content:"Vue资源"},{itemprop:"description",content:"工具提示/弹出窗口"}]},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/03.Vue%E8%B5%84%E6%BA%90.html",relativePath:"06.收藏夹/03.Vue资源.md",key:"v-21e06e58",path:"/vue-resources.html",headers:[{level:2,title:"官方资源",slug:"官方资源",normalizedTitle:"官方资源",charIndex:12},{level:2,title:"外部资源",slug:"外部资源",normalizedTitle:"外部资源",charIndex:82},{level:2,title:"工作门户",slug:"工作门户",normalizedTitle:"工作门户",charIndex:491},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:597},{level:2,title:"会议",slug:"会议",normalizedTitle:"会议",charIndex:669},{level:2,title:"播客",slug:"播客",normalizedTitle:"播客",charIndex:730},{level:2,title:"Youtube 渠道",slug:"youtube-渠道",normalizedTitle:"youtube 渠道",charIndex:1500},{level:2,title:"官方例子",slug:"官方例子",normalizedTitle:"官方例子",charIndex:1540},{level:2,title:"讲解",slug:"讲解",normalizedTitle:"讲解",charIndex:1653},{level:2,title:"事例",slug:"事例",normalizedTitle:"事例",charIndex:11449},{level:2,title:"书籍",slug:"书籍",normalizedTitle:"书籍",charIndex:20137},{level:2,title:"博客文章",slug:"博客文章",normalizedTitle:"博客文章",charIndex:21657},{level:2,title:"开源的",slug:"开源的",normalizedTitle:"开源的",charIndex:21979},{level:2,title:"商业产品",slug:"商业产品",normalizedTitle:"商业产品",charIndex:29879},{level:2,title:"应用/网站",slug:"应用-网站",normalizedTitle:"应用/网站",charIndex:30560},{level:2,title:"互动体验",slug:"互动体验",normalizedTitle:"互动体验",charIndex:37633},{level:2,title:"企业用途",slug:"企业用途",normalizedTitle:"企业用途",charIndex:37935},{level:2,title:"A11y",slug:"a11y",normalizedTitle:"a11y",charIndex:38193},{level:2,title:"表格",slug:"表格",normalizedTitle:"表格",charIndex:29938},{level:2,title:"通知",slug:"通知",normalizedTitle:"通知",charIndex:30823},{level:2,title:"装载机",slug:"装载机",normalizedTitle:"装载机",charIndex:41823},{level:2,title:"进度条",slug:"进度条",normalizedTitle:"进度条",charIndex:42156},{level:2,title:"工具提示",slug:"工具提示",normalizedTitle:"工具提示",charIndex:43069},{level:2,title:"覆盖",slug:"覆盖",normalizedTitle:"覆盖",charIndex:43473},{level:2,title:"视差",slug:"视差",normalizedTitle:"视差",charIndex:45248},{level:2,title:"图标",slug:"图标",normalizedTitle:"图标",charIndex:18149},{level:2,title:"菜单",slug:"菜单",normalizedTitle:"菜单",charIndex:26795},{level:2,title:"输入",slug:"输入",normalizedTitle:"输入",charIndex:47157},{level:2,title:"轮播",slug:"轮播",normalizedTitle:"轮播",charIndex:44241},{level:2,title:"图表",slug:"图表",normalizedTitle:"图表",charIndex:5209},{level:2,title:"时间",slug:"时间",normalizedTitle:"时间",charIndex:16690},{level:2,title:"日历",slug:"日历",normalizedTitle:"日历",charIndex:32539},{level:2,title:"地图",slug:"地图",normalizedTitle:"地图",charIndex:8816},{level:2,title:"音频视频",slug:"音频视频",normalizedTitle:"音频视频",charIndex:52573},{level:2,title:"无限滚动",slug:"无限滚动",normalizedTitle:"无限滚动",charIndex:53036},{level:2,title:"拉动刷新",slug:"拉动刷新",normalizedTitle:"拉动刷新",charIndex:53252},{level:2,title:"降价",slug:"降价",normalizedTitle:"降价",charIndex:53644},{level:2,title:"PDF",slug:"pdf",normalizedTitle:"pdf",charIndex:53938},{level:2,title:"树",slug:"树",normalizedTitle:"树",charIndex:3475},{level:2,title:"社交分享",slug:"社交分享",normalizedTitle:"社交分享",charIndex:54680},{level:2,title:"搜索",slug:"搜索",normalizedTitle:"搜索",charIndex:21738},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:24921},{level:2,title:"标签",slug:"标签",normalizedTitle:"标签",charIndex:25393},{level:2,title:"电话号码输入格式器",slug:"电话号码输入格式器",normalizedTitle:"电话号码输入格式器",charIndex:60400},{level:2,title:"选择器",slug:"选择器",normalizedTitle:"选择器",charIndex:50919},{level:2,title:"发电机",slug:"发电机",normalizedTitle:"发电机",charIndex:60541},{level:2,title:"日期选择器",slug:"日期选择器",normalizedTitle:"日期选择器",charIndex:50917},{level:2,title:"选择",slug:"选择",normalizedTitle:"选择",charIndex:6980},{level:2,title:"滑块",slug:"滑块",normalizedTitle:"滑块",charIndex:47544},{level:2,title:"拖放",slug:"拖放",normalizedTitle:"拖放",charIndex:13590},{level:2,title:"自动完成",slug:"自动完成",normalizedTitle:"自动完成",charIndex:64659},{level:2,title:"类型选择",slug:"类型选择",normalizedTitle:"类型选择",charIndex:65223},{level:2,title:"颜色选择器",slug:"颜色选择器",normalizedTitle:"颜色选择器",charIndex:65582},{level:2,title:"开关",slug:"开关",normalizedTitle:"开关",charIndex:65795},{level:2,title:"屏蔽输入",slug:"屏蔽输入",normalizedTitle:"屏蔽输入",charIndex:66404},{level:2,title:"RTF 编辑",slug:"rtf-编辑",normalizedTitle:"rtf 编辑",charIndex:67510},{level:2,title:"图像处理",slug:"图像处理",normalizedTitle:"图像处理",charIndex:68515},{level:2,title:"视频操作",slug:"视频操作",normalizedTitle:"视频操作",charIndex:69289},{level:2,title:"上下文菜单",slug:"上下文菜单",normalizedTitle:"上下文菜单",charIndex:46593},{level:2,title:"其他",slug:"其他-2",normalizedTitle:"其他",charIndex:24921},{level:2,title:"向导",slug:"向导",normalizedTitle:"向导",charIndex:71878},{level:2,title:"CSV",slug:"csv",normalizedTitle:"csv",charIndex:22805},{level:2,title:"评论系统",slug:"评论系统",normalizedTitle:"评论系统",charIndex:72122},{level:2,title:"帆布",slug:"帆布",normalizedTitle:"帆布",charIndex:72226},{level:2,title:"链接预览",slug:"链接预览",normalizedTitle:"链接预览",charIndex:72514},{level:2,title:"游览",slug:"游览",normalizedTitle:"游览",charIndex:72554},{level:2,title:"UI 布局",slug:"ui-布局",normalizedTitle:"ui 布局",charIndex:72620},{level:2,title:"自适应",slug:"自适应",normalizedTitle:"自适应",charIndex:40929},{level:2,title:"手机",slug:"手机",normalizedTitle:"手机",charIndex:37882},{level:2,title:"组件集合",slug:"组件集合",normalizedTitle:"组件集合",charIndex:76162},{level:2,title:"管理模板",slug:"管理模板",normalizedTitle:"管理模板",charIndex:24251},{level:2,title:"服务器端渲染",slug:"服务器端渲染",normalizedTitle:"服务器端渲染",charIndex:8693},{level:2,title:"静态网站生成器",slug:"静态网站生成器",normalizedTitle:"静态网站生成器",charIndex:27086},{level:2,title:"其他",slug:"其他-3",normalizedTitle:"其他",charIndex:24921},{level:2,title:"事件处理",slug:"事件处理",normalizedTitle:"事件处理",charIndex:78202},{level:2,title:"响应式设计",slug:"响应式设计",normalizedTitle:"响应式设计",charIndex:51989},{level:2,title:"验证",slug:"验证",normalizedTitle:"验证",charIndex:1705},{level:2,title:"调整大小",slug:"调整大小",normalizedTitle:"调整大小",charIndex:57683},{level:2,title:"滚动",slug:"滚动",normalizedTitle:"滚动",charIndex:39284},{level:2,title:"路由",slug:"路由",normalizedTitle:"路由",charIndex:2580},{level:2,title:"延迟加载",slug:"延迟加载",normalizedTitle:"延迟加载",charIndex:48147},{level:2,title:"分页",slug:"分页",normalizedTitle:"分页",charIndex:12885},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:1278},{level:2,title:"元标记",slug:"元标记",normalizedTitle:"元标记",charIndex:85562},{level:2,title:"传送门",slug:"传送门",normalizedTitle:"传送门",charIndex:85767},{level:2,title:"过滤器",slug:"过滤器",normalizedTitle:"过滤器",charIndex:39467},{level:2,title:"SVG",slug:"svg",normalizedTitle:"svg",charIndex:16536},{level:2,title:"其他",slug:"其他-4",normalizedTitle:"其他",charIndex:24921},{level:2,title:"WebGL",slug:"webgl",normalizedTitle:"webgl",charIndex:87324},{level:2,title:"全屏",slug:"全屏",normalizedTitle:"全屏",charIndex:37449},{level:2,title:"页面可见性",slug:"页面可见性",normalizedTitle:"页面可见性",charIndex:87608},{level:2,title:"打印",slug:"打印",normalizedTitle:"打印",charIndex:87722}],headersStr:"官方资源 外部资源 工作门户 社区 会议 播客 Youtube 渠道 官方例子 讲解 事例 书籍 博客文章 开源的 商业产品 应用/网站 互动体验 企业用途 A11y 表格 通知 装载机 进度条 工具提示 覆盖 视差 图标 菜单 输入 轮播 图表 时间 日历 地图 音频视频 无限滚动 拉动刷新 降价 PDF 树 社交分享 搜索 其他 标签 电话号码输入格式器 选择器 发电机 日期选择器 选择 滑块 拖放 自动完成 类型选择 颜色选择器 开关 屏蔽输入 RTF 编辑 图像处理 视频操作 上下文菜单 其他 向导 CSV 评论系统 帆布 链接预览 游览 UI 布局 自适应 手机 组件集合 管理模板 服务器端渲染 静态网站生成器 其他 事件处理 响应式设计 验证 调整大小 滚动 路由 延迟加载 分页 动画 元标记 传送门 过滤器 SVG 其他 WebGL 全屏 页面可见性 打印",content:"# vue资源\n\n\n# 官方资源\n\n * 官方指南\n * API 参考\n * GitHub 回购\n * 发行说明\n * 样式指南\n * Vue.js 新闻\n\n\n# 外部资源\n\n * vue.js 资料まとめ(日语)by @hashrock\n * Vue.js 新闻稿-每周精选的 Vue.js 新闻的剂量\n * Vue.js 提示-成为更好的 Vue.js 开发人员的提示\n * Vue.js Wikipedia\n * Vue.js Radar-精选的新闻通讯和网站，涵盖了新的 Vue.js 版本/贡献。\n * Vue 新闻-专注于最新 Vue.js 新闻和信息的社交网站。\n * Vue 精选资源-推荐的 Vue.js 课程和教程。\n * BuiltForVue-所有 Vue.js 组件和软件包的 NPM 镜像。\n * Vue School-通过核心成员和行业专家的视频课程学习 Vue.js\n * VueDose。有关忙碌的开发人员的 Vue 生态系统的提示和技巧。\n * Vuelibs。基于 awesome-vue 存储库的 Vue.js 库和组件的简约列表。\n\n\n# 工作门户\n\n * Vue.js 职位-VueJobs-一个 Vue.js 职位门户，可为您所有的 Vue.js 职位招聘或录用。\n * Vue.js 面试问题-300 个 VueJS 面试问题和答案列表\n\n\n# 社区\n\n * Twitter\n * 官方论坛\n * vue-requests-请求您希望存在的 Vue.js 模块或获取有关模块的想法\n\n\n# 会议\n\n * VueConf\n * Vue.js 伦敦\n * VueConf US\n * VueConf 多伦多\n\n\n# 播客\n\n * Full Stack Radio＃30(11-23-2015)\n * JavaScript Jabber＃187(11-25-2015)\n * Changelog＃184(11-27-2015)\n * 软件工程日报(2015 年 12 月 29 日)\n * JavaScript Air 016(2016 年 3 月 30 日)\n * [Codecasts＃2-Falando Sobre Vuejs e Web Components(2016-08-19)pt-BR]\n * Full Stack Radio＃50(09-21-2016)\n * [和 Vue.js 框架的作者聊聊前端框架开发背后的故事zh-CN]\n * MW S04E08-Vue.js 与 Evan You 和 Sarah Drasner(04-27-2017)\n * 提交请求＃12-众筹开源(Vue.js)(06-15-2017)\n * The Web Platform Podcast 132：Vue.js(07-27-2017)\n * 带有 MaximilianSchwarzmüller 的 JavaScript Jabber＃276(08-29-2017)\n * 使用 Sarah Drasner 动画 VueJS(软件工程日报 01-12-2017)\n * Vue 观看次数(Vue 每周播客开始于 2018 年 3 月 6 日)\n * 官方 Vue.js 新闻播客\n * 通过 QIT 技术播客索引器播出的 Vue 播客列表\n * DNE 138-Vale a pena VueJS 吗？(01-05-2018)\n * Cynical Developer＃99(10-15-2018)\n * 语法＃130(03-27-2019)\n\n\n# Youtube 渠道\n\n * VueNYC\n * VueConf 欧盟\n\n\n# 官方例子\n\n * 基本示例\n * Vue.js TodoMVC\n * CoffeeScript 版本\n * Vue.js HackerNews Clone\n * Vue.js 2.0 HackerNews Clone\n\n\n# 讲解\n\n * Vue.js 屏幕录像关于 Laracasts -Auth0 博客上的Vuejs 2 身份验证教程\n * [Scotch.io 上的使用 Vue.js 创建 GitHub File Explorer\n * Vue.js 教程关于 Vegibit\n * Vue.js 使用 webpack，vue-loader 和热重装从零开始构建设置\n * Vuex 基础：教程和说明\n * Vuex 简介视频-来自伦敦 Vue.js 聚会＃1 的 James Browne -Laravist 上的Vue.js 中文系列视频教程\n * [craigmckenna.com 上的使用 Vue.js 开发反应式发票应用程序\n * 带有葡萄牙语的 Laravel 和 Vue.js 的混合应用示例，作者@vedovelli -oguzhan.in 上的Vue.js 土耳其语简介\n * Vue.js 西班牙语视频教学系列(3-8-2016)在 YouTube 上由 JuanAndrésNúñez 制作\n * [Stude.net 上的Vue.js 西班牙语电视广播系列 -bhnddowinf 上的讲解 Vue.js 官网中文-含代码，百度云，youtube\n * [Pusher 上的使用 VueJS，ES2015 和 Webpack 探索实时应用] -sekolahkoding.com 上的印尼语中的 Vue.js\n * .dev 中来自 Scratch 系列的 Vue.js 俄语\n * [Flask，RethinkDB，Vue.js，ч。СтвореннясервісудлязберіганняфайлівзFlask。1乌克兰\n * VueJS 2 法语教程Françaispar Grafikart\n * Jayway Vue.js 2 研讨会。使用 vue-router，vuex 和 vue-resource 构建一个电子商务站点\n * 如何使用 Wijmo 控件创建出色的 VueJS 应用程序 -bhnddowinf 上的讲解 Vue.js 2 官网中文-含代码，百度云，youtube\n * Vue.js 备忘单：服务器端应用程序，路由器，Vuex 存储，GraphQL 等由@xpepermint\n * 使用 Vue.js 加载类似图片的媒体\n * [Metric Loop]上的如何在 Laravel Spark 项目中使用 Vuex /metricloop.com/blog)\n * [Metric Loop]上的如何在 Vuex 中设置模块(https://metricloop.com/blog ) -关于 Laracasts 的学习 Vue 2：循序渐进\n * Vue.js 中文教程\n * 在 Vue.js 2.0 框架上启动和运行在 SitePoint 上\n * [Metric Loop]上的如何使用 Vuex 进行 API 调用(https://metricloop.com/blog )\n * [度量循环](https：// metricloop)上的如何使用 Vuex 构建功能。 com / blog) -DevMarketer 在 YouTube 上发布了Vue.js 2.0 基础知识\n * [无知的 Vuex-Vue 的应用程序数据存储上缺少的入门手册](https://medium.com/js-dojo/vuex-for-the-clueless-the-missing-primer-on-vues-application-data -store-33fa51ffc3af＃.2j25xpfui)\n * 实时网格组件 Laravel，Vue.js，Vuex 和 Socket.io\n * VueJS 2-完整指南(包括 Vuex)-Udemy 教程\n * [在egghead.io上使用 Vue.js 开发 Web 应用](https://egghead.io/courses/develop-web-apps-with-vue-js)\n * Vue.js 2-入门\n * Vue.js 2 和 Vuex(基本)\n * Fatih Acet在 YouTube 上的TürkçeVueJSEğitimVideoları\n * [通过六个步骤从头开始在 Vue.js 中构建 JSON 树视图组件](https://devblog.digimondo.io/building-a-json-tree-view-component-in-vue-js-from-scratch -由Arvid Kahl在digimondo devblog上的-in-six-steps-ce0c05c2fdd8＃.738ok0l4p)\n * Vue！-Illya Klymov 在 YouTube 上的 OpenLecture 2017.01 俄语(@xanf)\n * @afropolymath(https://afropolymath.svbtle.com/bootstrapping-your-first-vue-js-project/)。 com / afropolymath)\n * [@分离]的从头开始构建 vue-hackernews-2.0(https://github.com/Detachment)\n * [使用 vue-kindergarten 为您的 Vue.js 和 Nuxt.js 应用程序提供基于角色的授权](https://medium.com/@JiriChara/role-based-authorization-for-your-vue-js-and-nuxt- js 应用程序使用 vue 幼儿园-fd483e013ec5＃.kp81np177)\n * 完整的 Vue.js 应用程序教程-使用 Vue 创建简单的预算应用程序，作者为@matthiaswh\n * Vue.js 教程：经过渲染的 SEO 友好示例\n * [Vue.js 简介，供仅了解足够的 jQuery 的人使用](https://medium.com/@mattrothenberg/vue-js-introduction-for-people-who-know-just-enough-jquery-to -通过 eab5aa193d77 获取)\n * 使用 Vue.js 和 Axios 从第三方 API 获取数据\n * Vue 2 的趣味项目(视频)，作者：Packt 的 Peter van Meijgaard。(2017 年 4 月)\n * [Vue JS：同时运行 Express 和 Webpack Dev Server](Henrik Fogelberg)在媒体上的(https://medium.com/dailyjs/vue-js-simultanelyly-running-express-and-webpack-dev-server-292f4a7ed7a3)\n * [The Net Ninja]在 YouTube 上发布了Vue JS 2 教程(https://www.thenetninja.co.uk)\n * 在 5 分钟内将无头 CMS 添加到 VueJ 中\n * vue 架构中的观察者\n * 使用 Vue.js 构建您的第一个应用\n * 5 个学习 Vue.js 的实用示例\n * [@jesalg]的从 KnockoutJS 迁移至 VueJS(https://twitter.com/jesalg)\n * 通过 Vue.js 创建测验由[@ rap2h](https://twitter.com/ rap2h)\n * [@chadcampbell]的Vue.js：入门(https://twitter.com/chadcampbell)\n * Vue.js 2 和 Firebase-构建实时单页 Web 应用程序\n * Vue.js 2 和 Vue 资源-具有外部 API 访问权限的实际应用程序\n * 面向初学者的 Vue.js 交互式屏幕录像\n * [AliGÖREN]在 YouTube 上发布的Vue.JS ile NASAAPI'ınıKullanarak VeriÇekme(https://aligoren.com)\n * 使用 Vue.js 2 进行 Web 开发(视频)，作者是 Packt 的 Olga Filipova。(2017 年 6 月)\n * 使用 VueJS 和 Pusher 建立实时图表\n * Vue 简介，前端大师课程的回购\n * 关于 CSS 技巧的 Vue 指南\n * 在您的 VueJS 应用中使用打字稿 -关于 nodelover 的Vue.js 视频系列，免费，入门，实战 -ninghao.net 上的Vue.js 预览\n * [@chadcampbell]的Vue.js：开发机器设置(https://twitter.com/chadcampbell)\n * 使用 Vue-router 构建 Vue v2 JS 应用 @mikestreety\n * [@Atom_Hernandez][https://medium.com/@davidatomhernandez/how-to-a-simple-carousel-with-vue-138715d615d7)制作自己的旋转木马](https://twitter.com / Atom_Hernandez)\n * [使用官方 Vue 测试工具和 Jest 对 Vue.js 组件进行单元测试](https://alexjoverm.github.io/series/Unit-Testing-Vue-js-Components-with-the-Official-Vue-Testing- @alexjoverm的 Tools-and-Jest /)\n * [创建 Vue.js 过渡和动画：实时示例，作者为@udyuxdev\n * 创建自定义 Vue.js 插件\n * VueJS 第 1 部分中的异步\n * VueJS 第 2 部分中的异步\n * [@mikestreety]https://www.mikestreety.co.uk/blog/vue-js-using-localstorage-with-the-vuex-store)使用[不带插件的 Vuex 存储使用 localStorage] //twitter.com/mikestreety)\n * [@mikestreety]的使用道具通过 Vue Router 访问组件内的 URL 参数(@mikestreety)(https://twitter.com/mikestreety)\n * [使用 Pm2 和 Nginx 在生产中部署 Vue.js — SSR(Vuetify)](https://medium.com/@kamerk22/deploy-vue-js-ssr-vuetify-on-production-with-pm2-and- nginx-ec7b5c0748a3)\n * laracast上的Testing Vue Components\n * [[CodyLSeibert]的[使用 Vue.js 和 Express.js 构建全栈 Web 应用](https://twitter.com/CodyLSeibert )\n * Vue.js 2 条食谱(视频)，由 Packt 的 Peter van Meijgaard 撰写。(2017 年 9 月)\n * [Sabe.io]上的Vue.js 入门(https://sabe.io/)\n * 使用 Vue 2 构建您的第一个高级 CRUD 应用程序(视频)(https://www.packtpub.com/web-development/building-your-first-advanced-crud-application-vue-2-video)范·迈加德(Pack Meitgaard)(2017 年 7 月)\n * 프론트엔드Vue.js입문서\n * [Inflearn]上的누구나다루기쉬운Vue.js(视频) ](https://www.inflearn.com/)，由Captain Pangyo\n * 在 2 小时内建立一个 Vue.js 博客顶部在Snipcart\n * [Sales Bhatnagar @sachinbee的VueJS 2 入门 Udemy\n * [Sabe.io]上的Vuex 入门：在 Vue.js 中管理状态(https://sabe.io/)\n * [Sergii Stotskyi 的使用 CASL 的 Vue2 ACL]\n * [简化 JavaScript 选择-Angular 诉 React 诉 Vue(视频)](https://www.packtpub.com/application-development/javascript-choice-made-easy-%E2%80%93-angular- v-react-v-vue-video)，Packt 的 Daniel Kmak。(2017 年 11 月) -Storyblok 博客上的使用 Auth0 的 Vuejs 2.5+身份验证教程\n * 带有 Vue 的 GraphCMS 初学者指南在 GraphCMS 上\n * 在 Chrome 和 VS Code 中调试 Vue.js此食谱展示了如何将 Debugger for Chrome 扩展程序与 VS Code 一起使用调试由 Vue CLI 生成的 Vue.js 应用程序。\n * [Packet Sachin Bhatnagar 的Vue JS 2 入门(视频)。(2018 年 1 月)\n * 使用 Vue.js 构建电影应用界面，作者是 Hassan Djirdeh，[@ djirdehh](https： //twitter.com/djirdehh)\n * 让我们建立一个自定义的 Vue.js 路由器，作者：Hassan Djirdeh，[@djirdehh](https：// twitter .com / djirdehh)\n * 由 Vue，Webpack 4 和 Babel 入门，作者是 Bjorn Krols，[@ KrolsBjorn](https ：//twitter.com/KrolsBjorn)\n * 如何将 Bootstrap 4 添加到您的 Vue 项目，作者：Bjorn Krols，@ KrolsBjorn\n * [如何将语义 UI 添加到您的 Vue 项目中](作者：Bjorn Krols，@KrolsBjorn( https://twitter.com/KrolsBjorn)\n * [Bjorn Krols 的如何将 ESLint 添加到您的 Vue 项目，@KrolsBjorn\n * 如何通过 Vue 中的 URL 查询参数使内容动态化(https://medium.com/@BjornKrols/tutorial-dynamic-content-via-url-query-parameters-in-vue-js-d2df19b66633) Krols，@KrolsBjorn\n * 如何为 AWS S3 托管的 Vue 应用程序启用历史记录模式作者：Bjorn Krols，@KrolsBjorn\n * [Bjorn Krols 的使用断点调试 Vue 应用程序的基本介绍，@ KrolsBjorn\n * 使用 ButterCMS 无头后端构建 Vue.Js 电子商务应用程序\n * MASTER VUE.JS\n * 使用 Go 和 Vue.js 构建投票应用程序\n * 使用 Vue.js 构建协作绘画应用程序\n * 使用 Stripe 构建实时付款信息中心\n * 使用 Vue.js 构建加密货币跟踪器\n * 使用 Vue.js 构建设计反馈应用程序\n * 使用 Flask 和 Vue.js 开发单页应用\n * 使用 Stripe，Vue.js 和 Flask 接受付款\n * [serverlarup.net 上的使用 Laravel 和 VueJS 进行 API 驱动的开发(免费课程)\n * 在 Vue.js 中管理状态，作者：哈桑·吉尔德(Hassan Djirdeh)，@djirdehh\n * 由 Vue.js 制作的真实世界项目，由 Packt 的 Daniel Khalil 撰写。(2018 年 8 月)\n * [Heartbeat(Vue + NW.js 视频系列)]https://goo.gl/8p3msR)，作者：@@ ackzell(https://github.com/ackzell)(2017-2018)\n * 带有 Nuxt.js 的 Firebase 服务器端渲染 Vue 应用程序(带有 JavaScript 框架的服务器端渲染)\n * Firebase 使用 Nuxt.js(使用 JavaScript 框架的服务器端渲染)测量 Vue SSR 性能)\n * 使用 D3 和 Vue 创建交互式地图(2018 年 10 月)\n * 编写通用的，支持 SSR 的 Vue 组件的指南\n * [Vue School]的Vue.js 基础知识(https://vueschool.io)\n * Vuex for Everyone由Vue School\n * [Vue School]的Vue.js 表单验证(https://vueschool.io)\n * [Vue School]的Vue.js 大师班(https://vueschool.io)\n * [Vue School]的Vue.js Firebase 实时数据库(https://vueschool.io)\n * [Vue School]的Vue.js Firebase 身份验证(https://vueschool.io)\n * [Vue School]的带有 Vue.js 的动态表单(https://vueschool.io)\n * [Vue School]的Custom Vue.js Directives(https://vueschool.io)\n * Vue.js 应用程序开发要点，作者是 Packt 的 BartłomiejPotaczek。(2018 年 10 月)\n * 对 Vue.js 进行故障排除，作者：克里斯蒂安·赫尔(Packet Hur)，帕特。(2018 年 10 月)\n * Nuxt.js-类固醇上的 Vue.js，作者：MaximilianSchwarzmüller，Packt。(2018 年 10 月)\n * 使用 Quasar(和 Vue)构建电子文件资源管理器，作者：@@ hawkeye64](https://github.com/hawkeye64)。(2018 年 11 月)\n * [Udemy]上的使用 Vue JS 2 和 Firebase 构建 Web 应用程序(https：// [The Net Ninja]的 www.udemy.com/)(https://www.thenetninja.co.uk/)\n * [Udemy]上的Vue JS 2-完整指南(包括 Vue Router 和 Vuex)( https://www.udemy.com/)，MaximilianSchwarzmüller\n * [使用 Vue.js，Vuex，Vuetify 和 Firebase 的 SPA 应用程序(第 1 部分)](https://www.jenniferbland.com/spa-application-using-vue-js-vuex-vuetify-and-firebase-part -1 /)由 Jennifer Bland @ratracegrad。(2018 年 11 月)\n * [使用 Vue.js，Vuex，Vuetify 和 Firebase 的 SPA 应用程序(第 2 部分)](https://www.jenniferbland.com/spa-application-using-vue-js-vuex-vuetify-and-firebase-part -2 /)由 Jennifer Bland @ratracegrad。(2018 年 11 月)\n * [使用 Vue.js，Vuex，Vuetify 和 Firebase 的 SPA 应用程序(第 3 部分)](https://www.jenniferbland.com/spa-application-using-vue-js-vuex-vuetify-and-firebase-part -3 /)由 Jennifer Bland @ratracegrad。(2018 年 11 月)\n * [使用 Vue.js，Vuex，Vuetify 和 Firebase 的 SPA 应用程序(第 4 部分)](https://www.jenniferbland.com/spa-application-using-vue-js-vuex-vuetify-and-firebase-part -4 /)，作者是 Jennifer Bland @ratracegrad。(2018 年 11 月)\n * [詹妮弗·布兰德(Jennifer Bland)@ratracegrad将国际化添加到 Vue 应用程序 )。(2018 年 11 月)\n * 由 Vue JS 2 编写的实用项目，作者是 Packt 的 Jack Herrington。(2018 年 12 月)\n * [Lessipe](https：// lessipe)的Lessipe上的Vue.js기초다지기(视频) .com /)\n * 由 Vue.js 和 Node.js 进行的全栈 Web 开发，作者 Haider Rehman， Packt。(2019 年 1 月)\n * Designer for Vue，由 Design + Code 提供(2019 年 2 月)\n * [Talat Tufekci]的Vue 土耳其语简介(https://www.onbirkod.com)\n * [Talat Tufekci]的使用土耳其语的 Vue-Resource 提取数据(https://www.onbirkod.com)\n * [Talat Tufekci]的使用土耳其语 Vue-router 的 Spa 应用程序 /www.onbirkod.com)\n * [Talat Tufekci]的使用土耳其语的 Vue-cli 创建 Vue 项目 https://www.onbirkod.com)\n * [Taul Tufekci]的Vue 组件和土耳其语 Vuex 之间的消息传递 .onbirkod.com)\n * [作者：Michael Thiessen]如何在vue中动态添加类名称\n * 使用 ScaffoldHub 使用 Vue JS，Node JS 和 SQL 或 MongoDB 构建图书馆 Web 应用程序作者 Felipe Lima [@scaffoldhub_io](https：// twitter.com/scaffoldhub_io)\n * 使用 NativeScript + Vue 构建实时位置跟踪应用，由 Saibbyweb 撰写\n\n\n# 事例\n\n * 使用 Laravel 中的 JWT Auth +示例后端 API 的入门应用程序\n * 节点 Webkit + Vue 示例@brandonjpierce\n * Vue 样本@superlloyd\n * 使用 vue.js + vue-router 的 HackerNews 克隆，作者@kazupon\n * 电子+ Vue 示例，@ bradstewart\n * [Boris Okunskiy]的单页应用程序示例(Vue + Voie)(https://github.com/inca)\n * 开始-用 Vue +流明编写的 Task Manager SPA，作者是Raj Abishek\n * [BosNaufal]的Vue Mini Shop(https://github.com/BosNaufal)\n * Vue SoundCloud由mul14\n * 功能请求(Laravel + Vue 组合)由haydenbbickerton\n * [@ yjj5855]的Vue Cookbook(Vue1.0 + Express)(https://github.com/yjj5855)：演示服务的第一个屏幕渲染\n * Strong Together-一个启动器项目，基于 Browserify 和 Semantic-，以独立或 Laravel / Laravel Spark 项目的形式构建单页 Vue.js 应用程序， ui)由WebSemantics\n * vuetest：在 iframe 中具有用户身份验证，bootstrap ui，上传器，所见即所得编辑器的广告管理网站\n * vue-shopping由andylei18\n * Vue-cnodejs，060由@shinygang\n * vue-zhihu-daily由hilongjw\n * VueChess- [gustaYo]的多人在线国际象棋游戏(https://github.com/gustaYo)\n * Ngexplorer-vuejs-client- Nugexplorer的正式客户端](https://github.com/gustaYo)\n * [Vue 2048(Vue + Webpack)][https：// pengfu](https：// pengfu](https://github.com/pengfu)的https://pengfu.github.io/vue-2048/)：流行的 2048 游戏使用 Vue 实现，Webpack，Sass，ES6\n * [BosNaufal]的Vue Simple PWA(https://github.com/BosNaufal)\n * Tour of Heroes(Vue 2.0)：Angular 2.0 的 Vue 2.0 端口[Tour of Heroes](https：// angular。 io / docs / ts / latest / tutorial /)演示应用程序。亮点：ES6 / 7，渲染功能，JSX，revue(Vue 的 Redux 绑定)，[vue-router](https://github.com/vuejs/ vue-router)，Airbnb eslint，webpack。由@ aweber1\n * vue-table-pagination由echovic进行分页的表\n * Feathers and Vue 2.0 Blog Admin Demo演示了如何在 Vue 2.0 中使用 Feathers。它包含[delay]的身份验证，vue 路由器，vue 无限加载和角色(https://github.com/delay)\n * vue-zhihudaily-2.0Zhihudaily 演示程序是使用 Vue 2.0，vue-router 和 vuex 构建的，并具有服务器端渲染功能。由cs1707\n * vue-demo-todolist是一个简单的 vue2.0 演示，它使用 Vue 2.0 vue-cli 构建。通过fishenal\n * [liueans]的vue-AdminLte(https://github.com/liujians)\n * vue(2.0)+ Node.js：博客内容管理系统(CMS)，作者@ycwalker\n * ngexplorer-quasar- Ngexplorer的实现与[quasar 框架](https： //gust.Yo 的//github.com/rstoenescu/quasar-framework)(https://github.com/gustaYo)\n * zhihu-daily-vuemoonou基于 vue2.0 的 zhihu 日报\n * loopback-vueloopback + vue + vue-resource，ionic-app，vue 页面分页功能，验证权限控制，访问令牌机制，凭证，CI ，docker qxl1231\n * vue-s3-dropzoneVue.js 拖放组件可将文件无服务器上传到 AWS S3\n * easy-vue一个简单的示例，使用 vue 在 vue 2.0，vuex 2.0，vue-router 2.0，vue-infinite-scroll 2.0， [TIGERB]的 vue-progressbar 2.0(https://github.com/tigerb)\n * [度量循环]的Vuex 事件消息演示(https://metricloop.com/blog)\n * vue-memo使用 Vue.js(> 2.x。)，vue-router(> 2.x。)，vuex( > 2.x。)，vuex-router-sync @ next(> 3.x。)和 Firebase(> 3.6.x)，作者为akifo\n * Resume Vue[ChangJoo Park]的基于 JSON 的基于 Vue 2.0 的简历(https://github.com/ChangJoo-Park/) -使用Phoenix Framework，Vue 和 Vue Router(demo开发的具有 JWT 身份验证的应用示例 phoenix-vue-auth.herokuapp.com))@ Angarsk8\n * 在 Vue 2.0 中使用路由器示例 CRUD 应用(https://github.com/shershen08/vue.js-v2-crud-application)(https://github.com/shershen08)\n * [@mgyongyosi]的ASP.NET Core Vue.js 服务器端呈现示例(https://github.com/mgyongyosi)\n * vuefire-quickstart-通过@sejr记录的带 Webpack 和 eslint 的 Firebase 集成。\n * hello-vue-django Vue.js 和 Django 集成入门项目，带有热代码重载\n * 实时社交新闻应用，是由Phoenix，Vue，Vue Router 和 Vuex([_demo _](https ：//loopa-news.herokuapp.com))，作者为@ Angarsk8\n * vue-calculator是一个使用 Vue 2.0 构建的简单计算器，vue-cli(webpack-simple)。通过CaiYiLiang\n * Wikipedia-viewer一个简单的 Wikipedia-viewer 页面，使用 vue2.x，vue-router，vue-cli(webpack)构建-simple)和 ajax(jsonp)。通过CaiYiLiang\n * vue2.x-douban使用 vue2.x，vue-router 和 axios(豆瓣电影)构建豆瓣电影的简单方法。通过超人\n * vue-laravel-exampleVue-Laravel-示例是使用 Laravel 设置 Vue 的简单示例。通过Jiajian Chan\n * vue-foundation一个演示应用程序，将 VueJS 与Zurb Foundation集成，使用 webpack vue-cli f\n * aspnetcore-Vue-starter一个 VueJS 2 入门模板，它是 asp.net MVC dotnetcore 项目的一部分。该模板包括 VueJS 客户端应用程序和后端 API 控制器。\n * vue-reddit-app使用 Vue 2 构建的 Reddit SPA demo。 X，Vue 路由器 2，Vuex 和 axios。@ yujiahaol68使用 Muse-UI 和 vue-cli Webpack 模板\n * vue-music-qq一个 qq-music 项目基于 vue-cli。页面简单流畅\n * 带有 Vue-Redux 和 Plain VueJSX 的 NavigationTab导航选项卡同时具有普通 Vue JSX 和 Vue + Redux 绑定\n * Veggie Map使用 Vuejs + Vue 路由器+ Leaflet 和 Firebase 的交互式演示\n * vuejs-d3示例如何使用 d3 进行可视化的示例。\n * vue-twitter-client使用 Vue 2.X，Vuex，electron-vue 和 Electron 构建的 Twitter 客户端应用程序\n * Douban使用 Vue2.x + Vuex + Vue-router + vue-resource 创建的很棒的 douban 示例。通过jeneser\n * Storyblok vuejs-boilerplate-集成 Storyblok 的组件系统，允许创建可编辑的网站。\n * Vuexpresso-使用 VueX，Vue-Router，Vue-Apollo，webpack，GraphQL，Apollo-client，express 和 mongo 的样板\n * 带有 Sails.js 示例项目的 Vue.js-该项目适用于单页应用程序的新手，并希望通过实际学习例。\n * Vue.js＆Pyramid Web 框架应用程序-使用 Pylons Pyramid Webframework 后端 Vuejs webpack2，vue-router，yarn(数据包管理器)的样板\n * vue-feathers-chat在前端使用 Vue，在后端使用 Feathers 进行的示例实时聊天，但仅使用 Socket.IO-Client 进行通信\n * vue-xplan使用 Vue 和 three.js 创建的旋转地球演示页面\n * vueSocketChatRoom使用 vue2.x，vuex2.x，vue-router2.x，vux2.x，socket.io 的套接字聊天室\n * @Binaryify的vue-tetris(使用 Vue，Vuex，不可变代码 Tetris 编码)：使用 Vue，Vuex，Immutable 编码俄罗斯方块。\n * @kasheftin的route-planner-vue：用于规划具有多个路线的工具 Google 地图上可排序的图层，可拖动的方向，标记和形状。\n * MyDiary-Vue使用 Vue 2.X 构建的日记应用程序，还具有联系人和待办事项列表功能\n * AliGÖREN在 Github 上的VueJS 示例项目\n * todo-mvc-webpack由voluntapear使用 webpack-basic 在 Vue 2 上实现 TodoMVC 模板，并带有显示 vuex，vue-router，中央事件总线和 VueFire 的示例。\n * [gustaYo]的Chess Storybook Example与 Vue 2.0(https://github.com/gustaYo)\n * Vue Weather Notifier一个带有 SVG 和 Vuex 的小型示例动画应用程序\n * Nuxt 类型一个带有 Nuxt 的示例 Vue 项目，用于路由/ SSR 到演示页面转换\n * VueBlog一个博客系统，支持wmui的服务端渲染\n * Cinemateka-用 Vue v1 和 Laravel 5 制作的 SPA 的示例。电影和活动时间表。俄罗斯的评论。\n * vue-2.x-boilerplate-适用于 Vue 项目 Vuex + vue-router 的简单入门套件\n * vue-minesweeper-由[rhapsodyn]开发的带有 vuejs 的致命简单扫雷游戏(https://github.com/rhapsodyn)\n * X-Flowchart-Vue- [OXOYO]的 SVG 和 Vue 流程图编辑器(https://github.com/OXOYO)\n * koa-vue-notes-web-充实的 SPA，在后端使用 Koa 2.3，在前端使用 Vue 2.4。包括功能齐全的用户身份验证组件，针对用户笔记的 CRUD 操作以及 Vuex 存储模块。\n * Vuejs 购物车-使用 Vuejs 和 Firebase 的购物车示例\n * PokedexVueJs@ rchung95\n * vuefire-auth使用 Firebase 进行 Vuefire Vue2-Auth-Email 验证\n * vuefire-realtimedatabase具有 Firebase 的 Vuefire Vue2-RealtimeDatabaseCRUD\n * vuefire-storage具有 Firebase 的 Vuefire Vue2-Storage\n * vue2-PWA-Blog@ deepak-singh\n * vue-firebase-auth-vuex具有 Vuex 的 Vue2 Firebase 身份验证，并支持渐进式 Web 应用程序\n * vue-chart-stater-kit使用 Vue 路由器，Vue 图表，Element-UI 的快速入门\n * vue2.0-demos使用 mint-ui，Element-UI，并有一些演示(选择城市等)\n * conwayConway 在 Vue 中的生活游戏。\n * vuex-feature-scoped-structure功能范围 vuex 应用程序结构的示例应用程序\n * vuex-examples-有关使用 Vuex 构建真实世界应用程序的简单示例\n * vue-vuex-todomvc-示例 TodoMVC Vue.js 应用程序具有通过 REST 的 Vuex 存储和服务器后端以及使用赛普拉斯(Cypress)的全套 E2E 测试。 io测试运行程序。\n * vuejs-sqljs-boilerplate-这是同时使用 Vue.js 和 sql.js 的样板\n * X-WebDesktop-Vue- [OXOYO]基于 Vue 的 WebDesktop 系统(https://github.com/OXOYO)\n * vuejs-music-player-一个 Vue.js 精简音乐播放器\n * Vue.js 最佳实践示例项目-使用 Vue.js + Vue 路由器+ Vuex + Vuelidate 的最佳实践示例项目\n * [Vue.js 一个]客户端- [一个]用 Vue2.5 编写的客户端\n * Vue.js 2.5，带有 vue-cli v3，包括使用 auth0 进行身份验证，作者多米尼克·安格(Dominik Angerer)，Storyblok\n * Skeleton Vue + TypeScript-TypeScript，VueJS，ElementUI，Vue Router，Vuex，材质图标，BrowserSync，Dockerfile\n * @jesalg的PENV Starter-有关如何在 VueJS，Express 和 PostgreSQL 中使用的基本示例连词。\n * vue-relay-examples-使用 vue-relay 的示例应用程序的集合。\n * laravel-vue-boilerplate-具有用户 CRUD 的 Laravel 5.5 SPA 样板，使用 Vue.js 2.5，Bootstrap 4，TypeScript，Sass，Pug 和笑话。\n * Vue 设计系统-用于使用 Vue.js 构建 UI 设计系统的开源样板。\n * Vue Bulma 演示-一个简单的演示网站，可联合检查 Bulma / Vue JS 和 express。\n * 准备好使用 TypeScript，vuex，vue-router，HMR 等进行生产的入门应用程序\n * vue.js 与 laravel 结合的前阶段分离开发模板-laravel 护照/ Vue.JS 和 Element UI 的模板网站。\n * 由 Vue.js 进行的 Web 开发动手，作者：Roman Kuba，Packt。(2018 年 5 月)\n * Vue 在线商城-在线 SPA 演示，基于 VUE 开发的前分离电子商城前端项目\n * FUE-使用 Vue.js + Vue 路由器+ Vuex + Vuetify + FeathersJS 的 Admin SPA 客户端和服务器端样板\n * Vue + TypeScript 食谱-一本小小的食谱，涵盖了一些不太明显的解决方案，供人们开始使用 Vue + TypeScript\n * Vuejs 示例\n * ASP.NET Core Vue 入门 CLI 3.0使用 Vue CLI 3.0 和自定义配置(默认 TypeScript，Vue，路由器)的 Vue 入门模板，Vuex，Vuetify)通过@SoftwareAteliers与 ASP。＆＃8203; NET Core 集成(2018 年 9 月)\n * vue-soundcloud由Soroush Chehresa用 Vue.js 2 构建的 Soundcloud 客户端。\n * vue-cart一个由 vue，vuex 和 vue 路由器制成的简单购物车。通过crisgon\n * Nuxt + Apollo + Element一个带有 Nuxt，Element(自定义主题)和 Vue Apollo 的 Vue.js SSR 样板。\n * vue-daily-zhihu由walleeeee使用 Vue 2.0 和 vue-router＆vuex 构建的简单演示)\n * 木炭使用 Vue CLI 3.0 并由[Seth Davis]用 Bulma 样式设置的入门模板(https://github.com/setholito)\n * 带有 TypeScript 的多页 ASP.NET Core Vue-多页 ASP.NET Core Vue，Typescript，Vuex，Vue 路由器，布尔玛，Sass 和 Jest 应用程序。有关如何在.NET Core MVC 中将 Vue.js 用作多页(多个迷你 spa)应用程序的模板/起点。\n * CION-Vue.js 的设计系统样板-一个主要为 Vue.js 应用程序设计的设计系统。它利用设计令牌，带有集成代码游乐场的生活风格指南以及用于常见 UI 任务的可重用组件。\n * Vue websockets 示例-使用 Vue.js 2 + Node 项目的 Websockets 使用的基本示例，以获取完整的工作示例。\n * Vue(2.0)+ Node.js：一个博客，作者@ FatDong1\n * vue-todo-list待办事项列表示例应用程序基于 Vue + Vuex + Vuetify + Vee-Validate\n * Vue.js 和 Ionic v4 示例-一组如何在 Vue.js 中使用 Ionic v4 的示例\n * 使用 Vue，Vuex 和 Vue-Router 的个人网站- MuratcanŞentürk 用 vue，vuex 和 vue-router 制作的简单网站示例\n * 客户端 Vue.js- 演示-Vue.js 客户端端，用于[Justin Wash]的微型，快速加载，无 node.js 的单页应用程序(https://github.com/Trifectuh)\n * 大型 Vue.js 应用样板+ Vuex\n * 无画布的 Vue.js 上的蛇游戏\n * 使用 CometChat 构建 Vue 聊天应用\n\n\n# 书籍\n\n * Vue.js je 下，作者：Alex Kyriakidis 和 Packt 的 Kostas Maniatis。(2016 年 11 月)\n * 学习 Vue.js 2，作者：Packt 的 Olga Filipova。(2016 年 12 月)\n * Vue.js 2 的威严，作者：Alex Kyriakidis 和 Lestapub 的 Kostas Maniatis。(2017 年 3 月)\n * Vue.js 2 Cookbook，作者是 Andrea Passaglia，Packt。(2017 年 5 月)\n * Vue.js 实战，作者 Erik Hanchett 和 Benjamin Listwon(2018 年春季)\n * 测试 Vue.js 应用程序作者 Edd Yerburgh(2018 年夏季)\n * Vue.js 2 和 Bootstrap 4 Web 开发，Packt 的 Olga Filipova。(2017 年 9 月) -Casa doCódigo 的 Leonardo Vilarinho 的Front-end com Vue.js。(2017 年 11 月) -Packt 的 Guillaume Chau 撰写的Vue.js 2 个 Web 开发项目。(2017 年 11 月)\n * Full-Stack Vue.js 2 和 Laravel 5，Packt Anthony Gore。(2017 年 12 月)\n * [Package Mike Street 的Vue.js 2.x 示例。(2017 年 12 月) -Oleksandr Kocherhin 的Mastering Vue.js。(2018 年 1 月)\n * Fullstack Vue：Vue.js 完整指南，作者：哈桑·迪吉德(Hassan Djirdeh)，内特·默里(Nate Murray)和阿里·勒纳(Ari Lerner)。(2018 年 3 月) -Packt 的 Paul Halliday 撰写的Vue.js 2 设计模式和最佳做法。(2018 年 3 月)\n * Vuex 快速入门指南，作者：Packt 的 Andrea Koutifaris。(2018 年 4 月)\n * 使用 Vue.js 和 Node 进行全栈 Web 开发，作者：Aneeta Sharma，Packt。(2018 年 5 月) -Flavio Copes 的Vue 手册。(2018 年 7 月)\n * ASP.NET Core 2 和 Vue.js，作者：Stuart Ratcliffe，Packt。(2018 年 7 月)\n * [Vue.js：解释性解释](Casa doCódigo 的 Caio Incau)(https://www.casadocodigo.com.br/products/livro-vue)。(2017 年 9 月)\n * 了解 Vue.js，作者是 Brett Nelson，Apress。(2018 年 8 月)\n * 精益：构建与部署，作者 Leanpub 的 Daniel Schmitz。(2018 年 9 月)\n * 由 Spring 5 和 Vue.js 2 构建应用程序，作者：James J. Ye，Packt。(2018 年 10 月)\n * Vue.js 快速入门指南，Packt 的 Ajdin Imsirovic。(2018 年 10 月) -Frederik Dietz 撰写的Vue.js 组件模式课程(2019 年 4 月)\n\n\n# 博客文章\n\n * Vue x Hasura GraphQL\n * 在 Vue.js 中使用 GraphQL 突变\n * 了解如何使用 Vue.JS 构建数据驱动的搜索 UI\n * 使用 GitLab CI / CD 将 Vue.js 应用程序自动部署到 AWS S3\n * 将 Vue 应用程式码头化\n * 使用 Docker 和 Gitlab CI 将 Flask and Vue 应用程序部署到 Heroku\n * [Kevin Peters]的大型 Vuex 应用程序结构\n * [Kevin Peters]的在 Vue.js 中构成计算属性\n * 通过实际示例了解如何重构 Vue.js 单个文件组件由Kevin Peters\n\n\n# 开源的\n\n * PageKit-使用 Symfony 组件和 Vue.js 构建的模块化轻量级 CMS。\n * npmcharts.com-比较 npm 软件包并发现下载趋势。\n * Koel-可以正常工作的个人音乐流服务器。\n * Raven 阅读器-使用原子电子和 vue.js 制作的简单 RSS 阅读器。\n * Gokotta-由电子和 vue 构建的简单音乐播放器。\n * CoPilot-基于 AdminLTE 和 vue.js 集成的管理门户。\n * Retrospectify-在敏捷团队中进行协作回顾的简单工具。\n * jade-press-基于 mongodb，nodejs，koa，vue 等的 Cms。\n * astralapp-轻松组织 GitHub Stars。\n * EME-优雅的 Markdown 编辑器。\n * Github-explorer-一个可以帮助您更好地检查 github 的水疗中心。\n * 酒店-从浏览器启动开发服务器，并在几秒钟内获得本地域。\n * Surfbird-使用现代网络技术编写的 Twitter 客户端。\n * Approach0-一个可识别数学的搜索引擎。\n * Flox-自托管电影，系列和动漫观看列表。\n * JavaScript Guessing Game-用于识别 JavaScript 工具和库的游戏。\n * vue-ghpages-blog-Vue.js 2 + Webpack 2 基于 GitHub 页面的博客。\n * Vuedo-使用 Laravel 和 Vue.js 构建的博客平台。\n * vue-music163-一个 Vue.js 音乐项目。\n * Tomato5-实时协作工具，它将 Pomodoro 技术与团队状态共享板结合在一起。\n * Web 学习-一种服务，可让您轻松访问有关 Web 开发和编程的数千个视频教程。\n * ExcelJSON-一种将 CSV，TSV 与 JSON 相互转换的工具。\n * Materialize-blog-使用 Laravel5.3 和 Vue2.x 构建的材料博客。\n * VueCompomnentGenerator-在浏览器上生成 vue 单个文件组件。\n * SDR 新闻-来自多个来源(Reddit，Hacker News 和 Prominent Blogs)的 Web 设计人员和开发人员新闻。\n * PJ Blog-使用 Laravel 和 Vue.js 构建的开源博客。\n * Lulumi-browser-Lulumi-browser 是使用 Vue.js 2 和 Electron 编码的轻型浏览器。\n * vue-wordpress-pwa\n * OpenAPI 3 查看器-浏览并测试 OpenAPI 3.0 规范中描述的 REST API\n * Stacer-Linux 系统优化程序和监视\n * Distrochooser.de-Linux 初学者的入门指南\n * Buka-电子书管理\n * 文档-一个无需构建过程即可编写文档的框架\n * pm86-Node.js 应用网站的生产流程经理\n * vms-一个 Vue.js 2.0 管理系统\n * nativescript-vue-NativeScript 渲染器的 Vue.js 实现。\n * piper-基于 Vue 的拖放式移动网站构建器。\n * mmf-blog-vue2-基于 Vue2(Vue-router，Vuex)和 Webpack2 的博客。\n * 媒体管理器-Web 文件管理器。\n * dyu / bookmarks-一个由 leveldb 驱动的自包含，自托管的书签应用程序，由 Vue2.1.x 构建。\n * JSON 模式编辑器-JSON 模式的直观编辑器。使用 Vue.js 2 和 Firebase 开发。\n * npm-stats-npm 包下载统计信息面板\n * vue2-admin-lte-一个将 AdminLTE 转换为可与 Vuejs(v2.x)一起使用的项目。\n * Dockeron-基于 Electron + Vue.js 构建的桌面 Docker 项目。\n * Flamme-一个基于 Education 和 Vue.js 构建的开源 Tinder 桌面客户端，用于教育目的\n * Goldfish-使用 VueJS，Golang 和 Bulma CSS 构建的 HashiCorp Vault UI\n * 管理-基于Vuetify的管理控制台，请选中[在线演示](http：// adminify。 genyii.com)\n * 提示-用 Vue.js 编写的框架，用于在 Web 浏览器中创建类似命令行的界面。\n * Hare-🐇 基于 Vue.js 2.x，Koa 2.x，Element-UI 和 Nuxt.js 的应用程序样板\n * Paper-Dashboard-为 Vue 制作的 Creative Tim Paper Dashboard\n * AdminLTE-VueJS2-一个在 AdminLTE 上实现 VueJS(v2.x)的开源项目。\n * 材质仪表板-为 Vue 制作的创意 Tim 材质仪表板\n * Explore-Github-VueJS 2 Github Explorer 使用 API v3\n * CoreUI-由 Vue.js 支持的开源管理模板\n * ChuckNorris-使用 VueJS + api.chucknorris.io 构建的 Chuck Norris 笑话生成器\n * LeafPlayer-一个简单，快速，私有的音乐流服务器。\n * JSON 编辑器-一种可识别架构的 JSON 编辑器。用 Vue2 开发。\n * Voten-使用 Vue2 和 Laravel 构建的类似 Reddit 的平台。\n * News Weaver-使用 VueJS 和 VuetifyJS 制作的基于 Web 的 RSS 阅读器/聚合器\n * 唤醒 Billie Joe！-根据绿日的歌曲“唤醒我，当九月结束”而倒计时到十月的网站。使用 Vue 和 Firebase 创建。\n * Astrum-旨在包含在任何 Web 项目中的轻量级模式库。\n * vue2-pwa-vision-带有 Vue2 + Vuetify +渐进式 Web App 的人脸检测 Google Cloud Vision\n * vue2-pwa-rekognition-使用 Vue2 + Vuetify + Progressive Web App 进行人脸检测的 Amazon Rekognition\n * AmmoBin.ca-有关加拿大在线弹药价格的元搜索网站\n * SPA-asp.net-api-vuejs--用于使用基本任务管理和消息传递的 Vue.js 单页应用程序 ASP .NET Webapi 2 和 SQL Server\n * Book-Trading-Club-与您所在地区的其他图书读者进行贸易或借阅图书。使用 nodejs 和 vuejs2 构建\n * vuejs-extension-pack vscode-扩展 packf 或 vscode，具有用于 Vue.js 开发的流行 VS Code 扩展。\n * Wiki.js-基于 NodeJS，Git 和 Markdown 构建的现代，轻量级且功能强大的 Wiki 应用程序\n * vue-pwa-speech-在 Vue2 + Vuetify + Progressive Web App 上使用 Google Cloud 进行文字演讲\n * vue-speech-streaming-在渐进式 Web App 上执行流式语音识别可通过 Google Cloud Speech + socket.io 实时生成语音到文本\n * 我的动画列表-一个易于获取 CSS 动画代码的工具\n * vue-input-streaming-使用 Pusher 进行 TextInput 流实时和双向数据绑定广播\n * TidyTab-一个 Chrome 扩展程序，用于整理这些标签。\n * peregrine-cms-基于 Vue.js 和 Apache Sling 的可选 CMS\n * concept-to-clinic-具有 Vue.js 界面的肺癌预测项目\n * grid-awesome-使用 css 显示为网格布局生成样板 css：grid; 属性。\n * Light Bootstrap 仪表板-为 Vue 制作的创意 Tim Light Bootstrap 仪表板\n * Hubaga-适用于开发人员和其他数字商店的免费轻量级 WordPress 电子商务插件。\n * vue-webpack-buefy-具有全功能 Webpack 和 Buefy 的 Vue.js 入门\n * Coypu-类似文本编辑器的每周计划\n * 核心服务器-高度可扩展的 VueJs 框架，具有集成的 API 系统和多种高级功能。\n * discord-logo-基于 SVG 的 Vue.js 动画不和谐徽标生成器。(Github 页面)\n * node-vue-template-用于使用 Node.js(API)和 Vue.js(SPA)构建完整应用程序的入门模板，其中包括一些软件包和配置，以帮助快速开始开发。\n * vue-storefront-Vue.js 店面-电子商务的 PWA。100％离线，与平台无关，无头，支持 Magento2。\n * fd-vue-IoT 框架的 Vue.js 客户端\n * wildfire-其他注释插件的替代品。\n * 收据-简单的自动化桌面应用程序，可以从 Uber 和 Lyft 下载并整理您的税款发票。\n * vue-chrome-extension-boilerplate-使用 Vue.js 和 Webpack 进行 Chrome 扩展的样板\n * TimeMark-一个可以记录您的时间的时间管理器，还将开发更多功能。\n * Laravel Enso-由 Bulma，VueJS 和 Laravel 构建的 SPA 管理面板，开箱即用地打包了很多功能。\n * 代码说明-针对使用 Electron＆Vue.js 构建的开发人员的简单代码段管理器。\n * Pomotroid-简单，美观且可自定义的 Pomodoro 计时器。\n * XMR Miner-加密货币(XMR)挖掘应用程序，使用 Vue.js 构建并使用 D3 进行可视化\n * XMR Paper-Monero 钱包生成器，使用 Vue.js 构建\n * JoyProxy-Chrome 扩展程序，用于处理代理设置\n * 活动自动化-管理日常活动并及时获取报告。\n * jsettlers-web流行的德国棋盘游戏，用赚来的资源建造六角形，定居点，城市，道路\n * Tamiat CMS-Tamiat 是面向前端的 CMS，使用 Vue.JS 作为前端，并与 Firebase 集成了后端功能。\n * vuegg-vue GUI 生成器：一次性创建模型和代码！它通过其可视化编辑器利用页面，组件和样式的创建。为您的下一个 vuejs 项目生成所有脚手架代码。\n * Podlove Web Player-经过 Podcast 优化的基于 HTML5 的音频播放器，具有章节，字幕和嵌入功能。\n * Leo Vue-使用开源 Leo 概述编辑器/ IDE 创建带有嵌套菜单的 Web 应用程序，并支持内容中的 Vue 组件。\n * Justine-使用 Vue 组件作为文档模板的可配置 HTML 文档生成器(当前支持 JSDoc)\n * Deezer-Vue-使用 Vue \\ Vuex 构建的 Deezer 客户端\n * Vuep.run-Vue 的在线 SFC 编辑器\n * V·oogle-Google.com，已修订\n * Pomidorus-使用 Vue 和 D3 构建 Pomodoro 时间跟踪器 🍅\n * Hubble-：telescope：浏览 GitHub Stars 的历史。\n * Vuepress-简约的 Vue 驱动的静态网站生成器\n * Socialhome-具有社交网络功能的联合富个人资料生成器\n * GenVue-一个可托管的 Web 应用程序，允许机密用户上传和共享基于 Vue.js，Vuetifyjs 和 NetCore WebAPI 堆栈的私有文件\n * vue-array-Vue 下的数组对象操作，Vue 下的数组对象操作使用此包可操作数组。Vue 可以监视阵列中的更改\n * Laqu-l-具有 Quasar Framework，带有 OAUTH 2.0 身份验证的 GraphQL API 后端，Firebase 就绪，多语言功能等的完整应用入门套件。\n * Protovue-一个原型组件库，可帮助设计人员和开发人员快速搭建抽象的应用程序布局。\n * Chattier-使用 Laravel 5.6，Vue.js 2 和 Bulma(Buefy 组件+ Bulmaswatch 主题)构建的 SPA 社交网络。还使用 JWT 身份验证。\n * chrome-ribbon-reminder-使用 Vue 和 Async / Await 编写的 Chrome 扩展程序。使用弹出显示并更改徽章计数。\n * 收藏夹-一个简单的简单收藏夹生成器。\n * 模块化家谱-使用 Laravel 5.7，Vue.js 2.5 和各种组件的家谱/族谱管理系统。工作正在进行中。\n * 最小注释-使用 Vue.js 构建 Web 应用\n * 烘焙一个应用程序，旨在帮助咖啡爱好者在学习 Laravel + Vue.js 的同时找到他们的下一杯咖啡。\n * 堆栈编辑-浏览器内 Markdown 编辑器\n * Bael 博客模板-静态生成的博客模板，该模板使用 Netlify CMS 作为后端，使用 Netlify 进行托管。具有野蛮美学，模糊搜索，无服务器电子邮件注册等功能。\n * Buefy Shop示例商店，开源的，具有 Nuxt，Stripe，Firebase，Bulma 和无服务器功能。\n * sysmon用于 Linux 的 AB / S 模式系统监视器。您可以在任何地方通过 Web 浏览器远程监视系统资源的使用情况。\n * eth-vue一个松露盒子，提供您快速构建具有 Vue.js 身份验证功能的以太坊 dApp 所需的一切，包括易于部署到 Vue.js 的配置。 Ropsten 网络。它还具有 Gravatar 功能。\n * Nippon-color受 nipponcolors 点 com 的启发。这是使用 vue-cli 3 的日本彩色 PWA 版本。\n * Saleina CMS一个静态网站内容管理系统，使用 git 作为后端使用 vue 构建。\n * Vuido用于创建本机桌面应用程序的框架。它可以使用本机 GUI 组件在 Windows，OS X 和 Linux 上运行。\n * YouGetYouTube 视频/音频/字幕下载器+ Cutter\n * Vue Pug 手写笔Vue + Pug +手写笔样板 💚🐶🖌\n * Crypto News允许您转换加密货币，查看每个 ICO 的最新新闻和汇率–来自一个加密货币世界的所有数据。\n * Epiboard一个新的选项卡页面扩展，具有材料设计和有用的功能：new：：tada：\n * zhudyos / duic分布式配置中心：新：\n * Vuemmerce使用 Vue.js 和 Bulma 框架构建的免费电子商务模板：新：\n * Nucleus分层体系结构 ASP.NET Core API 和 Vuejs 客户端应用程序启动模板\n * Carpoolear阿根廷拼车应用程序的开源 Vue.js 前端(移动和 Cordova 应用程序)：[Carpoolear](https://carpoolear.com。 ar)\n * Statusfy：Statusfy 是一个状态页面系统，易于使用且完全开源。\n * DynamoDb-GUI-Client：DynamoDb 的跨平台 GUI 客户端\n * RosterWebApp开源名册 Web 应用程序，允许对员工/团队的名册进行工作会议和其他功能。\n * Vue 电子商店 Templet-带有 vue / vuex / vue-router 和 bootstrap4 的电子商务 Templet。\n * Kitty Ipsum-生成由不同语言的“喵”组成的 lorem ipsum。\n * Git Superstar-计算您的 git 星级和顶级存储库。\n * Twill-用于 Laravel 的开源 CMS 工具包，可帮助开发人员快速创建直观，强大而灵活的自定义管理控制台。\n * MATH_BOT-通过对机器人编程来学习数学。\n * Vue 填字游戏-一个基于 Vue.js 的填字游戏构建器和填充前端应用程序。使用CodeSandbox构建。\n * Vue 组织结构图-免费管理和发布您的交互式组织结构图(orgchart)，无需网络服务器。\n * 哔-使用 Vue.js 和 Ionic 4 构建的帐户安全扫描程序\n * Vue CRUD-基于 Vue.js 的 REST-ful CRUD 系统。Vue CRUD 允许您轻松创建快速应用程序，例如 CMS 或 CRM。\n * Vue HQ 管理员仪表板–由 Vue，Sass，Firestore 和 Netlify 支持的现代管理仪表板。\n * MToDo-带有简单身份验证的迷你待办事项列表，该身份验证是使用 Vue.js 和 JSON Server 作为数据模拟构建的。非常适合作为发现有关真实 Vue.js 参考的任何人的参考\n * FireX 代理-FireX 代理是用户值得信赖的 Chrome 和 Firefox 浏览器扩展程序，可让您解除阻止任何网站的权限并私密安全地浏览 Web。🛡\n * VueSolitaire-接龙(spider，klondike)包含在 Vue.js 中。\n * Thermal-一站式访问所有 Git 存储库。\n * QMK Configurator-Vue.js 中的 QMK 固件键盘配置 UI。\n * Eplee用 Vue.js 和 Electron.js 制作的甜美，简单的 epub 阅读器。\n * vue-realworld-example-app-示例性全栈 Medium.com 克隆\n * 每日-精选的开发新闻已传递到您的新标签页 👩🏽‍💻\n * Laravel 文件管理器-Laravel 的强大文件管理器\n * Vue 加密仪表板-用 Vue.js 制作的 Cryptocurrency 仪表板\n\n\n# 商业产品\n\n * Wijmo-具有 VueJS 支持的 UI 控件的集合。\n * 整理说明\n * Formester-表格，电子邮件营销自动化变得容易\n * ChatWoot-通过 Facebook Messenger 进行 Livechat 和代理协作。\n * VueA-具有多种布局和 laravel 版本的 VueJS 管理模板。\n * Teleo-团队合作应用在讲话，计划和做事之间轻松移动\n * Cover-基于 Vue.js 构建的高质量组件库\n * EducationLink-适用于教育代理商和大学的 CRM 和销售自动化。\n * Pragmatic v2.0-使用 Vue.js 和 Element 构建的响应式和可配置管理模板。\n * 座位-简单而现代的团队沟通和协作解决方案。\n * Moonitor-台式机的加密货币跟踪器。\n * Deskree-将想法，任务和问题集中在一处的在线协作平台。\n * OSHCExpress-OSHC(海外学生健康保险)保险(澳大利亚国际学生保险)的比较和电子商务。\n * Agiloo-适用于 Scrum 和看板的项目管理应用\n * ScaffoldHub-带有 NodeJS，MongoDB 或 SQL 的 VueJS 在线 Web App 生成器。\n * Commandeer-可以重新构想管理。使用 Vue.js 和 Electron 构建的桌面云管理应用程序。\n * SA Email Builder-使用 VueJS 和 Quasar Framework 做出响应的电子邮件模板构建器\n\n\n# 应用/网站\n\n * Laravel Spark\n * 副视频\n * 表格\n * Laracasts\n * esa.io\n * 稀土掘金\n * 布拉格机场\n * 投资组合网站\n * 乐风乐团\n * Atiiv-面向私人教练及其客户的应用程序。\n * 统计\n * Embalses！-使用美国地质调查局数据库报告水坝水位的工具。\n * TravelMap-旅行者基于地图创建博客的简单方法。\n * 适当的衬衫制造商-定制衬衫的制造商。\n * CheckIt\n * Reddit 新闻-浏览器扩展程序，用于显示来自 reddit 的通知和新闻。\n * 卡通网络自行制作 Powerpuff\n * 小桃酱\n * cloudradioo-Web 应用程序，可随机播放 soundcloud 图表中的前 50 首歌曲\n * vNotes-使用 Vue.js 和本地存储 API 的 Markdown 简洁漂亮的记事本。\n * 开放功能计算机\n * Dermail-用 Vue.js 编写的针对 Dermail 的 Webmail 客户端，Dermail 是用 node.js 编写的邮件系统。\n * octimine-专利搜索引擎。\n * Draxed-基于 Web 的 MySQL 和 PostgreSQL 数据浏览器和仪表板管理器。\n * Leapspotleap-查找您附近的 Wikipedia 文章的简单方法。或只是导航到一个地方并找到有趣的维基百科信息。响应式 Web 应用程序。\n * X-SONGTAO-个人博客。FE 和 CMS 位于同一 vue SPA 中。\n * Jobinja-在伊朗运营的求职委员会和职业平台。\n * 滚蛋吧！莆田系-显示所有 Put 田医院的信息\n * Jobi：招聘平台\n * 香料屋-高质量香料的电子商务网站。结帐，购物车，产品详细信息页面和搜索是使用 Vue 构建的。Checkout 是用 Vue＆Vuex 编写的单页应用程序。\n * Livestorm-网络研讨会/直播活动应用。\n * Metric Loop-一个技术服务和解决方案网站。\n * 保持\n * 全球考试-语言能力测试在线培训\n * SlugSurvival-一个可帮助学生更好地计划课程的网络应用程序(业余项目，不属于 UCSC)。\n * FreePoll.Online-使用 Vue.js，vue 可排序，语义 UI 和 Zappa 构建的群体决策工具。\n * GitRelease-使用带有电子的 vue.js 在 mac 菜单栏上跟踪 github 项目的新版本。\n * 12BAY.VN-在线预订机票。\n * PLAYCODE.IO-快速前端实验的游乐场。\n * The Void Radio-地下室内音乐在线广播。\n * Bitly Vue-使用 VueJS 和 Bitly API 缩短 URL。\n * Storyblok-使用 VueJS 作为前端的基于 API 的/分离的 CMS。\n * WizzAir\n * 移至 HTTPS-有关将不同平台/托管站点移至 HTTPS 的指南\n * Booknshelf-发现有关不同主题的出色书籍和书架。\n * Top HN-在 Hacker News 上实时显示最新新闻活动\n * Euronews-Euronews 是一种多语言新闻媒体服务，总部位于法国里昂。\n * Roozameروزامه??-Roozame 是波斯语的智能新闻媒体服务。\n * Koumoul\n * NinjaCalc-一组与嵌入式工程相关的计算器，使用 vue.js 作为开源单页应用程序构建。\n * Vue.js Feed-最新的 Vue.js 新闻，教程，插件等。基于Vuedo，使用 Vue.js 和 Laravel 制作。\n * 蒜瓣-使用 Vue2.0 和 Douban API 开发的网络应用\n * 猜对了-一个“猜单词”游戏-用 Vue / vuex / vue-router(前端)和 Laravel / MySQL(后端)编写。代码是GitHub 上的开源(尽管不是在 kdcinfo 上运行游戏的实时文件)。\n * GRAP-商业通讯服务\n * 简易模拟\n * mmf-blog-vue2-ssr使用 Vue 2.0，vue-router 和 vuex 构建的博客，并具有服务器端渲染\n * JSON 模式编辑器-使用 Vue.js 和 Firebase 构建的 JSON 模式的直观编辑器。\n * Winsome Trivia-一个单人或多人琐事游戏，具有由 Vue.js 构建并由 Open Trivia 数据库提供支持的 2,000 多个独特问题。\n * Moon Organizer-农历日历应用\n * Flash-Vue-“未来的抽认卡”将学习无处不在：rocket：\n * Kinderbesteck-具有 Vue2.0，Vuex，Vue 路由器的完整在线商店 SPA\n * n2ex-vue ssr(必须)网站，请使用 v2ex API\n * 词库-众包在线词库\n * Chattanosy-由社区提供的田纳西州查塔努加新事物的数据库。\n * PAIXIN-正版图片销售网站\n * CodeBottle-将代码段拖放到您的项目中\n * 1XBET-自 2007 年开始运营的博彩公司\n * MyOwnTV-用于创建互联网电视的流媒体网站\n * CrowdCircus-欧洲最大的众筹和众筹平台\n * 与某人交谈-与世界各地的陌生人进行免费，匿名和保密的在线文本聊天。\n * 车轮工厂-ui 组件和库共享网站\n * ابیاتنابپارسی-波斯诗集\n * Ripplectron-Ripple(区块链硬币)vue-electron 的电子钱包桌面客户端\n * PingBreak使用 vuejs 作为实时仪表板的免费，简单的网站监控服务\n * Todoist 致敬-Todoist 克隆，用 Rails + Vue 编写\n * JSON 编辑器-使用 Vue2 和 firebase 构建的可识别架构的 JSON 编辑器。\n * Develteam-独立游戏开发者的社交网络。\n * Mixsii-适用于青少年，成人，家人和朋友的免费视频聊天室网站。\n * PipQuest-Vue 中内置的复古益智游戏\n * Matryx-去中心化的协作平台。\n * iPrevYou-YouTube™ 播放器-用于在桌面上观看 youtube 视频的 Chrome 应用。\n * 物品管理器-传送命运 2 游戏物品的应用程序。\n * 前端大师 Vue 简介-前端大师全日制课程\n * TR-101-鼓合成器/音序器。\n * Bazaar-媒体共享平台。\n * WynnStats-非官方的 WynnCraft 统计信息。\n * Vectr-免费的矢量图形软件\n * 大脑位-Emotiv 耳机的 P300 在线拼写机制\n * Coin Dashboard-完全客户端的加密货币资产仪表板。\n * Habitica-角色扮演游戏形式的在线任务管理应用程序。\n * MadeWithVueJs-由 Vue.js 制作的项目图库(网站本身也使用 Vue.js)\n * CodeDependencyScanner-显示.Net 汇编代码依赖关系的 AC＃dektop 应用程序使用 Vue，Neutronium 和 D3.js 构建。\n * 千以太坊首页-百万美元首页被重新构想为以太坊 DApp。在 Vue.js 上构建并开源。\n * 让我们着迷-免费的在线图像升级和神经网络增强功能。\n * Pi.TEAM-在线发票和会计-简单易用的在线会计和发票，单用户和自由职业者免费。\n * Vuethwallet-一个简单的应用程序使用 vuejs 生成以太坊钱包。\n * Tipe-下一代 API 优先的 CMS。使用功能强大的编辑工具创建内容，并使用 GraphQL 或 REST API 从任何地方访问它。停止让 CMS 决定如何构建应用。\n * Vuethexplore-一个简单的应用程序使用 vuejs 探索以太坊区块链。\n * Fintechers-以 Fintech 为重点的工作委员会。\n * Devjournal-项目和构想的协作待办事项列表。\n * Bubbleflat-一种在线平台，可通过搜索具有相似生活方式，兴趣爱好或学校的人来帮助学生和年轻的专业人 士找到理想的室友。Laravel 和 Vuejs\n * TeaQuinox Tea Co-专门从事散叶茶的电子商务网站。\n * blip-测试网站的速度，移动友好性，安全性和 HTML5 文档类型。在某个位置查找商家，然后整体测试其网站，或者只是测试您自己的 URL。\n * sunpos-太阳位置，仰角，方位角，黄道/赤道坐标和日出/日落时间(朱利安日)计算和转换实用程序。使用纯 JS，Vuejs 和 i18n Vuejs 本地化插件对网站进行编程。可视化是使用 D3.js 创建的。\n * U3xyz-基于 vue ssr 的个人博客。\n * 27.ua-乌克兰的互联网大型超市\n * 国际象棋守护者-从您自己的游戏中回答国际象棋位置问题。\n * 二十一点休息-二十一点的快速游戏\n * MECHANICAL-适用于 Firefox 的 Reddit mod，可显示上下文数据见解。\n * GameVix-与他人交换您使用过的视频游戏光盘，无忧。具有材料设计的 PWA。\n * VivifyScrum-适用于交付团队的敏捷项目管理应用程序。可定制的 Scrum 和看板板。\n * 9GAG-流行的在线平台和社交媒体网站\n * CryptoVue-实时加密货币仪表板\n * 厨房故事-烹饪平台\n * MailRabbit-在没有开发人员的情况下创建，A / B 测试和监视交易电子邮件。\n * Vue 资源精选-出色的 Vue 组件列表，类别，内嵌演示秀和简介\n * Cronhub-无痛 Cron 监控工具\n * wrkprty-针对自由职业者，远程工作者和希望离开办公室的专业人员的弹出协作活动。\n * 用爱制造-世界各地的“用爱制造 ❤️”倡议是庆祝 🎉，促进 📣 和建立 build 品牌的运动。它从 Dribbble，ProductHunt，Behance 和 Techcrunch 等多个来源获取 Tech 新闻，设计灵感和趋势。💝\n * 产品路径-在创业公司和科技公司中发现超过 1,000 个产品工作。\n * V·oogle-Google.com，已修订。一个笑话项目。😃\n * 经纪人注释-'研究成为房地产经纪人'：房屋：\n * SyncLounge-SyncLounge 是用于在多个位置的多个播放器之间同步 Plex 内容的工具。\n * HCE.it-一家意大利代理商的网站，完全由 Vue 使用基于 Laravel 的无头 CMS 创建。\n * 页面-网页设计灵感\n * Scrumpy-敏捷团队的漂亮项目管理工具\n * Spektrum-Spektrum Media Agency 网站\n * SPKSPK 生态系统的网站\n * IDDEF☪️ 重视人类的网页，CMS，CRM 和捐赠以及所有电子商务页面的协会联合会均使用 Vue.js，Vuex 和纯 JavaScript 设计 🙏\n * 配置文件管理-一种管理配置文件的简单方法\n * 烘焙这个应用程序旨在帮助咖啡爱好者在学习 Laravel + Vue.js 的同时找到他们的下一杯咖啡。\n * YBR-集中的 YBS 公开电子投诉管理系统。(全 SPA)\n * Regex Fiddler\n * Myanpwel-活动票务平台的网站。\n * CryptoArte-以太坊的艺术品收藏，不可替代的代币和 Dapp。\n * Muuviez-具有时尚设计的电影发现和跟踪网站\n * NAGA VIRTUAL-NAGA VIRTUAL 是第一个独立的虚拟商品市场。\n * Scroll.in-Scroll.in 是独立的新闻，信息和娱乐企业。\n * Akunyi-慈善网站\n * Mark Ruffalo 会做什么？-动机网站基于 Mark Ruffalo 在获得成功之前在数百次试镜中失败的故事。\n * 白兰地-菜单栏的品牌资产管理器。\n * Ruster 社区-CN 的 Rust 全栈社区论坛。\n * NBC Sports-NBC Sports 是一家体育新闻网站。\n * WITHIN-虚拟现实中的非凡故事。\n * plottr.io-规划跑步和骑车路线\n * beCamp-在弗吉尼亚州夏洛茨维尔举行的由社区组织的技术会议。网站代码是开源的。\n * Trustpilot-免费开放给所有评论平台。\n * Lagom-简单，直观且响应迅速的 WHMCS 主题\n * ScoutMyTrip-Roadtrip Planner-印度的公路旅行计划应用程序，可帮助旅行者建立行程，发现景点，寻找酒店，加油站，美食餐厅等沿路线。\n * Podflix-播客应用。\n * GamersClub-巴西最大的电子竞技社区发展公司\n * MIT-麻省理工学院的官方网站。\n * Elvenar-Elvenar 是一个基于浏览器的幻想城市建设者游戏。\n * 信标-：blue_heart：这项服务可让您在多个网站之间共享内容。\n * Artfinder-Artfinder 是买卖艺术品的网站。\n * Rolodromo-专门用于桌面 RPG 的西班牙语网站。\n * GitHubExplorer-用于探索 GitHub 的纯静态页面 webapp。使用Vuejs和GitHub GraphQL API v4。\n * 主题演讲-与 Vue 一同展示。\n * HappyPlants-用于组织植物的渐进式 Web 应用 🌱。\n * Pocket Lists-世界上最友好的待办事项列表应用程序。\n * Padlet-协作公告板\n * Glovo-按需交付\n * MySigMail-MySigMail 是一个免费的浏览器电子邮件签名生成器，无需创建帐户\n * Wordguru-一个简单的口头游戏，您可以分成几个小组，并尝试猜测尽可能多的关键字。\n * ApiFlash-基于 Chrome 的截图 API，基于 AWS Lambda 开发人员专用\n * Kitty Ipsum-生成由不同语言的“喵”组成的 lorem ipsum。\n * Git Superstar-计算您的 git 星级和顶级存储库。\n * DECS-分散的多合一工作区，用于管理代码段并保护敏感数据。\n * Careup-牙医 🦷 的业务管理工具。\n * Asciiur-互联网的 ascii 艺术收藏\n * Tapestri Designer-用于设计用于基因组测序实验(NGS)的 PCR 引物的免费工具\n * Remote-Access-SSH-使用 node-ssh 的基于 Web 的远程主机访问\n * 地图标记生成器-一个免费的在线工具，可即时生成自定义地图图标\n * Monocle Reader-在一个地方关注提要，Twitter，YouTube，博客和其他所有内容。\n * 前站导航-前端社区，文档收录。\n * Geenes-生成调色板并将其应用于 UI，然后将其导出到草图或代码中。\n * Blurrish-Mac / Windows 加密的 Morning Pages 日记，由 Vue 和 Electron 构建。书写时模糊，因此可以在公共工作区中记录日志。\n * ExifShot-摄影的方式和方式，精美绝伦。\n * Studolog-用于学生的在线文件共享平台，包括测试人员和评论。目前仅捷克语 🇨🇿。\n * sum.cumo–数字业务模型(以 Vue 作为技术堆栈的核心)。\n * Gamebrary-用于组织视频游戏收藏的开源工具。\n * Guds-比较各大超市的价格。仅适用于墨西哥 🇲🇽。\n * Premium Poker Tools-扑克玩家用来学习的东西。\n * QMK Configurator-从浏览器配置，构建和下载自定义 QMK 固件。\n * Worksome-适用于合格的 IT 专业人员，自由职业者以及希望雇用他们的公司的市场/平台。\n * Translator-vuejs-使用 Vuejs，Yandex API 和 ResponsiveVoice.js API 构建的翻译应用程序。\n * 大计时器-用于研讨会，会议和演示的全屏倒数计时器。Big Timer 可以帮助研讨会主持人，会议椅，设计短跑选手，演示者和有抱负的游戏节目主持人坚持自己的计划。\n * Wirenook-用于构建响应式网站线框的免费在线应用程序。高保真和低保真，项目共享和 svg 下载。\n * Kvalitetskontroll-为建筑业量身定制的挪威管理系统。\n * Poolside FM-复古音乐播放器\n\n\n# 互动体验\n\n * Jean-Pierre Morin | 1700 LAPOSTE\n * Facebook NewsFeed\n * YouTube AdBlitz 2016\n * Omnisense 体验\n * Louis Ansa 网站(投资组合)\n * Djeco.com\n * Tolks.io\n * 遇见 Graham\n * NOIZE 原创\n * TR-101 合成鼓机\n * Bootstrap 4 编辑器\n * Subtletab-浏览器扩展\n * web-riimote-将您的智能手机变成 3D 控制器(源代码)\n * CSS ColorVars-交互式工具代码生成(源代码)\n\n\n# 企业用途\n\n * 塞恩斯伯里的\n * AREX -大疆创新 -Octimine GmbH -浑力集\n * GitLab\n * Clemenger BBDO Melbourne\n * ZenMate\n * 代码\n * Storyblok\n * Monito-建立 Booking.com 以进行国际汇款\n * Hypefactors-数据驱动的 PR 专业人员的软件 -Adobe -IBM\n * Cotabox\n * Aromajoin-基于硬件，软件和材料技术的协调发展最好的数字气味产品。\n * 家乐福\n\n\n# A11y\n\n * Vue A11y 项目-Vue.js 社区项目，用于改善 Web 可访问性。\n * vue-skip-to-它可以帮助仅使用键盘的人跳到最重要的地方。\n * vue-axe-Vue.js 应用程序的可访问性审核。\n * vue-announcer-Vue 的一种简单方法，可为屏幕阅读器宣布任何有用的信息。\n * eslint-plugin-vue-a11y-用于.vue 中元素可访问性规则的静态 AST 检查器\n * vue-focus-lock-这是一个陷阱！焦点锁定。A11y util，用于确定焦点。\n * vue-a11y-calendar-可访问的国际化 Vue 日历。\n\n\n# 表格\n\n * vuetable-2数据表简化\n * vue-tables-2-Vue.js 2 网格组件。\n * vue-datasource-一个 vue.js 服务器端组件，用于创建动态表。\n * ag-grid-vue-用于 ag-Grid 的 Vue 适配器。\n * vue-data-tables-Vue2.0 数据表，基于 element-ui。\n * vue-floatThead-用于 floatThead 的 Vue 2.0 组件，floatThead 是一个浮动的粘性表头插件。\n * vuetiful-datatable-具有排序，过滤，分页，分组和聚合的数据表组件。\n * vue-materialize-datatable-Materialize CSS 的 VueJS 数据表\n * vue-good-table-一个易于使用的 VueJS(2.x)表插件，具有排序，列过滤，分页等功能。\n * vue-grid-Vue.js 的灵活网格组件\n * vue-easytable-基于 Vue2.x 的功能强大的表组件\n * vue2-datatable-component-永远不会烂的 Vue.js 2.x 最佳数据表\n * vue-js-grid-Vue.js 2.x 响应式网格系统，具有平滑的排序，拖放和重新排序\n * vue-handsontable-official用于 Handsontable 电子表格组件的 Vue.js 包装器\n * vue-grid-用于 Vue.js 2.x 的功能强大的 flexbox 网格系统，使用内联样式构建\n * vue-data-tablee-基于 vue-good-table，一个简单漂亮的表组件\n * vue-scrolling-table-具有 flexbox 大小的简单表格组件，滚动表格主体(水平和垂直)，所有 tr / th / td 的插槽渲染。\n * el-search-table-pagination-将 Element UI 的 Form，Table 和 Pagination 组件组合在一起。基于 Vue 2.x。(详细信息)\n * vue-crud-x-使用 Vuetify 布局的可扩展 Crud 组件，除了通常的页面，排序，过滤器之外，它还能嵌套的 CRUD，自定义表单，过滤器，操作。\n * Vue 数据表-VueJS 支持的数据表，具有 Laravel 服务器端加载和 JSON 模板设置\n * v2-table-一个基于 Vue 2.x 的简单表组件。\n * vue-cheetah-grid-在 Vue.js 的画布上工作的高性能网格引擎。\n * vue-table-component-直指 Vue 组件以显示表。\n * @ lossendae / vue-table-Vue.js 2.x 的简单表组件，具有分页和可排序的列。\n * el-data-table-基于 element-ui，可以轻松完成任务\n * DevExtreme Vue 网格-用于 Bootstrap 的基于插件的高性能 Vue 数据网格。\n * vue-ads-table-tree-具有过滤，排序和分页功能的 vue Table 组件。行可以具有子行，因此可以构建树结构。它还支持异步调用以从后端加载行。它是使用 CSS 框架tailwindcss构建的\n * 用于 Vue 的 Synfusion 数据网格-显示和处理具有分页，排序，过滤，编辑和分组等功能的表格数据。\n * @ marketconnect / vue-pivot-table-数据透视表的 vue 组件\n * vue-teible-Web 的轻巧灵活的表组件：zap：\n * vue-jqxgrid-具有过滤，排序，编辑，分组，数据导出和其他功能的 Vue 数据网格。\n * vue-jqxpivotgrid-具有枢轴设计器的 Vue 枢轴数据网格，钻取单元格，枢轴功能。\n * toast-ui.vue-grid- [TOAST UI Grid]的 Vue 包装器(http://ui.toast.com/tui -grid /)。\n * vueye-datatable-Vueye 数据表是基于 Vue.js 2 的响应数据表组件，它按页面组织数据以便于浏览。\n * vue-sorted-table-一个将表转换为排序表的插件。支持嵌套的对象键，自定义图标和可重用组件。\n * vue-bootstrap4-table-基于 Vue 2 和 Bootstrap 4 的高级数据表，其中包括多列过滤，多列排序，分页和信息，复选框行和高度可定制的插槽选项。\n * vuejs-smart-table-直截了当的表格组件，使用原始 HTML 表格结构，并具有开箱即用的排序，过滤，分页和选择功能。\n * @ myena / vue-table-用于客户端/服务器数据处理的表组件。筛选，排序，分页，分组，展开详细信息行。高度可定制的通孔，用于过滤器，标题，列，分页，详细信息行。\n * vue-jd-table-Vue 2 的高级且灵活的数据表组件。功能丰富：搜索，过滤，导出，分页(传统和虚拟)滚动)等等！\n * vue-grd-用于网格布局的简单，轻巧和灵活的 Vue.js 组件。\n * iview-table-page-将 iview UI 的表和页面组件组合在一起。基于 Vue2.x。并听到了一些使用 iview-table-page 的示例。\n\n\n# 通知\n\n * vue-notifications-Vue.js 不可知的非阻塞通知库。\n * vue-easy-toast-vue / vue2 的 Toast 插件。\n * vue-toasted-适用于 VueJS 的自适应 Touch 兼容 Toast 插件。\n * vue-notifikation-Vue.js 通知插件。\n * vue-notification-使用Velocity制作动画的 Vue.js 2+通知插件。\n * vs-notify-微小但功能强大的通知组件，没有依赖项。\n * vue2-notify-Vue.js 2+通知插件。\n * vue-notifyjs-极简主义，3kb 可通知通知插件\n * vueup-Vue.js 的简单，轻巧和优雅的全局通知弹出窗口\n * vuex-flash-Vuex 2.x 中用于 VueJS 2.x 的 Flash 消息组件。\n * vue-snotify-Vue.js 2 通知中心\n * vue-notify-me-Vue 的可堆叠通知警报\n * vue-noty-围绕 Noty 的 Vue.js 2 包装器\n * vue-notice-Vue.js 2 使用本机 API 围绕 Noty.js 进行包装\n * vue-flash-message-简单但灵活的通知插件\n * @ voerro / vue-notifications-具有 HTML 和样式支持的简单 Vue.js 2 通知插件。\n * vue-awesome-notifications-具有高级异步支持的轻量级 Vue.js 通知库。\n * vue-izitoast-围绕 IziToast 的 Vue.js 2 包装器。\n * vue-toastr-2-基于toastr的 Vue.js 的简单敬酒通知)\n * vue-snack-基于 Google Material 的 Snackbars 的 Vue.JS 插件。\n * vue-m-message-vue 的消息插件。\n * vue-notification-bell-用于显示通知的 Vue UI 组件。\n * v-tostini-Vue.js 2.x 真正纯正的吐司通知机制。不包括 CSS。\n * vue-toast-notification-另一个 Vue.js Toast 通知插件。\n\n\n# 装载机\n\n * vue-radial-progress-Vue.js 的径向进度栏组件。\n * vue-simple-spinner-适用于 Vue.js 的简单灵活的微调器\n * vue-wait-适用于 Vue / Vuex 和 Nuxt 应用程序的复杂加载程序管理。\n * vue-progress-path-支持任何自定义 SVG 路径的可自定义进度指示器和微调器。\n * vue-blockui-用于 vue 2 的 BlockUI，类似于 jquery blockUI，可用于加载屏幕。\n * epic-spinners-易于使用的带有 vue.js 集成的 css spinners 集合。\n * svg-progress-bar-Vue.js 的简单进度条。\n * vue-loading-overlay-微小的全屏加载指示器\n * vue-loaders- [loaders.css]的 vue 包装器(https://github.com/ConnorAtherton/loaders.css)\n * vue-promise-btn-小巧而强大的异步按钮(或任何其他标签)工具，带有精美的内置微调器\n * vue-spinkit-🌈 带有 VueJS CSS 动画的加载指示器集合\n * vue2-form-loading-VueJS 指令可与表单一起使用，以便在加载下一页时禁用提交按钮\n * vue-element-loading-⏳ 在容器内加载或全屏显示 Vue.js\n * tb-skeleton-Vue.js 的骨架屏幕加载\n * vue-spinners-💫 为 Vuejs 加载微调器组件的集合\n * vue-progress-bar-这是一个基于 vue 的级联进度条插件\n * vue-loading-button-👇 带有滑动加载指示器的直截了当按钮\n\n\n# 进度条\n\n * vue-progressbar-vue 的轻量级进度条。\n * vue2-loading-bar-最简单的 YouTube，例如 Vue 2 的加载条组件。\n * vue-top-progress-另一个为 Vue.js 加载栏组件的顶级进度。\n * vue-nprogress-进度条基于 Vue 的 nprogress。\n * vue-progress-button-Vue.js 2.x 动画按钮组件。\n * vue-simple-progress-Vue.js 的简单，灵活的进度栏\n * vue-component-loading-管理每个组件内部的加载状态，并使用进度条显示全局加载状态。\n * vue-scroll-progress-用于页面滚动进度条的简单 Vue.js 插件\n * vue-read-progress-页面顶部的可自定义进度条，显示滚动进度\n * easy-circular-progress-具有计数效果的简单循环进度组件\n\n\n# 工具提示\n\n工具提示/弹出窗口\n\n * v-tooltip-使用 Vue 2.x 的简单工具提示。\n * vue-popper-component-Vue.js 的 Popper.js 指令。\n * vue-directive-tooltip-简单，灵活的工具提示指令(基于 Popper.js)！[Vue.js](https：// img.shields.io/badge/vue-2-green.svg)\n * vue-popperjs-基于 VueJS 2.x popover 组件的popper.js\n * vue-tooltipster-基于 VueJS 2.x 工具提示组件的tooltipster.js。支持 html 内容，悬停和悬停+单击事件。\n * k-pop-基于popper.js的简单 popover 组件。高度可定制的。带有主题。支持自定义触发器，并且可以监听任何事件。\n\n\n# 覆盖\n\n * vuedals-一个 VueJS(2.x)插件，用于具有单个组件实例的多个模态窗口。\n * sweet-modal-vue-发生模态的最甜的库。现在可用于 Vue.js。\n * vue-js-modal-简单易用，高度可定制，移动友好的 Vue.js 2.0+模态，具有 0 个依赖关系。\n * vudal-vue.js 的模态窗口\n * vodal-具有动画的 Vue 模态。\n * vue-image-lightbox-一个 Vue 图像灯箱/图库，可以很好地显示图像。\n * vue2-simplert-Vue 2 简单警报组件(受 SweetAlert 启发)，作者：Irfan Maulana\n * Vue-Semantic-Modal-不具有 jQuery 依赖关系的 Vue 2 语义-UI 模态组件\n * v-img-易于安装的图库。\n * vue-dialog-drag-可拖动对话框\n * vue-ya-semantic-modal-Vue2 的另一个语义 UI 模态组件，没有 Jquery 但具有 Vue 转换\n * vue-pure-lightbox-非常简单的灯箱插件，没有任何依赖性-仅 Vue！🖼\n * v-viewer-基于[viewer.js]的 vue 图像查看器组件，支持旋转，缩放，缩放等(https：// github.com/fengyuanchen/viewerjs)\n * vue-messagebox-Vue 上易于定制的消息框组件。\n * vuejs-dialog-轻量级，基于承诺的警报，提示和确认对话框。\n * @ hscmap / vue-window-vue2 的窗口 UI 组件。\n * vue-gallery-VueJS 响应式和可自定义的图像和视频库，轮播和灯箱，已针对移动和桌面 Web 浏览器进行了优化。基于 blueimp-gallery\n * vue-swal-用于将 SweetAlert 集成到 Vuejs 的小型包装器。(与 SSR 兼容)\n * vue-modal-dialogs-✨ 承诺自己的对话框！\n * vue-img-view-Vue.js 的插件，您可以在任意位置拖动/查看/旋转图片\n * vue-modaltor-vuejs 的最先进的可配置模态组件\n * v-modal-backdrop-用于 vue 的简单通用背景组件\n * vue-cute-modal-适用于 Vue 应用程序的简单易用的 Modal 组件。\n * v-dialogs-一个简单而强大的对话框，包括基于 Vue2.x 的 Modal，Alert，Mask 和 Toast 模式\n * vue-gallery-slideshow-VueJS 的响应式画廊组件\n * vue-a11y-dialog-用于可访问对话框[a11y-dialog](https://github.com的Vue.js组件包装器。 com / edenspiekermann / a11y-dialog)。\n * vue-slideout-panel-VueJS 的可堆叠面板组件\n * v-gallery-用于在“ gallery”或“ carousel”中显示图像的 Vue2 插件\n * vue2-image-loader-vue2 的图像 lazyLoad loader 组件\n * vue-my-photos-一个简单的无依赖图像灯箱组件，具有过滤功能\n * vue-img-orientation-changer-一个 Vue.js 指令，可自动调整您的 img 以更正方向。\n * vue-topmodal-一个完全可定制，易于使用的 Vue.js 模态组件。(自适应，可堆叠，可滚动，动画)\n * vue-modal🖼-为多个可切换模态内容提供对象数组或快速内联您的内容。完全可定制的 Vue 模态组件。\n * @ innologica / vue-stackable-modal-用于可堆叠的模态对话框的库。完全可定制且非常易于使用。\n * vue-sweetalert2-sweetlaert2 的包装器，支持 TypeScript，Nuxt 和 SSR\n\n\n# 视差\n\n * vue-parallax-以比窗口慢的速度滚动图像以产生整洁的光学效果。\n * vue-parallaxy-用于视差图像滚动效果的 Vue.js 组件。\n * vue-mouse-parallax-一个易于使用的鼠标视差组件-由 Vue.js 制成\n * vue-parallax-js-微小的 vue 组件，为元素上的视差效果添加了指令。\n\n\n# 图标\n\n * vue-awesome-Vue.js 的 Font Awesome 组件，使用嵌入式 SVG。\n * vue-material-design-icons-单个 SVG Material Design 图标集合文件组件。\n * vue-icon-font-Vuejs 的 iconfont 插件(支持 Font-class 和 Symbol)。\n * vue-ionicons-来自离子团队的 Vue 图标集组件。\n * vue-ico-具有嵌入式浏览器支持和选择性捆绑功能的 Vue 简易图标\n * mdi-vue-Vuejs 的 Material Design 图标组件\n * vue-fontawesome-Font Awesome 5 Vue 组件\n * g-icon-svg 图标的简单图标组件(与类似于 Font Awesome 的字体工具包兼容)\n * vue-simple-line-icons-Vuejs 的简单线条图标组件\n * vue-country-flag-国家标记图标的 Vue 组件- vicon- Vicon 是用于 vue 的简单 iconfont 组件。\n * md-svg-vue-Google 为 Vue.js 和 Nuxt.js 提供的 Material Design 图标(服务器端支持(带缓存)，内嵌 svg)渲染，官方图标名称)\n * vue-lang-code-flags-Vue 组件，显示语言来源国的标志\n * vue-zondicons-精美[Zondicon]的 Vue 组件(http://www.zondicons.com/icons.html)svg 图标\n * vue-eva-icons-简单漂亮的开源 eva 图标作为 Vue 组件。\n * vue-unicons-为您的下一个项目提供超过 1000 个像素完美的 svg unicons 作为 Vue 组件。\n * vue-fa-简单的 FontAwesome 5 Vue.js 2 组件。\n * vue-cryptoicon-美丽的像素完美的 400+加密货币和 10+法定货币图标。\n\n\n# 菜单\n\n * vue-accordion-适用于 Vue.js 的简单手风琴导航菜单组件。\n * vue-js-dropdown-Vue.js 2 下拉菜单组件。轻巧，易于使用和扩展，无外部缺陷。\n * vue-slideout-流行的库[slideout]的 Vue 实现(https://github.com/Mango/slideout)\n * vue-quick-menu-这是基于 vue.js2 的 Web 导航组件。\n * @ hscmap / vue-menu-vue2 的菜单/上下文菜单组件。\n * vue-router-nav-简约的响应式导航栏，呈现 vue-router 的路线。\n * vue-drawer-layout-一个简单的 DrawerLayout 组件(例如 Android)具有 Vue.js。\n * vue-simple-menu-具有一组基本功能的简单菜单组件，在 80％的情况下足够\n * vue-tree-navigation-具有 vue-router 支持的 Vue.js 2 树导航\n * bp-vuejs-dropdown-Vuejs => 2 下拉菜单。易于使用，无需外部，可选。\n * vue-bulma-accordion-简单，易于配置的手风琴或具有 Bulma 自定义样式的可折叠样式或内置的可用图标\n * v-selectmenu-针对 Vue2 的简单，容易和高度定制的菜单解决方案。\n * vue-burger-menu-具有不同 CSS 动画的画布外边栏 Menu 组件。\n * vue-dynamic-dropdown-一个高度可定制的，易于使用的优雅下拉组件\n * vue-navigation-bar-适用于您的 Vue 项目的简单，漂亮的导航栏。\n * vue-simple-search-dropdown-一个没有外部依赖关系的简单可搜索输入下拉组件\n * @ innologica / vue-dropdown-menu-Vue 的下拉菜单组件。任何元素都可以是下拉触发器，任何内容都可以下拉内容。\n * vue-menu-aim-菜单三角形选择，又名亚马逊\n\n\n# 输入\n\n * minus-plus-input-带正负号的数字输入；包含在 Vue.js v1 和 v2 中。\n * vue-integer-plusminus-带有 vue 2 增量和减量按钮的整数输入。\n * vue-numeric-input-带有控件的数字输入组件。\n * vue-number-smarty-数字输入可以在聚焦字段时更改滚动值。\n * vuetify-number-smarty-数字输入可在字段聚焦时更改滚动值(Vuetify.js 实现)。\n\n\n# 轮播\n\n * vue-easy-slider-Vue.js 的滑块组件。\n * vue-l-carousel-Vue.js v2.x +的响应式轮播(即滑块或滑动)组件。\n * vue-awesome-swiper-Vue.js(1.x〜2.x)的 Swiper(slide)组件。\n * vue-lory-基于 lory 的 Vue 滑块组件。\n * vue-slick-Slick-carousel 的 Vue 组件。\n * vue-flickity-Flickity.js 的 Vue 组件。\n * vue-carousel-3d-Vue Carousel 3D-Vue.js 美观，灵活且受触摸支持的 3D Carousel。\n * vue-carousel-适用于 Vue.js 的灵活，响应迅速，触摸友好的轮播。\n * vue-coverflow-vue2.x Coverflow 组件。\n * vue-agile–受 Slick 启发的轮播组件，仅以 Vue.js 和 Vanilla JS 编写。\n * vue-tiny-slider–由 ganlanyuan 创建的轮播组件，用 Vue.js 编写。没有 jQuery。适用于 IE8 +。\n * vue2-text-swimlane-用于 Vue.js 的 Text Swimlane 插件\n * vue-picture-swipe-Vue Picture Swipe Gallery(具有缩略图，延迟加载和轻扫的图像画廊)由 photowipe 支持。\n * vue2-siema-非常小的 Siema 转盘/滑块库的插件包装。\n * vue-flux-带有 20 个炫酷过渡的图片滑块。\n * vue-glide- [Glide.js]上方的 Vue 滑块和轮播组件(https://github.com/glidejs/glide)\n * vue-owl-carousel- [Owl Carousel 2]的 Vue 组件(https://owlcarousel2.github.io/OwlCarousel2/)\n * vueper-slides-适用于 Vue JS 的易于触摸且响应迅速的幻灯片/轮播。\n * vue-canvas-carousel- [vuc-carousel]的 Vue 画布组件(http://vuc.tianchenyong.top/#/carousel)\n * 胡珀-针对 Vue 优化的可自定义的可访问轮播滑块\n * 语言-Vue 的简单图像库组件，在下面显示带有缩略图的大图像\n * vue-piece-slider-动画幻灯片的碎片化外观\n * vue2-photo-carousel-Vue2 的照片轮播组件\n\n\n# 图表\n\n * vue-morris-VueJS 组件包装了 Morris.js。\n * vue-charts-适用于 Vue.js 的 Google Charts 插件。\n * vue-chartjs-Chart.js 的 Vue.js 包装器。\n * hchs-vue-charts-基于 ChartJs 的 Vue2.0 包装器。\n * vue-echarts-Vue.js 的 ECharts 组件。\n * vuetrend-Vue.js 的简洁优雅火花线。\n * vue-highcharts-Vue 的 Highcharts 组件。\n * vue-echarts-v3-ECharts.js(v3.x +)的 Vue.js(v2.x +)组件包装。\n * vue-chartist-Chartist 的 Vue.js 2.0 组件包装。\n * g2-vue-用于在 Vue 组件中轻松使用 G2 的工厂包装。\n * vuebars-适用于 Vue.js 的简洁优雅的火花棒。\n * vue-d3-network-使用 d3-force 绘制网络图形的 Vue 组件\n * vue2vis- Visjs的 Vue2 包装器。\n * vue-c3-用于 c3 图表的可重用 vue 组件\n * vue-d2b-d2b 图表的 Vue 组件。(包括轴，饼图，sankey 和森伯斯特图)\n * VueChart-一个非常简单的 Chart Vue 包装器。\n * vue-chartkick-用一行 Vue 创建漂亮的 JavaScript 图表\n * d3vue-用于在 VueJS 中创建反应性数据可视化的 D3 插件\n * vue2-frappe-VueJS 的 Frappe Charts 的简单包装\n * vue-google-charts-Google Charts lib 的反应性 Vue.js 包装器\n * vue-graph-数据可视化库，用于 Vue.js 中的仪表板实现\n * vue.d3.sunburst-基于 D3.js 的反应性旭日形组件\n * v-chart-plugin-一个可定制的组件，用于添加绑定到组件数据的 D3 图表。\n * vue-jqxchart-具有饼图，气泡，甜甜圈，线，条，栏，面积，瀑布，极地和蜘蛛系列的制图组件。\n * toast-ui.vue-chart- [TOAST UI 图表]的 Vue 包装器(http://ui.toast.com/tui -图表/)。\n * vue-apexcharts- [ApexCharts]的 Vue.js 组件(https://github.com/apexcharts/apexcharts.js)。\n * vue-doughnut-chart-Vue.js 的甜甜圈图组件。\n * v-charts-基于 Vue2.x 和 Echarts 的图表组件。\n * vue-css-donut-chart-用于绘制纯 CSS 甜甜圈图的轻量级 Vue 组件。\n * vue-trend-chart-Vue.js 的简单趋势图\n * vueplotlib-声明性，交互式，链接的绘图组件\n * vgauge-GaugeJS 的 Vue 包装器-创建漂亮的量规\n * vue-plotly- plotly.js声明性图表库的包装，随附 20 图表类型，包括 3D 图表，统计图和 SVG 地图。\n * vue-funnel-graph-js-Vue.js 的漏斗图绘制库。创建垂直和水平动画 SVG 漏斗图，并添加标签，值，图例和其他信息。\n * pure-vue-chart-在没有任何图表库相关性的情况下实现的轻量级 vue 图表\n\n\n# 时间\n\n * vue-timeago-Vue 的一个很小的 timeago 组件。\n * vue-moment-jalaali-针对您的 Vue.js 项目的 Jalaali Moment.js 过滤器。\n * vue-countdown-timer-添加了时区转换支持。\n * vue-analog-clock-range-显示时差的模拟时钟范围。\n * vue-moment-lib-使用相同的 momentjs API 的简单 Vue.js 2.0 MomentJS 库(过滤器和全局变量)。\n * vuejs-countdown-适用于 vue js 2.0 的简单倒数计时器组件\n * vue2-flip-countdown-Vue 2.x 具有倒转效果的倒数计时器\n * timeline-vuejs-Vue 的简约时间表\n * vue-awesome-countdown-Vue 2.5.0+具有高性能和高精度的倒计时插件。官方网站：https://vac.js.org\n * vue-clock2-显示 Vue 的时钟组件。\n * vuemodoro-Pomodoro 计时器作为单个文件 Vue 组件。\n\n\n# 日历\n\n * vue-fullcalendar-Vue 日历 fullCalendar。无需 jQuery。安排事件管理。\n * vue-event-calendar-Vue2 的简单事件日历，除 Vue2 外没有其他依赖项。\n * vue-calendar-picker-用于事件显示，时段选择和日期选择器的轻量级日历组件。\n * vue-lunar-calendar-农历的 vue 组件。使用 Moment.js 进行日期操作。\n * vue-simple-calendar-基于 Flexbox 的 Vue 月历功能；支持多日活动，本地化，节日表情符号，拖放。没有依赖关系。\n * vue2-calendar-一个简单的完整日历组件，旨在灵活而轻巧。\n * vue-jlunar-datepicker-具有节日和节气的中国农历日期选择器组件。\n * vue-full-calendar-Vue 1 和 2 的完整fullcalendar.io包装器\n * v-calendar-动画日历/日期选择器，显示简单和重复日期的区域，指标和日弹出窗口。\n * vue-infinite-calendar-Vue 2 的简单无限日历实现\n * vue-calendar-适用于 Vue 2.1.5+的简单日历组件，支持自定义内容。没有依赖关系。\n * vue2-event-calendar-Vue2 的事件日历，支持自定义事件项和日历标题。\n * vue2-datePicker-infinite-Vue2 的无限 datePicker，易于使用且没有依赖性。\n * vue2-slot-calendar-vue 2 日历，支持月球或日期事件的日期选择器组件，引导程序样式。\n * quasar-calendar-使用 Quasar 框架的 vue.js 日历，可实现每月，多天和议程视图。\n * vue2-datepicker-Vue2 的漂亮 datepicker / datetimepicker 组件\n * vue-pikaday- Pikadaydatepicker 的 VueJS 包装器组件\n * vue-tuicalendar- tui.calendar日历的 VueJS 包装器组件\n * vue-jqxscheduler-VueJS Scheduler 组件。\n * toast-ui.vue-calendar- [TOAST UI 日历]的 Vue 包装器(http://ui.toast.com/tui -日历)。\n * vue-functional-calendar-基于 Vue 的轻量级高性能日历组件(日期选择器，日期范围)。\n * vue-cal-Vue JS 完整日历，无依赖项，无 BS。🤘。\n * vue-draggableCal-不是普通的日期选择器。一个 Vuejs 可拖动的日期选择器，具有全新的响应式设计，可移动使用且具有 0 个依赖项，已压缩 17kb\n * vue-material-year-calendar-Vue2 的全年(每页 12 个月)日历。使用 dayjs。\n * vuelendar-用 VueJS 编写的简洁日历\n\n\n# 地图\n\n * vue2-google-maps-Google Maps 组件，用于带有 2 向数据绑定的 vue。\n * vue2-leaflet-传单地图的 Vue 2 组件。\n * vue-mapbox-gl-Mapbox GL JS 的 Vue 2.x 组件\n * vue-yandex-maps-Yandex Maps 的 Vue 2.x 组件\n * vue-baidu-map-百度地图的 Vue 2.x 组件。\n * vue-choropleth-Vue 2.x 组件，用于显示一个 Choropleth 贴图。\n * vuelayers-Vue 2 组件可与 OpenLayers 一起使用。\n * vue-googlemaps-Vue 2.x 组件，用于集成 Google Maps。\n * vue-static-map-Vue 2.x 简单组件，可生成静态 Google 地图\n * vue-mapbox-Mapbox GL JS 库周围的 Vue 2.x 包装器，提供了与地图交互的途径。\n\n\n# 音频视频\n\n * Vue-APlayer-：cake：用于 Vue 2.x 的易于配置的音乐播放器。\n * vue-audio-音频标签包装器；Vue 2.x 的声音播放器组件\n * vue-dplayer-基于 DPlayer 的 Vue 2.x 视频播放器组件。\n * vue-canvasvideo-一个 Vue 2.x 组件，用于在 iOS / Safari 上播放视频背景和自动播放视频。\n * vue-music-基于 html5``的 Vue 组件。\n * vue-audio-visual-Vue HTML5 音频可视化组件。\n * vue-plyr-一组用于 plyr 视频和音频播放器的 Vue 组件。\n * v-playback-一个 Vue2 插件，可简化视频播放。\n * vue-audio-recorder-Vue.js 的音频记录器。它允许在服务器上创建，播放，下载和存储记录\n * vue-video-section-Vue 的简单视频标头/部分组件。适用于视频背景并在其上叠加内容。\n\n\n# 无限滚动\n\n * vue-infinite-loading-适用于 Vue.js 1.0 和 Vue.js 2.0 的无限滚动插件。\n * vue-mugen-scroll-Vue.js 的无限滚动组件 2。\n * vue-infinite-scroll-vue.js 的无限滚动指令。\n * vue-loop-Vue.js 2 的无限内容循环组件。\n * vue-scroller-Vue.js 2 的无限内容循环组件，包括诸如“拉动刷新”，“无限加载”之类的功能，'snaping-scroll'。\n * vue-infinite-list-无限列表 mixin 可以为 Vue.js 2 回收 dom\n * vue-infinite-slide-bar-∞ 无限滑动条组件。\n * vue-virtual-infinite-scroll-基于 Iscroll 的 vue2 组件，支持具有高性能滚动，无限负载和拉动的大数据列表刷新。\n\n\n# 拉动刷新\n\n * vue-pull-refresh-拉动刷新 Vue.js 2.0 的组件。\n * vue-pull-to-下拉刷新和上拉为 Vue.js 组件加载了更多内容并无限滚动。\n * vue-data-loading-另一个用于无限滚动和向下/向上加载数据的组件。\n * vue-quick-loadmore-Vue 的下拉刷新和上拉无限滚动插件。\n\n\n# 降价\n\n * vue-markdown-适用于 Vue 的强大，高速 Markdown 解析器。\n * vue-mavonEditor-基于 Vue 的降价编辑器，支持多种个性化功能。\n * vue-simple-markdown-适用于 Vue 的简单，高速 Markdown 解析器。\n * vue-simplemde- simplemde的包装。不论是初学者还是专家，都可轻松编辑。具有内置的自动保存和拼写检查功能。\n * toast-ui.vue-editor- [TOAST UI 编辑器]的 Vue 包装器(http://ui.toast.com/tui -编辑)。\n\n\n# PDF\n\n * vue-pdf-基于 mozilla 的 PDF.js 的 pdf 查看器\n * pdfvuer-Vue 的 PDF 查看器，使用 Mozilla 的 PDF.js 和文本支持。演示\n\n\n# 树\n\n * Vue.D3.tree-基于[D3.js]的树状视图(https://d3js.org/)\n * vue-json-tree-view-Vue.js 的 JSON 树视图组件。\n * vue-tree-Vue.js 2.X 的树组件。\n * liquor-tree-惊人的 Vue 树组件\n * vue-trees-ui-基于 Vue 的 Tree Ui。\n * Bosket-前端框架(Vue，React，Angular 和 Riot)的树视图组件的集合。\n * plantain-00 / tree-component-一个 reactjs，angular 和 vuejs 树组件。\n * sl-vue-tree-适用于 Vue.js 的简单可定制的可拖动树组件\n * vue-draggable-nested-tree-适用于 Vuejs2 [@phphe](https://github.com的功能强大的可自定义可拖动树视图组件。 com / phphe)\n * vuejs-tree-高度可定制的 VueJs 树查看器\n * vue-jstree-适用于 Vue2 的树形插件，带有漂亮的图标和拖放功能\n * vue-vtree-Vue.js 的通用且灵活的树组件\n * vue-json-component-JSON 树视图，没有依赖项，TypeScript 支持且易于定制。\n * vue-tree-list-用于树形结构的 vue 组件\n\n\n# 社交分享\n\n * vue-social-sharing-一个 Vue.js 组件，用于共享指向社交网络的链接，可与 Vue.js 1.X 或 2.X 一起使用。\n * vue-goodshare-用于社交共享的 Vue.js 组件，具有精美的按钮设计。简单的安装，丰富的文档，开发人员支持，SEO 友好，干净的代码，无需脚本即可快速跟踪页面上的用户活动。使用 Vue.js2.x。\n * vue-socialmedia-share-一个 Vue.js 组件，用于使用 Vue 2.X 共享与社交网络的链接\n * vue-picture-sharesheet-一个 Vue 图片共享表组件，受到苹果新闻编辑室中图片共享表的启发\n * vue-twitter-用于嵌入 Twitter 小部件(例如时间线，按钮)的 Vue.js 组件\n * vue-share-buttons-Vue.js 组件，用于在您的项目中放置按钮，您可以共享任何东西\n\n＃＃ 二维码\n\n * vue-qriously-一个 Vue.js 2 组件，用于使用 qrious 在 HTML Canvas 上绘制 QR 代码。\n * vue-qart-vue 2.x 用于 qart.js 的指令。\n * vue-qrcode-reader-一个 Vue.js 2 组件，可从相机流中检测和解码 QR 码。\n\n\n# 搜索\n\n * vue-fuse-模糊搜索库 Fuse.js 的轻量级插件\n * vue-instantsearch-使用Algolia创建即时搜索体验的终极工具箱。\n * vue-innersearch-用于 Elasticsearch 的 Vue.js 包装器\n * reactivesearch-vue-用于使用 Elasticsearch 构建数据驱动的应用程序的 UI 组件\n\n\n# 其他\n\n * vue-avatar-vue.js 的头像组件。\n * vue-touch-ripple-Vue.js 的触摸波纹组件(1.x〜2.x)。\n * vue-typer-Vue 组件，用于模拟用户键入，选择和擦除文本。\n * vue-keyboard-Vue 2 虚拟键盘组件。\n * vue-twentytwenty-图像比较组件，可与 Vue.js 2.x 一起使用\n * vue-cookie-law-Vue.js 2.x 的 Cookie 信息插件\n * vue-gravatar-适用于 Vue.js 2.x 的简陋的 gravatar 组件\n * vue-clipboard2-一种易于使用的 Vue.js 2.x 剪贴板剪贴板绑定\n * vue-flashcard-带有 Vue.js 2.x 动画的 FLashcard 组件：bulb：\n * vue-truncate-collapsed-一个简单的组件，它会截断文本并为 Vue.js 2 添加可点击的“阅读更多/显示较少”。 X\n * vue-kanban-灵活的拖放式看板板组件\n * vue-letter-avatar-vue.js 的简单优雅的字母头像组件\n * vue-highlightjs-使用 highlight.js 突出显示语法\n * v-clipboard-简单，小巧且易于使用的指令将您的模型保存到剪贴板(最小 2kb，无依赖项)\n * vue-invisible-recaptcha-超级简单的 Google 隐形 reCAPTCHA 集成\n * vue-embed-Embed 组件基于 Vue 2.x 的 embed.js，该组件可嵌入表情符号，媒体，地图，tweet，要点，代码，服务和减价。\n * vue-particles-粒子背景的 Vue.js 组件\n * vue-uniq-ids-Vue.js 2.x 插件，可帮助使用与 ID 相关的属性，且无副作用\n * vue-multivue-在同一页面上使用同一类的多个 vue 应用。\n * vue-affix-一个 Vue.js 2.x 插件，可在滚动时在窗口中添加元素，类似于 Bootstrap Affix，但更简单，更智能\n * X-Browser-Update-Vue-一个 Vue.js 浏览器更新插件。\n * vue-query-builder-用于使用嵌套条件构建复杂查询的 UI 组件。\n * vue-info-card-一个简单漂亮的卡片组件，带有优美的火花线和 CSS3 翻转动画。\n * v-offline-简单，小巧且易于使用的 Vue 应用程序检测离线和在线事件(最小 390b)\n * vue-word-cloud-词云生成器。\n * vue-flat-surface-shader- Vue-flat-surface-shader\n * vue-easteregg-Easey 在您的 Vue 应用中添加了 Easteregg(默认使用 konami 代码)\n * vue-barcode-scanner\n * vue-heatmapjs-用于跟踪和可视化鼠标活动的 Vue 指令\n * vue-maze-由 Vue.js 组件制作的小巧迷宫游戏\n * vue-drag-verify-这是一个 vue 组件，可以滑动以解锁以进行登录或注册。\n * vue-balloon-Vue 组件，用于在页面一角创建固定的，可缩放的容器。与 gmail 中使用的邮件撰写包装类似。\n * vue-sticker-任意方向的贴纸效果\n * v-rating-⭐️ 使用 VueJS 制作的语义 UI 中的评级组件(<500B 压缩，速度非常快)\n * vue-content-placeholders-用于在 vue 中渲染诸如 Facebook 之类的伪造(渐进)内容的可组合组件\n * vue-page-designer-Vue 组件，用于拖放来设计和构建移动网站。\n * vue-creativecommons-CreativeCommons.org Vue.js 组件库。\n * vue-status-indicator-一个 Vue.js 组件，用于将状态指示器显示为彩色圆点。\n * vue-google-adsense-具有 InFeed 和 InArticle Ads 支持的 Vue.js Google Adsense 组件\n * emoji-vue-Vue.js 项目的 Emoji😎👌🏻 下拉菜单\n * vue-chessboard-棋盘 vue 组件可加载位置，创建位置并查看威胁。\n * vue-mindmap-用于 mindnode 映射的 Vue 组件。\n * v-currency-用于格式化货币的 Vue 组件。\n * vue-emoji-picker-高度可定制的 Unicode 表情符号选择器 🔥🚀\n * vue-8-puzzle-一个由 Vue.js 组件制作的小巧幻灯片益智游戏\n * vue-e164-具有 E.164 标准支持的可自定义电话格式化程序\n * vue-pgn-Vue.js 组件，用于以 pgn 格式查看棋牌游戏\n * vue-avatar-editor-使用清晰的用户界面调整大小，旋转并裁剪上传的头像。\n * vue-connection-listener-Vue 事件总线插件监听在线/离线更改。\n * vue-sauce-Vue 的“查看源代码”指令。\n * vue-prom-Vue 承诺包装器组件。\n * 数字键盘-用于移动浏览器的数字键盘。\n * vue-zoom-on-hover-鼠标悬停时图像缩放\n * vue-sensitive-image-Vue 组件，可让您快速创建具有最佳数量的所有设备图像源的响应式图像标签。\n * vue-highlight-text-Vue 组件，用于突出显示单词的多个实例\n * vue-cast-props-提供了一种将 props 转换为常见数据类型的便捷方法。\n * vue2-heropatterns-一个 Vue2 实现，允许您将流行的 Hero Patterns 添加到任何 Div 上\n * vue-link-一个将所有链接都链接在一起的组件(处理外部和内部链接相同)\n * vue-identify-network-⚡️ 识别您的用户正在使用哪种互联网！\n * vue-cloneya-用于克隆 DOM 元素的 vue 组件\n * vue-survey-builder-vue.js 应用程序的调查生成器\n * vue-if-bot-一个轻量级的组件，用于基于用户代理向客户端隐藏/显示内容\n * vue-clampy-Vue.js(2+)指令，通过在其中包含内容的元素加上省略号来限制元素的内容太长。\n * vue-cookie-accept-decline-在页面上显示带有文字，拒绝按钮和接受按钮的横幅。记住使用 cookie 进行选择。使用创建时的当前选择来发出事件。符合 GDPR 要求。\n * @ lossendae / vue-avatar-VueJS 2.0 的头像组件。\n * vue-text-highlight-Vue.js 的文本荧光笔库 💄\n * vue2-hammerVue 2.x 的 Hammer.js 包装器支持移动触摸。\n * vue-countable-countable.js 的 Vue 绑定。提供实时的段落，句子，单词和字符计数。\n * v-show-slide-一个 Vue.js 指令，用于将元素上下移动动画：自动滑动。\n * vue-swipe-actions-适用于 Vue.js 的 iOS 样式滑动操作\n * vue-friendly-iframe-用于创建超快速加载，无阻塞 iframe 的 Vue js 组件。\n * vue-beautiful-chat-一个简单而美丽的 Vue 聊天组件后端不可知，完全可自定义和可扩展。\n * vue-magnifier-Vue.js 2.x 的简单图像缩放/放大组件。\n * vue-highlight-words-Vue 组件可在较大的文本正文中突出显示单词。从[react-highlight-words]移植(https://github.com/bvaughn/react-highlight-words)\n * vue-tags-ball-使用此插件创建漂亮的球形标签\n * vue-rippler-用于自定义波纹效果的简单 Vue.js 插件\n * vue-contacts-Vue 的移动通讯录组件\n * basic-vue-chat-易于使用的 Vue.js 聊天\n * vue-resize-text-一个 vue 指令，可根据元素宽度自动调整字体大小。\n * vue-github-profile-一个 Vue 组件，用于查看确定的用户的配置文件和存储库\n * vue-niege-🎅 单文件 Vue 组件可通过画布添加暴风雪。\n * vue-dynamic-star-rating-高度动态的 Vue 明星评分组件，例如 Google Play 评分 ⭐️⭐️⭐️⭐️⭐️⭐️\n * vue-katex-在 Vue.js 中使用 KaTeX 进行数学排版的简单插件\n * vue-canvas-identify- [vuc-identify]的 Vue 画布组件(http://vuc.tianchenyong.top)\n * vue-canvas-material- [vuc-material]的 Vue 画布组件(http://vuc.tianchenyong.top/#/materia)\n * vue-baberrage-一个基于 Vue.js 的简单弹幕插件 😎\n * vue-terminal-ui-🖥TerminalUI 模拟器 Vue：自定义和基本命令\n * vue-command-完全正常工作的 Vue.js 终端模拟器\n * vue-ribbon-GitHub 功能区的 Vue 组件\n * avatio-avatar-插图化身的 Vue 组件- Avatio使用\n * vue-jazzicon-用于 Vue 的简陋的 Jazzicon 组件。\n * vue-star-rating-一个简单的，高度可定制的星级评分组件 ⭐️⭐️⭐️\n * vue-fixed-header-简单且跨浏览器友好的由 TypeScript 编写的 Vue.js 固定标头组件。\n * vue-particle-effect-buttons一个爆发粒子效果按钮组件。\n * vue-insomnia-防止显示屏进入休眠状态(唤醒锁定)。\n * vue-car-plate-keyboard-用于 VueJS 2.x 的汽车牌照号码键盘。能源车牌 🚗🚗🚗)\n * vue-dataflow-editor-Vue2 数据流图编辑器\n * cool-emoji-picker-Vue 的快速即插即用[Tw] emoji Picker(用于 Twemoji 渲染的+ textarea)组件。\n\n\n# 标签\n\n * vue-tabs-简单的标签和药丸。\n * vue-swipe-tabs-vue.js(vue2)的触摸滑动选项卡组件。\n * vue-tabs-component-一种使用 Vue 显示标签的简便方法。\n * vue-k-tabs-具有 Gitlab 设计的简单标签组件。\n * vue-tabs-with-active-line-简单的 Vue 2 组件，可让您制作带有移动底线的标签\n * vue-tabs-chrome-一个类似于 Chrome 的标签的 Vue 组件。\n\n\n# 电话号码输入格式器\n\n * vue-phone-number-input-一个漂亮的输入，用于格式化与国家/地区代码有效的电话号码：fire：\n\n\n# 选择器\n\n * vue-smooth-picker-Vue 2.x 的平滑选择器组件，例如 iOS 本机日期时间选择器。\n\n\n# 发电机\n\n * FormSchema Native-使用 JSON Schema 和 Vue.js 生成表单\n * vue-awesome-form-一个 vue.js 组件，就像 json-editor\n * vue-generator-Vue 项目的初始路由器和组件。\n * vue-form-json-从 json 生成具有验证和 bulma 样式的 vue 表单\n * form-create-具有动态呈现，数据收集，验证和提交功能的表单生成器，支持 json 数据\n * element-form-builder-使用 JSON 模式构建 element-ui 表单。\n * ncform-一种非常好的配置生成表单的方式\n * Laraform-具有 Laravel 支持的 Vue.js 的高级表单生成器\n * vue-ele-form-Vue DataForm，基于 element-ui\n\n\n# 日期选择器\n\n * vue-datepicker- [未维护]具有用于 Vue.js 的材质设计的日历和 datepicker 组件。\n * vue2-timepicker- [未维护] Vue 2.x 的下拉时间选择器(小时|分钟|秒)，具有灵活的时间格式支持。\n * vuejs-datepicker-一个简单的 Vue.js datepicker 组件。支持禁用日期，内联模式，翻译。\n * vuedt- [未维护]疯狂的轻量级(5.5kb！)Vuejs 日期和时间选择器组件，动画效果很好，而且没有太多的模糊感。\n * vue-flatpickr-component用于flatpickr日期时间选择器的 Vue.js 组件\n * vue-bootstrap-datetimepickerVue.js 组件，用于[eonasdan-bootstrap-datetimepicker](https://github.com/Eonasdan/bootstrap- datetimepicker /)\n * vue-jalaali-datepicker-vue.js 的 Jalaali 日历和日期选择器 2。\n * vue-date-picker-一个受材料设计启发的 vue 日期选择器组件\n * vue-monthly-picker-仅适用于月份和年份选择器的 Vue.js 组件\n * vue-hotel-datepicker-响应式日期范围选择器，显示选定的住宿天数，允许自定义入住/退房规则，屏蔽日期，本地化支持等。\n * vue2-persian-datepicker-vue 的真棒波斯 datepicker 组件。کامپوننتانتخابتاریخبرایویو。\n * vue-datetime-Vue 的移动友好日期时间选择器。支持日期，日期时间和时间模式，i18n 和禁用日期。\n * vue-rangedate-picker-具有简单用法的范围日期选择器\n * v2-datepicker-基于 Vue 2.x 的简单 datepicker 组件。\n * vue-datepicker-local-Vue2 的一个漂亮的 Datepicker 组件。\n * vue-airbnb-style-datepicker-Vue datepicker，外观和功能与流行的 AirBnb datepicker 相似。轻巧，可配置且良好的浏览器支持！\n * vue-persian-datetime-picker波斯材料 datepicker。支持日期时间，日期，时间，年，月。\n * VCalendar非常可定制且功能强大的日历/日期选择器组件，具有许多功能和完善的文档。\n * @ owumaro / vue-date-range-picker-使用 Bootstrap 4 样式进行日期范围选择的 Vue 组件\n * vue-datepicker-mobile-适用于 vue2 的移动友好日期选择器。：cn：选择日期或日期范围，然后自定义所需的日期。\n * vue-draggable-cal-不是普通的日期选择器。一个 Vuejs 可拖动的日期选择器，具有全新的响应式设计，可移动且具有 0 个依赖项，已压缩 17kb。\n * vue-vanilla-datetime-picker-Vue 的日期时间选择器。\n * vue2-daterange-picker-基于 bootstrap-daterangepicker 的 Vue2 日期范围选择器(无 jQuery 依赖性)\n * vue-timeselector-完全简单可定制的 Vue.js 功能强大的时间选择器组件。\n * vue-date-picker-Vue 2.x 的轻量级 datepicker 组件。\n * vue-ctk-date-time-picker-一个漂亮的 VueJS 组件，用于选择日期和时间(使用范围模式)：新：\n * simple-vue2-datetimepicker-一个简单易用的 vue.js 组件，用于日期和时间选择。：新：\n * vue-business-hours-Vue 组件，用于在管理面板或仪表板中选择营业时间。\n * material-vue-daterange-picker-Vuejs 2.x 的 Material Design 样式的日期范围选择器，与 vuetify 和友好版本兼容手机。\n * vue-datepicker-具有 Vuejs 2.x 的 Material Design 样式的干净响应式日期选择器。(日期/月/季度&&日期范围选择器)：新：\n\n\n# 选择\n\n * vue-select-一个本地 Vue.js 组件，提供与 Select2 类似的功能，而无需 jQuery 的开销。\n * vue-multiselect-Vue.js 的通用选择/多重选择/标记组件。\n * stf-vue-select-最灵活和自定义的选择 Vue2\n * vue-select-image-Vue 2 组件，用于从列表中选择图像\n * @ riophae / vue-treeselect-具有对 Vue.js 的嵌套选项支持的多选组件。\n * @ k186 / pd-select-一个移动 UI 组件，例如 Vue 2.x 的 IOS 选择器，可以随便定义。\n * vue-dropdowns-如果对 vue2.x 使用对象，则是一种显示选择框的简约且可适应的方法\n * v-cascade-带有 Vue 2.x 的层叠选择器的一个可爱组件(支持 PC 和 Mobile)\n * vue-multi-select-用于对 Vue2 进行选择/多重选择的自定义组件。\n * v-region-一个简单的区域选择器，提供中文行政区划数据。\n * v-selectpage-Vue2，分页列表或表格视图的强大选择器，使用标签进行多项选择，i18n 和服务器端资源支持。\n * vue-cool-select-引导程序/材质设计主题，支持广告位，自动填充，事件，验证等。\n * @ myena / advanced-select-具有搜索功能，用于(取消)全选和 Bootstrap 3 主题的单/多选择组件\n * @ alfsnd / vue-bootstrap-select-Vue 版本的bootstrap-select。\n\n\n# 滑块\n\n * vue-slider-component-vue1.x 和 vue2.x 的滑块。\n * vue-circle-slider-vue2.x 的圆形滑块组件。\n * vue-netflix-slider-像 Netflix 的滑块。\n * vue-slide-bar-非常简单的 vue 滑条组件。\n * textra-Vue js 插件可滑动文本。\n * vue-knob-control-Vue.js 的旋钮控件\n\n\n# 拖放\n\n * vuedraggable-Vue 组件允许与 View-Model 同步进行拖放排序。基于 Sortable.js。\n * vue-dragula-拖放是如此简单，很痛苦。\n * vue2-dragula-Vue2 的vue-dragula分支，有很多改进。\n * awe-dnd-具有 Vue 的可排序列表指令。\n * vue-draggable-resizable-用于可拖动和可调整大小元素的 Vue2 组件。\n * vddl-用于使用 HTML5 拖放 API 修改列表的 Vue 组件，支持 VueJs 版本 1 和 2。\n * vue-drag-drop-HTML5 拖放 API 的最小且轻巧的包装器。\n * vue-swing-可滑动的卡片界面，如在 Jelly 和 Tinder 等应用中所见。\n * vue-slicksort-一套无需依赖的混合包，用于动画，触摸友好，可排序的列表\n * draggable-vue-directive-处理任何 Vue 组件拖放的简单指令。\n * vue-smooth-dnd-smooth-dnd 库的 Vue 包装器。拖放，可分类的库，适用于许多情况。\n * vue-drag-resize-一个无依赖的 Vue 组件，用于可拖动和可调整大小的元素，具有高宽比，反应性道具等\n * vue-drag-it-dude-Vue2 组件，可让您将对象拖动到任意位置。\n * vue-draggable-Vue 拖放库没有任何依赖性。简单易用。\n * vue-nestable-作为 vue 组件制作的简单拖放层次列表。\n * vue-draggable-nested-tree-适用于 Vuejs2 [@phphe](https://github.com的功能强大的可自定义可拖动树视图组件。 com / phphe)\n\n\n# 自动完成\n\n * vue-instant-Vue 即时可让您轻松为 vue 2 应用程序创建带有自动建议的自定义搜索控件。\n * v-autocomplete-Vue.js 的自动填充组件\n * vue-awesomplete-Awesomplete 的 Vue 包装器\n * vue-auto-complete-Vue2 的自动完成。适用于对象或 api 调用。\n * vue-autosuggest-WAI-ARIA 完整的 Autosuggest 组件，对渲染和样式进行了完全自定义。\n * v-autosuggest-一个简单的模块化 Vuejs 组件，可以自动建议来自动态或静态数据查询的输入。\n * 自动完成-适用于 Vue.js 2. *的简单自动完成组件\n * vue-infinite-autocomplete-Vue 的 Vue 无限-自动完成包装 2。\n * vue-simple-suggest-Vue.js 的简单但功能丰富的自动完成组件\n * v-suggest-一个 Vue2 插件，用于输入内容建议，支持键盘快速选择。\n * vue-bootstrap-typeahead-使用 Bootstrap 4 CSS 的 Vue2 的 typeahead / autocomplete 组件。\n\n\n# 类型选择\n\n * vue-input-tag-Vue.js 2.0 输入标签组件。\n * v-distpicker一个灵活，高度可用的区域选择器，用于为 Vue.js 2.x 挑选中国的省，市和地区。\n * vue-img-inputerVue 2 的优美，高度可定制的 img 类型输入\n * vue-img-previewvue 2 中的图像输入预览组件\n * v-image：相机：用于输入 type = file 的小组件(<1kb，已压缩)\n * @ voerro / vue-tagsinput一个简单的标签输入了带有 typeahead / autocomplete 的 Vue.js 2 组件\n * vue-tag-selector-类似于标签的输入。轻巧，可自定义并处理 REGEX 验证！\n\n\n# 颜色选择器\n\n * vue-color-适用于 Sketch，Photoshop，Chrome 等的 Vue 拾色器。\n * vue-swatches-帮助用户选择漂亮的颜色！\n * radial-color-picker-简约的拾色器，着重于尺寸，可访问性和性能。\n * vue-color-picker-board-为人类设计的 Vue 拾色器组件！\n * verte-一个完整的 Vue.js 颜色选择器组件。\n\n\n# 开关\n\n * vue-switches-具有主题支持的 Vue.js 的开/关开关组件。\n * vue-js-toggle-button-Vue.js 2.0+切换/切换按钮-简单，漂亮，可自定义。\n * vue-checkbox-radio-一个 Vue 组件，可轻松设置复选框和广播输入的样式。\n * vue-enhanced-check-用于重新设计/标记复选框/无线电的 Vue 组件，包括切换/切换按钮。\n * pretty-checkbox-vue- [pretty-checkbox 3]的实现(https://lokesh-coder.github.io/pretty- checkbox /)(用于美化复选框和单选按钮的纯 CSS 库)组件，适用于 Vue.js 2.2+。\n * vue2-collapse-Vue Collapse 是一个灵活的内容切换插件，用于手风琴列表或任何其他有条件的内容呈现。\n * vue-badger-accordion-用于 Vue.js 2.0+的 Badger 手风琴的包装组件\n * vue-loading-checkbox-具有加载状态的高度可定制的 Vue.js 复选框 UI 组件\n * vue-rocker-switch-Vue.js 的可自定义翘板开关组件。\n * vue-toggle-btn-高度可定制，易于使用的优雅切换/切换按钮组件\n\n\n# 屏蔽输入\n\n * vue-masked-input-Vue.js 的蒙版输入组件。\n * vue-text-mask-用于 React，Angular，Ember，Vue 和普通 JavaScript 的输入掩码。\n * vue-ip-input-由 vuejs 实现的 ip 输入。\n * vue-numeric-输入字段组件，用于显示基于 Vue 的货币值。\n * awesome-mask-基于纯 VanillaJS 实现的 Mask 指令\n * v-money-货币的微小(<2k 压缩)输入/指令掩码\n * vue-autonumeric-一个 Vue.js 组件，包装了很棒的AutoNumeric输入格式化程序库\n * vue-inputmask-Vue.js 指令可将 Robin Herbots 的 inputmask 库添加到您的输入中(香草 javascript)。\n * vue-input-number-Vue.js 2 的自定义输入数字组件。\n * v-unicode-Vue 指令通过 unicode 值限制输入。\n * vue-cleave-component- [cleave.js]的 Vue.js 组件(http://nosir.github.io/cleave.js /)\n * vue-ip-具有端口和材料设计支持的 ip 地址输入\n * vue-r-mask-具有类似于 javascript 正则表达式的模板的指令。\n * vue-input-code-基于 Vue.js 2.0+验证码输入组件。\n * label-edit-受 Trello 的启发。单击以显示可编辑的输入并返回值更改。这是 Vue 组件。\n * vue-jquery-mask- [jQuery Mask 插件]的 Vue.js v2.x 组件(https://github.com/igorescobar/ jQuery-掩码-插件)\n * vue-the-mask-Tiny(<2k gzipipped)和 Vue.js 的无依赖掩码输入\n * vue-canvas-input- [vuc-input]的 Vue 画布组件(http://vuc.tianchenyong.top/#/identify)\n * vue-currency-input-轻松输入 Vue.js 的货币格式数字。\n * vue-restricted-input-基于[restricted-input]的 vue.js 输入掩码库(https://github.com/braintree /受限输入)\n\n\n# RTF 编辑\n\n * vue-quill-editor-Vue2 的鹅毛笔编辑器组件。\n * vue-mobiledoc-editor-适用于 Vuejs 的 mobiledoc 编辑器组件工具包。\n * vue2-medium-editor-Vue 2 的 MediumEditor 组件。\n * vue-froala-用于 Froala 编辑器的 VueJS 包装器。\n * vue-froala-wysiwyg-Froala WYSIWIG HTML 编辑器的官方 VueJS 插件。\n * vue-at-Vue 的 At.js。\n * vue-wysiwyg轻巧，快速且可扩展的所见即所得编辑器\n * vue-trumbowyg[Trumbowyg]的 Vue.js 组件(http://alex-d.github.io/Trumbowyg/)所见即所得编辑器\n * vue-pell-editor用于Pell的 Vue.js 组件所见即所得编辑器\n * vue-tinymce-editorVue2 的 Tinymce 编辑器组件。\n * vue-mce-VueJS 的 tinymce 编辑器组件。\n * Vue2-Editor-使用 Vue.js 和 Quilljs 的 HTML 编辑器\n * vue-codemirror-Vue2 的 Codemirror 组件。\n * vue-easy-tinymce-一个简单而强大的软件包，可在 Vue.js 项目中轻松使用 tinymce。\n * vue-highlightable-input-输入文字时突出显示和设置样式\n * vue-trix-用于 Vue.js 的简单轻巧的 Trix 富文本编辑器\n * tiptap-Vue.js 的不可渲染且可扩展的 RTF 编辑器\n * toast-ui.vue-editor- [TOAST UI 编辑器]的 Vue 包装器(http://ui.toast.com/tui -编辑)。\n * ckeditor5-vue-Vue.js 的官方 CKEditor 5 Rich Text 编辑器组件。\n * yimo-vue-editor-Vue2 的 wangEditor2 组件。\n * vue-mathlive适用于 Vue.hjs 的 MathLive 数学编辑器(mathfield)\n\n\n# 图像处理\n\n * vue-core-image-upload-一个用于裁剪和上传图像的 vue 插件。\n\n * vue-croppa-适用于 Vue 2.0 的简单易用的可自定义轻量级移动友好图像裁剪器。\n\n * vue-cropper-vue2.0 的图片剪辑插件\n\n * toast-ui.vue-image-editor- [TOAST UI 图像编辑器]的 Vue 包装器(http：// ui。 toast.com/tui-image-editor)。\n\n * vue-quick-cropper-Vue 移动头像上传裁剪插件可以选择裁剪区域和缩放。\n\n * vue-canvas-image-Vue 画布组件，用于vuc-image\n\n * vue-croppie-另一个图像裁剪器\n\n * vue-slim-cropper-💇Vue 2.x 的简单优雅的移动图像裁剪上传组件。\n\n * vue-advanced-cropper-先进的裁剪器，使您有机会创建几乎任何想要的裁剪器\n\n * vue-cloudinary-vue(2.0)插件提供了可重用的指令，可通过动态操作从 Cloudinary(https://cloudinary.com)获取图像(调整大小/裁剪/效果/水印/缩放/格式化)和优化(webp / png /自动质量/自动视网膜)。\n\n * img-Vuer-Vue2 的 Mobile-First 图像查看器/图库\n\n * vue-image-loader-Vue 加载器/渐进式图像插件，例如 Medium。\n\n * vue-load-image-在图像加载期间显示加载器，并在图像加载失败时显示替代内容。\n\n * vue-image-painter-V Vue 2.x 的图像魔术动画绘制效果组件。\n\n\n# 视频操作\n\n * vue-playlist-轻量级的 vue(2.0)组件，没有依赖关系，可提供真正无缝的 html5 视频播放。使用 Vanilla JS 进行无缝视频播放的唯一且唯一可行的解 决方案。它需要一系列视频并将它们拼接在一起成为一个视频。\n\n＃＃ 上传文件\n\n * vue-clip-用于 VueJ 的简单且可入侵的文件上传器。支持 Vue> = 2.1。\n * vue-simple-upload-Vue.js 的简单文件上传组件。\n * vue2-multi-uploader-使用 Vue.js v2 和 Axios 的拖放式多文件上传器组件。上载器显示文件名，大小和添加文件的总大小。它还允许设置所需的最小文件上传数量。\n * vue-dropzone-Dropzone.js 的 Vue.js(vue2)组件-具有图像预览功能的拖放文件上传实用程序。\n * vue-transmit-一个纯粹的基于 Vue 2.0 的 Dropzone.js 的 Vue.js 拖放上传器组件\n * vue-upload-component-Vue 上载组件，多文件上载，上载目录，拖动上载，拖动目录。支持 Vue> = 2.0\n * vue-uploader-一个由 simple-uploader.js 驱动的 Vue.js 上传组件\n * ic-firebase-uploader-用于 Firebase 存储的干净的多文件上传组件。\n * vuejs-uploader-用于大型文件上传的可恢复的分段文件上传器。\n * vue-filepond-FilePond 的 Vue.js 组件-文件上传库，可以上传您扔给它的任何内容。\n * v-uploader-一个 Vue2 插件，可以使上传文件变得更加轻松简单，您可以拖动文件或在对话框中选择文件进行上传\n\n\n# 上下文菜单\n\n * vue-context-menu-vue js 的上下文菜单组件。\n * vue-lil-context-menu-Vue 的灵活的 lil 上下文菜单组件。\n * vue-mouse-menu-适用于 vue 2+的鼠标菜单组件。\n * @ hscmap / vue-menu-vue2 的菜单/上下文菜单组件。\n * vue-context-用于 vue js 的简单但灵活的上下文菜单。\n * vue-simple-context-menu-为 Vue 构建的简单上下文菜单组件。左键单击和右键单击都可以很好地工作。\n * vue-context-menu-popup-Vue 2 的上下文菜单弹出窗口。右键单击即可工作，也可以通过编程方式触发。\n * @ kiyoaki_w / vue-context-为 Vue2 构建的可自定义上下文菜单组件，支持惊人的图标。\n\n\n# 其他\n\n * vue-gmaps-使用 Google Maps API 搜索地点和地址。\n * vuep-使用实时编辑器和预览渲染 Vue 组件的组件。\n * vue-places-Places 组件基于 Vue 2.x 的 places.js。将任何输入转换为地址自动完成。\n * vue-password-strength-meter-vue.js 中基于 zxcvbn 的密码强度计。\n * vue-float-label-Vue.js 的浮动标签模式。\n * vue-longpress-一个 VueJS(2.x)按钮组件，需要您持续按下以确认给定的动作。\n * vue-google-autocomplete-适用于 Google Maps Places API 的 Vue.js(2.x)自动建议组件。\n * vue-ip-input-Vue.js 2.x 的 ip 输入组件\n * vue-default-value-Vue.js 2.x 指令为可编辑元素设置默认值，而不会影响模型状态\n * vue-model-autoset-一个 Vue.js 插件，可解决通过 v-model 指令观察动态添加的属性时 Vue 的限制\n * vue-submit-Ladda 的简单实现([1](http://lab.hakim.se /ladda/)，2)不到 90 行代码，没有任何依赖关系。\n * vue-rate-Vue 的费率组件\n * vuetify-google-autocomplete-适用于 Google Maps Places API 的 Vuetify 就绪 Vue.js(2.x)自动建议组件。\n * vue-ripple-directive-材质纹波效果作为 Vue 指令。\n * vue-fab-Vue 浮动操作按钮。\n * vue-complexify-来自 jquery.complexify.js 的 Vuejs 移植库。\n * vue-mc-Vue.js 的模型和集合\n * vue-stars-高度可定制的等级控制(使用星号或其他字符)\n * vue-confirmation-button-可自定义的确认按钮，要求用户在执行操作之前先阅读消息\n * vue-poll-用于投票的 Vue.js 组件\n * vue-diagrams-vue.js 的图表组件，受 react-diagrams 启发\n * vue-easy-polls-一个 Vue.js 组件，用于创建民意调查，投票和显示结果。它易于实现且易于定制。\n * vue-m-button-vue 的漂亮按钮组件。\n * vue-long-click-用于 vue 的长按(长按)指令库，支持移动设备和台式机。\n * vue-ui-predicate-规则编辑器，通用过滤 UI，Vue JS 的谓词组件。\n * vue-mobile-detection-Vue.js 原型函数this。$ isMobile()会根据布尔值是否返回布尔值用户正在使用手机浏览。\n * vue-input-contenteditable-用于`contenteditable'的 Vue 组件包装，具有您通常期望的所有功能。进行漂亮的输入，不受“ input [type ='text']”的限制。\n\n\n# 向导\n\n * vue-form-wizard-基于选项卡的组件，可以代替经典的 bootstrap 和 jQuery 表单向导\n * vue-stepper-一个简单的步进器，具有诸如 next，back 和 end 之类的简单动作，可以执行简单的表单。\n * vue-stepper-component-具有 Vuex 支持和零依赖性的完全可定制的 Stepper 组件。\n\n\n# CSV\n\n * vuecsv-来自 json 的简单 CSV 下载程序，带有选项模式面板组件。\n\n\n# 评论系统\n\n * vue-comment-grid-💬 使用 CSS Grid 和 Firebase REST API + Authentication 构建的自适应 Vue.js 注释系统插件。\n\n\n# 帆布\n\n * vue-easeljs-对 HTML5 canvas 元素的数据驱动控制。\n * vue-canvas-effect-Vue.js 的简单画布效果集合。\n * vue-konva-Vue＆Canvas-JavaScript 库，用于使用 Vue 绘制复杂的画布图形。\n * vue-html2canvas-Vue mixin 捕获 html 并使用 Html2Canvas 将其转换为图像。\n * vue-canvas-nest-适用于 canvas-nest 的 Vue.js 组件。\n * vue-signature-pad-V Vue 签名板组件\n\n\n# 链接预览\n\n * link-prevue-用于生成链接预览的灵活组件。\n\n\n# 游览\n\n * vue-tour-轻巧且可自定义的游览插件\n * vue-page-guide-具有指令的页面游览/指南插件\n\n\n# UI 布局\n\n * vue-waterfall-Vue.js 的瀑布布局组件。\n * vueisotope-用于同位素过滤器和分类魔术布局的 Vue 组件。\n * vue-grid-layout-Vue.js 的可拖动和可调整大小的网格布局。\n * vue-drag-zone-Vue.js(2.x)的拖动区域组件。\n * vue-masonry-用于砌体块布局的 Vue.js 指令。\n * vue-fraction-grid-基于 Flexbox 的 Vue.js 响应式分数网格系统。\n * vue-virtual-scroll-list-Vue(2.x)组件通过使用虚拟滚动列表支持大数据。\n * vue-virtual-scroller-用于有效滚动大量元素的组件(Vue 2.x)。\n * vue-virtualscroll- [Vue 2.x]组件用于虚拟滚动内容。\n * vue-inview- [Vue 2.x]视口，在输入或离开 DOM 元素时获取通知。\n * dnd-grid-具有可拖动和可调整大小的框的 vuejs 网格\n * vue-extend-layout-扩展默认布局或为 Vue.js SPA 的页面创建自定义布局\n * vue-masonry-css-由 CSS 驱动的 Vue.js Masonry 布局组件，无依赖\n * vue-fullpage.js-Vue.js 的官方 fullPage.js 组件。\n * vue-virtual-collection-用于有效渲染大型集合数据的 Vue 组件。\n * 自动响应-vue-Vue 的自动响应网格布局库。\n * VueFlex-一个 flexbox 网格系统。\n * v-chacheli-一个 Vue.js 组件，用于创建和显示类似于仪表板的自定义网格布局。\n * vue-grid-styled-一组轻量级的功能网格组件，从 React 的grid-styled / jxnblk /网格样式/)\n * 简单网格-用于网格布局的 Vue 组件，支持 flex。\n * vue-container-component-受 Bootstrap 容器启发的简单容器组件\n * vue-colcade-用于将 Colcade 网格布局集成到 Vuejs 的小包装。\n * vue-ads-layout-一个小的 Vue 组件库，可快速生成带有工具栏，左/右抽屉和页脚的响应式 Web 应用程序布局。所有组件都可以固定或相对放置。\n * vue-magic-grid-Vue.js 2 的 Magic Grid 小端口。\n * vue-splitter-pane-一个 Vuejs 组件，它以可调节的拆分方式(垂直或水平)呈现两个插槽。\n * splitpanes-一个 Vue JS 可靠，简单且可触摸的窗格拆分器/缩放器。\n * vue-mock-layout-轻松模拟 Vue 应用程序的布局。\n * vue-simple-drawer-带有反弹动画，支持嵌套和自定义主题的小抽屉面板。方向：左/右/上/下\n * vue-grd-用于网格布局的简单，轻巧和灵活的 Vue.js 组件。\n\n\n# 自适应\n\n * quasar-framework-类星体框架。使用 VueJs 2 使用相同的代码构建响应式网站，混合移动应用程序(在 Android 和 iOS 上看起来本机)和 Electron 应用程序。\n * vue-material-Vue.js 的材料设计。\n * vuetify-Vue.js 的材料组件框架 2。\n * muse-ui-Vue.js 的材料组件库 2。\n * buefy-基于布尔玛框架的组件。\n * element-ui-用于 Web 的 Vue.js 2.0 UI 工具包。\n * vue-bulma-components-对 vue 组件轻松使用 bulma 类语法。\n * iview-ui-适用于 Web 的 Vue.js 2.0 UI 框架。\n * AT-UI-Vue.js 2.0 使用 ♥ 制作的专门用于桌面应用程序的全新扁平 UI-Kit\n * v-semantic-Vue 的semantic-ui的实现\n * bootstrap-vue-Vue.js 2 的bootstrap-4网格和组件的实现。\n * fish-ui-用于 Web 的 Vue.js 2.0 UI 工具包\n * zircle-ui-开发可缩放用户界面的前端库。\n * vue-mdc-adapter-根据 MDC 团队[指南]的 Vue.js 的材料组件集成(https://github.com/material -components / material-components-web / blob / master / docs / integrating-into-frameworks.md)。\n * Material Components Vue- [material-components-web]的包装器(https://github.com/material-components/material-components-网络)的 Vue.js\n * VueFace-用于 Web 的 Vue.js 2.0 UI 组件库\n * vuesax-Vue.js 的前端 vue 组件。\n * vuecidity-Vue.js 2.0 的 UI 组件框架\n * ant-design-vue-基于 Ant Design 和 Vue 2.5.0 的企业级 UI 组件\n * heyui-(https://www.heyui.top/zh)-适用于 Web 的 Vue.js 2.0 UI 工具包。\n * Carvue.js-IBM 的 Vue.js 碳设计系统\n * BalmUI-Vue.js 的下一代 Material UI\n * Osiris UI-：art：一个 Vue.js 2.0 通用响应式 UI 组件库\n * N3-components-使用 Vue 2 构建的漂亮 Web 组件\n * 碎片 Vue-✨ 基于 Bootstrap 4 框架的时尚＆UI 组件库。\n * 基础 Vue-基于 SAP Fiori 基础的组件。\n * Framevuerk-🚀 快速，响应迅速，无依赖性，基于 Vue.js 的方向支持和可配置 UI 框架。\n * @ Carbon / vue-@carbon 团队的 Carbon Design System 组件。\n * NutUI-适用于移动网络的 Vue.js 2.0 UI 工具包\n * Inkline-Inkline 是用于 Vue.js 的现代 UI / UX 框架，旨在创建完美的响应式 Web 应用程序。\n * vue-awesome-mui-用于 Web 的 Vue.js 2.0 MUI 组件\n * MDBootstrap-基于最新的 Bootstrap 4 和 Vue 2.6.10 的强大 UI 工具包，提供了一组平滑的，响应式页面模板，布局，组件和小部件，以快速构建响应迅速，移动优先的网站和应用。\n\n\n# 手机\n\n * Framework7-Vue-使用 Framework7＆Vue 构建功能齐全的 iOS 和 Android 应用。\n\n * vux- [中文]基于 WeUI 的 Vue UI 组件。\n\n * vue-onsenui-使用 HTML5 和 JavaScript 的移动应用开发框架和 SDK。创建美观，高性能的跨平台移动应用程序。基于 Web 组件，并提供 Angular 1、2，React 和 Vue.js 的绑定。\n\n * Weex-Weex 提供了发布跨平台的功能，因此 Web，Android 和 IOS 应用程序可以使用相同的 API 开发功能。\n\n * weex-eros- [中文] Eros 是基于 Weex 和 Vue 的应用程序解决方案，使您能够使用 Vue 的 API，简单快速地开发 Vue 中小型应用程序。\n\n * mint-ui-Vue.js 的移动 UI 元素。\n\n * vant-来自 YouZan 的 Vue.js 2.0 移动用户界面。\n\n * cube-ui-Vue.js 编写的出色的移动 ui lib 实现 2。\n\n * mand-mobile-基于 Vue.js 2 的移动 UI 工具包，专为金融场景而设计。\n\n\n# 组件集合\n\n * vue-mdc-Vue.js 的 Material Components Web。\n * keen-ui-用 Vue 编写并受 Material Design 启发的基本 UI 组件的轻量级集合。\n * vue-admin-Vue 管理面板框架，由 Vue 2.0 和 Bulma 0.3 提供支持。\n * vuikit-具有 Vue 所有功能的 UIkit。\n * uiv由 Vue2 实现的 Bootstrap3 组件。\n * wffranco / vue-strap-使用 Vue.js 2 构建的 Bootstrap 3 组件\n * jsmod-vue-pc-适用于 vue 2.0 的高度可扩展的 Web 组件\n * guilhermewaess / SemVue-使用 Vue 2 实现的语义 UI 模块\n * office-ui-fabric-vue-Vue.js 的 Office UI Fabric 实现\n * vuestic-admin-带有自定义组件集合的 Vue Admin 仪表板。内置 Vue 2 和 Bootstrap 4\n * 语义 UI Vue-Vue 的语义 UI 集成\n * vuesax-Vue.js 的前端 vue 组件。\n * Vue 的基本 JS 2-功能齐全的 45+ Vue.js 组件，其中包括数据网格，图表，计划程序和图表组件等。\n * Banshee-一个几乎没有渲染的 Vue UI 组件和实用程序框架，没有 CSS。\n * vue-atlas-漂亮的 Vue 组件库。\n * DevExtreme Vue 组件-65+响应迅速且功能完善的 Vue UI 组件，具有可自定义的 Material Design 和 Bootstrap 兼容主题。\n * jqwidgets-70 多个具有 Material Design 主题的 Vue.js 2.0 UI 组件。\n * vue-uix-Vue.js 中用于网页实现的 UI 集合\n * vuedarkmode-Vue.js 的极简暗设计系统 🎨\n * Kendo Vue 用户界面–为业务应用程序构建的 70 多个 UI 组件，包括网格。对多种设计语言(包括材料设计和 Bootstrap)的支持完全响应。\n * Vuent-实现 Microsoft Fluent Design 的 Vue.js 组件\n * bpit / vue-专注于效果的 Vue 组件库\n * vue-tailwind-具有可自定义类的 Vue 组件可用于 TailwindCSS，但与任何框架兼容。\n\n\n# 管理模板\n\n * iView Vue 管理员-iView Vue 管理员/基于 iView 2.x 的管理门户模板\n * element Vue Admin-element Vue Admin /基于 Element UI 2.x 的管理门户模板\n * vue-element-admin-基于 Element UI 2.x 的神奇 vue 管理员\n * D2 管理员-vue 制作的优雅后台模板在线演示\n * rest-admin-基于 Vue 和 Bootstrap 4 的 Restful 管理面板在线演示\n * Shards Dashboard Lite Vue-✨ 现代管理模板，具有数十个自定义组件和模板。\n * Vue 材质管理员-Vue 材质设计管理员模板\n * element-admin-使用 Vue CLI 3 和 element-ui 的简单而强大的 vue 管理员。\n\n\n# 服务器端渲染\n\n * Nuxt.js-通用的 Vue.js 框架。\n * Ream-用于构建服务器呈现的静态网站的简约框架。\n * Universal vue-Vue CLI 插件，可轻松创建通用 Vue 应用程序\n\n\n# 静态网站生成器\n\n * VuePress-简约的 Vue 驱动的静态网站生成器。\n * Peco-人类的静态网站生成器。未维护\n * Sabre-一个静态网站生成器，用于使用 Vue.js 构建快速的网站。\n * Gridsome-使用 Vue.js 构建超快速，现代化的网站\n\n\n# 其他\n\n * app-framework-具有 HTML 和 JavaScript 的 IOS 和 Android 应用程序-开发，构建和部署-免费和开源。\n * Myfirebase-一种已解耦的单页应用程序框架，该框架与 google firebase 高度兼容。\n * Vue-Access-Control基于 Vue.js 的前端访问控制框架 2。\n * Basys工具箱，用于构建完整的 Vue.js 应用程序\n * CabloyJS基于 KoaJS＆EggJS＆VueJS＆Framework7 的终极 NodeJS 全栈业务开发平台\n\n\n# 事件处理\n\n * vue-shortkey-Vue-ShortKey-Vue.js 的插件。\n * vue-throttle-event-基于 requestAnimationFrame 的油门事件。\n * vue-waypoint-Vue 的 Waypoint 组件，这是滚动时触发功能的最简单方法。\n * vue-clickaway-可重用的 Vue.js 组件的可重用 clickaway 指令。\n * vue-scrollfire-在特定的滚动位置触发事件。\n * vue-resize-directive-Vue 指令可检测具有去污和节流能力的调整大小事件。\n * v-click-outside-Vue 指令对元素外部的点击做出反应，而不会停止事件传播。\n * vue-outside-events-Vue 2.x 指令可帮助指定元素侦听发生在自身外部的特定事件。\n * vue-selectable-Vue 1.x / 2.x 指令可通过鼠标选择项目。\n * vue-click-helper-Vue2.x 指令可处理同一元素上的 click 事件和 dblclick 事件。\n * v-hotkey-Vue 2.x 指令，用于将热键绑定到组件。\n * vue-resize-Vue 2.x 组件可检测 DOM 元素的大小调整(基于事件/无 window.onresize)\n * vue-observe-visibility-使用 Intersection Observer API 的 Vue 2.x 指令可检测元素是否可见(在视口中是否被隐藏) CSS)。\n * v-dragged-用于拖动事件检测的 Vue 2.x 指令插件。\n * vue-esc-Vue.js 指令，可在转义键盘上添加文档事件监听器。\n * vue-global-events–使用 Vue 的事件修饰符处理全局事件(如快捷方式)的组件\n * vue-edge-check–检查浏览器边缘，以防止用`vue-router'滑动边缘时奇怪地触发过渡效果\n * vue-mutation-observer–使用 MutationObserver API 观察 DOM 中变化的简单而微小的指令\n * vue-scroll-show–如果用户在滚动后到达该元素，则显示该元素\n * vue-tabevents–其他打开的标签页之间易于通信\n * vue-visibility-trigger-👀 滚动到视图时以声明方式触发方法\n\n\n# 响应式设计\n\n * vue-viewports-定义您的自定义视口，并在组件中使用它们。\n * vue 响应：Vue.js(2.x)指令用于隐藏/显示具有 Bootstrap 4、3 或自定义断点的 HTML 元素。\n * vue-match-media-Vue 2.x 兼容插件，提供一致，语义化的方法来使组件具有媒体查询意识。\n * vue-media-query-mixin-Vue 2 媒体查询 mixin 可以在组件 js 和组件模板中使用。与引导程序和可视化视口兼容。如果屏幕宽度为 xs，则返回 wxS；如果屏幕宽度为 sm，则返回 wSM。\n * vue-breakpoints-Vue 2 最小组件，用于显示和隐藏基于断点的元素。受到 Airbnb 的启发。\n * vue-mq-提供一些有用的工具，以语义和移动优先的 API(Vue 2.x)快速设置响应式设计\n * VueResizeSensor-支持调整大小事件的容器。\n * vue-breakpoint-component-用于 组成 CSS 断点状态。\n * fine-mq-一个很好的 API，可以轻松地管理 JS 中的媒体查询，并且可以与 VueJS 作为插件进行一流的集成。\n * vue-response-components-使用ResizeObserver创建响应组件。\n * vue-screen-size-可以轻松，被动地访问屏幕的宽度和高度。\n\n\n# 验证\n\n * vue-formly-JavaScript 支持的 Vue.js 表单。\n\n * vue-focus-用于可重用 Vue.js 组件的可重用 focus 指令。\n\n * vue-form-generator-Vue.js 的基于架构的表单生成器组件。\n\n * FormSchema Native-使用 JSON Schema 和 Vue.js 生成表单\n\n * ic-formly-由 vue-formly 提供支持的简单表单组件。\n\n * 表单生成器-基于 Json 模板的表单生成器，基于 Vue 和 Laravel。\n\n * vue-autofocus-directive-Vue 自动聚焦指令。\n\n * vue-awesome-form-一个 vue.js 组件，就像 json-editor\n\n * vue-form-components-带有验证的干净＆最小化 vue 表单元素\n\n * ncform-一种非常好的配置生成表单的方式\n\n * vee-validate-简单的 Vue.js 输入验证插件。\n\n * vue-rawmodel-Vue.js v2 的 RawModel.js 插件。表单验证从未如此简单。\n\n * vuelidate-针对 Vue.js 的简单，轻量级基于模型的验证。\n\n * simple-vue-validator-一个简单而灵活的 vue.js 验证器库。\n\n * vue-vform-Vue.js 2 表单组件，集成了 jQuery 验证和 Axios。\n\n * vue-form-Vue.js 的全面表单验证。\n\n * vuelidation-简单，功能强大的 vuejs 验证。\n\n * laravel-vue-validator-显示来自 laravel 验证规则的错误\n\n * vue-daval-超级 vue 数据验证器。简便，简单，准确。\n\n * willvalidate-Vue.js 的验证表单。\n\n * vue-m-validator-用于 VueJ 的模型数据验证库。\n\n * vue-isyourpasswordsafe-用 Vue 编写的小型实用程序，用于检查给定的密码是否已针对“我已被拥有” API 泄漏。\n\n * vue-form-send-用于从表单和原始验证发送数据的 Vue.js 指令\n\n * FormVuelar-考虑服务器端验证的 Vue 表单组件\n\n * vue-final-validate-根据我的开发经验，Vue 验证解决方案支持嵌套，异步。\n\n * vform-一种在 Vue 中处理 Laravel 后端验证的简单方法。\n\n\n# 调整大小\n\n * vue-not-visible-Vue 指令，用于从屏幕上小于断点的 dom(如 v-if)元素中删除。\n * vue-window-size-提供反应性窗口大小属性。\n * vue-sensitive-text-↔ 相对于其父节点的宽度缩放其子节点的组件\n\n\n# 滚动\n\n * vue-chat-scroll-Vue.js 2.0 的自动滚动至底部指令。\n * vue-scrollto-添加了一个指令，该指令侦听单击事件并滚动到元素。\n * vue-next-level-scroll-一种基于组件且支持 SSR 的方法，可使用现代 Scroll Behavior API 进行平滑滚动\n * vue-scroll-sync-同步容器滚动位置的组件\n * v-scroll-lock-用于正文滚动锁定而不中断目标元素滚动的 Vue.js 指令\n * vue2-perfect-scrollbar-PerfectScrollbar 简约包装器\n * vue-scroll-to-添加了一个指令，该指令侦听单击事件并滚动到元素。\n * vue-scroll-progressbar-可自定义的组件，用于指示进度条中滚动的相对位置。\n * vue-backtotop-Vue.js 的 Back-to-top 组件，单击该组件可将页面滚动到顶部。\n * VBar-适用于 Vue.js 2x 的虚拟响应式跨浏览器滚动条组件。\n * Vuebar-使用本地滚动行为的自定义滚动条的 Vue 2 指令。轻巧，高性能，可定制且无依赖性。\n * vue-detached-scrollbar-一个简单的滚动条，可以从正在滚动的容器中分离出来。\n * vuescroll-基于 Vue.js 的滚动插件，用于统一 PC 和移动设备中的滚动。\n * vue-simplebar-Simplebar 插件的 Vue.js 包装器。\n * smooth-vuebar-平滑滚动条的 Vue 指令包装\n * vue-scrollview-一个组件，该组件利用作用域的插槽来检测 vue 组件何时进入和离开视口。\n * vue-scrollactive-根据视口中的当前部分在菜单项中添加一个活动类，单击菜单项时也会滚动到该部分。\n * vue-intersect-一个 Vue 组件，用于向 Vue 组件或 HTML 元素添加交集观察者。\n * vue-scrollmonitor-一个 Vue 插件，可在支持多种浏览器的情况下观看视口内部元素的可见性状态(使用提供/注入，因此兼容 vue@2.2 。X)\n * vue-stroll-适用于 Vue.js 2.x 的超棒 CSS3 列表滚动效果组件。\n * navscroll-js-在滚动时突出显示菜单项，并且在单击菜单项时也会滚动到某个部分。用作 vue 组件，vue 指令或与 vanilla js 一起使用。\n * vue-scrollwatch-一个轻便的插件，可检测滚动事件，在元素进入视口时自定义回调，将'scrollTo'api 暴露给特定元素。使用 vue 指令。\n * vue-check-view-一个检查元素是否在视口中的插件。快速，小型，无依赖性，实时演示。\n * vue-stickto-支持多个 DOM 节点的 vue 指令会自动粘贴到顶部\n * vue2-scrollspy-一个 scrollspy 插件和动画滚动到。\n * vue-scroll-behavior-自定义路线导航中的滚动行为。特别是哈希模式。\n * vue-scroll-stop-到达边缘时停止传播滚动。\n * vue-seamless-scroll-Vue.js 的简单无缝 滚动。\n\n\n# 路由\n\n * vue-router-Vue.js 的官方路由器。\n * vue-router-storage-Vue.js 2 和 vue-router 2 的路由器存储和解决方案\n * vue-tidyroutes-分散的 vue-router 路由定义\n * vue-routisan-基于 Laravel 路由系统的 Vue 路由器的优雅路由定义\n * vue-error-page-提供路由器视图的包装器，使您可以显示错误页面而不更改 URL\n * vue-router-sitemap-通过 vue-router 配置生成 sitemap.xml\n * vue-smart-route-智能路由指令，可使用 Vue.js 制作具有智能外观的应用程序。\n * vue-router-lite-Vue.js 2 的基于组件的声明性路由器。\n\n\n# 延迟加载\n\n * vue-lazyload-一个 Vue.js 插件，用于将图像或组件延迟加载到应用程序中。\n * vue-lazy-background-images-延迟加载 Vue 2 的背景图像。\n * vue-progressive-image-Vue 渐进式图像加载插件。\n * vue-l-lazyload-Vue.js v2.x +的 lazyload 插件。\n * vue-lazyload-img-专门针对移动浏览器进行了优化。支持 V2 和 v1。\n * vue-lazy-images-Vue 2.x 的 lazyload 图像插件。\n * v-lazy-img-Tiny(<0.6kb)指令，用于 Vue 2 的渐进式图像加载。\n * vue-clazy-load-使用 IntersecionObserver for Vue 2 的轻量级可转换图像延迟加载组件。\n * vue-lazy-this-使用 Intersection Observer API 的延迟加载组件。\n * v2-lazy-list-一个基于 Vue 2.x 的简单的延迟加载列表组件\n * pimg-一个用于延迟加载图像的简单渐进图像组件。\n * vue-tiny-lazyload-img-用于延迟加载图像的小尺寸 Vue.js v.2 +指令\n * vue-lazy-youtube-video-一个用于延迟加载 YouTube 视频的简单 Vue.js 组件。\n * lazyload-vue-适用于 vanilla-lazyload 的 Vue 插件。\n\n\n# 分页\n\n * vue-paginate-一个简单的 vue.js 插件，可对数据进行分页。\n * vue-pagination-2-Vue.js 2 分页组件。\n * vuejs-uib-pagination-适用于 Vue.js 的最佳，完整的分页插件。受角引导分页启发。\n * vuejs-paginate-用于创建分页的 Vue.js(v2.x +)组件。\n * vue-pagination-bootstrap-一个 Vue.js(1.x＆2.x)服务器端分页组件，带有基于 Bootstrap 的模板\n * laravel-vue-semantic-ui-pagination-与 Laravel 和 Semantic-UI 一起使用的 Vue.js 2.x 分页。\n * vue-paginate-al-Vue 分页并返回您的数据。\n * vue-tiny-pagination-用于创建微小分页的 Vue 组件。\n * laravel-vue-pagination-适用于 Laravel 分页器的 Vue.js 分页组件，可与 Bootstrap 一起使用。\n * vue-lpage-低级 Vue 分页组件。\n * v 页-一个简单的分页栏，包括基于 Vue2.x 的长度菜单，i18n 支持。\n * vue-smart-pagination-具有许多不错设置的任何数据的智能分页。\n * vue-paginatron-分页组件使用范围插槽道具构建，具有最大的灵活性。\n * vue-ads-pagination-使用 css 框架[tailwindcss](https://tailwindcss.com/docs/what -is-tailwind /)\n\n\n# 动画\n\n * vue2-animate-Animate.css 的 Vue.js 2.0 端口。与 Vue 的内置转换一起使用。\n * animated-vue-一个 Vue.js 2.x 插件，可轻松使用 Animate.css 动画作为过渡。就像``一样简单！\n * vue-lottie-一个 Vue.js 2.x 插件，用于基于 bodymovin 渲染特效动画\n * Vueg-使 vue-router 具有过渡效果/为 webApp 提供转场特效的开源 Vue 插件\n * v-animate-css-最容易实现 Animate.css 的 Vue 2 指令\n * vue-mixin-tween-Mixin 工厂，它将补间值添加到动画的组件上下文中\n * v-odometer-轻松平滑地转换数字。使用此库可为您的应用程序提供平滑的动画，仅适用于数字。\n * vue2-transitions✨ 可重复使用的 Vue 2 过渡组件\n * vue-overdriveVue 应用程序的超级简单的魔术移动过渡 🎩\n * animated-number-vue超级简单的数字动画方法。\n * vue-typed-js集成了 Typed.js，可轻松创建打字动画。\n * vue-parent-change-transition启用子组件在更改父组件时进行动画处理。\n * vue-smooth-reflow响应数据变化而转换元素重排。\n * VueTween允许组件补间其属性。\n * vue-slide-up-down就像 jQuery 的slideUp /slideDown一样，但是对于 Vue！\n * vue-animejsVue 的简单anime.js指令。\n * Eagle.jsEagle.js 是 Vue.js 的基于 Web 的幻灯片框架。\n * vue-posePose for Vue 是一个声明式运动系统，结合了 CSS 过渡的简单性和 CSS 的强大功能和灵活性 JavaScript。\n * vue-slide-up-down-component这是一个简单的界面，但是实现了非常灵活而强大的幻灯片动画 Vue！\n * femtoTween具有一流 Vue 支持的简约(零深度，小于 1k)补间库\n * vue-sequential-entrance插件，用于创建带有页面元素列表的优雅的连续动画入口。零努力。简单轻巧\n * vue-animate-scroll一种超级轻量级 的方法，可在元素滚动到视图中时向其添加 CSS 动画。\n * vue-svg-transition创建 2 状态，SVG 驱动的过渡\n * vue-page-transitionVue.js 的简单路由/页面转换\n\n\n# 元标记\n\n * vue-head-管理 head 标签的元信息，一种简单的方法。\n * vue-meta-在 Vue 2.0 组件中管理页面元信息。支持 SSR +流媒体。\n * vue-headful-从视图中设置文档``和 meta 标签。\n * vue-simple-headful-使用 vue.js 轻松设置元标记-具有 TypeScript 支持的更简单的vue-headful替代方法。\n\n\n# 传送门\n\n * vue-dom-portal-Vue.js 组件中 DOM 元素的转义口。\n * portal-vue-一个 Vue 插件，用于在 DOM 中的任何位置渲染组件的模板(在 virtualDOM 级别上有效，不会在 DOM 中移动节点)\n\n\n# 过滤器\n\n * vue2-filters-适用于 Vue 2. *的标准过滤器 Vue 1. *的集合。\n * vue-morphling-Vue 2 的标准和自定义过滤器的集合。\n * vue-currency-filter-轻巧且可自定义的 Vue 2 货币过滤器。\n * vue-trans-一个简单的过滤器，提供了与 Symfony trans 相似的翻译方式。\n * vue-string-filter-轻量级 Vue 2 字符串处理过滤器。\n * vue-units-在 Vue 2 中使用的方便的单位转换过滤器的集合。\n * vue-numeral-filter-过滤器的集合，允许在组件的模板部分内联使用 Numeral.js。\n * vue-filter-date-format-Vue 2 的简单日期时间过滤器。\n * vue-filter-pluralize-Vue 2 的简单复数过滤器。\n * vue-filter-date-parse-Vue 2 的简单解析日期时间过滤器。\n\n\n# SVG\n\n * vue-svgicon-创建 svg 图标组件的工具。(版本 2.x)。\n * vue-content-loading-Vue 组件可轻松构建(或使用预设)Facebook 之类的 SVG 加载卡。\n * vue-annotator-使用任何 SVG 元素(“ rect”，“ polygon”以及其他更多元素，即使包装了 HTML 元素如“ canvas”，也可以为页面添加注释)在foreignObject中)\n * vue-svg-sprite-简单使用 SVG sprite(vue 2.x)的指令。\n * vue-svg-filler-用于自定义 svg 文件 🖍(vue 2.x)的 Vue 组件。\n\n\n# 其他\n\n * vue-resource-progressbar-interceptor-将进度条与所有请求联系在一起的拦截器，很明显，正在加载某些东西。\n * vue-images-loaded-Vue.js 2.0 指令可检测图像加载。\n * vue-visible-VueJS(2.x)的 v-visible 指令，类似于 v-show 但具有可见性。\n * vue-resize-sensor-用于检测容器大小的组件(基于事件)\n * v-blur-Vue 指令动态模糊元素\n * vue-async-methods-用于基于承诺的方法的帮助程序实用程序\n * vue-openseadragon-适用于 Vue.js 的 OpenSeaDragon 组件(缩放和平移)\n * vue-match-heights-指令将元素的高度设置为相同。\n * vue-conditional-attrs-用于条件渲染属性和指令的 Vue.js 组件\n * vue-cbsc-一个 Vue.js 2.x 组件，用于以编程方式混合，着色和转换颜色。\n * vue-spatialnavigation-用于空间导航(键盘导航)的 Vue 指令(Vue.js 2.x)\n * vue-lifecycle-Vue.js 生命周期指令。\n * vue-aspect-ratio-vue 的长宽比指令。\n * @ kooljay82 / vue-m-camera-为避免自动更改通过用户设备的相机拍摄的照片方向。\n\n\n# WebGL\n\n * vue-3d-model-Vue 组件中的 3D 模型查看器。\n * vue-pano-Vue 组件中的全景查看器。\n * vue-threejs-Three.js 的 Vue 绑定。\n * VueGL-Vue.js 组件通过 three.js 反应性地渲染 3D 图形\n * vue-vr-使用 Vue 构建 VR 应用程序的框架\n * vue-displacement-slideshow-一个 Vue.js 组件，可简化 Webgl 图像位移转换。\n\n\n# 全屏\n\n * vue-fullscreen-用于全屏的简单 Vue 组件。\n\n\n# 页面可见性\n\n * vue-page-visibility-awesome-易于配置的页面可见性 api 的 Vue 2.x 组件。\n * vue-authplugin-美观的 auth 控制插件，支持指令和原型方法。\n\n\n# 打印\n\n * vue-html-to-paper-Vue mixin 用于将 html 元素打印到纸张上。",normalizedContent:"# vue资源\n\n\n# 官方资源\n\n * 官方指南\n * api 参考\n * github 回购\n * 发行说明\n * 样式指南\n * vue.js 新闻\n\n\n# 外部资源\n\n * vue.js 资料まとめ(日语)by @hashrock\n * vue.js 新闻稿-每周精选的 vue.js 新闻的剂量\n * vue.js 提示-成为更好的 vue.js 开发人员的提示\n * vue.js wikipedia\n * vue.js radar-精选的新闻通讯和网站，涵盖了新的 vue.js 版本/贡献。\n * vue 新闻-专注于最新 vue.js 新闻和信息的社交网站。\n * vue 精选资源-推荐的 vue.js 课程和教程。\n * builtforvue-所有 vue.js 组件和软件包的 npm 镜像。\n * vue school-通过核心成员和行业专家的视频课程学习 vue.js\n * vuedose。有关忙碌的开发人员的 vue 生态系统的提示和技巧。\n * vuelibs。基于 awesome-vue 存储库的 vue.js 库和组件的简约列表。\n\n\n# 工作门户\n\n * vue.js 职位-vuejobs-一个 vue.js 职位门户，可为您所有的 vue.js 职位招聘或录用。\n * vue.js 面试问题-300 个 vuejs 面试问题和答案列表\n\n\n# 社区\n\n * twitter\n * 官方论坛\n * vue-requests-请求您希望存在的 vue.js 模块或获取有关模块的想法\n\n\n# 会议\n\n * vueconf\n * vue.js 伦敦\n * vueconf us\n * vueconf 多伦多\n\n\n# 播客\n\n * full stack radio＃30(11-23-2015)\n * javascript jabber＃187(11-25-2015)\n * changelog＃184(11-27-2015)\n * 软件工程日报(2015 年 12 月 29 日)\n * javascript air 016(2016 年 3 月 30 日)\n * [codecasts＃2-falando sobre vuejs e web components(2016-08-19)pt-br]\n * full stack radio＃50(09-21-2016)\n * [和 vue.js 框架的作者聊聊前端框架开发背后的故事zh-cn]\n * mw s04e08-vue.js 与 evan you 和 sarah drasner(04-27-2017)\n * 提交请求＃12-众筹开源(vue.js)(06-15-2017)\n * the web platform podcast 132：vue.js(07-27-2017)\n * 带有 maximilianschwarzmuller 的 javascript jabber＃276(08-29-2017)\n * 使用 sarah drasner 动画 vuejs(软件工程日报 01-12-2017)\n * vue 观看次数(vue 每周播客开始于 2018 年 3 月 6 日)\n * 官方 vue.js 新闻播客\n * 通过 qit 技术播客索引器播出的 vue 播客列表\n * dne 138-vale a pena vuejs 吗？(01-05-2018)\n * cynical developer＃99(10-15-2018)\n * 语法＃130(03-27-2019)\n\n\n# youtube 渠道\n\n * vuenyc\n * vueconf 欧盟\n\n\n# 官方例子\n\n * 基本示例\n * vue.js todomvc\n * coffeescript 版本\n * vue.js hackernews clone\n * vue.js 2.0 hackernews clone\n\n\n# 讲解\n\n * vue.js 屏幕录像关于 laracasts -auth0 博客上的vuejs 2 身份验证教程\n * [scotch.io 上的使用 vue.js 创建 github file explorer\n * vue.js 教程关于 vegibit\n * vue.js 使用 webpack，vue-loader 和热重装从零开始构建设置\n * vuex 基础：教程和说明\n * vuex 简介视频-来自伦敦 vue.js 聚会＃1 的 james browne -laravist 上的vue.js 中文系列视频教程\n * [craigmckenna.com 上的使用 vue.js 开发反应式发票应用程序\n * 带有葡萄牙语的 laravel 和 vue.js 的混合应用示例，作者@vedovelli -oguzhan.in 上的vue.js 土耳其语简介\n * vue.js 西班牙语视频教学系列(3-8-2016)在 youtube 上由 juanandresnunez 制作\n * [stude.net 上的vue.js 西班牙语电视广播系列 -bhnddowinf 上的讲解 vue.js 官网中文-含代码，百度云，youtube\n * [pusher 上的使用 vuejs，es2015 和 webpack 探索实时应用] -sekolahkoding.com 上的印尼语中的 vue.js\n * .dev 中来自 scratch 系列的 vue.js 俄语\n * [flask，rethinkdb，vue.js，ч。створеннясервісудлязберіганняфаилівзflask。1乌克兰\n * vuejs 2 法语教程francaispar grafikart\n * jayway vue.js 2 研讨会。使用 vue-router，vuex 和 vue-resource 构建一个电子商务站点\n * 如何使用 wijmo 控件创建出色的 vuejs 应用程序 -bhnddowinf 上的讲解 vue.js 2 官网中文-含代码，百度云，youtube\n * vue.js 备忘单：服务器端应用程序，路由器，vuex 存储，graphql 等由@xpepermint\n * 使用 vue.js 加载类似图片的媒体\n * [metric loop]上的如何在 laravel spark 项目中使用 vuex /metricloop.com/blog)\n * [metric loop]上的如何在 vuex 中设置模块(https://metricloop.com/blog ) -关于 laracasts 的学习 vue 2：循序渐进\n * vue.js 中文教程\n * 在 vue.js 2.0 框架上启动和运行在 sitepoint 上\n * [metric loop]上的如何使用 vuex 进行 api 调用(https://metricloop.com/blog )\n * [度量循环](https：// metricloop)上的如何使用 vuex 构建功能。 com / blog) -devmarketer 在 youtube 上发布了vue.js 2.0 基础知识\n * [无知的 vuex-vue 的应用程序数据存储上缺少的入门手册](https://medium.com/js-dojo/vuex-for-the-clueless-the-missing-primer-on-vues-application-data -store-33fa51ffc3af＃.2j25xpfui)\n * 实时网格组件 laravel，vue.js，vuex 和 socket.io\n * vuejs 2-完整指南(包括 vuex)-udemy 教程\n * [在egghead.io上使用 vue.js 开发 web 应用](https://egghead.io/courses/develop-web-apps-with-vue-js)\n * vue.js 2-入门\n * vue.js 2 和 vuex(基本)\n * fatih acet在 youtube 上的turkcevuejsegitimvideoları\n * [通过六个步骤从头开始在 vue.js 中构建 json 树视图组件](https://devblog.digimondo.io/building-a-json-tree-view-component-in-vue-js-from-scratch -由arvid kahl在digimondo devblog上的-in-six-steps-ce0c05c2fdd8＃.738ok0l4p)\n * vue！-illya klymov 在 youtube 上的 openlecture 2017.01 俄语(@xanf)\n * @afropolymath(https://afropolymath.svbtle.com/bootstrapping-your-first-vue-js-project/)。 com / afropolymath)\n * [@分离]的从头开始构建 vue-hackernews-2.0(https://github.com/detachment)\n * [使用 vue-kindergarten 为您的 vue.js 和 nuxt.js 应用程序提供基于角色的授权](https://medium.com/@jirichara/role-based-authorization-for-your-vue-js-and-nuxt- js 应用程序使用 vue 幼儿园-fd483e013ec5＃.kp81np177)\n * 完整的 vue.js 应用程序教程-使用 vue 创建简单的预算应用程序，作者为@matthiaswh\n * vue.js 教程：经过渲染的 seo 友好示例\n * [vue.js 简介，供仅了解足够的 jquery 的人使用](https://medium.com/@mattrothenberg/vue-js-introduction-for-people-who-know-just-enough-jquery-to -通过 eab5aa193d77 获取)\n * 使用 vue.js 和 axios 从第三方 api 获取数据\n * vue 2 的趣味项目(视频)，作者：packt 的 peter van meijgaard。(2017 年 4 月)\n * [vue js：同时运行 express 和 webpack dev server](henrik fogelberg)在媒体上的(https://medium.com/dailyjs/vue-js-simultanelyly-running-express-and-webpack-dev-server-292f4a7ed7a3)\n * [the net ninja]在 youtube 上发布了vue js 2 教程(https://www.thenetninja.co.uk)\n * 在 5 分钟内将无头 cms 添加到 vuej 中\n * vue 架构中的观察者\n * 使用 vue.js 构建您的第一个应用\n * 5 个学习 vue.js 的实用示例\n * [@jesalg]的从 knockoutjs 迁移至 vuejs(https://twitter.com/jesalg)\n * 通过 vue.js 创建测验由[@ rap2h](https://twitter.com/ rap2h)\n * [@chadcampbell]的vue.js：入门(https://twitter.com/chadcampbell)\n * vue.js 2 和 firebase-构建实时单页 web 应用程序\n * vue.js 2 和 vue 资源-具有外部 api 访问权限的实际应用程序\n * 面向初学者的 vue.js 交互式屏幕录像\n * [aligoren]在 youtube 上发布的vue.js ile nasaapi'ınıkullanarak vericekme(https://aligoren.com)\n * 使用 vue.js 2 进行 web 开发(视频)，作者是 packt 的 olga filipova。(2017 年 6 月)\n * 使用 vuejs 和 pusher 建立实时图表\n * vue 简介，前端大师课程的回购\n * 关于 css 技巧的 vue 指南\n * 在您的 vuejs 应用中使用打字稿 -关于 nodelover 的vue.js 视频系列，免费，入门，实战 -ninghao.net 上的vue.js 预览\n * [@chadcampbell]的vue.js：开发机器设置(https://twitter.com/chadcampbell)\n * 使用 vue-router 构建 vue v2 js 应用 @mikestreety\n * [@atom_hernandez][https://medium.com/@davidatomhernandez/how-to-a-simple-carousel-with-vue-138715d615d7)制作自己的旋转木马](https://twitter.com / atom_hernandez)\n * [使用官方 vue 测试工具和 jest 对 vue.js 组件进行单元测试](https://alexjoverm.github.io/series/unit-testing-vue-js-components-with-the-official-vue-testing- @alexjoverm的 tools-and-jest /)\n * [创建 vue.js 过渡和动画：实时示例，作者为@udyuxdev\n * 创建自定义 vue.js 插件\n * vuejs 第 1 部分中的异步\n * vuejs 第 2 部分中的异步\n * [@mikestreety]https://www.mikestreety.co.uk/blog/vue-js-using-localstorage-with-the-vuex-store)使用[不带插件的 vuex 存储使用 localstorage] //twitter.com/mikestreety)\n * [@mikestreety]的使用道具通过 vue router 访问组件内的 url 参数(@mikestreety)(https://twitter.com/mikestreety)\n * [使用 pm2 和 nginx 在生产中部署 vue.js — ssr(vuetify)](https://medium.com/@kamerk22/deploy-vue-js-ssr-vuetify-on-production-with-pm2-and- nginx-ec7b5c0748a3)\n * laracast上的testing vue components\n * [[codylseibert]的[使用 vue.js 和 express.js 构建全栈 web 应用](https://twitter.com/codylseibert )\n * vue.js 2 条食谱(视频)，由 packt 的 peter van meijgaard 撰写。(2017 年 9 月)\n * [sabe.io]上的vue.js 入门(https://sabe.io/)\n * 使用 vue 2 构建您的第一个高级 crud 应用程序(视频)(https://www.packtpub.com/web-development/building-your-first-advanced-crud-application-vue-2-video)范·迈加德(pack meitgaard)(2017 年 7 月)\n * 프론트엔드vue.js입문서\n * [inflearn]上的누구나다루기쉬운vue.js(视频) ](https://www.inflearn.com/)，由captain pangyo\n * 在 2 小时内建立一个 vue.js 博客顶部在snipcart\n * [sales bhatnagar @sachinbee的vuejs 2 入门 udemy\n * [sabe.io]上的vuex 入门：在 vue.js 中管理状态(https://sabe.io/)\n * [sergii stotskyi 的使用 casl 的 vue2 acl]\n * [简化 javascript 选择-angular 诉 react 诉 vue(视频)](https://www.packtpub.com/application-development/javascript-choice-made-easy-%e2%80%93-angular- v-react-v-vue-video)，packt 的 daniel kmak。(2017 年 11 月) -storyblok 博客上的使用 auth0 的 vuejs 2.5+身份验证教程\n * 带有 vue 的 graphcms 初学者指南在 graphcms 上\n * 在 chrome 和 vs code 中调试 vue.js此食谱展示了如何将 debugger for chrome 扩展程序与 vs code 一起使用调试由 vue cli 生成的 vue.js 应用程序。\n * [packet sachin bhatnagar 的vue js 2 入门(视频)。(2018 年 1 月)\n * 使用 vue.js 构建电影应用界面，作者是 hassan djirdeh，[@ djirdehh](https： //twitter.com/djirdehh)\n * 让我们建立一个自定义的 vue.js 路由器，作者：hassan djirdeh，[@djirdehh](https：// twitter .com / djirdehh)\n * 由 vue，webpack 4 和 babel 入门，作者是 bjorn krols，[@ krolsbjorn](https ：//twitter.com/krolsbjorn)\n * 如何将 bootstrap 4 添加到您的 vue 项目，作者：bjorn krols，@ krolsbjorn\n * [如何将语义 ui 添加到您的 vue 项目中](作者：bjorn krols，@krolsbjorn( https://twitter.com/krolsbjorn)\n * [bjorn krols 的如何将 eslint 添加到您的 vue 项目，@krolsbjorn\n * 如何通过 vue 中的 url 查询参数使内容动态化(https://medium.com/@bjornkrols/tutorial-dynamic-content-via-url-query-parameters-in-vue-js-d2df19b66633) krols，@krolsbjorn\n * 如何为 aws s3 托管的 vue 应用程序启用历史记录模式作者：bjorn krols，@krolsbjorn\n * [bjorn krols 的使用断点调试 vue 应用程序的基本介绍，@ krolsbjorn\n * 使用 buttercms 无头后端构建 vue.js 电子商务应用程序\n * master vue.js\n * 使用 go 和 vue.js 构建投票应用程序\n * 使用 vue.js 构建协作绘画应用程序\n * 使用 stripe 构建实时付款信息中心\n * 使用 vue.js 构建加密货币跟踪器\n * 使用 vue.js 构建设计反馈应用程序\n * 使用 flask 和 vue.js 开发单页应用\n * 使用 stripe，vue.js 和 flask 接受付款\n * [serverlarup.net 上的使用 laravel 和 vuejs 进行 api 驱动的开发(免费课程)\n * 在 vue.js 中管理状态，作者：哈桑·吉尔德(hassan djirdeh)，@djirdehh\n * 由 vue.js 制作的真实世界项目，由 packt 的 daniel khalil 撰写。(2018 年 8 月)\n * [heartbeat(vue + nw.js 视频系列)]https://goo.gl/8p3msr)，作者：@@ ackzell(https://github.com/ackzell)(2017-2018)\n * 带有 nuxt.js 的 firebase 服务器端渲染 vue 应用程序(带有 javascript 框架的服务器端渲染)\n * firebase 使用 nuxt.js(使用 javascript 框架的服务器端渲染)测量 vue ssr 性能)\n * 使用 d3 和 vue 创建交互式地图(2018 年 10 月)\n * 编写通用的，支持 ssr 的 vue 组件的指南\n * [vue school]的vue.js 基础知识(https://vueschool.io)\n * vuex for everyone由vue school\n * [vue school]的vue.js 表单验证(https://vueschool.io)\n * [vue school]的vue.js 大师班(https://vueschool.io)\n * [vue school]的vue.js firebase 实时数据库(https://vueschool.io)\n * [vue school]的vue.js firebase 身份验证(https://vueschool.io)\n * [vue school]的带有 vue.js 的动态表单(https://vueschool.io)\n * [vue school]的custom vue.js directives(https://vueschool.io)\n * vue.js 应用程序开发要点，作者是 packt 的 bartłomiejpotaczek。(2018 年 10 月)\n * 对 vue.js 进行故障排除，作者：克里斯蒂安·赫尔(packet hur)，帕特。(2018 年 10 月)\n * nuxt.js-类固醇上的 vue.js，作者：maximilianschwarzmuller，packt。(2018 年 10 月)\n * 使用 quasar(和 vue)构建电子文件资源管理器，作者：@@ hawkeye64](https://github.com/hawkeye64)。(2018 年 11 月)\n * [udemy]上的使用 vue js 2 和 firebase 构建 web 应用程序(https：// [the net ninja]的 www.udemy.com/)(https://www.thenetninja.co.uk/)\n * [udemy]上的vue js 2-完整指南(包括 vue router 和 vuex)( https://www.udemy.com/)，maximilianschwarzmuller\n * [使用 vue.js，vuex，vuetify 和 firebase 的 spa 应用程序(第 1 部分)](https://www.jenniferbland.com/spa-application-using-vue-js-vuex-vuetify-and-firebase-part -1 /)由 jennifer bland @ratracegrad。(2018 年 11 月)\n * [使用 vue.js，vuex，vuetify 和 firebase 的 spa 应用程序(第 2 部分)](https://www.jenniferbland.com/spa-application-using-vue-js-vuex-vuetify-and-firebase-part -2 /)由 jennifer bland @ratracegrad。(2018 年 11 月)\n * [使用 vue.js，vuex，vuetify 和 firebase 的 spa 应用程序(第 3 部分)](https://www.jenniferbland.com/spa-application-using-vue-js-vuex-vuetify-and-firebase-part -3 /)由 jennifer bland @ratracegrad。(2018 年 11 月)\n * [使用 vue.js，vuex，vuetify 和 firebase 的 spa 应用程序(第 4 部分)](https://www.jenniferbland.com/spa-application-using-vue-js-vuex-vuetify-and-firebase-part -4 /)，作者是 jennifer bland @ratracegrad。(2018 年 11 月)\n * [詹妮弗·布兰德(jennifer bland)@ratracegrad将国际化添加到 vue 应用程序 )。(2018 年 11 月)\n * 由 vue js 2 编写的实用项目，作者是 packt 的 jack herrington。(2018 年 12 月)\n * [lessipe](https：// lessipe)的lessipe上的vue.js기초다지기(视频) .com /)\n * 由 vue.js 和 node.js 进行的全栈 web 开发，作者 haider rehman， packt。(2019 年 1 月)\n * designer for vue，由 design + code 提供(2019 年 2 月)\n * [talat tufekci]的vue 土耳其语简介(https://www.onbirkod.com)\n * [talat tufekci]的使用土耳其语的 vue-resource 提取数据(https://www.onbirkod.com)\n * [talat tufekci]的使用土耳其语 vue-router 的 spa 应用程序 /www.onbirkod.com)\n * [talat tufekci]的使用土耳其语的 vue-cli 创建 vue 项目 https://www.onbirkod.com)\n * [taul tufekci]的vue 组件和土耳其语 vuex 之间的消息传递 .onbirkod.com)\n * [作者：michael thiessen]如何在vue中动态添加类名称\n * 使用 scaffoldhub 使用 vue js，node js 和 sql 或 mongodb 构建图书馆 web 应用程序作者 felipe lima [@scaffoldhub_io](https：// twitter.com/scaffoldhub_io)\n * 使用 nativescript + vue 构建实时位置跟踪应用，由 saibbyweb 撰写\n\n\n# 事例\n\n * 使用 laravel 中的 jwt auth +示例后端 api 的入门应用程序\n * 节点 webkit + vue 示例@brandonjpierce\n * vue 样本@superlloyd\n * 使用 vue.js + vue-router 的 hackernews 克隆，作者@kazupon\n * 电子+ vue 示例，@ bradstewart\n * [boris okunskiy]的单页应用程序示例(vue + voie)(https://github.com/inca)\n * 开始-用 vue +流明编写的 task manager spa，作者是raj abishek\n * [bosnaufal]的vue mini shop(https://github.com/bosnaufal)\n * vue soundcloud由mul14\n * 功能请求(laravel + vue 组合)由haydenbbickerton\n * [@ yjj5855]的vue cookbook(vue1.0 + express)(https://github.com/yjj5855)：演示服务的第一个屏幕渲染\n * strong together-一个启动器项目，基于 browserify 和 semantic-，以独立或 laravel / laravel spark 项目的形式构建单页 vue.js 应用程序， ui)由websemantics\n * vuetest：在 iframe 中具有用户身份验证，bootstrap ui，上传器，所见即所得编辑器的广告管理网站\n * vue-shopping由andylei18\n * vue-cnodejs，060由@shinygang\n * vue-zhihu-daily由hilongjw\n * vuechess- [gustayo]的多人在线国际象棋游戏(https://github.com/gustayo)\n * ngexplorer-vuejs-client- nugexplorer的正式客户端](https://github.com/gustayo)\n * [vue 2048(vue + webpack)][https：// pengfu](https：// pengfu](https://github.com/pengfu)的https://pengfu.github.io/vue-2048/)：流行的 2048 游戏使用 vue 实现，webpack，sass，es6\n * [bosnaufal]的vue simple pwa(https://github.com/bosnaufal)\n * tour of heroes(vue 2.0)：angular 2.0 的 vue 2.0 端口[tour of heroes](https：// angular。 io / docs / ts / latest / tutorial /)演示应用程序。亮点：es6 / 7，渲染功能，jsx，revue(vue 的 redux 绑定)，[vue-router](https://github.com/vuejs/ vue-router)，airbnb eslint，webpack。由@ aweber1\n * vue-table-pagination由echovic进行分页的表\n * feathers and vue 2.0 blog admin demo演示了如何在 vue 2.0 中使用 feathers。它包含[delay]的身份验证，vue 路由器，vue 无限加载和角色(https://github.com/delay)\n * vue-zhihudaily-2.0zhihudaily 演示程序是使用 vue 2.0，vue-router 和 vuex 构建的，并具有服务器端渲染功能。由cs1707\n * vue-demo-todolist是一个简单的 vue2.0 演示，它使用 vue 2.0 vue-cli 构建。通过fishenal\n * [liueans]的vue-adminlte(https://github.com/liujians)\n * vue(2.0)+ node.js：博客内容管理系统(cms)，作者@ycwalker\n * ngexplorer-quasar- ngexplorer的实现与[quasar 框架](https： //gust.yo 的//github.com/rstoenescu/quasar-framework)(https://github.com/gustayo)\n * zhihu-daily-vuemoonou基于 vue2.0 的 zhihu 日报\n * loopback-vueloopback + vue + vue-resource，ionic-app，vue 页面分页功能，验证权限控制，访问令牌机制，凭证，ci ，docker qxl1231\n * vue-s3-dropzonevue.js 拖放组件可将文件无服务器上传到 aws s3\n * easy-vue一个简单的示例，使用 vue 在 vue 2.0，vuex 2.0，vue-router 2.0，vue-infinite-scroll 2.0， [tigerb]的 vue-progressbar 2.0(https://github.com/tigerb)\n * [度量循环]的vuex 事件消息演示(https://metricloop.com/blog)\n * vue-memo使用 vue.js(> 2.x。)，vue-router(> 2.x。)，vuex( > 2.x。)，vuex-router-sync @ next(> 3.x。)和 firebase(> 3.6.x)，作者为akifo\n * resume vue[changjoo park]的基于 json 的基于 vue 2.0 的简历(https://github.com/changjoo-park/) -使用phoenix framework，vue 和 vue router(demo开发的具有 jwt 身份验证的应用示例 phoenix-vue-auth.herokuapp.com))@ angarsk8\n * 在 vue 2.0 中使用路由器示例 crud 应用(https://github.com/shershen08/vue.js-v2-crud-application)(https://github.com/shershen08)\n * [@mgyongyosi]的asp.net core vue.js 服务器端呈现示例(https://github.com/mgyongyosi)\n * vuefire-quickstart-通过@sejr记录的带 webpack 和 eslint 的 firebase 集成。\n * hello-vue-django vue.js 和 django 集成入门项目，带有热代码重载\n * 实时社交新闻应用，是由phoenix，vue，vue router 和 vuex([_demo _](https ：//loopa-news.herokuapp.com))，作者为@ angarsk8\n * vue-calculator是一个使用 vue 2.0 构建的简单计算器，vue-cli(webpack-simple)。通过caiyiliang\n * wikipedia-viewer一个简单的 wikipedia-viewer 页面，使用 vue2.x，vue-router，vue-cli(webpack)构建-simple)和 ajax(jsonp)。通过caiyiliang\n * vue2.x-douban使用 vue2.x，vue-router 和 axios(豆瓣电影)构建豆瓣电影的简单方法。通过超人\n * vue-laravel-examplevue-laravel-示例是使用 laravel 设置 vue 的简单示例。通过jiajian chan\n * vue-foundation一个演示应用程序，将 vuejs 与zurb foundation集成，使用 webpack vue-cli f\n * aspnetcore-vue-starter一个 vuejs 2 入门模板，它是 asp.net mvc dotnetcore 项目的一部分。该模板包括 vuejs 客户端应用程序和后端 api 控制器。\n * vue-reddit-app使用 vue 2 构建的 reddit spa demo。 x，vue 路由器 2，vuex 和 axios。@ yujiahaol68使用 muse-ui 和 vue-cli webpack 模板\n * vue-music-qq一个 qq-music 项目基于 vue-cli。页面简单流畅\n * 带有 vue-redux 和 plain vuejsx 的 navigationtab导航选项卡同时具有普通 vue jsx 和 vue + redux 绑定\n * veggie map使用 vuejs + vue 路由器+ leaflet 和 firebase 的交互式演示\n * vuejs-d3示例如何使用 d3 进行可视化的示例。\n * vue-twitter-client使用 vue 2.x，vuex，electron-vue 和 electron 构建的 twitter 客户端应用程序\n * douban使用 vue2.x + vuex + vue-router + vue-resource 创建的很棒的 douban 示例。通过jeneser\n * storyblok vuejs-boilerplate-集成 storyblok 的组件系统，允许创建可编辑的网站。\n * vuexpresso-使用 vuex，vue-router，vue-apollo，webpack，graphql，apollo-client，express 和 mongo 的样板\n * 带有 sails.js 示例项目的 vue.js-该项目适用于单页应用程序的新手，并希望通过实际学习例。\n * vue.js＆pyramid web 框架应用程序-使用 pylons pyramid webframework 后端 vuejs webpack2，vue-router，yarn(数据包管理器)的样板\n * vue-feathers-chat在前端使用 vue，在后端使用 feathers 进行的示例实时聊天，但仅使用 socket.io-client 进行通信\n * vue-xplan使用 vue 和 three.js 创建的旋转地球演示页面\n * vuesocketchatroom使用 vue2.x，vuex2.x，vue-router2.x，vux2.x，socket.io 的套接字聊天室\n * @binaryify的vue-tetris(使用 vue，vuex，不可变代码 tetris 编码)：使用 vue，vuex，immutable 编码俄罗斯方块。\n * @kasheftin的route-planner-vue：用于规划具有多个路线的工具 google 地图上可排序的图层，可拖动的方向，标记和形状。\n * mydiary-vue使用 vue 2.x 构建的日记应用程序，还具有联系人和待办事项列表功能\n * aligoren在 github 上的vuejs 示例项目\n * todo-mvc-webpack由voluntapear使用 webpack-basic 在 vue 2 上实现 todomvc 模板，并带有显示 vuex，vue-router，中央事件总线和 vuefire 的示例。\n * [gustayo]的chess storybook example与 vue 2.0(https://github.com/gustayo)\n * vue weather notifier一个带有 svg 和 vuex 的小型示例动画应用程序\n * nuxt 类型一个带有 nuxt 的示例 vue 项目，用于路由/ ssr 到演示页面转换\n * vueblog一个博客系统，支持wmui的服务端渲染\n * cinemateka-用 vue v1 和 laravel 5 制作的 spa 的示例。电影和活动时间表。俄罗斯的评论。\n * vue-2.x-boilerplate-适用于 vue 项目 vuex + vue-router 的简单入门套件\n * vue-minesweeper-由[rhapsodyn]开发的带有 vuejs 的致命简单扫雷游戏(https://github.com/rhapsodyn)\n * x-flowchart-vue- [oxoyo]的 svg 和 vue 流程图编辑器(https://github.com/oxoyo)\n * koa-vue-notes-web-充实的 spa，在后端使用 koa 2.3，在前端使用 vue 2.4。包括功能齐全的用户身份验证组件，针对用户笔记的 crud 操作以及 vuex 存储模块。\n * vuejs 购物车-使用 vuejs 和 firebase 的购物车示例\n * pokedexvuejs@ rchung95\n * vuefire-auth使用 firebase 进行 vuefire vue2-auth-email 验证\n * vuefire-realtimedatabase具有 firebase 的 vuefire vue2-realtimedatabasecrud\n * vuefire-storage具有 firebase 的 vuefire vue2-storage\n * vue2-pwa-blog@ deepak-singh\n * vue-firebase-auth-vuex具有 vuex 的 vue2 firebase 身份验证，并支持渐进式 web 应用程序\n * vue-chart-stater-kit使用 vue 路由器，vue 图表，element-ui 的快速入门\n * vue2.0-demos使用 mint-ui，element-ui，并有一些演示(选择城市等)\n * conwayconway 在 vue 中的生活游戏。\n * vuex-feature-scoped-structure功能范围 vuex 应用程序结构的示例应用程序\n * vuex-examples-有关使用 vuex 构建真实世界应用程序的简单示例\n * vue-vuex-todomvc-示例 todomvc vue.js 应用程序具有通过 rest 的 vuex 存储和服务器后端以及使用赛普拉斯(cypress)的全套 e2e 测试。 io测试运行程序。\n * vuejs-sqljs-boilerplate-这是同时使用 vue.js 和 sql.js 的样板\n * x-webdesktop-vue- [oxoyo]基于 vue 的 webdesktop 系统(https://github.com/oxoyo)\n * vuejs-music-player-一个 vue.js 精简音乐播放器\n * vue.js 最佳实践示例项目-使用 vue.js + vue 路由器+ vuex + vuelidate 的最佳实践示例项目\n * [vue.js 一个]客户端- [一个]用 vue2.5 编写的客户端\n * vue.js 2.5，带有 vue-cli v3，包括使用 auth0 进行身份验证，作者多米尼克·安格(dominik angerer)，storyblok\n * skeleton vue + typescript-typescript，vuejs，elementui，vue router，vuex，材质图标，browsersync，dockerfile\n * @jesalg的penv starter-有关如何在 vuejs，express 和 postgresql 中使用的基本示例连词。\n * vue-relay-examples-使用 vue-relay 的示例应用程序的集合。\n * laravel-vue-boilerplate-具有用户 crud 的 laravel 5.5 spa 样板，使用 vue.js 2.5，bootstrap 4，typescript，sass，pug 和笑话。\n * vue 设计系统-用于使用 vue.js 构建 ui 设计系统的开源样板。\n * vue bulma 演示-一个简单的演示网站，可联合检查 bulma / vue js 和 express。\n * 准备好使用 typescript，vuex，vue-router，hmr 等进行生产的入门应用程序\n * vue.js 与 laravel 结合的前阶段分离开发模板-laravel 护照/ vue.js 和 element ui 的模板网站。\n * 由 vue.js 进行的 web 开发动手，作者：roman kuba，packt。(2018 年 5 月)\n * vue 在线商城-在线 spa 演示，基于 vue 开发的前分离电子商城前端项目\n * fue-使用 vue.js + vue 路由器+ vuex + vuetify + feathersjs 的 admin spa 客户端和服务器端样板\n * vue + typescript 食谱-一本小小的食谱，涵盖了一些不太明显的解决方案，供人们开始使用 vue + typescript\n * vuejs 示例\n * asp.net core vue 入门 cli 3.0使用 vue cli 3.0 和自定义配置(默认 typescript，vue，路由器)的 vue 入门模板，vuex，vuetify)通过@softwareateliers与 asp。＆＃8203; net core 集成(2018 年 9 月)\n * vue-soundcloud由soroush chehresa用 vue.js 2 构建的 soundcloud 客户端。\n * vue-cart一个由 vue，vuex 和 vue 路由器制成的简单购物车。通过crisgon\n * nuxt + apollo + element一个带有 nuxt，element(自定义主题)和 vue apollo 的 vue.js ssr 样板。\n * vue-daily-zhihu由walleeeee使用 vue 2.0 和 vue-router＆vuex 构建的简单演示)\n * 木炭使用 vue cli 3.0 并由[seth davis]用 bulma 样式设置的入门模板(https://github.com/setholito)\n * 带有 typescript 的多页 asp.net core vue-多页 asp.net core vue，typescript，vuex，vue 路由器，布尔玛，sass 和 jest 应用程序。有关如何在.net core mvc 中将 vue.js 用作多页(多个迷你 spa)应用程序的模板/起点。\n * cion-vue.js 的设计系统样板-一个主要为 vue.js 应用程序设计的设计系统。它利用设计令牌，带有集成代码游乐场的生活风格指南以及用于常见 ui 任务的可重用组件。\n * vue websockets 示例-使用 vue.js 2 + node 项目的 websockets 使用的基本示例，以获取完整的工作示例。\n * vue(2.0)+ node.js：一个博客，作者@ fatdong1\n * vue-todo-list待办事项列表示例应用程序基于 vue + vuex + vuetify + vee-validate\n * vue.js 和 ionic v4 示例-一组如何在 vue.js 中使用 ionic v4 的示例\n * 使用 vue，vuex 和 vue-router 的个人网站- muratcansenturk 用 vue，vuex 和 vue-router 制作的简单网站示例\n * 客户端 vue.js- 演示-vue.js 客户端端，用于[justin wash]的微型，快速加载，无 node.js 的单页应用程序(https://github.com/trifectuh)\n * 大型 vue.js 应用样板+ vuex\n * 无画布的 vue.js 上的蛇游戏\n * 使用 cometchat 构建 vue 聊天应用\n\n\n# 书籍\n\n * vue.js je 下，作者：alex kyriakidis 和 packt 的 kostas maniatis。(2016 年 11 月)\n * 学习 vue.js 2，作者：packt 的 olga filipova。(2016 年 12 月)\n * vue.js 2 的威严，作者：alex kyriakidis 和 lestapub 的 kostas maniatis。(2017 年 3 月)\n * vue.js 2 cookbook，作者是 andrea passaglia，packt。(2017 年 5 月)\n * vue.js 实战，作者 erik hanchett 和 benjamin listwon(2018 年春季)\n * 测试 vue.js 应用程序作者 edd yerburgh(2018 年夏季)\n * vue.js 2 和 bootstrap 4 web 开发，packt 的 olga filipova。(2017 年 9 月) -casa docodigo 的 leonardo vilarinho 的front-end com vue.js。(2017 年 11 月) -packt 的 guillaume chau 撰写的vue.js 2 个 web 开发项目。(2017 年 11 月)\n * full-stack vue.js 2 和 laravel 5，packt anthony gore。(2017 年 12 月)\n * [package mike street 的vue.js 2.x 示例。(2017 年 12 月) -oleksandr kocherhin 的mastering vue.js。(2018 年 1 月)\n * fullstack vue：vue.js 完整指南，作者：哈桑·迪吉德(hassan djirdeh)，内特·默里(nate murray)和阿里·勒纳(ari lerner)。(2018 年 3 月) -packt 的 paul halliday 撰写的vue.js 2 设计模式和最佳做法。(2018 年 3 月)\n * vuex 快速入门指南，作者：packt 的 andrea koutifaris。(2018 年 4 月)\n * 使用 vue.js 和 node 进行全栈 web 开发，作者：aneeta sharma，packt。(2018 年 5 月) -flavio copes 的vue 手册。(2018 年 7 月)\n * asp.net core 2 和 vue.js，作者：stuart ratcliffe，packt。(2018 年 7 月)\n * [vue.js：解释性解释](casa docodigo 的 caio incau)(https://www.casadocodigo.com.br/products/livro-vue)。(2017 年 9 月)\n * 了解 vue.js，作者是 brett nelson，apress。(2018 年 8 月)\n * 精益：构建与部署，作者 leanpub 的 daniel schmitz。(2018 年 9 月)\n * 由 spring 5 和 vue.js 2 构建应用程序，作者：james j. ye，packt。(2018 年 10 月)\n * vue.js 快速入门指南，packt 的 ajdin imsirovic。(2018 年 10 月) -frederik dietz 撰写的vue.js 组件模式课程(2019 年 4 月)\n\n\n# 博客文章\n\n * vue x hasura graphql\n * 在 vue.js 中使用 graphql 突变\n * 了解如何使用 vue.js 构建数据驱动的搜索 ui\n * 使用 gitlab ci / cd 将 vue.js 应用程序自动部署到 aws s3\n * 将 vue 应用程式码头化\n * 使用 docker 和 gitlab ci 将 flask and vue 应用程序部署到 heroku\n * [kevin peters]的大型 vuex 应用程序结构\n * [kevin peters]的在 vue.js 中构成计算属性\n * 通过实际示例了解如何重构 vue.js 单个文件组件由kevin peters\n\n\n# 开源的\n\n * pagekit-使用 symfony 组件和 vue.js 构建的模块化轻量级 cms。\n * npmcharts.com-比较 npm 软件包并发现下载趋势。\n * koel-可以正常工作的个人音乐流服务器。\n * raven 阅读器-使用原子电子和 vue.js 制作的简单 rss 阅读器。\n * gokotta-由电子和 vue 构建的简单音乐播放器。\n * copilot-基于 adminlte 和 vue.js 集成的管理门户。\n * retrospectify-在敏捷团队中进行协作回顾的简单工具。\n * jade-press-基于 mongodb，nodejs，koa，vue 等的 cms。\n * astralapp-轻松组织 github stars。\n * eme-优雅的 markdown 编辑器。\n * github-explorer-一个可以帮助您更好地检查 github 的水疗中心。\n * 酒店-从浏览器启动开发服务器，并在几秒钟内获得本地域。\n * surfbird-使用现代网络技术编写的 twitter 客户端。\n * approach0-一个可识别数学的搜索引擎。\n * flox-自托管电影，系列和动漫观看列表。\n * javascript guessing game-用于识别 javascript 工具和库的游戏。\n * vue-ghpages-blog-vue.js 2 + webpack 2 基于 github 页面的博客。\n * vuedo-使用 laravel 和 vue.js 构建的博客平台。\n * vue-music163-一个 vue.js 音乐项目。\n * tomato5-实时协作工具，它将 pomodoro 技术与团队状态共享板结合在一起。\n * web 学习-一种服务，可让您轻松访问有关 web 开发和编程的数千个视频教程。\n * exceljson-一种将 csv，tsv 与 json 相互转换的工具。\n * materialize-blog-使用 laravel5.3 和 vue2.x 构建的材料博客。\n * vuecompomnentgenerator-在浏览器上生成 vue 单个文件组件。\n * sdr 新闻-来自多个来源(reddit，hacker news 和 prominent blogs)的 web 设计人员和开发人员新闻。\n * pj blog-使用 laravel 和 vue.js 构建的开源博客。\n * lulumi-browser-lulumi-browser 是使用 vue.js 2 和 electron 编码的轻型浏览器。\n * vue-wordpress-pwa\n * openapi 3 查看器-浏览并测试 openapi 3.0 规范中描述的 rest api\n * stacer-linux 系统优化程序和监视\n * distrochooser.de-linux 初学者的入门指南\n * buka-电子书管理\n * 文档-一个无需构建过程即可编写文档的框架\n * pm86-node.js 应用网站的生产流程经理\n * vms-一个 vue.js 2.0 管理系统\n * nativescript-vue-nativescript 渲染器的 vue.js 实现。\n * piper-基于 vue 的拖放式移动网站构建器。\n * mmf-blog-vue2-基于 vue2(vue-router，vuex)和 webpack2 的博客。\n * 媒体管理器-web 文件管理器。\n * dyu / bookmarks-一个由 leveldb 驱动的自包含，自托管的书签应用程序，由 vue2.1.x 构建。\n * json 模式编辑器-json 模式的直观编辑器。使用 vue.js 2 和 firebase 开发。\n * npm-stats-npm 包下载统计信息面板\n * vue2-admin-lte-一个将 adminlte 转换为可与 vuejs(v2.x)一起使用的项目。\n * dockeron-基于 electron + vue.js 构建的桌面 docker 项目。\n * flamme-一个基于 education 和 vue.js 构建的开源 tinder 桌面客户端，用于教育目的\n * goldfish-使用 vuejs，golang 和 bulma css 构建的 hashicorp vault ui\n * 管理-基于vuetify的管理控制台，请选中[在线演示](http：// adminify。 genyii.com)\n * 提示-用 vue.js 编写的框架，用于在 web 浏览器中创建类似命令行的界面。\n * hare-🐇 基于 vue.js 2.x，koa 2.x，element-ui 和 nuxt.js 的应用程序样板\n * paper-dashboard-为 vue 制作的 creative tim paper dashboard\n * adminlte-vuejs2-一个在 adminlte 上实现 vuejs(v2.x)的开源项目。\n * 材质仪表板-为 vue 制作的创意 tim 材质仪表板\n * explore-github-vuejs 2 github explorer 使用 api v3\n * coreui-由 vue.js 支持的开源管理模板\n * chucknorris-使用 vuejs + api.chucknorris.io 构建的 chuck norris 笑话生成器\n * leafplayer-一个简单，快速，私有的音乐流服务器。\n * json 编辑器-一种可识别架构的 json 编辑器。用 vue2 开发。\n * voten-使用 vue2 和 laravel 构建的类似 reddit 的平台。\n * news weaver-使用 vuejs 和 vuetifyjs 制作的基于 web 的 rss 阅读器/聚合器\n * 唤醒 billie joe！-根据绿日的歌曲“唤醒我，当九月结束”而倒计时到十月的网站。使用 vue 和 firebase 创建。\n * astrum-旨在包含在任何 web 项目中的轻量级模式库。\n * vue2-pwa-vision-带有 vue2 + vuetify +渐进式 web app 的人脸检测 google cloud vision\n * vue2-pwa-rekognition-使用 vue2 + vuetify + progressive web app 进行人脸检测的 amazon rekognition\n * ammobin.ca-有关加拿大在线弹药价格的元搜索网站\n * spa-asp.net-api-vuejs--用于使用基本任务管理和消息传递的 vue.js 单页应用程序 asp .net webapi 2 和 sql server\n * book-trading-club-与您所在地区的其他图书读者进行贸易或借阅图书。使用 nodejs 和 vuejs2 构建\n * vuejs-extension-pack vscode-扩展 packf 或 vscode，具有用于 vue.js 开发的流行 vs code 扩展。\n * wiki.js-基于 nodejs，git 和 markdown 构建的现代，轻量级且功能强大的 wiki 应用程序\n * vue-pwa-speech-在 vue2 + vuetify + progressive web app 上使用 google cloud 进行文字演讲\n * vue-speech-streaming-在渐进式 web app 上执行流式语音识别可通过 google cloud speech + socket.io 实时生成语音到文本\n * 我的动画列表-一个易于获取 css 动画代码的工具\n * vue-input-streaming-使用 pusher 进行 textinput 流实时和双向数据绑定广播\n * tidytab-一个 chrome 扩展程序，用于整理这些标签。\n * peregrine-cms-基于 vue.js 和 apache sling 的可选 cms\n * concept-to-clinic-具有 vue.js 界面的肺癌预测项目\n * grid-awesome-使用 css 显示为网格布局生成样板 css：grid; 属性。\n * light bootstrap 仪表板-为 vue 制作的创意 tim light bootstrap 仪表板\n * hubaga-适用于开发人员和其他数字商店的免费轻量级 wordpress 电子商务插件。\n * vue-webpack-buefy-具有全功能 webpack 和 buefy 的 vue.js 入门\n * coypu-类似文本编辑器的每周计划\n * 核心服务器-高度可扩展的 vuejs 框架，具有集成的 api 系统和多种高级功能。\n * discord-logo-基于 svg 的 vue.js 动画不和谐徽标生成器。(github 页面)\n * node-vue-template-用于使用 node.js(api)和 vue.js(spa)构建完整应用程序的入门模板，其中包括一些软件包和配置，以帮助快速开始开发。\n * vue-storefront-vue.js 店面-电子商务的 pwa。100％离线，与平台无关，无头，支持 magento2。\n * fd-vue-iot 框架的 vue.js 客户端\n * wildfire-其他注释插件的替代品。\n * 收据-简单的自动化桌面应用程序，可以从 uber 和 lyft 下载并整理您的税款发票。\n * vue-chrome-extension-boilerplate-使用 vue.js 和 webpack 进行 chrome 扩展的样板\n * timemark-一个可以记录您的时间的时间管理器，还将开发更多功能。\n * laravel enso-由 bulma，vuejs 和 laravel 构建的 spa 管理面板，开箱即用地打包了很多功能。\n * 代码说明-针对使用 electron＆vue.js 构建的开发人员的简单代码段管理器。\n * pomotroid-简单，美观且可自定义的 pomodoro 计时器。\n * xmr miner-加密货币(xmr)挖掘应用程序，使用 vue.js 构建并使用 d3 进行可视化\n * xmr paper-monero 钱包生成器，使用 vue.js 构建\n * joyproxy-chrome 扩展程序，用于处理代理设置\n * 活动自动化-管理日常活动并及时获取报告。\n * jsettlers-web流行的德国棋盘游戏，用赚来的资源建造六角形，定居点，城市，道路\n * tamiat cms-tamiat 是面向前端的 cms，使用 vue.js 作为前端，并与 firebase 集成了后端功能。\n * vuegg-vue gui 生成器：一次性创建模型和代码！它通过其可视化编辑器利用页面，组件和样式的创建。为您的下一个 vuejs 项目生成所有脚手架代码。\n * podlove web player-经过 podcast 优化的基于 html5 的音频播放器，具有章节，字幕和嵌入功能。\n * leo vue-使用开源 leo 概述编辑器/ ide 创建带有嵌套菜单的 web 应用程序，并支持内容中的 vue 组件。\n * justine-使用 vue 组件作为文档模板的可配置 html 文档生成器(当前支持 jsdoc)\n * deezer-vue-使用 vue \\ vuex 构建的 deezer 客户端\n * vuep.run-vue 的在线 sfc 编辑器\n * v·oogle-google.com，已修订\n * pomidorus-使用 vue 和 d3 构建 pomodoro 时间跟踪器 🍅\n * hubble-：telescope：浏览 github stars 的历史。\n * vuepress-简约的 vue 驱动的静态网站生成器\n * socialhome-具有社交网络功能的联合富个人资料生成器\n * genvue-一个可托管的 web 应用程序，允许机密用户上传和共享基于 vue.js，vuetifyjs 和 netcore webapi 堆栈的私有文件\n * vue-array-vue 下的数组对象操作，vue 下的数组对象操作使用此包可操作数组。vue 可以监视阵列中的更改\n * laqu-l-具有 quasar framework，带有 oauth 2.0 身份验证的 graphql api 后端，firebase 就绪，多语言功能等的完整应用入门套件。\n * protovue-一个原型组件库，可帮助设计人员和开发人员快速搭建抽象的应用程序布局。\n * chattier-使用 laravel 5.6，vue.js 2 和 bulma(buefy 组件+ bulmaswatch 主题)构建的 spa 社交网络。还使用 jwt 身份验证。\n * chrome-ribbon-reminder-使用 vue 和 async / await 编写的 chrome 扩展程序。使用弹出显示并更改徽章计数。\n * 收藏夹-一个简单的简单收藏夹生成器。\n * 模块化家谱-使用 laravel 5.7，vue.js 2.5 和各种组件的家谱/族谱管理系统。工作正在进行中。\n * 最小注释-使用 vue.js 构建 web 应用\n * 烘焙一个应用程序，旨在帮助咖啡爱好者在学习 laravel + vue.js 的同时找到他们的下一杯咖啡。\n * 堆栈编辑-浏览器内 markdown 编辑器\n * bael 博客模板-静态生成的博客模板，该模板使用 netlify cms 作为后端，使用 netlify 进行托管。具有野蛮美学，模糊搜索，无服务器电子邮件注册等功能。\n * buefy shop示例商店，开源的，具有 nuxt，stripe，firebase，bulma 和无服务器功能。\n * sysmon用于 linux 的 ab / s 模式系统监视器。您可以在任何地方通过 web 浏览器远程监视系统资源的使用情况。\n * eth-vue一个松露盒子，提供您快速构建具有 vue.js 身份验证功能的以太坊 dapp 所需的一切，包括易于部署到 vue.js 的配置。 ropsten 网络。它还具有 gravatar 功能。\n * nippon-color受 nipponcolors 点 com 的启发。这是使用 vue-cli 3 的日本彩色 pwa 版本。\n * saleina cms一个静态网站内容管理系统，使用 git 作为后端使用 vue 构建。\n * vuido用于创建本机桌面应用程序的框架。它可以使用本机 gui 组件在 windows，os x 和 linux 上运行。\n * yougetyoutube 视频/音频/字幕下载器+ cutter\n * vue pug 手写笔vue + pug +手写笔样板 💚🐶🖌\n * crypto news允许您转换加密货币，查看每个 ico 的最新新闻和汇率–来自一个加密货币世界的所有数据。\n * epiboard一个新的选项卡页面扩展，具有材料设计和有用的功能：new：：tada：\n * zhudyos / duic分布式配置中心：新：\n * vuemmerce使用 vue.js 和 bulma 框架构建的免费电子商务模板：新：\n * nucleus分层体系结构 asp.net core api 和 vuejs 客户端应用程序启动模板\n * carpoolear阿根廷拼车应用程序的开源 vue.js 前端(移动和 cordova 应用程序)：[carpoolear](https://carpoolear.com。 ar)\n * statusfy：statusfy 是一个状态页面系统，易于使用且完全开源。\n * dynamodb-gui-client：dynamodb 的跨平台 gui 客户端\n * rosterwebapp开源名册 web 应用程序，允许对员工/团队的名册进行工作会议和其他功能。\n * vue 电子商店 templet-带有 vue / vuex / vue-router 和 bootstrap4 的电子商务 templet。\n * kitty ipsum-生成由不同语言的“喵”组成的 lorem ipsum。\n * git superstar-计算您的 git 星级和顶级存储库。\n * twill-用于 laravel 的开源 cms 工具包，可帮助开发人员快速创建直观，强大而灵活的自定义管理控制台。\n * math_bot-通过对机器人编程来学习数学。\n * vue 填字游戏-一个基于 vue.js 的填字游戏构建器和填充前端应用程序。使用codesandbox构建。\n * vue 组织结构图-免费管理和发布您的交互式组织结构图(orgchart)，无需网络服务器。\n * 哔-使用 vue.js 和 ionic 4 构建的帐户安全扫描程序\n * vue crud-基于 vue.js 的 rest-ful crud 系统。vue crud 允许您轻松创建快速应用程序，例如 cms 或 crm。\n * vue hq 管理员仪表板–由 vue，sass，firestore 和 netlify 支持的现代管理仪表板。\n * mtodo-带有简单身份验证的迷你待办事项列表，该身份验证是使用 vue.js 和 json server 作为数据模拟构建的。非常适合作为发现有关真实 vue.js 参考的任何人的参考\n * firex 代理-firex 代理是用户值得信赖的 chrome 和 firefox 浏览器扩展程序，可让您解除阻止任何网站的权限并私密安全地浏览 web。🛡\n * vuesolitaire-接龙(spider，klondike)包含在 vue.js 中。\n * thermal-一站式访问所有 git 存储库。\n * qmk configurator-vue.js 中的 qmk 固件键盘配置 ui。\n * eplee用 vue.js 和 electron.js 制作的甜美，简单的 epub 阅读器。\n * vue-realworld-example-app-示例性全栈 medium.com 克隆\n * 每日-精选的开发新闻已传递到您的新标签页 👩🏽‍💻\n * laravel 文件管理器-laravel 的强大文件管理器\n * vue 加密仪表板-用 vue.js 制作的 cryptocurrency 仪表板\n\n\n# 商业产品\n\n * wijmo-具有 vuejs 支持的 ui 控件的集合。\n * 整理说明\n * formester-表格，电子邮件营销自动化变得容易\n * chatwoot-通过 facebook messenger 进行 livechat 和代理协作。\n * vuea-具有多种布局和 laravel 版本的 vuejs 管理模板。\n * teleo-团队合作应用在讲话，计划和做事之间轻松移动\n * cover-基于 vue.js 构建的高质量组件库\n * educationlink-适用于教育代理商和大学的 crm 和销售自动化。\n * pragmatic v2.0-使用 vue.js 和 element 构建的响应式和可配置管理模板。\n * 座位-简单而现代的团队沟通和协作解决方案。\n * moonitor-台式机的加密货币跟踪器。\n * deskree-将想法，任务和问题集中在一处的在线协作平台。\n * oshcexpress-oshc(海外学生健康保险)保险(澳大利亚国际学生保险)的比较和电子商务。\n * agiloo-适用于 scrum 和看板的项目管理应用\n * scaffoldhub-带有 nodejs，mongodb 或 sql 的 vuejs 在线 web app 生成器。\n * commandeer-可以重新构想管理。使用 vue.js 和 electron 构建的桌面云管理应用程序。\n * sa email builder-使用 vuejs 和 quasar framework 做出响应的电子邮件模板构建器\n\n\n# 应用/网站\n\n * laravel spark\n * 副视频\n * 表格\n * laracasts\n * esa.io\n * 稀土掘金\n * 布拉格机场\n * 投资组合网站\n * 乐风乐团\n * atiiv-面向私人教练及其客户的应用程序。\n * 统计\n * embalses！-使用美国地质调查局数据库报告水坝水位的工具。\n * travelmap-旅行者基于地图创建博客的简单方法。\n * 适当的衬衫制造商-定制衬衫的制造商。\n * checkit\n * reddit 新闻-浏览器扩展程序，用于显示来自 reddit 的通知和新闻。\n * 卡通网络自行制作 powerpuff\n * 小桃酱\n * cloudradioo-web 应用程序，可随机播放 soundcloud 图表中的前 50 首歌曲\n * vnotes-使用 vue.js 和本地存储 api 的 markdown 简洁漂亮的记事本。\n * 开放功能计算机\n * dermail-用 vue.js 编写的针对 dermail 的 webmail 客户端，dermail 是用 node.js 编写的邮件系统。\n * octimine-专利搜索引擎。\n * draxed-基于 web 的 mysql 和 postgresql 数据浏览器和仪表板管理器。\n * leapspotleap-查找您附近的 wikipedia 文章的简单方法。或只是导航到一个地方并找到有趣的维基百科信息。响应式 web 应用程序。\n * x-songtao-个人博客。fe 和 cms 位于同一 vue spa 中。\n * jobinja-在伊朗运营的求职委员会和职业平台。\n * 滚蛋吧！莆田系-显示所有 put 田医院的信息\n * jobi：招聘平台\n * 香料屋-高质量香料的电子商务网站。结帐，购物车，产品详细信息页面和搜索是使用 vue 构建的。checkout 是用 vue＆vuex 编写的单页应用程序。\n * livestorm-网络研讨会/直播活动应用。\n * metric loop-一个技术服务和解决方案网站。\n * 保持\n * 全球考试-语言能力测试在线培训\n * slugsurvival-一个可帮助学生更好地计划课程的网络应用程序(业余项目，不属于 ucsc)。\n * freepoll.online-使用 vue.js，vue 可排序，语义 ui 和 zappa 构建的群体决策工具。\n * gitrelease-使用带有电子的 vue.js 在 mac 菜单栏上跟踪 github 项目的新版本。\n * 12bay.vn-在线预订机票。\n * playcode.io-快速前端实验的游乐场。\n * the void radio-地下室内音乐在线广播。\n * bitly vue-使用 vuejs 和 bitly api 缩短 url。\n * storyblok-使用 vuejs 作为前端的基于 api 的/分离的 cms。\n * wizzair\n * 移至 https-有关将不同平台/托管站点移至 https 的指南\n * booknshelf-发现有关不同主题的出色书籍和书架。\n * top hn-在 hacker news 上实时显示最新新闻活动\n * euronews-euronews 是一种多语言新闻媒体服务，总部位于法国里昂。\n * roozameروزامه??-roozame 是波斯语的智能新闻媒体服务。\n * koumoul\n * ninjacalc-一组与嵌入式工程相关的计算器，使用 vue.js 作为开源单页应用程序构建。\n * vue.js feed-最新的 vue.js 新闻，教程，插件等。基于vuedo，使用 vue.js 和 laravel 制作。\n * 蒜瓣-使用 vue2.0 和 douban api 开发的网络应用\n * 猜对了-一个“猜单词”游戏-用 vue / vuex / vue-router(前端)和 laravel / mysql(后端)编写。代码是github 上的开源(尽管不是在 kdcinfo 上运行游戏的实时文件)。\n * grap-商业通讯服务\n * 简易模拟\n * mmf-blog-vue2-ssr使用 vue 2.0，vue-router 和 vuex 构建的博客，并具有服务器端渲染\n * json 模式编辑器-使用 vue.js 和 firebase 构建的 json 模式的直观编辑器。\n * winsome trivia-一个单人或多人琐事游戏，具有由 vue.js 构建并由 open trivia 数据库提供支持的 2,000 多个独特问题。\n * moon organizer-农历日历应用\n * flash-vue-“未来的抽认卡”将学习无处不在：rocket：\n * kinderbesteck-具有 vue2.0，vuex，vue 路由器的完整在线商店 spa\n * n2ex-vue ssr(必须)网站，请使用 v2ex api\n * 词库-众包在线词库\n * chattanosy-由社区提供的田纳西州查塔努加新事物的数据库。\n * paixin-正版图片销售网站\n * codebottle-将代码段拖放到您的项目中\n * 1xbet-自 2007 年开始运营的博彩公司\n * myowntv-用于创建互联网电视的流媒体网站\n * crowdcircus-欧洲最大的众筹和众筹平台\n * 与某人交谈-与世界各地的陌生人进行免费，匿名和保密的在线文本聊天。\n * 车轮工厂-ui 组件和库共享网站\n * ابیاتنابپارسی-波斯诗集\n * ripplectron-ripple(区块链硬币)vue-electron 的电子钱包桌面客户端\n * pingbreak使用 vuejs 作为实时仪表板的免费，简单的网站监控服务\n * todoist 致敬-todoist 克隆，用 rails + vue 编写\n * json 编辑器-使用 vue2 和 firebase 构建的可识别架构的 json 编辑器。\n * develteam-独立游戏开发者的社交网络。\n * mixsii-适用于青少年，成人，家人和朋友的免费视频聊天室网站。\n * pipquest-vue 中内置的复古益智游戏\n * matryx-去中心化的协作平台。\n * iprevyou-youtube™ 播放器-用于在桌面上观看 youtube 视频的 chrome 应用。\n * 物品管理器-传送命运 2 游戏物品的应用程序。\n * 前端大师 vue 简介-前端大师全日制课程\n * tr-101-鼓合成器/音序器。\n * bazaar-媒体共享平台。\n * wynnstats-非官方的 wynncraft 统计信息。\n * vectr-免费的矢量图形软件\n * 大脑位-emotiv 耳机的 p300 在线拼写机制\n * coin dashboard-完全客户端的加密货币资产仪表板。\n * habitica-角色扮演游戏形式的在线任务管理应用程序。\n * madewithvuejs-由 vue.js 制作的项目图库(网站本身也使用 vue.js)\n * codedependencyscanner-显示.net 汇编代码依赖关系的 ac＃dektop 应用程序使用 vue，neutronium 和 d3.js 构建。\n * 千以太坊首页-百万美元首页被重新构想为以太坊 dapp。在 vue.js 上构建并开源。\n * 让我们着迷-免费的在线图像升级和神经网络增强功能。\n * pi.team-在线发票和会计-简单易用的在线会计和发票，单用户和自由职业者免费。\n * vuethwallet-一个简单的应用程序使用 vuejs 生成以太坊钱包。\n * tipe-下一代 api 优先的 cms。使用功能强大的编辑工具创建内容，并使用 graphql 或 rest api 从任何地方访问它。停止让 cms 决定如何构建应用。\n * vuethexplore-一个简单的应用程序使用 vuejs 探索以太坊区块链。\n * fintechers-以 fintech 为重点的工作委员会。\n * devjournal-项目和构想的协作待办事项列表。\n * bubbleflat-一种在线平台，可通过搜索具有相似生活方式，兴趣爱好或学校的人来帮助学生和年轻的专业人 士找到理想的室友。laravel 和 vuejs\n * teaquinox tea co-专门从事散叶茶的电子商务网站。\n * blip-测试网站的速度，移动友好性，安全性和 html5 文档类型。在某个位置查找商家，然后整体测试其网站，或者只是测试您自己的 url。\n * sunpos-太阳位置，仰角，方位角，黄道/赤道坐标和日出/日落时间(朱利安日)计算和转换实用程序。使用纯 js，vuejs 和 i18n vuejs 本地化插件对网站进行编程。可视化是使用 d3.js 创建的。\n * u3xyz-基于 vue ssr 的个人博客。\n * 27.ua-乌克兰的互联网大型超市\n * 国际象棋守护者-从您自己的游戏中回答国际象棋位置问题。\n * 二十一点休息-二十一点的快速游戏\n * mechanical-适用于 firefox 的 reddit mod，可显示上下文数据见解。\n * gamevix-与他人交换您使用过的视频游戏光盘，无忧。具有材料设计的 pwa。\n * vivifyscrum-适用于交付团队的敏捷项目管理应用程序。可定制的 scrum 和看板板。\n * 9gag-流行的在线平台和社交媒体网站\n * cryptovue-实时加密货币仪表板\n * 厨房故事-烹饪平台\n * mailrabbit-在没有开发人员的情况下创建，a / b 测试和监视交易电子邮件。\n * vue 资源精选-出色的 vue 组件列表，类别，内嵌演示秀和简介\n * cronhub-无痛 cron 监控工具\n * wrkprty-针对自由职业者，远程工作者和希望离开办公室的专业人员的弹出协作活动。\n * 用爱制造-世界各地的“用爱制造 ❤️”倡议是庆祝 🎉，促进 📣 和建立 build 品牌的运动。它从 dribbble，producthunt，behance 和 techcrunch 等多个来源获取 tech 新闻，设计灵感和趋势。💝\n * 产品路径-在创业公司和科技公司中发现超过 1,000 个产品工作。\n * v·oogle-google.com，已修订。一个笑话项目。😃\n * 经纪人注释-'研究成为房地产经纪人'：房屋：\n * synclounge-synclounge 是用于在多个位置的多个播放器之间同步 plex 内容的工具。\n * hce.it-一家意大利代理商的网站，完全由 vue 使用基于 laravel 的无头 cms 创建。\n * 页面-网页设计灵感\n * scrumpy-敏捷团队的漂亮项目管理工具\n * spektrum-spektrum media agency 网站\n * spkspk 生态系统的网站\n * iddef☪️ 重视人类的网页，cms，crm 和捐赠以及所有电子商务页面的协会联合会均使用 vue.js，vuex 和纯 javascript 设计 🙏\n * 配置文件管理-一种管理配置文件的简单方法\n * 烘焙这个应用程序旨在帮助咖啡爱好者在学习 laravel + vue.js 的同时找到他们的下一杯咖啡。\n * ybr-集中的 ybs 公开电子投诉管理系统。(全 spa)\n * regex fiddler\n * myanpwel-活动票务平台的网站。\n * cryptoarte-以太坊的艺术品收藏，不可替代的代币和 dapp。\n * muuviez-具有时尚设计的电影发现和跟踪网站\n * naga virtual-naga virtual 是第一个独立的虚拟商品市场。\n * scroll.in-scroll.in 是独立的新闻，信息和娱乐企业。\n * akunyi-慈善网站\n * mark ruffalo 会做什么？-动机网站基于 mark ruffalo 在获得成功之前在数百次试镜中失败的故事。\n * 白兰地-菜单栏的品牌资产管理器。\n * ruster 社区-cn 的 rust 全栈社区论坛。\n * nbc sports-nbc sports 是一家体育新闻网站。\n * within-虚拟现实中的非凡故事。\n * plottr.io-规划跑步和骑车路线\n * becamp-在弗吉尼亚州夏洛茨维尔举行的由社区组织的技术会议。网站代码是开源的。\n * trustpilot-免费开放给所有评论平台。\n * lagom-简单，直观且响应迅速的 whmcs 主题\n * scoutmytrip-roadtrip planner-印度的公路旅行计划应用程序，可帮助旅行者建立行程，发现景点，寻找酒店，加油站，美食餐厅等沿路线。\n * podflix-播客应用。\n * gamersclub-巴西最大的电子竞技社区发展公司\n * mit-麻省理工学院的官方网站。\n * elvenar-elvenar 是一个基于浏览器的幻想城市建设者游戏。\n * 信标-：blue_heart：这项服务可让您在多个网站之间共享内容。\n * artfinder-artfinder 是买卖艺术品的网站。\n * rolodromo-专门用于桌面 rpg 的西班牙语网站。\n * githubexplorer-用于探索 github 的纯静态页面 webapp。使用vuejs和github graphql api v4。\n * 主题演讲-与 vue 一同展示。\n * happyplants-用于组织植物的渐进式 web 应用 🌱。\n * pocket lists-世界上最友好的待办事项列表应用程序。\n * padlet-协作公告板\n * glovo-按需交付\n * mysigmail-mysigmail 是一个免费的浏览器电子邮件签名生成器，无需创建帐户\n * wordguru-一个简单的口头游戏，您可以分成几个小组，并尝试猜测尽可能多的关键字。\n * apiflash-基于 chrome 的截图 api，基于 aws lambda 开发人员专用\n * kitty ipsum-生成由不同语言的“喵”组成的 lorem ipsum。\n * git superstar-计算您的 git 星级和顶级存储库。\n * decs-分散的多合一工作区，用于管理代码段并保护敏感数据。\n * careup-牙医 🦷 的业务管理工具。\n * asciiur-互联网的 ascii 艺术收藏\n * tapestri designer-用于设计用于基因组测序实验(ngs)的 pcr 引物的免费工具\n * remote-access-ssh-使用 node-ssh 的基于 web 的远程主机访问\n * 地图标记生成器-一个免费的在线工具，可即时生成自定义地图图标\n * monocle reader-在一个地方关注提要，twitter，youtube，博客和其他所有内容。\n * 前站导航-前端社区，文档收录。\n * geenes-生成调色板并将其应用于 ui，然后将其导出到草图或代码中。\n * blurrish-mac / windows 加密的 morning pages 日记，由 vue 和 electron 构建。书写时模糊，因此可以在公共工作区中记录日志。\n * exifshot-摄影的方式和方式，精美绝伦。\n * studolog-用于学生的在线文件共享平台，包括测试人员和评论。目前仅捷克语 🇨🇿。\n * sum.cumo–数字业务模型(以 vue 作为技术堆栈的核心)。\n * gamebrary-用于组织视频游戏收藏的开源工具。\n * guds-比较各大超市的价格。仅适用于墨西哥 🇲🇽。\n * premium poker tools-扑克玩家用来学习的东西。\n * qmk configurator-从浏览器配置，构建和下载自定义 qmk 固件。\n * worksome-适用于合格的 it 专业人员，自由职业者以及希望雇用他们的公司的市场/平台。\n * translator-vuejs-使用 vuejs，yandex api 和 responsivevoice.js api 构建的翻译应用程序。\n * 大计时器-用于研讨会，会议和演示的全屏倒数计时器。big timer 可以帮助研讨会主持人，会议椅，设计短跑选手，演示者和有抱负的游戏节目主持人坚持自己的计划。\n * wirenook-用于构建响应式网站线框的免费在线应用程序。高保真和低保真，项目共享和 svg 下载。\n * kvalitetskontroll-为建筑业量身定制的挪威管理系统。\n * poolside fm-复古音乐播放器\n\n\n# 互动体验\n\n * jean-pierre morin | 1700 laposte\n * facebook newsfeed\n * youtube adblitz 2016\n * omnisense 体验\n * louis ansa 网站(投资组合)\n * djeco.com\n * tolks.io\n * 遇见 graham\n * noize 原创\n * tr-101 合成鼓机\n * bootstrap 4 编辑器\n * subtletab-浏览器扩展\n * web-riimote-将您的智能手机变成 3d 控制器(源代码)\n * css colorvars-交互式工具代码生成(源代码)\n\n\n# 企业用途\n\n * 塞恩斯伯里的\n * arex -大疆创新 -octimine gmbh -浑力集\n * gitlab\n * clemenger bbdo melbourne\n * zenmate\n * 代码\n * storyblok\n * monito-建立 booking.com 以进行国际汇款\n * hypefactors-数据驱动的 pr 专业人员的软件 -adobe -ibm\n * cotabox\n * aromajoin-基于硬件，软件和材料技术的协调发展最好的数字气味产品。\n * 家乐福\n\n\n# a11y\n\n * vue a11y 项目-vue.js 社区项目，用于改善 web 可访问性。\n * vue-skip-to-它可以帮助仅使用键盘的人跳到最重要的地方。\n * vue-axe-vue.js 应用程序的可访问性审核。\n * vue-announcer-vue 的一种简单方法，可为屏幕阅读器宣布任何有用的信息。\n * eslint-plugin-vue-a11y-用于.vue 中元素可访问性规则的静态 ast 检查器\n * vue-focus-lock-这是一个陷阱！焦点锁定。a11y util，用于确定焦点。\n * vue-a11y-calendar-可访问的国际化 vue 日历。\n\n\n# 表格\n\n * vuetable-2数据表简化\n * vue-tables-2-vue.js 2 网格组件。\n * vue-datasource-一个 vue.js 服务器端组件，用于创建动态表。\n * ag-grid-vue-用于 ag-grid 的 vue 适配器。\n * vue-data-tables-vue2.0 数据表，基于 element-ui。\n * vue-floatthead-用于 floatthead 的 vue 2.0 组件，floatthead 是一个浮动的粘性表头插件。\n * vuetiful-datatable-具有排序，过滤，分页，分组和聚合的数据表组件。\n * vue-materialize-datatable-materialize css 的 vuejs 数据表\n * vue-good-table-一个易于使用的 vuejs(2.x)表插件，具有排序，列过滤，分页等功能。\n * vue-grid-vue.js 的灵活网格组件\n * vue-easytable-基于 vue2.x 的功能强大的表组件\n * vue2-datatable-component-永远不会烂的 vue.js 2.x 最佳数据表\n * vue-js-grid-vue.js 2.x 响应式网格系统，具有平滑的排序，拖放和重新排序\n * vue-handsontable-official用于 handsontable 电子表格组件的 vue.js 包装器\n * vue-grid-用于 vue.js 2.x 的功能强大的 flexbox 网格系统，使用内联样式构建\n * vue-data-tablee-基于 vue-good-table，一个简单漂亮的表组件\n * vue-scrolling-table-具有 flexbox 大小的简单表格组件，滚动表格主体(水平和垂直)，所有 tr / th / td 的插槽渲染。\n * el-search-table-pagination-将 element ui 的 form，table 和 pagination 组件组合在一起。基于 vue 2.x。(详细信息)\n * vue-crud-x-使用 vuetify 布局的可扩展 crud 组件，除了通常的页面，排序，过滤器之外，它还能嵌套的 crud，自定义表单，过滤器，操作。\n * vue 数据表-vuejs 支持的数据表，具有 laravel 服务器端加载和 json 模板设置\n * v2-table-一个基于 vue 2.x 的简单表组件。\n * vue-cheetah-grid-在 vue.js 的画布上工作的高性能网格引擎。\n * vue-table-component-直指 vue 组件以显示表。\n * @ lossendae / vue-table-vue.js 2.x 的简单表组件，具有分页和可排序的列。\n * el-data-table-基于 element-ui，可以轻松完成任务\n * devextreme vue 网格-用于 bootstrap 的基于插件的高性能 vue 数据网格。\n * vue-ads-table-tree-具有过滤，排序和分页功能的 vue table 组件。行可以具有子行，因此可以构建树结构。它还支持异步调用以从后端加载行。它是使用 css 框架tailwindcss构建的\n * 用于 vue 的 synfusion 数据网格-显示和处理具有分页，排序，过滤，编辑和分组等功能的表格数据。\n * @ marketconnect / vue-pivot-table-数据透视表的 vue 组件\n * vue-teible-web 的轻巧灵活的表组件：zap：\n * vue-jqxgrid-具有过滤，排序，编辑，分组，数据导出和其他功能的 vue 数据网格。\n * vue-jqxpivotgrid-具有枢轴设计器的 vue 枢轴数据网格，钻取单元格，枢轴功能。\n * toast-ui.vue-grid- [toast ui grid]的 vue 包装器(http://ui.toast.com/tui -grid /)。\n * vueye-datatable-vueye 数据表是基于 vue.js 2 的响应数据表组件，它按页面组织数据以便于浏览。\n * vue-sorted-table-一个将表转换为排序表的插件。支持嵌套的对象键，自定义图标和可重用组件。\n * vue-bootstrap4-table-基于 vue 2 和 bootstrap 4 的高级数据表，其中包括多列过滤，多列排序，分页和信息，复选框行和高度可定制的插槽选项。\n * vuejs-smart-table-直截了当的表格组件，使用原始 html 表格结构，并具有开箱即用的排序，过滤，分页和选择功能。\n * @ myena / vue-table-用于客户端/服务器数据处理的表组件。筛选，排序，分页，分组，展开详细信息行。高度可定制的通孔，用于过滤器，标题，列，分页，详细信息行。\n * vue-jd-table-vue 2 的高级且灵活的数据表组件。功能丰富：搜索，过滤，导出，分页(传统和虚拟)滚动)等等！\n * vue-grd-用于网格布局的简单，轻巧和灵活的 vue.js 组件。\n * iview-table-page-将 iview ui 的表和页面组件组合在一起。基于 vue2.x。并听到了一些使用 iview-table-page 的示例。\n\n\n# 通知\n\n * vue-notifications-vue.js 不可知的非阻塞通知库。\n * vue-easy-toast-vue / vue2 的 toast 插件。\n * vue-toasted-适用于 vuejs 的自适应 touch 兼容 toast 插件。\n * vue-notifikation-vue.js 通知插件。\n * vue-notification-使用velocity制作动画的 vue.js 2+通知插件。\n * vs-notify-微小但功能强大的通知组件，没有依赖项。\n * vue2-notify-vue.js 2+通知插件。\n * vue-notifyjs-极简主义，3kb 可通知通知插件\n * vueup-vue.js 的简单，轻巧和优雅的全局通知弹出窗口\n * vuex-flash-vuex 2.x 中用于 vuejs 2.x 的 flash 消息组件。\n * vue-snotify-vue.js 2 通知中心\n * vue-notify-me-vue 的可堆叠通知警报\n * vue-noty-围绕 noty 的 vue.js 2 包装器\n * vue-notice-vue.js 2 使用本机 api 围绕 noty.js 进行包装\n * vue-flash-message-简单但灵活的通知插件\n * @ voerro / vue-notifications-具有 html 和样式支持的简单 vue.js 2 通知插件。\n * vue-awesome-notifications-具有高级异步支持的轻量级 vue.js 通知库。\n * vue-izitoast-围绕 izitoast 的 vue.js 2 包装器。\n * vue-toastr-2-基于toastr的 vue.js 的简单敬酒通知)\n * vue-snack-基于 google material 的 snackbars 的 vue.js 插件。\n * vue-m-message-vue 的消息插件。\n * vue-notification-bell-用于显示通知的 vue ui 组件。\n * v-tostini-vue.js 2.x 真正纯正的吐司通知机制。不包括 css。\n * vue-toast-notification-另一个 vue.js toast 通知插件。\n\n\n# 装载机\n\n * vue-radial-progress-vue.js 的径向进度栏组件。\n * vue-simple-spinner-适用于 vue.js 的简单灵活的微调器\n * vue-wait-适用于 vue / vuex 和 nuxt 应用程序的复杂加载程序管理。\n * vue-progress-path-支持任何自定义 svg 路径的可自定义进度指示器和微调器。\n * vue-blockui-用于 vue 2 的 blockui，类似于 jquery blockui，可用于加载屏幕。\n * epic-spinners-易于使用的带有 vue.js 集成的 css spinners 集合。\n * svg-progress-bar-vue.js 的简单进度条。\n * vue-loading-overlay-微小的全屏加载指示器\n * vue-loaders- [loaders.css]的 vue 包装器(https://github.com/connoratherton/loaders.css)\n * vue-promise-btn-小巧而强大的异步按钮(或任何其他标签)工具，带有精美的内置微调器\n * vue-spinkit-🌈 带有 vuejs css 动画的加载指示器集合\n * vue2-form-loading-vuejs 指令可与表单一起使用，以便在加载下一页时禁用提交按钮\n * vue-element-loading-⏳ 在容器内加载或全屏显示 vue.js\n * tb-skeleton-vue.js 的骨架屏幕加载\n * vue-spinners-💫 为 vuejs 加载微调器组件的集合\n * vue-progress-bar-这是一个基于 vue 的级联进度条插件\n * vue-loading-button-👇 带有滑动加载指示器的直截了当按钮\n\n\n# 进度条\n\n * vue-progressbar-vue 的轻量级进度条。\n * vue2-loading-bar-最简单的 youtube，例如 vue 2 的加载条组件。\n * vue-top-progress-另一个为 vue.js 加载栏组件的顶级进度。\n * vue-nprogress-进度条基于 vue 的 nprogress。\n * vue-progress-button-vue.js 2.x 动画按钮组件。\n * vue-simple-progress-vue.js 的简单，灵活的进度栏\n * vue-component-loading-管理每个组件内部的加载状态，并使用进度条显示全局加载状态。\n * vue-scroll-progress-用于页面滚动进度条的简单 vue.js 插件\n * vue-read-progress-页面顶部的可自定义进度条，显示滚动进度\n * easy-circular-progress-具有计数效果的简单循环进度组件\n\n\n# 工具提示\n\n工具提示/弹出窗口\n\n * v-tooltip-使用 vue 2.x 的简单工具提示。\n * vue-popper-component-vue.js 的 popper.js 指令。\n * vue-directive-tooltip-简单，灵活的工具提示指令(基于 popper.js)！[vue.js](https：// img.shields.io/badge/vue-2-green.svg)\n * vue-popperjs-基于 vuejs 2.x popover 组件的popper.js\n * vue-tooltipster-基于 vuejs 2.x 工具提示组件的tooltipster.js。支持 html 内容，悬停和悬停+单击事件。\n * k-pop-基于popper.js的简单 popover 组件。高度可定制的。带有主题。支持自定义触发器，并且可以监听任何事件。\n\n\n# 覆盖\n\n * vuedals-一个 vuejs(2.x)插件，用于具有单个组件实例的多个模态窗口。\n * sweet-modal-vue-发生模态的最甜的库。现在可用于 vue.js。\n * vue-js-modal-简单易用，高度可定制，移动友好的 vue.js 2.0+模态，具有 0 个依赖关系。\n * vudal-vue.js 的模态窗口\n * vodal-具有动画的 vue 模态。\n * vue-image-lightbox-一个 vue 图像灯箱/图库，可以很好地显示图像。\n * vue2-simplert-vue 2 简单警报组件(受 sweetalert 启发)，作者：irfan maulana\n * vue-semantic-modal-不具有 jquery 依赖关系的 vue 2 语义-ui 模态组件\n * v-img-易于安装的图库。\n * vue-dialog-drag-可拖动对话框\n * vue-ya-semantic-modal-vue2 的另一个语义 ui 模态组件，没有 jquery 但具有 vue 转换\n * vue-pure-lightbox-非常简单的灯箱插件，没有任何依赖性-仅 vue！🖼\n * v-viewer-基于[viewer.js]的 vue 图像查看器组件，支持旋转，缩放，缩放等(https：// github.com/fengyuanchen/viewerjs)\n * vue-messagebox-vue 上易于定制的消息框组件。\n * vuejs-dialog-轻量级，基于承诺的警报，提示和确认对话框。\n * @ hscmap / vue-window-vue2 的窗口 ui 组件。\n * vue-gallery-vuejs 响应式和可自定义的图像和视频库，轮播和灯箱，已针对移动和桌面 web 浏览器进行了优化。基于 blueimp-gallery\n * vue-swal-用于将 sweetalert 集成到 vuejs 的小型包装器。(与 ssr 兼容)\n * vue-modal-dialogs-✨ 承诺自己的对话框！\n * vue-img-view-vue.js 的插件，您可以在任意位置拖动/查看/旋转图片\n * vue-modaltor-vuejs 的最先进的可配置模态组件\n * v-modal-backdrop-用于 vue 的简单通用背景组件\n * vue-cute-modal-适用于 vue 应用程序的简单易用的 modal 组件。\n * v-dialogs-一个简单而强大的对话框，包括基于 vue2.x 的 modal，alert，mask 和 toast 模式\n * vue-gallery-slideshow-vuejs 的响应式画廊组件\n * vue-a11y-dialog-用于可访问对话框[a11y-dialog](https://github.com的vue.js组件包装器。 com / edenspiekermann / a11y-dialog)。\n * vue-slideout-panel-vuejs 的可堆叠面板组件\n * v-gallery-用于在“ gallery”或“ carousel”中显示图像的 vue2 插件\n * vue2-image-loader-vue2 的图像 lazyload loader 组件\n * vue-my-photos-一个简单的无依赖图像灯箱组件，具有过滤功能\n * vue-img-orientation-changer-一个 vue.js 指令，可自动调整您的 img 以更正方向。\n * vue-topmodal-一个完全可定制，易于使用的 vue.js 模态组件。(自适应，可堆叠，可滚动，动画)\n * vue-modal🖼-为多个可切换模态内容提供对象数组或快速内联您的内容。完全可定制的 vue 模态组件。\n * @ innologica / vue-stackable-modal-用于可堆叠的模态对话框的库。完全可定制且非常易于使用。\n * vue-sweetalert2-sweetlaert2 的包装器，支持 typescript，nuxt 和 ssr\n\n\n# 视差\n\n * vue-parallax-以比窗口慢的速度滚动图像以产生整洁的光学效果。\n * vue-parallaxy-用于视差图像滚动效果的 vue.js 组件。\n * vue-mouse-parallax-一个易于使用的鼠标视差组件-由 vue.js 制成\n * vue-parallax-js-微小的 vue 组件，为元素上的视差效果添加了指令。\n\n\n# 图标\n\n * vue-awesome-vue.js 的 font awesome 组件，使用嵌入式 svg。\n * vue-material-design-icons-单个 svg material design 图标集合文件组件。\n * vue-icon-font-vuejs 的 iconfont 插件(支持 font-class 和 symbol)。\n * vue-ionicons-来自离子团队的 vue 图标集组件。\n * vue-ico-具有嵌入式浏览器支持和选择性捆绑功能的 vue 简易图标\n * mdi-vue-vuejs 的 material design 图标组件\n * vue-fontawesome-font awesome 5 vue 组件\n * g-icon-svg 图标的简单图标组件(与类似于 font awesome 的字体工具包兼容)\n * vue-simple-line-icons-vuejs 的简单线条图标组件\n * vue-country-flag-国家标记图标的 vue 组件- vicon- vicon 是用于 vue 的简单 iconfont 组件。\n * md-svg-vue-google 为 vue.js 和 nuxt.js 提供的 material design 图标(服务器端支持(带缓存)，内嵌 svg)渲染，官方图标名称)\n * vue-lang-code-flags-vue 组件，显示语言来源国的标志\n * vue-zondicons-精美[zondicon]的 vue 组件(http://www.zondicons.com/icons.html)svg 图标\n * vue-eva-icons-简单漂亮的开源 eva 图标作为 vue 组件。\n * vue-unicons-为您的下一个项目提供超过 1000 个像素完美的 svg unicons 作为 vue 组件。\n * vue-fa-简单的 fontawesome 5 vue.js 2 组件。\n * vue-cryptoicon-美丽的像素完美的 400+加密货币和 10+法定货币图标。\n\n\n# 菜单\n\n * vue-accordion-适用于 vue.js 的简单手风琴导航菜单组件。\n * vue-js-dropdown-vue.js 2 下拉菜单组件。轻巧，易于使用和扩展，无外部缺陷。\n * vue-slideout-流行的库[slideout]的 vue 实现(https://github.com/mango/slideout)\n * vue-quick-menu-这是基于 vue.js2 的 web 导航组件。\n * @ hscmap / vue-menu-vue2 的菜单/上下文菜单组件。\n * vue-router-nav-简约的响应式导航栏，呈现 vue-router 的路线。\n * vue-drawer-layout-一个简单的 drawerlayout 组件(例如 android)具有 vue.js。\n * vue-simple-menu-具有一组基本功能的简单菜单组件，在 80％的情况下足够\n * vue-tree-navigation-具有 vue-router 支持的 vue.js 2 树导航\n * bp-vuejs-dropdown-vuejs => 2 下拉菜单。易于使用，无需外部，可选。\n * vue-bulma-accordion-简单，易于配置的手风琴或具有 bulma 自定义样式的可折叠样式或内置的可用图标\n * v-selectmenu-针对 vue2 的简单，容易和高度定制的菜单解决方案。\n * vue-burger-menu-具有不同 css 动画的画布外边栏 menu 组件。\n * vue-dynamic-dropdown-一个高度可定制的，易于使用的优雅下拉组件\n * vue-navigation-bar-适用于您的 vue 项目的简单，漂亮的导航栏。\n * vue-simple-search-dropdown-一个没有外部依赖关系的简单可搜索输入下拉组件\n * @ innologica / vue-dropdown-menu-vue 的下拉菜单组件。任何元素都可以是下拉触发器，任何内容都可以下拉内容。\n * vue-menu-aim-菜单三角形选择，又名亚马逊\n\n\n# 输入\n\n * minus-plus-input-带正负号的数字输入；包含在 vue.js v1 和 v2 中。\n * vue-integer-plusminus-带有 vue 2 增量和减量按钮的整数输入。\n * vue-numeric-input-带有控件的数字输入组件。\n * vue-number-smarty-数字输入可以在聚焦字段时更改滚动值。\n * vuetify-number-smarty-数字输入可在字段聚焦时更改滚动值(vuetify.js 实现)。\n\n\n# 轮播\n\n * vue-easy-slider-vue.js 的滑块组件。\n * vue-l-carousel-vue.js v2.x +的响应式轮播(即滑块或滑动)组件。\n * vue-awesome-swiper-vue.js(1.x〜2.x)的 swiper(slide)组件。\n * vue-lory-基于 lory 的 vue 滑块组件。\n * vue-slick-slick-carousel 的 vue 组件。\n * vue-flickity-flickity.js 的 vue 组件。\n * vue-carousel-3d-vue carousel 3d-vue.js 美观，灵活且受触摸支持的 3d carousel。\n * vue-carousel-适用于 vue.js 的灵活，响应迅速，触摸友好的轮播。\n * vue-coverflow-vue2.x coverflow 组件。\n * vue-agile–受 slick 启发的轮播组件，仅以 vue.js 和 vanilla js 编写。\n * vue-tiny-slider–由 ganlanyuan 创建的轮播组件，用 vue.js 编写。没有 jquery。适用于 ie8 +。\n * vue2-text-swimlane-用于 vue.js 的 text swimlane 插件\n * vue-picture-swipe-vue picture swipe gallery(具有缩略图，延迟加载和轻扫的图像画廊)由 photowipe 支持。\n * vue2-siema-非常小的 siema 转盘/滑块库的插件包装。\n * vue-flux-带有 20 个炫酷过渡的图片滑块。\n * vue-glide- [glide.js]上方的 vue 滑块和轮播组件(https://github.com/glidejs/glide)\n * vue-owl-carousel- [owl carousel 2]的 vue 组件(https://owlcarousel2.github.io/owlcarousel2/)\n * vueper-slides-适用于 vue js 的易于触摸且响应迅速的幻灯片/轮播。\n * vue-canvas-carousel- [vuc-carousel]的 vue 画布组件(http://vuc.tianchenyong.top/#/carousel)\n * 胡珀-针对 vue 优化的可自定义的可访问轮播滑块\n * 语言-vue 的简单图像库组件，在下面显示带有缩略图的大图像\n * vue-piece-slider-动画幻灯片的碎片化外观\n * vue2-photo-carousel-vue2 的照片轮播组件\n\n\n# 图表\n\n * vue-morris-vuejs 组件包装了 morris.js。\n * vue-charts-适用于 vue.js 的 google charts 插件。\n * vue-chartjs-chart.js 的 vue.js 包装器。\n * hchs-vue-charts-基于 chartjs 的 vue2.0 包装器。\n * vue-echarts-vue.js 的 echarts 组件。\n * vuetrend-vue.js 的简洁优雅火花线。\n * vue-highcharts-vue 的 highcharts 组件。\n * vue-echarts-v3-echarts.js(v3.x +)的 vue.js(v2.x +)组件包装。\n * vue-chartist-chartist 的 vue.js 2.0 组件包装。\n * g2-vue-用于在 vue 组件中轻松使用 g2 的工厂包装。\n * vuebars-适用于 vue.js 的简洁优雅的火花棒。\n * vue-d3-network-使用 d3-force 绘制网络图形的 vue 组件\n * vue2vis- visjs的 vue2 包装器。\n * vue-c3-用于 c3 图表的可重用 vue 组件\n * vue-d2b-d2b 图表的 vue 组件。(包括轴，饼图，sankey 和森伯斯特图)\n * vuechart-一个非常简单的 chart vue 包装器。\n * vue-chartkick-用一行 vue 创建漂亮的 javascript 图表\n * d3vue-用于在 vuejs 中创建反应性数据可视化的 d3 插件\n * vue2-frappe-vuejs 的 frappe charts 的简单包装\n * vue-google-charts-google charts lib 的反应性 vue.js 包装器\n * vue-graph-数据可视化库，用于 vue.js 中的仪表板实现\n * vue.d3.sunburst-基于 d3.js 的反应性旭日形组件\n * v-chart-plugin-一个可定制的组件，用于添加绑定到组件数据的 d3 图表。\n * vue-jqxchart-具有饼图，气泡，甜甜圈，线，条，栏，面积，瀑布，极地和蜘蛛系列的制图组件。\n * toast-ui.vue-chart- [toast ui 图表]的 vue 包装器(http://ui.toast.com/tui -图表/)。\n * vue-apexcharts- [apexcharts]的 vue.js 组件(https://github.com/apexcharts/apexcharts.js)。\n * vue-doughnut-chart-vue.js 的甜甜圈图组件。\n * v-charts-基于 vue2.x 和 echarts 的图表组件。\n * vue-css-donut-chart-用于绘制纯 css 甜甜圈图的轻量级 vue 组件。\n * vue-trend-chart-vue.js 的简单趋势图\n * vueplotlib-声明性，交互式，链接的绘图组件\n * vgauge-gaugejs 的 vue 包装器-创建漂亮的量规\n * vue-plotly- plotly.js声明性图表库的包装，随附 20 图表类型，包括 3d 图表，统计图和 svg 地图。\n * vue-funnel-graph-js-vue.js 的漏斗图绘制库。创建垂直和水平动画 svg 漏斗图，并添加标签，值，图例和其他信息。\n * pure-vue-chart-在没有任何图表库相关性的情况下实现的轻量级 vue 图表\n\n\n# 时间\n\n * vue-timeago-vue 的一个很小的 timeago 组件。\n * vue-moment-jalaali-针对您的 vue.js 项目的 jalaali moment.js 过滤器。\n * vue-countdown-timer-添加了时区转换支持。\n * vue-analog-clock-range-显示时差的模拟时钟范围。\n * vue-moment-lib-使用相同的 momentjs api 的简单 vue.js 2.0 momentjs 库(过滤器和全局变量)。\n * vuejs-countdown-适用于 vue js 2.0 的简单倒数计时器组件\n * vue2-flip-countdown-vue 2.x 具有倒转效果的倒数计时器\n * timeline-vuejs-vue 的简约时间表\n * vue-awesome-countdown-vue 2.5.0+具有高性能和高精度的倒计时插件。官方网站：https://vac.js.org\n * vue-clock2-显示 vue 的时钟组件。\n * vuemodoro-pomodoro 计时器作为单个文件 vue 组件。\n\n\n# 日历\n\n * vue-fullcalendar-vue 日历 fullcalendar。无需 jquery。安排事件管理。\n * vue-event-calendar-vue2 的简单事件日历，除 vue2 外没有其他依赖项。\n * vue-calendar-picker-用于事件显示，时段选择和日期选择器的轻量级日历组件。\n * vue-lunar-calendar-农历的 vue 组件。使用 moment.js 进行日期操作。\n * vue-simple-calendar-基于 flexbox 的 vue 月历功能；支持多日活动，本地化，节日表情符号，拖放。没有依赖关系。\n * vue2-calendar-一个简单的完整日历组件，旨在灵活而轻巧。\n * vue-jlunar-datepicker-具有节日和节气的中国农历日期选择器组件。\n * vue-full-calendar-vue 1 和 2 的完整fullcalendar.io包装器\n * v-calendar-动画日历/日期选择器，显示简单和重复日期的区域，指标和日弹出窗口。\n * vue-infinite-calendar-vue 2 的简单无限日历实现\n * vue-calendar-适用于 vue 2.1.5+的简单日历组件，支持自定义内容。没有依赖关系。\n * vue2-event-calendar-vue2 的事件日历，支持自定义事件项和日历标题。\n * vue2-datepicker-infinite-vue2 的无限 datepicker，易于使用且没有依赖性。\n * vue2-slot-calendar-vue 2 日历，支持月球或日期事件的日期选择器组件，引导程序样式。\n * quasar-calendar-使用 quasar 框架的 vue.js 日历，可实现每月，多天和议程视图。\n * vue2-datepicker-vue2 的漂亮 datepicker / datetimepicker 组件\n * vue-pikaday- pikadaydatepicker 的 vuejs 包装器组件\n * vue-tuicalendar- tui.calendar日历的 vuejs 包装器组件\n * vue-jqxscheduler-vuejs scheduler 组件。\n * toast-ui.vue-calendar- [toast ui 日历]的 vue 包装器(http://ui.toast.com/tui -日历)。\n * vue-functional-calendar-基于 vue 的轻量级高性能日历组件(日期选择器，日期范围)。\n * vue-cal-vue js 完整日历，无依赖项，无 bs。🤘。\n * vue-draggablecal-不是普通的日期选择器。一个 vuejs 可拖动的日期选择器，具有全新的响应式设计，可移动使用且具有 0 个依赖项，已压缩 17kb\n * vue-material-year-calendar-vue2 的全年(每页 12 个月)日历。使用 dayjs。\n * vuelendar-用 vuejs 编写的简洁日历\n\n\n# 地图\n\n * vue2-google-maps-google maps 组件，用于带有 2 向数据绑定的 vue。\n * vue2-leaflet-传单地图的 vue 2 组件。\n * vue-mapbox-gl-mapbox gl js 的 vue 2.x 组件\n * vue-yandex-maps-yandex maps 的 vue 2.x 组件\n * vue-baidu-map-百度地图的 vue 2.x 组件。\n * vue-choropleth-vue 2.x 组件，用于显示一个 choropleth 贴图。\n * vuelayers-vue 2 组件可与 openlayers 一起使用。\n * vue-googlemaps-vue 2.x 组件，用于集成 google maps。\n * vue-static-map-vue 2.x 简单组件，可生成静态 google 地图\n * vue-mapbox-mapbox gl js 库周围的 vue 2.x 包装器，提供了与地图交互的途径。\n\n\n# 音频视频\n\n * vue-aplayer-：cake：用于 vue 2.x 的易于配置的音乐播放器。\n * vue-audio-音频标签包装器；vue 2.x 的声音播放器组件\n * vue-dplayer-基于 dplayer 的 vue 2.x 视频播放器组件。\n * vue-canvasvideo-一个 vue 2.x 组件，用于在 ios / safari 上播放视频背景和自动播放视频。\n * vue-music-基于 html5``的 vue 组件。\n * vue-audio-visual-vue html5 音频可视化组件。\n * vue-plyr-一组用于 plyr 视频和音频播放器的 vue 组件。\n * v-playback-一个 vue2 插件，可简化视频播放。\n * vue-audio-recorder-vue.js 的音频记录器。它允许在服务器上创建，播放，下载和存储记录\n * vue-video-section-vue 的简单视频标头/部分组件。适用于视频背景并在其上叠加内容。\n\n\n# 无限滚动\n\n * vue-infinite-loading-适用于 vue.js 1.0 和 vue.js 2.0 的无限滚动插件。\n * vue-mugen-scroll-vue.js 的无限滚动组件 2。\n * vue-infinite-scroll-vue.js 的无限滚动指令。\n * vue-loop-vue.js 2 的无限内容循环组件。\n * vue-scroller-vue.js 2 的无限内容循环组件，包括诸如“拉动刷新”，“无限加载”之类的功能，'snaping-scroll'。\n * vue-infinite-list-无限列表 mixin 可以为 vue.js 2 回收 dom\n * vue-infinite-slide-bar-∞ 无限滑动条组件。\n * vue-virtual-infinite-scroll-基于 iscroll 的 vue2 组件，支持具有高性能滚动，无限负载和拉动的大数据列表刷新。\n\n\n# 拉动刷新\n\n * vue-pull-refresh-拉动刷新 vue.js 2.0 的组件。\n * vue-pull-to-下拉刷新和上拉为 vue.js 组件加载了更多内容并无限滚动。\n * vue-data-loading-另一个用于无限滚动和向下/向上加载数据的组件。\n * vue-quick-loadmore-vue 的下拉刷新和上拉无限滚动插件。\n\n\n# 降价\n\n * vue-markdown-适用于 vue 的强大，高速 markdown 解析器。\n * vue-mavoneditor-基于 vue 的降价编辑器，支持多种个性化功能。\n * vue-simple-markdown-适用于 vue 的简单，高速 markdown 解析器。\n * vue-simplemde- simplemde的包装。不论是初学者还是专家，都可轻松编辑。具有内置的自动保存和拼写检查功能。\n * toast-ui.vue-editor- [toast ui 编辑器]的 vue 包装器(http://ui.toast.com/tui -编辑)。\n\n\n# pdf\n\n * vue-pdf-基于 mozilla 的 pdf.js 的 pdf 查看器\n * pdfvuer-vue 的 pdf 查看器，使用 mozilla 的 pdf.js 和文本支持。演示\n\n\n# 树\n\n * vue.d3.tree-基于[d3.js]的树状视图(https://d3js.org/)\n * vue-json-tree-view-vue.js 的 json 树视图组件。\n * vue-tree-vue.js 2.x 的树组件。\n * liquor-tree-惊人的 vue 树组件\n * vue-trees-ui-基于 vue 的 tree ui。\n * bosket-前端框架(vue，react，angular 和 riot)的树视图组件的集合。\n * plantain-00 / tree-component-一个 reactjs，angular 和 vuejs 树组件。\n * sl-vue-tree-适用于 vue.js 的简单可定制的可拖动树组件\n * vue-draggable-nested-tree-适用于 vuejs2 [@phphe](https://github.com的功能强大的可自定义可拖动树视图组件。 com / phphe)\n * vuejs-tree-高度可定制的 vuejs 树查看器\n * vue-jstree-适用于 vue2 的树形插件，带有漂亮的图标和拖放功能\n * vue-vtree-vue.js 的通用且灵活的树组件\n * vue-json-component-json 树视图，没有依赖项，typescript 支持且易于定制。\n * vue-tree-list-用于树形结构的 vue 组件\n\n\n# 社交分享\n\n * vue-social-sharing-一个 vue.js 组件，用于共享指向社交网络的链接，可与 vue.js 1.x 或 2.x 一起使用。\n * vue-goodshare-用于社交共享的 vue.js 组件，具有精美的按钮设计。简单的安装，丰富的文档，开发人员支持，seo 友好，干净的代码，无需脚本即可快速跟踪页面上的用户活动。使用 vue.js2.x。\n * vue-socialmedia-share-一个 vue.js 组件，用于使用 vue 2.x 共享与社交网络的链接\n * vue-picture-sharesheet-一个 vue 图片共享表组件，受到苹果新闻编辑室中图片共享表的启发\n * vue-twitter-用于嵌入 twitter 小部件(例如时间线，按钮)的 vue.js 组件\n * vue-share-buttons-vue.js 组件，用于在您的项目中放置按钮，您可以共享任何东西\n\n＃＃ 二维码\n\n * vue-qriously-一个 vue.js 2 组件，用于使用 qrious 在 html canvas 上绘制 qr 代码。\n * vue-qart-vue 2.x 用于 qart.js 的指令。\n * vue-qrcode-reader-一个 vue.js 2 组件，可从相机流中检测和解码 qr 码。\n\n\n# 搜索\n\n * vue-fuse-模糊搜索库 fuse.js 的轻量级插件\n * vue-instantsearch-使用algolia创建即时搜索体验的终极工具箱。\n * vue-innersearch-用于 elasticsearch 的 vue.js 包装器\n * reactivesearch-vue-用于使用 elasticsearch 构建数据驱动的应用程序的 ui 组件\n\n\n# 其他\n\n * vue-avatar-vue.js 的头像组件。\n * vue-touch-ripple-vue.js 的触摸波纹组件(1.x〜2.x)。\n * vue-typer-vue 组件，用于模拟用户键入，选择和擦除文本。\n * vue-keyboard-vue 2 虚拟键盘组件。\n * vue-twentytwenty-图像比较组件，可与 vue.js 2.x 一起使用\n * vue-cookie-law-vue.js 2.x 的 cookie 信息插件\n * vue-gravatar-适用于 vue.js 2.x 的简陋的 gravatar 组件\n * vue-clipboard2-一种易于使用的 vue.js 2.x 剪贴板剪贴板绑定\n * vue-flashcard-带有 vue.js 2.x 动画的 flashcard 组件：bulb：\n * vue-truncate-collapsed-一个简单的组件，它会截断文本并为 vue.js 2 添加可点击的“阅读更多/显示较少”。 x\n * vue-kanban-灵活的拖放式看板板组件\n * vue-letter-avatar-vue.js 的简单优雅的字母头像组件\n * vue-highlightjs-使用 highlight.js 突出显示语法\n * v-clipboard-简单，小巧且易于使用的指令将您的模型保存到剪贴板(最小 2kb，无依赖项)\n * vue-invisible-recaptcha-超级简单的 google 隐形 recaptcha 集成\n * vue-embed-embed 组件基于 vue 2.x 的 embed.js，该组件可嵌入表情符号，媒体，地图，tweet，要点，代码，服务和减价。\n * vue-particles-粒子背景的 vue.js 组件\n * vue-uniq-ids-vue.js 2.x 插件，可帮助使用与 id 相关的属性，且无副作用\n * vue-multivue-在同一页面上使用同一类的多个 vue 应用。\n * vue-affix-一个 vue.js 2.x 插件，可在滚动时在窗口中添加元素，类似于 bootstrap affix，但更简单，更智能\n * x-browser-update-vue-一个 vue.js 浏览器更新插件。\n * vue-query-builder-用于使用嵌套条件构建复杂查询的 ui 组件。\n * vue-info-card-一个简单漂亮的卡片组件，带有优美的火花线和 css3 翻转动画。\n * v-offline-简单，小巧且易于使用的 vue 应用程序检测离线和在线事件(最小 390b)\n * vue-word-cloud-词云生成器。\n * vue-flat-surface-shader- vue-flat-surface-shader\n * vue-easteregg-easey 在您的 vue 应用中添加了 easteregg(默认使用 konami 代码)\n * vue-barcode-scanner\n * vue-heatmapjs-用于跟踪和可视化鼠标活动的 vue 指令\n * vue-maze-由 vue.js 组件制作的小巧迷宫游戏\n * vue-drag-verify-这是一个 vue 组件，可以滑动以解锁以进行登录或注册。\n * vue-balloon-vue 组件，用于在页面一角创建固定的，可缩放的容器。与 gmail 中使用的邮件撰写包装类似。\n * vue-sticker-任意方向的贴纸效果\n * v-rating-⭐️ 使用 vuejs 制作的语义 ui 中的评级组件(<500b 压缩，速度非常快)\n * vue-content-placeholders-用于在 vue 中渲染诸如 facebook 之类的伪造(渐进)内容的可组合组件\n * vue-page-designer-vue 组件，用于拖放来设计和构建移动网站。\n * vue-creativecommons-creativecommons.org vue.js 组件库。\n * vue-status-indicator-一个 vue.js 组件，用于将状态指示器显示为彩色圆点。\n * vue-google-adsense-具有 infeed 和 inarticle ads 支持的 vue.js google adsense 组件\n * emoji-vue-vue.js 项目的 emoji😎👌🏻 下拉菜单\n * vue-chessboard-棋盘 vue 组件可加载位置，创建位置并查看威胁。\n * vue-mindmap-用于 mindnode 映射的 vue 组件。\n * v-currency-用于格式化货币的 vue 组件。\n * vue-emoji-picker-高度可定制的 unicode 表情符号选择器 🔥🚀\n * vue-8-puzzle-一个由 vue.js 组件制作的小巧幻灯片益智游戏\n * vue-e164-具有 e.164 标准支持的可自定义电话格式化程序\n * vue-pgn-vue.js 组件，用于以 pgn 格式查看棋牌游戏\n * vue-avatar-editor-使用清晰的用户界面调整大小，旋转并裁剪上传的头像。\n * vue-connection-listener-vue 事件总线插件监听在线/离线更改。\n * vue-sauce-vue 的“查看源代码”指令。\n * vue-prom-vue 承诺包装器组件。\n * 数字键盘-用于移动浏览器的数字键盘。\n * vue-zoom-on-hover-鼠标悬停时图像缩放\n * vue-sensitive-image-vue 组件，可让您快速创建具有最佳数量的所有设备图像源的响应式图像标签。\n * vue-highlight-text-vue 组件，用于突出显示单词的多个实例\n * vue-cast-props-提供了一种将 props 转换为常见数据类型的便捷方法。\n * vue2-heropatterns-一个 vue2 实现，允许您将流行的 hero patterns 添加到任何 div 上\n * vue-link-一个将所有链接都链接在一起的组件(处理外部和内部链接相同)\n * vue-identify-network-⚡️ 识别您的用户正在使用哪种互联网！\n * vue-cloneya-用于克隆 dom 元素的 vue 组件\n * vue-survey-builder-vue.js 应用程序的调查生成器\n * vue-if-bot-一个轻量级的组件，用于基于用户代理向客户端隐藏/显示内容\n * vue-clampy-vue.js(2+)指令，通过在其中包含内容的元素加上省略号来限制元素的内容太长。\n * vue-cookie-accept-decline-在页面上显示带有文字，拒绝按钮和接受按钮的横幅。记住使用 cookie 进行选择。使用创建时的当前选择来发出事件。符合 gdpr 要求。\n * @ lossendae / vue-avatar-vuejs 2.0 的头像组件。\n * vue-text-highlight-vue.js 的文本荧光笔库 💄\n * vue2-hammervue 2.x 的 hammer.js 包装器支持移动触摸。\n * vue-countable-countable.js 的 vue 绑定。提供实时的段落，句子，单词和字符计数。\n * v-show-slide-一个 vue.js 指令，用于将元素上下移动动画：自动滑动。\n * vue-swipe-actions-适用于 vue.js 的 ios 样式滑动操作\n * vue-friendly-iframe-用于创建超快速加载，无阻塞 iframe 的 vue js 组件。\n * vue-beautiful-chat-一个简单而美丽的 vue 聊天组件后端不可知，完全可自定义和可扩展。\n * vue-magnifier-vue.js 2.x 的简单图像缩放/放大组件。\n * vue-highlight-words-vue 组件可在较大的文本正文中突出显示单词。从[react-highlight-words]移植(https://github.com/bvaughn/react-highlight-words)\n * vue-tags-ball-使用此插件创建漂亮的球形标签\n * vue-rippler-用于自定义波纹效果的简单 vue.js 插件\n * vue-contacts-vue 的移动通讯录组件\n * basic-vue-chat-易于使用的 vue.js 聊天\n * vue-resize-text-一个 vue 指令，可根据元素宽度自动调整字体大小。\n * vue-github-profile-一个 vue 组件，用于查看确定的用户的配置文件和存储库\n * vue-niege-🎅 单文件 vue 组件可通过画布添加暴风雪。\n * vue-dynamic-star-rating-高度动态的 vue 明星评分组件，例如 google play 评分 ⭐️⭐️⭐️⭐️⭐️⭐️\n * vue-katex-在 vue.js 中使用 katex 进行数学排版的简单插件\n * vue-canvas-identify- [vuc-identify]的 vue 画布组件(http://vuc.tianchenyong.top)\n * vue-canvas-material- [vuc-material]的 vue 画布组件(http://vuc.tianchenyong.top/#/materia)\n * vue-baberrage-一个基于 vue.js 的简单弹幕插件 😎\n * vue-terminal-ui-🖥terminalui 模拟器 vue：自定义和基本命令\n * vue-command-完全正常工作的 vue.js 终端模拟器\n * vue-ribbon-github 功能区的 vue 组件\n * avatio-avatar-插图化身的 vue 组件- avatio使用\n * vue-jazzicon-用于 vue 的简陋的 jazzicon 组件。\n * vue-star-rating-一个简单的，高度可定制的星级评分组件 ⭐️⭐️⭐️\n * vue-fixed-header-简单且跨浏览器友好的由 typescript 编写的 vue.js 固定标头组件。\n * vue-particle-effect-buttons一个爆发粒子效果按钮组件。\n * vue-insomnia-防止显示屏进入休眠状态(唤醒锁定)。\n * vue-car-plate-keyboard-用于 vuejs 2.x 的汽车牌照号码键盘。能源车牌 🚗🚗🚗)\n * vue-dataflow-editor-vue2 数据流图编辑器\n * cool-emoji-picker-vue 的快速即插即用[tw] emoji picker(用于 twemoji 渲染的+ textarea)组件。\n\n\n# 标签\n\n * vue-tabs-简单的标签和药丸。\n * vue-swipe-tabs-vue.js(vue2)的触摸滑动选项卡组件。\n * vue-tabs-component-一种使用 vue 显示标签的简便方法。\n * vue-k-tabs-具有 gitlab 设计的简单标签组件。\n * vue-tabs-with-active-line-简单的 vue 2 组件，可让您制作带有移动底线的标签\n * vue-tabs-chrome-一个类似于 chrome 的标签的 vue 组件。\n\n\n# 电话号码输入格式器\n\n * vue-phone-number-input-一个漂亮的输入，用于格式化与国家/地区代码有效的电话号码：fire：\n\n\n# 选择器\n\n * vue-smooth-picker-vue 2.x 的平滑选择器组件，例如 ios 本机日期时间选择器。\n\n\n# 发电机\n\n * formschema native-使用 json schema 和 vue.js 生成表单\n * vue-awesome-form-一个 vue.js 组件，就像 json-editor\n * vue-generator-vue 项目的初始路由器和组件。\n * vue-form-json-从 json 生成具有验证和 bulma 样式的 vue 表单\n * form-create-具有动态呈现，数据收集，验证和提交功能的表单生成器，支持 json 数据\n * element-form-builder-使用 json 模式构建 element-ui 表单。\n * ncform-一种非常好的配置生成表单的方式\n * laraform-具有 laravel 支持的 vue.js 的高级表单生成器\n * vue-ele-form-vue dataform，基于 element-ui\n\n\n# 日期选择器\n\n * vue-datepicker- [未维护]具有用于 vue.js 的材质设计的日历和 datepicker 组件。\n * vue2-timepicker- [未维护] vue 2.x 的下拉时间选择器(小时|分钟|秒)，具有灵活的时间格式支持。\n * vuejs-datepicker-一个简单的 vue.js datepicker 组件。支持禁用日期，内联模式，翻译。\n * vuedt- [未维护]疯狂的轻量级(5.5kb！)vuejs 日期和时间选择器组件，动画效果很好，而且没有太多的模糊感。\n * vue-flatpickr-component用于flatpickr日期时间选择器的 vue.js 组件\n * vue-bootstrap-datetimepickervue.js 组件，用于[eonasdan-bootstrap-datetimepicker](https://github.com/eonasdan/bootstrap- datetimepicker /)\n * vue-jalaali-datepicker-vue.js 的 jalaali 日历和日期选择器 2。\n * vue-date-picker-一个受材料设计启发的 vue 日期选择器组件\n * vue-monthly-picker-仅适用于月份和年份选择器的 vue.js 组件\n * vue-hotel-datepicker-响应式日期范围选择器，显示选定的住宿天数，允许自定义入住/退房规则，屏蔽日期，本地化支持等。\n * vue2-persian-datepicker-vue 的真棒波斯 datepicker 组件。کامپوننتانتخابتاریخبرایویو。\n * vue-datetime-vue 的移动友好日期时间选择器。支持日期，日期时间和时间模式，i18n 和禁用日期。\n * vue-rangedate-picker-具有简单用法的范围日期选择器\n * v2-datepicker-基于 vue 2.x 的简单 datepicker 组件。\n * vue-datepicker-local-vue2 的一个漂亮的 datepicker 组件。\n * vue-airbnb-style-datepicker-vue datepicker，外观和功能与流行的 airbnb datepicker 相似。轻巧，可配置且良好的浏览器支持！\n * vue-persian-datetime-picker波斯材料 datepicker。支持日期时间，日期，时间，年，月。\n * vcalendar非常可定制且功能强大的日历/日期选择器组件，具有许多功能和完善的文档。\n * @ owumaro / vue-date-range-picker-使用 bootstrap 4 样式进行日期范围选择的 vue 组件\n * vue-datepicker-mobile-适用于 vue2 的移动友好日期选择器。：cn：选择日期或日期范围，然后自定义所需的日期。\n * vue-draggable-cal-不是普通的日期选择器。一个 vuejs 可拖动的日期选择器，具有全新的响应式设计，可移动且具有 0 个依赖项，已压缩 17kb。\n * vue-vanilla-datetime-picker-vue 的日期时间选择器。\n * vue2-daterange-picker-基于 bootstrap-daterangepicker 的 vue2 日期范围选择器(无 jquery 依赖性)\n * vue-timeselector-完全简单可定制的 vue.js 功能强大的时间选择器组件。\n * vue-date-picker-vue 2.x 的轻量级 datepicker 组件。\n * vue-ctk-date-time-picker-一个漂亮的 vuejs 组件，用于选择日期和时间(使用范围模式)：新：\n * simple-vue2-datetimepicker-一个简单易用的 vue.js 组件，用于日期和时间选择。：新：\n * vue-business-hours-vue 组件，用于在管理面板或仪表板中选择营业时间。\n * material-vue-daterange-picker-vuejs 2.x 的 material design 样式的日期范围选择器，与 vuetify 和友好版本兼容手机。\n * vue-datepicker-具有 vuejs 2.x 的 material design 样式的干净响应式日期选择器。(日期/月/季度&&日期范围选择器)：新：\n\n\n# 选择\n\n * vue-select-一个本地 vue.js 组件，提供与 select2 类似的功能，而无需 jquery 的开销。\n * vue-multiselect-vue.js 的通用选择/多重选择/标记组件。\n * stf-vue-select-最灵活和自定义的选择 vue2\n * vue-select-image-vue 2 组件，用于从列表中选择图像\n * @ riophae / vue-treeselect-具有对 vue.js 的嵌套选项支持的多选组件。\n * @ k186 / pd-select-一个移动 ui 组件，例如 vue 2.x 的 ios 选择器，可以随便定义。\n * vue-dropdowns-如果对 vue2.x 使用对象，则是一种显示选择框的简约且可适应的方法\n * v-cascade-带有 vue 2.x 的层叠选择器的一个可爱组件(支持 pc 和 mobile)\n * vue-multi-select-用于对 vue2 进行选择/多重选择的自定义组件。\n * v-region-一个简单的区域选择器，提供中文行政区划数据。\n * v-selectpage-vue2，分页列表或表格视图的强大选择器，使用标签进行多项选择，i18n 和服务器端资源支持。\n * vue-cool-select-引导程序/材质设计主题，支持广告位，自动填充，事件，验证等。\n * @ myena / advanced-select-具有搜索功能，用于(取消)全选和 bootstrap 3 主题的单/多选择组件\n * @ alfsnd / vue-bootstrap-select-vue 版本的bootstrap-select。\n\n\n# 滑块\n\n * vue-slider-component-vue1.x 和 vue2.x 的滑块。\n * vue-circle-slider-vue2.x 的圆形滑块组件。\n * vue-netflix-slider-像 netflix 的滑块。\n * vue-slide-bar-非常简单的 vue 滑条组件。\n * textra-vue js 插件可滑动文本。\n * vue-knob-control-vue.js 的旋钮控件\n\n\n# 拖放\n\n * vuedraggable-vue 组件允许与 view-model 同步进行拖放排序。基于 sortable.js。\n * vue-dragula-拖放是如此简单，很痛苦。\n * vue2-dragula-vue2 的vue-dragula分支，有很多改进。\n * awe-dnd-具有 vue 的可排序列表指令。\n * vue-draggable-resizable-用于可拖动和可调整大小元素的 vue2 组件。\n * vddl-用于使用 html5 拖放 api 修改列表的 vue 组件，支持 vuejs 版本 1 和 2。\n * vue-drag-drop-html5 拖放 api 的最小且轻巧的包装器。\n * vue-swing-可滑动的卡片界面，如在 jelly 和 tinder 等应用中所见。\n * vue-slicksort-一套无需依赖的混合包，用于动画，触摸友好，可排序的列表\n * draggable-vue-directive-处理任何 vue 组件拖放的简单指令。\n * vue-smooth-dnd-smooth-dnd 库的 vue 包装器。拖放，可分类的库，适用于许多情况。\n * vue-drag-resize-一个无依赖的 vue 组件，用于可拖动和可调整大小的元素，具有高宽比，反应性道具等\n * vue-drag-it-dude-vue2 组件，可让您将对象拖动到任意位置。\n * vue-draggable-vue 拖放库没有任何依赖性。简单易用。\n * vue-nestable-作为 vue 组件制作的简单拖放层次列表。\n * vue-draggable-nested-tree-适用于 vuejs2 [@phphe](https://github.com的功能强大的可自定义可拖动树视图组件。 com / phphe)\n\n\n# 自动完成\n\n * vue-instant-vue 即时可让您轻松为 vue 2 应用程序创建带有自动建议的自定义搜索控件。\n * v-autocomplete-vue.js 的自动填充组件\n * vue-awesomplete-awesomplete 的 vue 包装器\n * vue-auto-complete-vue2 的自动完成。适用于对象或 api 调用。\n * vue-autosuggest-wai-aria 完整的 autosuggest 组件，对渲染和样式进行了完全自定义。\n * v-autosuggest-一个简单的模块化 vuejs 组件，可以自动建议来自动态或静态数据查询的输入。\n * 自动完成-适用于 vue.js 2. *的简单自动完成组件\n * vue-infinite-autocomplete-vue 的 vue 无限-自动完成包装 2。\n * vue-simple-suggest-vue.js 的简单但功能丰富的自动完成组件\n * v-suggest-一个 vue2 插件，用于输入内容建议，支持键盘快速选择。\n * vue-bootstrap-typeahead-使用 bootstrap 4 css 的 vue2 的 typeahead / autocomplete 组件。\n\n\n# 类型选择\n\n * vue-input-tag-vue.js 2.0 输入标签组件。\n * v-distpicker一个灵活，高度可用的区域选择器，用于为 vue.js 2.x 挑选中国的省，市和地区。\n * vue-img-inputervue 2 的优美，高度可定制的 img 类型输入\n * vue-img-previewvue 2 中的图像输入预览组件\n * v-image：相机：用于输入 type = file 的小组件(<1kb，已压缩)\n * @ voerro / vue-tagsinput一个简单的标签输入了带有 typeahead / autocomplete 的 vue.js 2 组件\n * vue-tag-selector-类似于标签的输入。轻巧，可自定义并处理 regex 验证！\n\n\n# 颜色选择器\n\n * vue-color-适用于 sketch，photoshop，chrome 等的 vue 拾色器。\n * vue-swatches-帮助用户选择漂亮的颜色！\n * radial-color-picker-简约的拾色器，着重于尺寸，可访问性和性能。\n * vue-color-picker-board-为人类设计的 vue 拾色器组件！\n * verte-一个完整的 vue.js 颜色选择器组件。\n\n\n# 开关\n\n * vue-switches-具有主题支持的 vue.js 的开/关开关组件。\n * vue-js-toggle-button-vue.js 2.0+切换/切换按钮-简单，漂亮，可自定义。\n * vue-checkbox-radio-一个 vue 组件，可轻松设置复选框和广播输入的样式。\n * vue-enhanced-check-用于重新设计/标记复选框/无线电的 vue 组件，包括切换/切换按钮。\n * pretty-checkbox-vue- [pretty-checkbox 3]的实现(https://lokesh-coder.github.io/pretty- checkbox /)(用于美化复选框和单选按钮的纯 css 库)组件，适用于 vue.js 2.2+。\n * vue2-collapse-vue collapse 是一个灵活的内容切换插件，用于手风琴列表或任何其他有条件的内容呈现。\n * vue-badger-accordion-用于 vue.js 2.0+的 badger 手风琴的包装组件\n * vue-loading-checkbox-具有加载状态的高度可定制的 vue.js 复选框 ui 组件\n * vue-rocker-switch-vue.js 的可自定义翘板开关组件。\n * vue-toggle-btn-高度可定制，易于使用的优雅切换/切换按钮组件\n\n\n# 屏蔽输入\n\n * vue-masked-input-vue.js 的蒙版输入组件。\n * vue-text-mask-用于 react，angular，ember，vue 和普通 javascript 的输入掩码。\n * vue-ip-input-由 vuejs 实现的 ip 输入。\n * vue-numeric-输入字段组件，用于显示基于 vue 的货币值。\n * awesome-mask-基于纯 vanillajs 实现的 mask 指令\n * v-money-货币的微小(<2k 压缩)输入/指令掩码\n * vue-autonumeric-一个 vue.js 组件，包装了很棒的autonumeric输入格式化程序库\n * vue-inputmask-vue.js 指令可将 robin herbots 的 inputmask 库添加到您的输入中(香草 javascript)。\n * vue-input-number-vue.js 2 的自定义输入数字组件。\n * v-unicode-vue 指令通过 unicode 值限制输入。\n * vue-cleave-component- [cleave.js]的 vue.js 组件(http://nosir.github.io/cleave.js /)\n * vue-ip-具有端口和材料设计支持的 ip 地址输入\n * vue-r-mask-具有类似于 javascript 正则表达式的模板的指令。\n * vue-input-code-基于 vue.js 2.0+验证码输入组件。\n * label-edit-受 trello 的启发。单击以显示可编辑的输入并返回值更改。这是 vue 组件。\n * vue-jquery-mask- [jquery mask 插件]的 vue.js v2.x 组件(https://github.com/igorescobar/ jquery-掩码-插件)\n * vue-the-mask-tiny(<2k gzipipped)和 vue.js 的无依赖掩码输入\n * vue-canvas-input- [vuc-input]的 vue 画布组件(http://vuc.tianchenyong.top/#/identify)\n * vue-currency-input-轻松输入 vue.js 的货币格式数字。\n * vue-restricted-input-基于[restricted-input]的 vue.js 输入掩码库(https://github.com/braintree /受限输入)\n\n\n# rtf 编辑\n\n * vue-quill-editor-vue2 的鹅毛笔编辑器组件。\n * vue-mobiledoc-editor-适用于 vuejs 的 mobiledoc 编辑器组件工具包。\n * vue2-medium-editor-vue 2 的 mediumeditor 组件。\n * vue-froala-用于 froala 编辑器的 vuejs 包装器。\n * vue-froala-wysiwyg-froala wysiwig html 编辑器的官方 vuejs 插件。\n * vue-at-vue 的 at.js。\n * vue-wysiwyg轻巧，快速且可扩展的所见即所得编辑器\n * vue-trumbowyg[trumbowyg]的 vue.js 组件(http://alex-d.github.io/trumbowyg/)所见即所得编辑器\n * vue-pell-editor用于pell的 vue.js 组件所见即所得编辑器\n * vue-tinymce-editorvue2 的 tinymce 编辑器组件。\n * vue-mce-vuejs 的 tinymce 编辑器组件。\n * vue2-editor-使用 vue.js 和 quilljs 的 html 编辑器\n * vue-codemirror-vue2 的 codemirror 组件。\n * vue-easy-tinymce-一个简单而强大的软件包，可在 vue.js 项目中轻松使用 tinymce。\n * vue-highlightable-input-输入文字时突出显示和设置样式\n * vue-trix-用于 vue.js 的简单轻巧的 trix 富文本编辑器\n * tiptap-vue.js 的不可渲染且可扩展的 rtf 编辑器\n * toast-ui.vue-editor- [toast ui 编辑器]的 vue 包装器(http://ui.toast.com/tui -编辑)。\n * ckeditor5-vue-vue.js 的官方 ckeditor 5 rich text 编辑器组件。\n * yimo-vue-editor-vue2 的 wangeditor2 组件。\n * vue-mathlive适用于 vue.hjs 的 mathlive 数学编辑器(mathfield)\n\n\n# 图像处理\n\n * vue-core-image-upload-一个用于裁剪和上传图像的 vue 插件。\n\n * vue-croppa-适用于 vue 2.0 的简单易用的可自定义轻量级移动友好图像裁剪器。\n\n * vue-cropper-vue2.0 的图片剪辑插件\n\n * toast-ui.vue-image-editor- [toast ui 图像编辑器]的 vue 包装器(http：// ui。 toast.com/tui-image-editor)。\n\n * vue-quick-cropper-vue 移动头像上传裁剪插件可以选择裁剪区域和缩放。\n\n * vue-canvas-image-vue 画布组件，用于vuc-image\n\n * vue-croppie-另一个图像裁剪器\n\n * vue-slim-cropper-💇vue 2.x 的简单优雅的移动图像裁剪上传组件。\n\n * vue-advanced-cropper-先进的裁剪器，使您有机会创建几乎任何想要的裁剪器\n\n * vue-cloudinary-vue(2.0)插件提供了可重用的指令，可通过动态操作从 cloudinary(https://cloudinary.com)获取图像(调整大小/裁剪/效果/水印/缩放/格式化)和优化(webp / png /自动质量/自动视网膜)。\n\n * img-vuer-vue2 的 mobile-first 图像查看器/图库\n\n * vue-image-loader-vue 加载器/渐进式图像插件，例如 medium。\n\n * vue-load-image-在图像加载期间显示加载器，并在图像加载失败时显示替代内容。\n\n * vue-image-painter-v vue 2.x 的图像魔术动画绘制效果组件。\n\n\n# 视频操作\n\n * vue-playlist-轻量级的 vue(2.0)组件，没有依赖关系，可提供真正无缝的 html5 视频播放。使用 vanilla js 进行无缝视频播放的唯一且唯一可行的解 决方案。它需要一系列视频并将它们拼接在一起成为一个视频。\n\n＃＃ 上传文件\n\n * vue-clip-用于 vuej 的简单且可入侵的文件上传器。支持 vue> = 2.1。\n * vue-simple-upload-vue.js 的简单文件上传组件。\n * vue2-multi-uploader-使用 vue.js v2 和 axios 的拖放式多文件上传器组件。上载器显示文件名，大小和添加文件的总大小。它还允许设置所需的最小文件上传数量。\n * vue-dropzone-dropzone.js 的 vue.js(vue2)组件-具有图像预览功能的拖放文件上传实用程序。\n * vue-transmit-一个纯粹的基于 vue 2.0 的 dropzone.js 的 vue.js 拖放上传器组件\n * vue-upload-component-vue 上载组件，多文件上载，上载目录，拖动上载，拖动目录。支持 vue> = 2.0\n * vue-uploader-一个由 simple-uploader.js 驱动的 vue.js 上传组件\n * ic-firebase-uploader-用于 firebase 存储的干净的多文件上传组件。\n * vuejs-uploader-用于大型文件上传的可恢复的分段文件上传器。\n * vue-filepond-filepond 的 vue.js 组件-文件上传库，可以上传您扔给它的任何内容。\n * v-uploader-一个 vue2 插件，可以使上传文件变得更加轻松简单，您可以拖动文件或在对话框中选择文件进行上传\n\n\n# 上下文菜单\n\n * vue-context-menu-vue js 的上下文菜单组件。\n * vue-lil-context-menu-vue 的灵活的 lil 上下文菜单组件。\n * vue-mouse-menu-适用于 vue 2+的鼠标菜单组件。\n * @ hscmap / vue-menu-vue2 的菜单/上下文菜单组件。\n * vue-context-用于 vue js 的简单但灵活的上下文菜单。\n * vue-simple-context-menu-为 vue 构建的简单上下文菜单组件。左键单击和右键单击都可以很好地工作。\n * vue-context-menu-popup-vue 2 的上下文菜单弹出窗口。右键单击即可工作，也可以通过编程方式触发。\n * @ kiyoaki_w / vue-context-为 vue2 构建的可自定义上下文菜单组件，支持惊人的图标。\n\n\n# 其他\n\n * vue-gmaps-使用 google maps api 搜索地点和地址。\n * vuep-使用实时编辑器和预览渲染 vue 组件的组件。\n * vue-places-places 组件基于 vue 2.x 的 places.js。将任何输入转换为地址自动完成。\n * vue-password-strength-meter-vue.js 中基于 zxcvbn 的密码强度计。\n * vue-float-label-vue.js 的浮动标签模式。\n * vue-longpress-一个 vuejs(2.x)按钮组件，需要您持续按下以确认给定的动作。\n * vue-google-autocomplete-适用于 google maps places api 的 vue.js(2.x)自动建议组件。\n * vue-ip-input-vue.js 2.x 的 ip 输入组件\n * vue-default-value-vue.js 2.x 指令为可编辑元素设置默认值，而不会影响模型状态\n * vue-model-autoset-一个 vue.js 插件，可解决通过 v-model 指令观察动态添加的属性时 vue 的限制\n * vue-submit-ladda 的简单实现([1](http://lab.hakim.se /ladda/)，2)不到 90 行代码，没有任何依赖关系。\n * vue-rate-vue 的费率组件\n * vuetify-google-autocomplete-适用于 google maps places api 的 vuetify 就绪 vue.js(2.x)自动建议组件。\n * vue-ripple-directive-材质纹波效果作为 vue 指令。\n * vue-fab-vue 浮动操作按钮。\n * vue-complexify-来自 jquery.complexify.js 的 vuejs 移植库。\n * vue-mc-vue.js 的模型和集合\n * vue-stars-高度可定制的等级控制(使用星号或其他字符)\n * vue-confirmation-button-可自定义的确认按钮，要求用户在执行操作之前先阅读消息\n * vue-poll-用于投票的 vue.js 组件\n * vue-diagrams-vue.js 的图表组件，受 react-diagrams 启发\n * vue-easy-polls-一个 vue.js 组件，用于创建民意调查，投票和显示结果。它易于实现且易于定制。\n * vue-m-button-vue 的漂亮按钮组件。\n * vue-long-click-用于 vue 的长按(长按)指令库，支持移动设备和台式机。\n * vue-ui-predicate-规则编辑器，通用过滤 ui，vue js 的谓词组件。\n * vue-mobile-detection-vue.js 原型函数this。$ ismobile()会根据布尔值是否返回布尔值用户正在使用手机浏览。\n * vue-input-contenteditable-用于`contenteditable'的 vue 组件包装，具有您通常期望的所有功能。进行漂亮的输入，不受“ input [type ='text']”的限制。\n\n\n# 向导\n\n * vue-form-wizard-基于选项卡的组件，可以代替经典的 bootstrap 和 jquery 表单向导\n * vue-stepper-一个简单的步进器，具有诸如 next，back 和 end 之类的简单动作，可以执行简单的表单。\n * vue-stepper-component-具有 vuex 支持和零依赖性的完全可定制的 stepper 组件。\n\n\n# csv\n\n * vuecsv-来自 json 的简单 csv 下载程序，带有选项模式面板组件。\n\n\n# 评论系统\n\n * vue-comment-grid-💬 使用 css grid 和 firebase rest api + authentication 构建的自适应 vue.js 注释系统插件。\n\n\n# 帆布\n\n * vue-easeljs-对 html5 canvas 元素的数据驱动控制。\n * vue-canvas-effect-vue.js 的简单画布效果集合。\n * vue-konva-vue＆canvas-javascript 库，用于使用 vue 绘制复杂的画布图形。\n * vue-html2canvas-vue mixin 捕获 html 并使用 html2canvas 将其转换为图像。\n * vue-canvas-nest-适用于 canvas-nest 的 vue.js 组件。\n * vue-signature-pad-v vue 签名板组件\n\n\n# 链接预览\n\n * link-prevue-用于生成链接预览的灵活组件。\n\n\n# 游览\n\n * vue-tour-轻巧且可自定义的游览插件\n * vue-page-guide-具有指令的页面游览/指南插件\n\n\n# ui 布局\n\n * vue-waterfall-vue.js 的瀑布布局组件。\n * vueisotope-用于同位素过滤器和分类魔术布局的 vue 组件。\n * vue-grid-layout-vue.js 的可拖动和可调整大小的网格布局。\n * vue-drag-zone-vue.js(2.x)的拖动区域组件。\n * vue-masonry-用于砌体块布局的 vue.js 指令。\n * vue-fraction-grid-基于 flexbox 的 vue.js 响应式分数网格系统。\n * vue-virtual-scroll-list-vue(2.x)组件通过使用虚拟滚动列表支持大数据。\n * vue-virtual-scroller-用于有效滚动大量元素的组件(vue 2.x)。\n * vue-virtualscroll- [vue 2.x]组件用于虚拟滚动内容。\n * vue-inview- [vue 2.x]视口，在输入或离开 dom 元素时获取通知。\n * dnd-grid-具有可拖动和可调整大小的框的 vuejs 网格\n * vue-extend-layout-扩展默认布局或为 vue.js spa 的页面创建自定义布局\n * vue-masonry-css-由 css 驱动的 vue.js masonry 布局组件，无依赖\n * vue-fullpage.js-vue.js 的官方 fullpage.js 组件。\n * vue-virtual-collection-用于有效渲染大型集合数据的 vue 组件。\n * 自动响应-vue-vue 的自动响应网格布局库。\n * vueflex-一个 flexbox 网格系统。\n * v-chacheli-一个 vue.js 组件，用于创建和显示类似于仪表板的自定义网格布局。\n * vue-grid-styled-一组轻量级的功能网格组件，从 react 的grid-styled / jxnblk /网格样式/)\n * 简单网格-用于网格布局的 vue 组件，支持 flex。\n * vue-container-component-受 bootstrap 容器启发的简单容器组件\n * vue-colcade-用于将 colcade 网格布局集成到 vuejs 的小包装。\n * vue-ads-layout-一个小的 vue 组件库，可快速生成带有工具栏，左/右抽屉和页脚的响应式 web 应用程序布局。所有组件都可以固定或相对放置。\n * vue-magic-grid-vue.js 2 的 magic grid 小端口。\n * vue-splitter-pane-一个 vuejs 组件，它以可调节的拆分方式(垂直或水平)呈现两个插槽。\n * splitpanes-一个 vue js 可靠，简单且可触摸的窗格拆分器/缩放器。\n * vue-mock-layout-轻松模拟 vue 应用程序的布局。\n * vue-simple-drawer-带有反弹动画，支持嵌套和自定义主题的小抽屉面板。方向：左/右/上/下\n * vue-grd-用于网格布局的简单，轻巧和灵活的 vue.js 组件。\n\n\n# 自适应\n\n * quasar-framework-类星体框架。使用 vuejs 2 使用相同的代码构建响应式网站，混合移动应用程序(在 android 和 ios 上看起来本机)和 electron 应用程序。\n * vue-material-vue.js 的材料设计。\n * vuetify-vue.js 的材料组件框架 2。\n * muse-ui-vue.js 的材料组件库 2。\n * buefy-基于布尔玛框架的组件。\n * element-ui-用于 web 的 vue.js 2.0 ui 工具包。\n * vue-bulma-components-对 vue 组件轻松使用 bulma 类语法。\n * iview-ui-适用于 web 的 vue.js 2.0 ui 框架。\n * at-ui-vue.js 2.0 使用 ♥ 制作的专门用于桌面应用程序的全新扁平 ui-kit\n * v-semantic-vue 的semantic-ui的实现\n * bootstrap-vue-vue.js 2 的bootstrap-4网格和组件的实现。\n * fish-ui-用于 web 的 vue.js 2.0 ui 工具包\n * zircle-ui-开发可缩放用户界面的前端库。\n * vue-mdc-adapter-根据 mdc 团队[指南]的 vue.js 的材料组件集成(https://github.com/material -components / material-components-web / blob / master / docs / integrating-into-frameworks.md)。\n * material components vue- [material-components-web]的包装器(https://github.com/material-components/material-components-网络)的 vue.js\n * vueface-用于 web 的 vue.js 2.0 ui 组件库\n * vuesax-vue.js 的前端 vue 组件。\n * vuecidity-vue.js 2.0 的 ui 组件框架\n * ant-design-vue-基于 ant design 和 vue 2.5.0 的企业级 ui 组件\n * heyui-(https://www.heyui.top/zh)-适用于 web 的 vue.js 2.0 ui 工具包。\n * carvue.js-ibm 的 vue.js 碳设计系统\n * balmui-vue.js 的下一代 material ui\n * osiris ui-：art：一个 vue.js 2.0 通用响应式 ui 组件库\n * n3-components-使用 vue 2 构建的漂亮 web 组件\n * 碎片 vue-✨ 基于 bootstrap 4 框架的时尚＆ui 组件库。\n * 基础 vue-基于 sap fiori 基础的组件。\n * framevuerk-🚀 快速，响应迅速，无依赖性，基于 vue.js 的方向支持和可配置 ui 框架。\n * @ carbon / vue-@carbon 团队的 carbon design system 组件。\n * nutui-适用于移动网络的 vue.js 2.0 ui 工具包\n * inkline-inkline 是用于 vue.js 的现代 ui / ux 框架，旨在创建完美的响应式 web 应用程序。\n * vue-awesome-mui-用于 web 的 vue.js 2.0 mui 组件\n * mdbootstrap-基于最新的 bootstrap 4 和 vue 2.6.10 的强大 ui 工具包，提供了一组平滑的，响应式页面模板，布局，组件和小部件，以快速构建响应迅速，移动优先的网站和应用。\n\n\n# 手机\n\n * framework7-vue-使用 framework7＆vue 构建功能齐全的 ios 和 android 应用。\n\n * vux- [中文]基于 weui 的 vue ui 组件。\n\n * vue-onsenui-使用 html5 和 javascript 的移动应用开发框架和 sdk。创建美观，高性能的跨平台移动应用程序。基于 web 组件，并提供 angular 1、2，react 和 vue.js 的绑定。\n\n * weex-weex 提供了发布跨平台的功能，因此 web，android 和 ios 应用程序可以使用相同的 api 开发功能。\n\n * weex-eros- [中文] eros 是基于 weex 和 vue 的应用程序解决方案，使您能够使用 vue 的 api，简单快速地开发 vue 中小型应用程序。\n\n * mint-ui-vue.js 的移动 ui 元素。\n\n * vant-来自 youzan 的 vue.js 2.0 移动用户界面。\n\n * cube-ui-vue.js 编写的出色的移动 ui lib 实现 2。\n\n * mand-mobile-基于 vue.js 2 的移动 ui 工具包，专为金融场景而设计。\n\n\n# 组件集合\n\n * vue-mdc-vue.js 的 material components web。\n * keen-ui-用 vue 编写并受 material design 启发的基本 ui 组件的轻量级集合。\n * vue-admin-vue 管理面板框架，由 vue 2.0 和 bulma 0.3 提供支持。\n * vuikit-具有 vue 所有功能的 uikit。\n * uiv由 vue2 实现的 bootstrap3 组件。\n * wffranco / vue-strap-使用 vue.js 2 构建的 bootstrap 3 组件\n * jsmod-vue-pc-适用于 vue 2.0 的高度可扩展的 web 组件\n * guilhermewaess / semvue-使用 vue 2 实现的语义 ui 模块\n * office-ui-fabric-vue-vue.js 的 office ui fabric 实现\n * vuestic-admin-带有自定义组件集合的 vue admin 仪表板。内置 vue 2 和 bootstrap 4\n * 语义 ui vue-vue 的语义 ui 集成\n * vuesax-vue.js 的前端 vue 组件。\n * vue 的基本 js 2-功能齐全的 45+ vue.js 组件，其中包括数据网格，图表，计划程序和图表组件等。\n * banshee-一个几乎没有渲染的 vue ui 组件和实用程序框架，没有 css。\n * vue-atlas-漂亮的 vue 组件库。\n * devextreme vue 组件-65+响应迅速且功能完善的 vue ui 组件，具有可自定义的 material design 和 bootstrap 兼容主题。\n * jqwidgets-70 多个具有 material design 主题的 vue.js 2.0 ui 组件。\n * vue-uix-vue.js 中用于网页实现的 ui 集合\n * vuedarkmode-vue.js 的极简暗设计系统 🎨\n * kendo vue 用户界面–为业务应用程序构建的 70 多个 ui 组件，包括网格。对多种设计语言(包括材料设计和 bootstrap)的支持完全响应。\n * vuent-实现 microsoft fluent design 的 vue.js 组件\n * bpit / vue-专注于效果的 vue 组件库\n * vue-tailwind-具有可自定义类的 vue 组件可用于 tailwindcss，但与任何框架兼容。\n\n\n# 管理模板\n\n * iview vue 管理员-iview vue 管理员/基于 iview 2.x 的管理门户模板\n * element vue admin-element vue admin /基于 element ui 2.x 的管理门户模板\n * vue-element-admin-基于 element ui 2.x 的神奇 vue 管理员\n * d2 管理员-vue 制作的优雅后台模板在线演示\n * rest-admin-基于 vue 和 bootstrap 4 的 restful 管理面板在线演示\n * shards dashboard lite vue-✨ 现代管理模板，具有数十个自定义组件和模板。\n * vue 材质管理员-vue 材质设计管理员模板\n * element-admin-使用 vue cli 3 和 element-ui 的简单而强大的 vue 管理员。\n\n\n# 服务器端渲染\n\n * nuxt.js-通用的 vue.js 框架。\n * ream-用于构建服务器呈现的静态网站的简约框架。\n * universal vue-vue cli 插件，可轻松创建通用 vue 应用程序\n\n\n# 静态网站生成器\n\n * vuepress-简约的 vue 驱动的静态网站生成器。\n * peco-人类的静态网站生成器。未维护\n * sabre-一个静态网站生成器，用于使用 vue.js 构建快速的网站。\n * gridsome-使用 vue.js 构建超快速，现代化的网站\n\n\n# 其他\n\n * app-framework-具有 html 和 javascript 的 ios 和 android 应用程序-开发，构建和部署-免费和开源。\n * myfirebase-一种已解耦的单页应用程序框架，该框架与 google firebase 高度兼容。\n * vue-access-control基于 vue.js 的前端访问控制框架 2。\n * basys工具箱，用于构建完整的 vue.js 应用程序\n * cabloyjs基于 koajs＆eggjs＆vuejs＆framework7 的终极 nodejs 全栈业务开发平台\n\n\n# 事件处理\n\n * vue-shortkey-vue-shortkey-vue.js 的插件。\n * vue-throttle-event-基于 requestanimationframe 的油门事件。\n * vue-waypoint-vue 的 waypoint 组件，这是滚动时触发功能的最简单方法。\n * vue-clickaway-可重用的 vue.js 组件的可重用 clickaway 指令。\n * vue-scrollfire-在特定的滚动位置触发事件。\n * vue-resize-directive-vue 指令可检测具有去污和节流能力的调整大小事件。\n * v-click-outside-vue 指令对元素外部的点击做出反应，而不会停止事件传播。\n * vue-outside-events-vue 2.x 指令可帮助指定元素侦听发生在自身外部的特定事件。\n * vue-selectable-vue 1.x / 2.x 指令可通过鼠标选择项目。\n * vue-click-helper-vue2.x 指令可处理同一元素上的 click 事件和 dblclick 事件。\n * v-hotkey-vue 2.x 指令，用于将热键绑定到组件。\n * vue-resize-vue 2.x 组件可检测 dom 元素的大小调整(基于事件/无 window.onresize)\n * vue-observe-visibility-使用 intersection observer api 的 vue 2.x 指令可检测元素是否可见(在视口中是否被隐藏) css)。\n * v-dragged-用于拖动事件检测的 vue 2.x 指令插件。\n * vue-esc-vue.js 指令，可在转义键盘上添加文档事件监听器。\n * vue-global-events–使用 vue 的事件修饰符处理全局事件(如快捷方式)的组件\n * vue-edge-check–检查浏览器边缘，以防止用`vue-router'滑动边缘时奇怪地触发过渡效果\n * vue-mutation-observer–使用 mutationobserver api 观察 dom 中变化的简单而微小的指令\n * vue-scroll-show–如果用户在滚动后到达该元素，则显示该元素\n * vue-tabevents–其他打开的标签页之间易于通信\n * vue-visibility-trigger-👀 滚动到视图时以声明方式触发方法\n\n\n# 响应式设计\n\n * vue-viewports-定义您的自定义视口，并在组件中使用它们。\n * vue 响应：vue.js(2.x)指令用于隐藏/显示具有 bootstrap 4、3 或自定义断点的 html 元素。\n * vue-match-media-vue 2.x 兼容插件，提供一致，语义化的方法来使组件具有媒体查询意识。\n * vue-media-query-mixin-vue 2 媒体查询 mixin 可以在组件 js 和组件模板中使用。与引导程序和可视化视口兼容。如果屏幕宽度为 xs，则返回 wxs；如果屏幕宽度为 sm，则返回 wsm。\n * vue-breakpoints-vue 2 最小组件，用于显示和隐藏基于断点的元素。受到 airbnb 的启发。\n * vue-mq-提供一些有用的工具，以语义和移动优先的 api(vue 2.x)快速设置响应式设计\n * vueresizesensor-支持调整大小事件的容器。\n * vue-breakpoint-component-用于 组成 css 断点状态。\n * fine-mq-一个很好的 api，可以轻松地管理 js 中的媒体查询，并且可以与 vuejs 作为插件进行一流的集成。\n * vue-response-components-使用resizeobserver创建响应组件。\n * vue-screen-size-可以轻松，被动地访问屏幕的宽度和高度。\n\n\n# 验证\n\n * vue-formly-javascript 支持的 vue.js 表单。\n\n * vue-focus-用于可重用 vue.js 组件的可重用 focus 指令。\n\n * vue-form-generator-vue.js 的基于架构的表单生成器组件。\n\n * formschema native-使用 json schema 和 vue.js 生成表单\n\n * ic-formly-由 vue-formly 提供支持的简单表单组件。\n\n * 表单生成器-基于 json 模板的表单生成器，基于 vue 和 laravel。\n\n * vue-autofocus-directive-vue 自动聚焦指令。\n\n * vue-awesome-form-一个 vue.js 组件，就像 json-editor\n\n * vue-form-components-带有验证的干净＆最小化 vue 表单元素\n\n * ncform-一种非常好的配置生成表单的方式\n\n * vee-validate-简单的 vue.js 输入验证插件。\n\n * vue-rawmodel-vue.js v2 的 rawmodel.js 插件。表单验证从未如此简单。\n\n * vuelidate-针对 vue.js 的简单，轻量级基于模型的验证。\n\n * simple-vue-validator-一个简单而灵活的 vue.js 验证器库。\n\n * vue-vform-vue.js 2 表单组件，集成了 jquery 验证和 axios。\n\n * vue-form-vue.js 的全面表单验证。\n\n * vuelidation-简单，功能强大的 vuejs 验证。\n\n * laravel-vue-validator-显示来自 laravel 验证规则的错误\n\n * vue-daval-超级 vue 数据验证器。简便，简单，准确。\n\n * willvalidate-vue.js 的验证表单。\n\n * vue-m-validator-用于 vuej 的模型数据验证库。\n\n * vue-isyourpasswordsafe-用 vue 编写的小型实用程序，用于检查给定的密码是否已针对“我已被拥有” api 泄漏。\n\n * vue-form-send-用于从表单和原始验证发送数据的 vue.js 指令\n\n * formvuelar-考虑服务器端验证的 vue 表单组件\n\n * vue-final-validate-根据我的开发经验，vue 验证解决方案支持嵌套，异步。\n\n * vform-一种在 vue 中处理 laravel 后端验证的简单方法。\n\n\n# 调整大小\n\n * vue-not-visible-vue 指令，用于从屏幕上小于断点的 dom(如 v-if)元素中删除。\n * vue-window-size-提供反应性窗口大小属性。\n * vue-sensitive-text-↔ 相对于其父节点的宽度缩放其子节点的组件\n\n\n# 滚动\n\n * vue-chat-scroll-vue.js 2.0 的自动滚动至底部指令。\n * vue-scrollto-添加了一个指令，该指令侦听单击事件并滚动到元素。\n * vue-next-level-scroll-一种基于组件且支持 ssr 的方法，可使用现代 scroll behavior api 进行平滑滚动\n * vue-scroll-sync-同步容器滚动位置的组件\n * v-scroll-lock-用于正文滚动锁定而不中断目标元素滚动的 vue.js 指令\n * vue2-perfect-scrollbar-perfectscrollbar 简约包装器\n * vue-scroll-to-添加了一个指令，该指令侦听单击事件并滚动到元素。\n * vue-scroll-progressbar-可自定义的组件，用于指示进度条中滚动的相对位置。\n * vue-backtotop-vue.js 的 back-to-top 组件，单击该组件可将页面滚动到顶部。\n * vbar-适用于 vue.js 2x 的虚拟响应式跨浏览器滚动条组件。\n * vuebar-使用本地滚动行为的自定义滚动条的 vue 2 指令。轻巧，高性能，可定制且无依赖性。\n * vue-detached-scrollbar-一个简单的滚动条，可以从正在滚动的容器中分离出来。\n * vuescroll-基于 vue.js 的滚动插件，用于统一 pc 和移动设备中的滚动。\n * vue-simplebar-simplebar 插件的 vue.js 包装器。\n * smooth-vuebar-平滑滚动条的 vue 指令包装\n * vue-scrollview-一个组件，该组件利用作用域的插槽来检测 vue 组件何时进入和离开视口。\n * vue-scrollactive-根据视口中的当前部分在菜单项中添加一个活动类，单击菜单项时也会滚动到该部分。\n * vue-intersect-一个 vue 组件，用于向 vue 组件或 html 元素添加交集观察者。\n * vue-scrollmonitor-一个 vue 插件，可在支持多种浏览器的情况下观看视口内部元素的可见性状态(使用提供/注入，因此兼容 vue@2.2 。x)\n * vue-stroll-适用于 vue.js 2.x 的超棒 css3 列表滚动效果组件。\n * navscroll-js-在滚动时突出显示菜单项，并且在单击菜单项时也会滚动到某个部分。用作 vue 组件，vue 指令或与 vanilla js 一起使用。\n * vue-scrollwatch-一个轻便的插件，可检测滚动事件，在元素进入视口时自定义回调，将'scrollto'api 暴露给特定元素。使用 vue 指令。\n * vue-check-view-一个检查元素是否在视口中的插件。快速，小型，无依赖性，实时演示。\n * vue-stickto-支持多个 dom 节点的 vue 指令会自动粘贴到顶部\n * vue2-scrollspy-一个 scrollspy 插件和动画滚动到。\n * vue-scroll-behavior-自定义路线导航中的滚动行为。特别是哈希模式。\n * vue-scroll-stop-到达边缘时停止传播滚动。\n * vue-seamless-scroll-vue.js 的简单无缝 滚动。\n\n\n# 路由\n\n * vue-router-vue.js 的官方路由器。\n * vue-router-storage-vue.js 2 和 vue-router 2 的路由器存储和解决方案\n * vue-tidyroutes-分散的 vue-router 路由定义\n * vue-routisan-基于 laravel 路由系统的 vue 路由器的优雅路由定义\n * vue-error-page-提供路由器视图的包装器，使您可以显示错误页面而不更改 url\n * vue-router-sitemap-通过 vue-router 配置生成 sitemap.xml\n * vue-smart-route-智能路由指令，可使用 vue.js 制作具有智能外观的应用程序。\n * vue-router-lite-vue.js 2 的基于组件的声明性路由器。\n\n\n# 延迟加载\n\n * vue-lazyload-一个 vue.js 插件，用于将图像或组件延迟加载到应用程序中。\n * vue-lazy-background-images-延迟加载 vue 2 的背景图像。\n * vue-progressive-image-vue 渐进式图像加载插件。\n * vue-l-lazyload-vue.js v2.x +的 lazyload 插件。\n * vue-lazyload-img-专门针对移动浏览器进行了优化。支持 v2 和 v1。\n * vue-lazy-images-vue 2.x 的 lazyload 图像插件。\n * v-lazy-img-tiny(<0.6kb)指令，用于 vue 2 的渐进式图像加载。\n * vue-clazy-load-使用 intersecionobserver for vue 2 的轻量级可转换图像延迟加载组件。\n * vue-lazy-this-使用 intersection observer api 的延迟加载组件。\n * v2-lazy-list-一个基于 vue 2.x 的简单的延迟加载列表组件\n * pimg-一个用于延迟加载图像的简单渐进图像组件。\n * vue-tiny-lazyload-img-用于延迟加载图像的小尺寸 vue.js v.2 +指令\n * vue-lazy-youtube-video-一个用于延迟加载 youtube 视频的简单 vue.js 组件。\n * lazyload-vue-适用于 vanilla-lazyload 的 vue 插件。\n\n\n# 分页\n\n * vue-paginate-一个简单的 vue.js 插件，可对数据进行分页。\n * vue-pagination-2-vue.js 2 分页组件。\n * vuejs-uib-pagination-适用于 vue.js 的最佳，完整的分页插件。受角引导分页启发。\n * vuejs-paginate-用于创建分页的 vue.js(v2.x +)组件。\n * vue-pagination-bootstrap-一个 vue.js(1.x＆2.x)服务器端分页组件，带有基于 bootstrap 的模板\n * laravel-vue-semantic-ui-pagination-与 laravel 和 semantic-ui 一起使用的 vue.js 2.x 分页。\n * vue-paginate-al-vue 分页并返回您的数据。\n * vue-tiny-pagination-用于创建微小分页的 vue 组件。\n * laravel-vue-pagination-适用于 laravel 分页器的 vue.js 分页组件，可与 bootstrap 一起使用。\n * vue-lpage-低级 vue 分页组件。\n * v 页-一个简单的分页栏，包括基于 vue2.x 的长度菜单，i18n 支持。\n * vue-smart-pagination-具有许多不错设置的任何数据的智能分页。\n * vue-paginatron-分页组件使用范围插槽道具构建，具有最大的灵活性。\n * vue-ads-pagination-使用 css 框架[tailwindcss](https://tailwindcss.com/docs/what -is-tailwind /)\n\n\n# 动画\n\n * vue2-animate-animate.css 的 vue.js 2.0 端口。与 vue 的内置转换一起使用。\n * animated-vue-一个 vue.js 2.x 插件，可轻松使用 animate.css 动画作为过渡。就像``一样简单！\n * vue-lottie-一个 vue.js 2.x 插件，用于基于 bodymovin 渲染特效动画\n * vueg-使 vue-router 具有过渡效果/为 webapp 提供转场特效的开源 vue 插件\n * v-animate-css-最容易实现 animate.css 的 vue 2 指令\n * vue-mixin-tween-mixin 工厂，它将补间值添加到动画的组件上下文中\n * v-odometer-轻松平滑地转换数字。使用此库可为您的应用程序提供平滑的动画，仅适用于数字。\n * vue2-transitions✨ 可重复使用的 vue 2 过渡组件\n * vue-overdrivevue 应用程序的超级简单的魔术移动过渡 🎩\n * animated-number-vue超级简单的数字动画方法。\n * vue-typed-js集成了 typed.js，可轻松创建打字动画。\n * vue-parent-change-transition启用子组件在更改父组件时进行动画处理。\n * vue-smooth-reflow响应数据变化而转换元素重排。\n * vuetween允许组件补间其属性。\n * vue-slide-up-down就像 jquery 的slideup /slidedown一样，但是对于 vue！\n * vue-animejsvue 的简单anime.js指令。\n * eagle.jseagle.js 是 vue.js 的基于 web 的幻灯片框架。\n * vue-posepose for vue 是一个声明式运动系统，结合了 css 过渡的简单性和 css 的强大功能和灵活性 javascript。\n * vue-slide-up-down-component这是一个简单的界面，但是实现了非常灵活而强大的幻灯片动画 vue！\n * femtotween具有一流 vue 支持的简约(零深度，小于 1k)补间库\n * vue-sequential-entrance插件，用于创建带有页面元素列表的优雅的连续动画入口。零努力。简单轻巧\n * vue-animate-scroll一种超级轻量级 的方法，可在元素滚动到视图中时向其添加 css 动画。\n * vue-svg-transition创建 2 状态，svg 驱动的过渡\n * vue-page-transitionvue.js 的简单路由/页面转换\n\n\n# 元标记\n\n * vue-head-管理 head 标签的元信息，一种简单的方法。\n * vue-meta-在 vue 2.0 组件中管理页面元信息。支持 ssr +流媒体。\n * vue-headful-从视图中设置文档``和 meta 标签。\n * vue-simple-headful-使用 vue.js 轻松设置元标记-具有 typescript 支持的更简单的vue-headful替代方法。\n\n\n# 传送门\n\n * vue-dom-portal-vue.js 组件中 dom 元素的转义口。\n * portal-vue-一个 vue 插件，用于在 dom 中的任何位置渲染组件的模板(在 virtualdom 级别上有效，不会在 dom 中移动节点)\n\n\n# 过滤器\n\n * vue2-filters-适用于 vue 2. *的标准过滤器 vue 1. *的集合。\n * vue-morphling-vue 2 的标准和自定义过滤器的集合。\n * vue-currency-filter-轻巧且可自定义的 vue 2 货币过滤器。\n * vue-trans-一个简单的过滤器，提供了与 symfony trans 相似的翻译方式。\n * vue-string-filter-轻量级 vue 2 字符串处理过滤器。\n * vue-units-在 vue 2 中使用的方便的单位转换过滤器的集合。\n * vue-numeral-filter-过滤器的集合，允许在组件的模板部分内联使用 numeral.js。\n * vue-filter-date-format-vue 2 的简单日期时间过滤器。\n * vue-filter-pluralize-vue 2 的简单复数过滤器。\n * vue-filter-date-parse-vue 2 的简单解析日期时间过滤器。\n\n\n# svg\n\n * vue-svgicon-创建 svg 图标组件的工具。(版本 2.x)。\n * vue-content-loading-vue 组件可轻松构建(或使用预设)facebook 之类的 svg 加载卡。\n * vue-annotator-使用任何 svg 元素(“ rect”，“ polygon”以及其他更多元素，即使包装了 html 元素如“ canvas”，也可以为页面添加注释)在foreignobject中)\n * vue-svg-sprite-简单使用 svg sprite(vue 2.x)的指令。\n * vue-svg-filler-用于自定义 svg 文件 🖍(vue 2.x)的 vue 组件。\n\n\n# 其他\n\n * vue-resource-progressbar-interceptor-将进度条与所有请求联系在一起的拦截器，很明显，正在加载某些东西。\n * vue-images-loaded-vue.js 2.0 指令可检测图像加载。\n * vue-visible-vuejs(2.x)的 v-visible 指令，类似于 v-show 但具有可见性。\n * vue-resize-sensor-用于检测容器大小的组件(基于事件)\n * v-blur-vue 指令动态模糊元素\n * vue-async-methods-用于基于承诺的方法的帮助程序实用程序\n * vue-openseadragon-适用于 vue.js 的 openseadragon 组件(缩放和平移)\n * vue-match-heights-指令将元素的高度设置为相同。\n * vue-conditional-attrs-用于条件渲染属性和指令的 vue.js 组件\n * vue-cbsc-一个 vue.js 2.x 组件，用于以编程方式混合，着色和转换颜色。\n * vue-spatialnavigation-用于空间导航(键盘导航)的 vue 指令(vue.js 2.x)\n * vue-lifecycle-vue.js 生命周期指令。\n * vue-aspect-ratio-vue 的长宽比指令。\n * @ kooljay82 / vue-m-camera-为避免自动更改通过用户设备的相机拍摄的照片方向。\n\n\n# webgl\n\n * vue-3d-model-vue 组件中的 3d 模型查看器。\n * vue-pano-vue 组件中的全景查看器。\n * vue-threejs-three.js 的 vue 绑定。\n * vuegl-vue.js 组件通过 three.js 反应性地渲染 3d 图形\n * vue-vr-使用 vue 构建 vr 应用程序的框架\n * vue-displacement-slideshow-一个 vue.js 组件，可简化 webgl 图像位移转换。\n\n\n# 全屏\n\n * vue-fullscreen-用于全屏的简单 vue 组件。\n\n\n# 页面可见性\n\n * vue-page-visibility-awesome-易于配置的页面可见性 api 的 vue 2.x 组件。\n * vue-authplugin-美观的 auth 控制插件，支持指令和原型方法。\n\n\n# 打印\n\n * vue-html-to-paper-vue mixin 用于将 html 元素打印到纸张上。",charsets:{cyrillic:!0,cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1,description:"",meta:[{name:"twitter:title",content:"归档"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/@pages/archivesPage.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"归档"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/@pages/archivesPage.html"},{property:"og:site_name",content:"Bravo Yeung"},{itemprop:"name",content:"归档"},{itemprop:"description",content:""}]},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-7bb61519",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/20, 04:23:41"},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1,description:"",meta:[{name:"twitter:title",content:"分类"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/@pages/categoriesPage.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"分类"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/@pages/categoriesPage.html"},{property:"og:site_name",content:"Bravo Yeung"},{itemprop:"name",content:"分类"},{itemprop:"description",content:""}]},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-46832679",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/20, 04:23:41"},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1,description:"",meta:[{name:"twitter:title",content:"标签"},{name:"twitter:description",content:""},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/@pages/tagsPage.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"标签"},{property:"og:description",content:""},{property:"og:url",content:"https://dbdgs.cn/@pages/tagsPage.html"},{property:"og:site_name",content:"Bravo Yeung"},{itemprop:"name",content:"标签"},{itemprop:"description",content:""}]},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-3a384e99",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/20, 04:23:41"},{title:"你知道的越多，不知道的也就越多",frontmatter:{title:"你知道的越多，不知道的也就越多",date:"2020-05-06T15:52:40.000Z",permalink:"/known-and-unknown.html",sidebar:"auto",categories:["随笔"],tags:["学习","知识","鸡汤"],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。",meta:[{name:"twitter:title",content:"你知道的越多，不知道的也就越多"},{name:"twitter:description",content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"你知道的越多，不知道的也就越多"},{property:"og:description",content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。"},{property:"og:url",content:"https://dbdgs.cn/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-05-06T15:52:40.000Z"},{property:"article:tag",content:"学习"},{property:"article:tag",content:"知识"},{property:"article:tag",content:"鸡汤"},{itemprop:"name",content:"你知道的越多，不知道的也就越多"},{itemprop:"description",content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。"}]},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html",relativePath:"_posts/随笔/你知道的越多，不知道的也就越多.md",key:"v-0f18a2ab",path:"/known-and-unknown.html",excerpt:"<p>不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。</p>\n",headersStr:null,content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",normalizedContent:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"拥抱生活，拥抱快乐",frontmatter:{title:"拥抱生活，拥抱快乐",date:"2020-06-26T20:40:38.000Z",permalink:"/life-and-happy.html",sidebar:"auto",categories:["随笔"],tags:["鸡汤"],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200626212238.webp"},{name:"twitter:title",content:"拥抱生活，拥抱快乐"},{name:"twitter:description",content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200626212238.webp"},{name:"twitter:url",content:"https://dbdgs.cn/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"拥抱生活，拥抱快乐"},{property:"og:description",content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200626212238.webp"},{property:"og:url",content:"https://dbdgs.cn/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-06-26T20:40:38.000Z"},{property:"article:tag",content:"鸡汤"},{itemprop:"name",content:"拥抱生活，拥抱快乐"},{itemprop:"description",content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200626212238.webp"}]},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html",relativePath:"_posts/随笔/拥抱生活，拥抱快乐.md",key:"v-5d5e3e2b",path:"/life-and-happy.html",excerpt:"<p>生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。</p>\n",headersStr:null,content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",normalizedContent:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"Home",frontmatter:{home:!0,heroText:"大白的故事",tagline:"Web前端技术博客，积跬步以至千里，致敬每个爱学习的你。",features:[{title:"前端",details:"JavaScript、ES6、Vue框架等前端技术",link:"/web/",imgUrl:"/img/web.png"},{title:"页面",details:"html(5)/css(3)，前端页面相关技术",link:"/ui/",imgUrl:"/img/ui.png"},{title:"技术",details:"技术文档、教程、技巧、总结等文章",link:"/technology/",imgUrl:"/img/other.png"}],description:"大白的技术故事，专注于分享IT前沿技术、干货知识、热点资讯等，同时分享硬核的自媒体赚钱方法、推广技巧和运营实战，技术文章涵盖python,dotnet,node.js,git,github等。",meta:[{name:"twitter:title",content:"dbdgs | 大白的故事"},{name:"twitter:description",content:"大白的技术故事，专注于分享IT前沿技术、干货知识、热点资讯等，同时分享硬核的自媒体赚钱方法、推广技巧和运营实战，技术文章涵盖python,dotnet,node.js,git,github等。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"website"},{property:"og:title",content:"dbdgs | 大白的故事"},{property:"og:description",content:"大白的技术故事，专注于分享IT前沿技术、干货知识、热点资讯等，同时分享硬核的自媒体赚钱方法、推广技巧和运营实战，技术文章涵盖python,dotnet,node.js,git,github等。"},{property:"og:url",content:"https://dbdgs.cn/"},{property:"og:site_name",content:"Bravo Yeung"},{itemprop:"name",content:"dbdgs | 大白的故事"},{itemprop:"description",content:"大白的技术故事，专注于分享IT前沿技术、干货知识、热点资讯等，同时分享硬核的自媒体赚钱方法、推广技巧和运营实战，技术文章涵盖python,dotnet,node.js,git,github等。"}]},regularPath:"/",relativePath:"index.md",key:"v-55259a32",path:"/",headers:[{level:2,title:"✉️ 联系",slug:"联系",normalizedTitle:"✉️ 联系",charIndex:2}],headersStr:"✉️ 联系",content:"# ✉️ 联系\n\n * WeChat or QQ: 2719879027\n * Email: 2719879027@qq.com\n * GitHub: https://github.com/dbdgs\n",normalizedContent:"# ✉️ 联系\n\n * wechat or qq: 2719879027\n * email: 2719879027@qq.com\n * github: https://github.com/dbdgs\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"ECMAScript 6 简介",frontmatter:{feed:{enable:!0},title:"ECMAScript 6 简介",date:"2020-01-12T15:45:35.000Z",permalink:"/ecma-script6.html",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:[null],description:"\n说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源http://es6.ruanyifeng.com/，教程版权归原作者所有。\n\nECMAScript 6 简介\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。",meta:[{name:"twitter:title",content:"ECMAScript 6 简介"},{name:"twitter:description",content:"\n说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源http://es6.ruanyifeng.com/，教程版权归原作者所有。\n\nECMAScript 6 简介\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/01.ECMAScript%206%20%E7%AE%80%E4%BB%8B.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"ECMAScript 6 简介"},{property:"og:description",content:"\n说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源http://es6.ruanyifeng.com/，教程版权归原作者所有。\n\nECMAScript 6 简介\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。"},{property:"og:url",content:"https://dbdgs.cn/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/01.ECMAScript%206%20%E7%AE%80%E4%BB%8B.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-01-12T15:45:35.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"ECMAScript 6 简介"},{itemprop:"description",content:"\n说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源http://es6.ruanyifeng.com/，教程版权归原作者所有。\n\nECMAScript 6 简介\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。"}]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/01.ECMAScript%206%20%E7%AE%80%E4%BB%8B.html",relativePath:"《ES6 教程》笔记/01.ECMAScript 6 简介.md",key:"v-283cafc0",path:"/ecma-script6.html",headers:[{level:2,title:"ECMAScript 和 JavaScript 的关系",slug:"ecmascript-和-javascript-的关系",normalizedTitle:"ecmascript 和 javascript 的关系",charIndex:210},{level:2,title:"ES6 与 ECMAScript 2015 的关系",slug:"es6-与-ecmascript-2015-的关系",normalizedTitle:"es6 与 ecmascript 2015 的关系",charIndex:795},{level:2,title:"语法提案的批准流程",slug:"语法提案的批准流程",normalizedTitle:"语法提案的批准流程",charIndex:1756},{level:2,title:"ECMAScript 的历史",slug:"ecmascript-的历史",normalizedTitle:"ecmascript 的历史",charIndex:2184},{level:2,title:"部署进度",slug:"部署进度",normalizedTitle:"部署进度",charIndex:3648},{level:2,title:"Babel 转码器",slug:"babel-转码器",normalizedTitle:"babel 转码器",charIndex:4336},{level:3,title:"配置文件.babelrc",slug:"配置文件-babelrc",normalizedTitle:"配置文件.babelrc",charIndex:4688},{level:3,title:"命令行转码",slug:"命令行转码",normalizedTitle:"命令行转码",charIndex:5176},{level:3,title:"babel-node",slug:"babel-node",normalizedTitle:"babel-node",charIndex:5638},{level:3,title:"@babel/register 模块",slug:"babel-register-模块",normalizedTitle:"@babel/register 模块",charIndex:6011},{level:3,title:"babel API",slug:"babel-api",normalizedTitle:"babel api",charIndex:6406},{level:3,title:"@babel/polyfill",slug:"babel-polyfill",normalizedTitle:"@babel/polyfill",charIndex:7300},{level:3,title:"浏览器环境",slug:"浏览器环境",normalizedTitle:"浏览器环境",charIndex:7791},{level:2,title:"Traceur 转码器",slug:"traceur-转码器",normalizedTitle:"traceur 转码器",charIndex:8118},{level:3,title:"直接插入网页",slug:"直接插入网页",normalizedTitle:"直接插入网页",charIndex:8178},{level:3,title:"在线转换",slug:"在线转换",normalizedTitle:"在线转换",charIndex:9938},{level:3,title:"命令行转换",slug:"命令行转换",normalizedTitle:"命令行转换",charIndex:10679},{level:3,title:"Node 环境的用法",slug:"node-环境的用法",normalizedTitle:"node 环境的用法",charIndex:11158}],excerpt:'<blockquote>\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href="http://es6.ruanyifeng.com/" target="_blank" rel="nofollow noopener noreferrer">http://es6.ruanyifeng.com/<OutboundLink/></a>，教程版权归原作者所有。</p>\n</blockquote>\n<h1 id="ecmascript-6-简介"><a class="header-anchor" href="#ecmascript-6-简介">#</a> ECMAScript 6 简介</h1>\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\n',headersStr:"ECMAScript 和 JavaScript 的关系 ES6 与 ECMAScript 2015 的关系 语法提案的批准流程 ECMAScript 的历史 部署进度 Babel 转码器 配置文件.babelrc 命令行转码 babel-node @babel/register 模块 babel API @babel/polyfill 浏览器环境 Traceur 转码器 直接插入网页 在线转换 命令行转换 Node 环境的用法",content:"> 说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源http://es6.ruanyifeng.com/，教程版权归原作者所有。\n\n\n# ECMAScript 6 简介\n\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n\n# ECMAScript 和 JavaScript 的关系\n\n一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？\n\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。\n\n该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。\n\n因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。\n\n\n# ES6 与 ECMAScript 2015 的关系\n\nECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？\n\n2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。\n\n但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。\n\n但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。\n\n标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。\n\nES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。\n\n因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。\n\n\n# 语法提案的批准流程\n\n任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。\n\n一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。\n\n * Stage 0 - Strawman（展示阶段）\n * Stage 1 - Proposal（征求意见阶段）\n * Stage 2 - Draft（草案阶段）\n * Stage 3 - Candidate（候选人阶段）\n * Stage 4 - Finished（定案阶段）\n\n一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站GitHub.com/tc39/ecma262查看。\n\n本书的写作目标之一，是跟踪 ECMAScript 语言的最新进展，介绍 5.1 版本以后所有的新语法。对于那些明确或很有希望，将要列入标准的新语法，都将予以介绍。\n\n\n# ECMAScript 的历史\n\nES6 从开始制定到最后发布，整整用了 15 年。\n\n前面提到，ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。\n\n2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。\n\n为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。\n\n2007 年 10 月，ECMAScript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。\n\n2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。\n\n2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 委员会的总体考虑是，ES5 与 ES3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是 ES6，第六版发布以后，就指 ES7。TC39 的判断是，ES5 会在 2013 年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。\n\n2011 年 6 月，ECMAScript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。\n\n2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。\n\n2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。\n\n2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。\n\n\n# 部署进度\n\n各大浏览器的最新版本，对 ES6 的支持可以查看kangax.github.io/compat-table/es6/。随着时间的推移，支持度已经越来越高了，超过 90%的 ES6 语法特性都实现了。\n\nNode 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node 已经实现的 ES6 特性。\n\n// Linux & Mac\n$ node --v8-options | grep harmony\n\n// Windows\n$ node --v8-options | findstr harmony\n\n\n1\n2\n3\n4\n5\n\n\n我写了一个工具 ES-Checker，用来检查各种运行环境对 ES6 的支持情况。访问ruanyf.github.io/es-checker，可以看到您的浏览器支持 ES6 的程度。运行下面的命令，可以查看你正在使用的 Node 环境对 ES6 的支持程度。\n\n$ npm install -g es-checker\n$ es-checker\n\n=========================================\nPasses 24 feature Detections\nYour runtime supports 57% of ECMAScript 6\n=========================================\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Babel 转码器\n\nBabel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。\n\n// 转码前\ninput.map(item => item + 1);\n\n// 转码后\ninput.map(function (item) {\n  return item + 1;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。\n\n下面的命令在项目目录中，安装 Babel。\n\n$ npm install --save-dev @babel/core\n\n\n1\n\n\n\n# 配置文件.babelrc\n\nBabel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。\n\n该文件用来设置转码规则和插件，基本格式如下。\n\n{\n  \"presets\": [],\n  \"plugins\": []\n}\n\n\n1\n2\n3\n4\n\n\npresets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。\n\n# 最新转码规则\n$ npm install --save-dev @babel/preset-env\n\n# react 转码规则\n$ npm install --save-dev @babel/preset-react\n\n\n1\n2\n3\n4\n5\n\n\n然后，将这些规则加入.babelrc。\n\n  {\n    \"presets\": [\n      \"@babel/env\",\n      \"@babel/preset-react\"\n    ],\n    \"plugins\": []\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。\n\n\n# 命令行转码\n\nBabel 提供命令行工具@babel/cli，用于命令行转码。\n\n它的安装命令如下。\n\n$ npm install --save-dev @babel/cli\n\n\n1\n\n\n基本用法如下。\n\n# 转码结果输出到标准输出\n$ npx babel example.js\n\n# 转码结果写入一个文件\n# --out-file 或 -o 参数指定输出文件\n$ npx babel example.js --out-file compiled.js\n# 或者\n$ npx babel example.js -o compiled.js\n\n# 整个目录转码\n# --out-dir 或 -d 参数指定输出目录\n$ npx babel src --out-dir lib\n# 或者\n$ npx babel src -d lib\n\n# -s 参数生成source map文件\n$ npx babel src -d lib -s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# babel-node\n\n@babel/node模块的babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。\n\n首先，安装这个模块。\n\n$ npm install --save-dev @babel/node\n\n\n1\n\n\n然后，执行babel-node就进入 REPL 环境。\n\n$ npx babel-node\n> (x => x * 2)(1)\n2\n\n\n1\n2\n3\n\n\nbabel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。\n\n# es6.js 的代码\n# console.log((x => x * 2)(1));\n$ npx babel-node es6.js\n2\n\n\n1\n2\n3\n4\n\n\n\n# @babel/register 模块\n\n@babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。\n\n$ npm install --save-dev @babel/register\n\n\n1\n\n\n使用时，必须首先加载@babel/register。\n\n// index.js\nrequire('@babel/register');\nrequire('./es6.js');\n\n\n1\n2\n3\n\n\n然后，就不需要手动对index.js转码了。\n\n$ node index.js\n2\n\n\n1\n2\n\n\n需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。\n\n\n# babel API\n\n如果某些代码需要调用 Babel 的 API 进行转码，就要使用@babel/core模块。\n\nvar babel = require('@babel/core');\n\n// 字符串转码\nbabel.transform('code();', options);\n// => { code, map, ast }\n\n// 文件转码（异步）\nbabel.transformFile('filename.js', options, function(err, result) {\n  result; // => { code, map, ast }\n});\n\n// 文件转码（同步）\nbabel.transformFileSync('filename.js', options);\n// => { code, map, ast }\n\n// Babel AST转码\nbabel.transformFromAst(ast, code, options);\n// => { code, map, ast }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。\n\n下面是一个例子。\n\nvar es6Code = 'let x = n => n + 1';\nvar es5Code = require('@babel/core')\n  .transform(es6Code, {\n    presets: ['@babel/env']\n  })\n  .code;\n\nconsole.log(es5Code);\n// '\"use strict\";\\n\\nvar x = function x(n) {\\n  return n + 1;\\n};'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。\n\n\n# @babel/polyfill\n\nBabel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。\n\n举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。\n\n安装命令如下。\n\n$ npm install --save-dev @babel/polyfill\n\n\n1\n\n\n然后，在脚本头部，加入如下一行代码。\n\nimport '@babel/polyfill';\n// 或者\nrequire('@babel/polyfill');\n\n\n1\n2\n3\n\n\nBabel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。\n\n\n# 浏览器环境\n\nBabel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。\n\n<script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"><\/script>\n<script type=\"text/babel\">\n// Your ES6 code\n<\/script>\n\n\n1\n2\n3\n4\n\n\n注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。\n\nBabel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。\n\n\n# Traceur 转码器\n\nGoogle 公司的Traceur转码器，也可以将 ES6 代码转为 ES5 代码。\n\n\n# 直接插入网页\n\nTraceur 允许将 ES6 代码直接插入网页。首先，必须在网页头部加载 Traceur 库文件。\n\n<script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/bin/BrowserSystem.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\"><\/script>\n<script type=\"module\">\n  import './Greeter.js';\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，一共有 4 个script标签。第一个是加载 Traceur 的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用 ES6 代码。\n\n注意，第四个script标签的type属性的值是module，而不是text/javascript。这是 Traceur 编译器识别 ES6 代码的标志，编译器会自动将所有type=module的代码编译为 ES5，然后再交给浏览器执行。\n\n除了引用外部 ES6 脚本，也可以直接在网页中放置 ES6 代码。\n\n<script type=\"module\">\n  class Calc {\n    constructor() {\n      console.log('Calc constructor');\n    }\n    add(a, b) {\n      return a + b;\n    }\n  }\n\n  var c = new Calc();\n  console.log(c.add(4,5));\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n正常情况下，上面代码会在控制台打印出9。\n\n如果想对 Traceur 的行为有精确控制，可以采用下面参数配置的写法。\n\n<script>\n  // Create the System object\n  window.System = new traceur.runtime.BrowserTraceurLoader();\n  // Set some experimental options\n  var metadata = {\n    traceurOptions: {\n      experimental: true,\n      properTailCalls: true,\n      symbols: true,\n      arrayComprehension: true,\n      asyncFunctions: true,\n      asyncGenerators: exponentiation,\n      forOn: true,\n      generatorComprehension: true\n    }\n  };\n  // Load your module\n  System.import('./myModule.js', {metadata: metadata}).catch(function(ex) {\n    console.error('Import failed', ex.stack || ex);\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码中，首先生成 Traceur 的全局对象window.System，然后System.import方法可以用来加载 ES6。加载的时候，需要传入一个配置对象metadata，该对象的traceurOptions属性可以配置支持 ES6 功能。如果设为experimental: true，就表示除了 ES6 以外，还支持一些实验性的新功能。\n\n\n# 在线转换\n\nTraceur 也提供一个在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。\n\n上面的例子转为 ES5 代码运行，就是下面这个样子。\n\n<script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/bin/BrowserSystem.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\"><\/script>\n<script>\n$traceurRuntime.ModuleStore.getAnonymousModule(function() {\n  \"use strict\";\n\n  var Calc = function Calc() {\n    console.log('Calc constructor');\n  };\n\n  ($traceurRuntime.createClass)(Calc, {add: function(a, b) {\n    return a + b;\n  }}, {});\n\n  var c = new Calc();\n  console.log(c.add(4, 5));\n  return {};\n});\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 命令行转换\n\n作为命令行工具使用时，Traceur 是一个 Node 的模块，首先需要用 npm 安装。\n\n$ npm install -g traceur\n\n\n1\n\n\n安装成功后，就可以在命令行下使用 Traceur 了。\n\nTraceur 直接运行 ES6 脚本文件，会在标准输出显示运行结果，以前面的calc.js为例。\n\n$ traceur calc.js\nCalc constructor\n9\n\n\n1\n2\n3\n\n\n如果要将 ES6 脚本转为 ES5 保存，要采用下面的写法。\n\n$ traceur --script calc.es6.js --out calc.es5.js\n\n\n1\n\n\n上面代码的--script选项表示指定输入文件，--out选项表示指定输出文件。\n\n为了防止有些特性编译不成功，最好加上--experimental选项。\n\n$ traceur --script calc.es6.js --out calc.es5.js --experimental\n\n\n1\n\n\n命令行下转换生成的文件，就可以直接放到浏览器中运行。\n\n\n# Node 环境的用法\n\nTraceur 的 Node 用法如下（假定已安装traceur模块）。\n\nvar traceur = require('traceur');\nvar fs = require('fs');\n\n// 将 ES6 脚本转为字符串\nvar contents = fs.readFileSync('es6-file.js').toString();\n\nvar result = traceur.compile(contents, {\n  filename: 'es6-file.js',\n  sourceMap: true,\n  // 其他设置\n  modules: 'commonjs'\n});\n\nif (result.error)\n  throw result.error;\n\n// result 对象的 js 属性就是转换后的 ES5 代码\nfs.writeFileSync('out.js', result.js);\n// sourceMap 属性对应 map 文件\nfs.writeFileSync('out.js.map', result.sourceMap);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"> 说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源http://es6.ruanyifeng.com/，教程版权归原作者所有。\n\n\n# ecmascript 6 简介\n\necmascript 6.0（以下简称 es6）是 javascript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 javascript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n\n# ecmascript 和 javascript 的关系\n\n一个常见的问题是，ecmascript 和 javascript 到底是什么关系？\n\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，javascript 的创造者 netscape 公司，决定将 javascript 提交给标准化组织 ecma，希望这种语言能够成为国际标准。次年，ecma 发布 262 号标准文件（ecma-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ecmascript，这个版本就是 1.0 版。\n\n该标准从一开始就是针对 javascript 语言制定的，但是之所以不叫 javascript，有两个原因。一是商标，java 是 sun 公司的商标，根据授权协议，只有 netscape 公司可以合法地使用 javascript 这个名字，且 javascript 本身也已经被 netscape 公司注册为商标。二是想体现这门语言的制定者是 ecma，不是 netscape，这样有利于保证这门语言的开放性和中立性。\n\n因此，ecmascript 和 javascript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ecmascript 方言还有 jscript 和 actionscript）。日常场合，这两个词是可以互换的。\n\n\n# es6 与 ecmascript 2015 的关系\n\necmascript 2015（简称 es2015）这个词，也是经常可以看到的。它与 es6 是什么关系呢？\n\n2011 年，ecmascript 5.1 版发布后，就开始制定 6.0 版了。因此，es6 这个词的原意，就是指 javascript 语言的下一个版本。\n\n但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。\n\n但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。\n\n标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。\n\nes6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ecmascript 2015 标准》（简称 es2015）。2016 年 6 月，小幅修订的《ecmascript 2016 标准》（简称 es2016）如期发布，这个版本可以看作是 es6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 es2017 标准。\n\n因此，es6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 javascript 的下一代标准，涵盖了 es2015、es2016、es2017 等等，而 es2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 es6 的地方，一般是指 es2015 标准，但有时也是泛指“下一代 javascript 语言”。\n\n\n# 语法提案的批准流程\n\n任何人都可以向标准委员会（又称 tc39 委员会）提案，要求修改语言标准。\n\n一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 tc39 委员会批准。\n\n * stage 0 - strawman（展示阶段）\n * stage 1 - proposal（征求意见阶段）\n * stage 2 - draft（草案阶段）\n * stage 3 - candidate（候选人阶段）\n * stage 4 - finished（定案阶段）\n\n一个提案只要能进入 stage 2，就差不多肯定会包括在以后的正式标准里面。ecmascript 当前的所有提案，可以在 tc39 的官方网站github.com/tc39/ecma262查看。\n\n本书的写作目标之一，是跟踪 ecmascript 语言的最新进展，介绍 5.1 版本以后所有的新语法。对于那些明确或很有希望，将要列入标准的新语法，都将予以介绍。\n\n\n# ecmascript 的历史\n\nes6 从开始制定到最后发布，整整用了 15 年。\n\n前面提到，ecmascript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ecmascript 2.0（1998 年 6 月）和 ecmascript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 javascript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 javascript，其实就是在学 3.0 版的语法。\n\n2000 年，ecmascript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 es6 继承了。因此，es6 制定的起点其实是 2000 年。\n\n为什么 es4 没有通过呢？因为这个版本太激进了，对 es3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ecma 的第 39 号技术专家委员会（technical committee 39，简称 tc39）负责制订 ecmascript 标准，成员包括 microsoft、mozilla、google 等大公司。\n\n2007 年 10 月，ecmascript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 yahoo、microsoft、google 为首的大公司，反对 javascript 的大幅升级，主张小幅改动；以 javascript 创造者 brendan eich 为首的 mozilla 公司，则坚持当前的草案。\n\n2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ecma 开会决定，中止 ecmascript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ecmascript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 harmony（和谐）。会后不久，ecmascript 3.1 就改名为 ecmascript 5。\n\n2009 年 12 月，ecmascript 5.0 版正式发布。harmony 项目则一分为二，一些较为可行的设想定名为 javascript.next 继续开发，后来演变成 ecmascript 6；一些不是很成熟的设想，则被视为 javascript.next.next，在更远的将来再考虑推出。tc39 委员会的总体考虑是，es5 与 es3 基本保持兼容，较大的语法修正和新功能加入，将由 javascript.next 完成。当时，javascript.next 指的是 es6，第六版发布以后，就指 es7。tc39 的判断是，es5 会在 2013 年的年中成为 javascript 开发的主流标准，并在此后五年中一直保持这个位置。\n\n2011 年 6 月，ecmascript 5.1 版发布，并且成为 iso 国际标准（iso/iec 16262:2011）。\n\n2013 年 3 月，ecmascript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ecmascript 7。\n\n2013 年 12 月，ecmascript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。\n\n2015 年 6 月，ecmascript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。\n\n\n# 部署进度\n\n各大浏览器的最新版本，对 es6 的支持可以查看kangax.github.io/compat-table/es6/。随着时间的推移，支持度已经越来越高了，超过 90%的 es6 语法特性都实现了。\n\nnode 是 javascript 的服务器运行环境（runtime）。它对 es6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 node 已经实现的 es6 特性。\n\n// linux & mac\n$ node --v8-options | grep harmony\n\n// windows\n$ node --v8-options | findstr harmony\n\n\n1\n2\n3\n4\n5\n\n\n我写了一个工具 es-checker，用来检查各种运行环境对 es6 的支持情况。访问ruanyf.github.io/es-checker，可以看到您的浏览器支持 es6 的程度。运行下面的命令，可以查看你正在使用的 node 环境对 es6 的支持程度。\n\n$ npm install -g es-checker\n$ es-checker\n\n=========================================\npasses 24 feature detections\nyour runtime supports 57% of ecmascript 6\n=========================================\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# babel 转码器\n\nbabel 是一个广泛使用的 es6 转码器，可以将 es6 代码转为 es5 代码，从而在现有环境执行。这意味着，你可以用 es6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。\n\n// 转码前\ninput.map(item => item + 1);\n\n// 转码后\ninput.map(function (item) {\n  return item + 1;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的原始代码用了箭头函数，babel 将其转为普通函数，就能在不支持箭头函数的 javascript 环境执行了。\n\n下面的命令在项目目录中，安装 babel。\n\n$ npm install --save-dev @babel/core\n\n\n1\n\n\n\n# 配置文件.babelrc\n\nbabel 的配置文件是.babelrc，存放在项目的根目录下。使用 babel 的第一步，就是配置这个文件。\n\n该文件用来设置转码规则和插件，基本格式如下。\n\n{\n  \"presets\": [],\n  \"plugins\": []\n}\n\n\n1\n2\n3\n4\n\n\npresets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。\n\n# 最新转码规则\n$ npm install --save-dev @babel/preset-env\n\n# react 转码规则\n$ npm install --save-dev @babel/preset-react\n\n\n1\n2\n3\n4\n5\n\n\n然后，将这些规则加入.babelrc。\n\n  {\n    \"presets\": [\n      \"@babel/env\",\n      \"@babel/preset-react\"\n    ],\n    \"plugins\": []\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，以下所有 babel 工具和模块的使用，都必须先写好.babelrc。\n\n\n# 命令行转码\n\nbabel 提供命令行工具@babel/cli，用于命令行转码。\n\n它的安装命令如下。\n\n$ npm install --save-dev @babel/cli\n\n\n1\n\n\n基本用法如下。\n\n# 转码结果输出到标准输出\n$ npx babel example.js\n\n# 转码结果写入一个文件\n# --out-file 或 -o 参数指定输出文件\n$ npx babel example.js --out-file compiled.js\n# 或者\n$ npx babel example.js -o compiled.js\n\n# 整个目录转码\n# --out-dir 或 -d 参数指定输出目录\n$ npx babel src --out-dir lib\n# 或者\n$ npx babel src -d lib\n\n# -s 参数生成source map文件\n$ npx babel src -d lib -s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# babel-node\n\n@babel/node模块的babel-node命令，提供一个支持 es6 的 repl 环境。它支持 node 的 repl 环境的所有功能，而且可以直接运行 es6 代码。\n\n首先，安装这个模块。\n\n$ npm install --save-dev @babel/node\n\n\n1\n\n\n然后，执行babel-node就进入 repl 环境。\n\n$ npx babel-node\n> (x => x * 2)(1)\n2\n\n\n1\n2\n3\n\n\nbabel-node命令可以直接运行 es6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。\n\n# es6.js 的代码\n# console.log((x => x * 2)(1));\n$ npx babel-node es6.js\n2\n\n\n1\n2\n3\n4\n\n\n\n# @babel/register 模块\n\n@babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 babel 进行转码。\n\n$ npm install --save-dev @babel/register\n\n\n1\n\n\n使用时，必须首先加载@babel/register。\n\n// index.js\nrequire('@babel/register');\nrequire('./es6.js');\n\n\n1\n2\n3\n\n\n然后，就不需要手动对index.js转码了。\n\n$ node index.js\n2\n\n\n1\n2\n\n\n需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。\n\n\n# babel api\n\n如果某些代码需要调用 babel 的 api 进行转码，就要使用@babel/core模块。\n\nvar babel = require('@babel/core');\n\n// 字符串转码\nbabel.transform('code();', options);\n// => { code, map, ast }\n\n// 文件转码（异步）\nbabel.transformfile('filename.js', options, function(err, result) {\n  result; // => { code, map, ast }\n});\n\n// 文件转码（同步）\nbabel.transformfilesync('filename.js', options);\n// => { code, map, ast }\n\n// babel ast转码\nbabel.transformfromast(ast, code, options);\n// => { code, map, ast }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。\n\n下面是一个例子。\n\nvar es6code = 'let x = n => n + 1';\nvar es5code = require('@babel/core')\n  .transform(es6code, {\n    presets: ['@babel/env']\n  })\n  .code;\n\nconsole.log(es5code);\n// '\"use strict\";\\n\\nvar x = function x(n) {\\n  return n + 1;\\n};'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 es6 代码，第二个参数是转换的配置对象。\n\n\n# @babel/polyfill\n\nbabel 默认只转换新的 javascript 句法（syntax），而不转换新的 api，比如iterator、generator、set、map、proxy、reflect、symbol、promise等全局对象，以及一些定义在全局对象上的方法（比如object.assign）都不会转码。\n\n举例来说，es6 在array对象上新增了array.from方法。babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。\n\n安装命令如下。\n\n$ npm install --save-dev @babel/polyfill\n\n\n1\n\n\n然后，在脚本头部，加入如下一行代码。\n\nimport '@babel/polyfill';\n// 或者\nrequire('@babel/polyfill');\n\n\n1\n2\n3\n\n\nbabel 默认不转码的 api 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。\n\n\n# 浏览器环境\n\nbabel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。\n\n<script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"><\/script>\n<script type=\"text/babel\">\n// your es6 code\n<\/script>\n\n\n1\n2\n3\n4\n\n\n注意，网页实时将 es6 代码转为 es5，对性能会有影响。生产环境需要加载已经转码完成的脚本。\n\nbabel 提供一个repl 在线编译器，可以在线将 es6 代码转为 es5 代码。转换后的代码，可以直接作为 es5 代码插入网页运行。\n\n\n# traceur 转码器\n\ngoogle 公司的traceur转码器，也可以将 es6 代码转为 es5 代码。\n\n\n# 直接插入网页\n\ntraceur 允许将 es6 代码直接插入网页。首先，必须在网页头部加载 traceur 库文件。\n\n<script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/bin/browsersystem.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\"><\/script>\n<script type=\"module\">\n  import './greeter.js';\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，一共有 4 个script标签。第一个是加载 traceur 的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用 es6 代码。\n\n注意，第四个script标签的type属性的值是module，而不是text/javascript。这是 traceur 编译器识别 es6 代码的标志，编译器会自动将所有type=module的代码编译为 es5，然后再交给浏览器执行。\n\n除了引用外部 es6 脚本，也可以直接在网页中放置 es6 代码。\n\n<script type=\"module\">\n  class calc {\n    constructor() {\n      console.log('calc constructor');\n    }\n    add(a, b) {\n      return a + b;\n    }\n  }\n\n  var c = new calc();\n  console.log(c.add(4,5));\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n正常情况下，上面代码会在控制台打印出9。\n\n如果想对 traceur 的行为有精确控制，可以采用下面参数配置的写法。\n\n<script>\n  // create the system object\n  window.system = new traceur.runtime.browsertraceurloader();\n  // set some experimental options\n  var metadata = {\n    traceuroptions: {\n      experimental: true,\n      propertailcalls: true,\n      symbols: true,\n      arraycomprehension: true,\n      asyncfunctions: true,\n      asyncgenerators: exponentiation,\n      foron: true,\n      generatorcomprehension: true\n    }\n  };\n  // load your module\n  system.import('./mymodule.js', {metadata: metadata}).catch(function(ex) {\n    console.error('import failed', ex.stack || ex);\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码中，首先生成 traceur 的全局对象window.system，然后system.import方法可以用来加载 es6。加载的时候，需要传入一个配置对象metadata，该对象的traceuroptions属性可以配置支持 es6 功能。如果设为experimental: true，就表示除了 es6 以外，还支持一些实验性的新功能。\n\n\n# 在线转换\n\ntraceur 也提供一个在线编译器，可以在线将 es6 代码转为 es5 代码。转换后的代码，可以直接作为 es5 代码插入网页运行。\n\n上面的例子转为 es5 代码运行，就是下面这个样子。\n\n<script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/bin/browsersystem.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\"><\/script>\n<script>\n$traceurruntime.modulestore.getanonymousmodule(function() {\n  \"use strict\";\n\n  var calc = function calc() {\n    console.log('calc constructor');\n  };\n\n  ($traceurruntime.createclass)(calc, {add: function(a, b) {\n    return a + b;\n  }}, {});\n\n  var c = new calc();\n  console.log(c.add(4, 5));\n  return {};\n});\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 命令行转换\n\n作为命令行工具使用时，traceur 是一个 node 的模块，首先需要用 npm 安装。\n\n$ npm install -g traceur\n\n\n1\n\n\n安装成功后，就可以在命令行下使用 traceur 了。\n\ntraceur 直接运行 es6 脚本文件，会在标准输出显示运行结果，以前面的calc.js为例。\n\n$ traceur calc.js\ncalc constructor\n9\n\n\n1\n2\n3\n\n\n如果要将 es6 脚本转为 es5 保存，要采用下面的写法。\n\n$ traceur --script calc.es6.js --out calc.es5.js\n\n\n1\n\n\n上面代码的--script选项表示指定输入文件，--out选项表示指定输出文件。\n\n为了防止有些特性编译不成功，最好加上--experimental选项。\n\n$ traceur --script calc.es6.js --out calc.es5.js --experimental\n\n\n1\n\n\n命令行下转换生成的文件，就可以直接放到浏览器中运行。\n\n\n# node 环境的用法\n\ntraceur 的 node 用法如下（假定已安装traceur模块）。\n\nvar traceur = require('traceur');\nvar fs = require('fs');\n\n// 将 es6 脚本转为字符串\nvar contents = fs.readfilesync('es6-file.js').tostring();\n\nvar result = traceur.compile(contents, {\n  filename: 'es6-file.js',\n  sourcemap: true,\n  // 其他设置\n  modules: 'commonjs'\n});\n\nif (result.error)\n  throw result.error;\n\n// result 对象的 js 属性就是转换后的 es5 代码\nfs.writefilesync('out.js', result.js);\n// sourcemap 属性对应 map 文件\nfs.writefilesync('out.js.map', result.sourcemap);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"常用Git命令清单",frontmatter:{feed:{enable:!0},title:"常用Git命令清单",date:"2020-11-18T17:43:57.000Z",permalink:"/common-git-commands.html",categories:["《Git》学习笔记"],tags:[null],description:"一般来说，日常使用只要记住下图 6 个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。",meta:[{name:"image",content:"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png"},{name:"twitter:title",content:"常用Git命令清单"},{name:"twitter:description",content:"一般来说，日常使用只要记住下图 6 个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png"},{name:"twitter:url",content:"https://dbdgs.cn/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/00.%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"常用Git命令清单"},{property:"og:description",content:"一般来说，日常使用只要记住下图 6 个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。"},{property:"og:image",content:"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png"},{property:"og:url",content:"https://dbdgs.cn/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/00.%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-11-18T17:43:57.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"常用Git命令清单"},{itemprop:"description",content:"一般来说，日常使用只要记住下图 6 个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。"},{itemprop:"image",content:"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png"}]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/00.%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html",relativePath:"《Git》学习笔记/10.手册/00.常用Git命令清单.md",key:"v-11f80eb1",path:"/common-git-commands.html",headers:[{level:2,title:"一、新建代码库",slug:"一、新建代码库",normalizedTitle:"一、新建代码库",charIndex:189},{level:2,title:"二、配置",slug:"二、配置",normalizedTitle:"二、配置",charIndex:336},{level:2,title:"三、增加/删除文件",slug:"三、增加-删除文件",normalizedTitle:"三、增加/删除文件",charIndex:607},{level:2,title:"四、代码提交",slug:"四、代码提交",normalizedTitle:"四、代码提交",charIndex:1007},{level:2,title:"五、分支",slug:"五、分支",normalizedTitle:"五、分支",charIndex:1408},{level:2,title:"六、标签",slug:"六、标签",normalizedTitle:"六、标签",charIndex:2201},{level:2,title:"七、查看信息",slug:"七、查看信息",normalizedTitle:"七、查看信息",charIndex:2618},{level:2,title:"八、远程同步",slug:"八、远程同步",normalizedTitle:"八、远程同步",charIndex:3727},{level:2,title:"九、撤销",slug:"九、撤销",normalizedTitle:"九、撤销",charIndex:4149}],headersStr:"一、新建代码库 二、配置 三、增加/删除文件 四、代码提交 五、分支 六、标签 七、查看信息 八、远程同步 九、撤销",content:'# 常用Git命令清单\n\n一般来说，日常使用只要记住下图 6 个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\n\n>  * Workspace：工作区\n>  * Index / Stage：暂存区\n>  * Repository：仓库区（或本地仓库）\n>  * Remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\nGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n相关文章：\n\n《如何撤销 Git 操作？》\n\n《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\n\n> 命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html',normalizedContent:'# 常用git命令清单\n\n一般来说，日常使用只要记住下图 6 个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 git 命令清单。几个专用名词的译名如下。\n\n>  * workspace：工作区\n>  * index / stage：暂存区\n>  * repository：仓库区（或本地仓库）\n>  * remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个git代码库\n$ git init\n\n# 新建一个目录，将其初始化为git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\ngit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的git配置\n$ git config --list\n\n# 编辑git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagname]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -s [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] head --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] head --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff head\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前head为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n相关文章：\n\n《如何撤销 git 操作？》\n\n《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\n\n> 命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html',charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"Git分支-分支原理",frontmatter:{feed:{enable:!0},title:"Git分支-分支原理",date:"2020-11-18T17:43:57.000Z",permalink:"/git-branch-principles.html",categories:["《Git》学习笔记"],tags:["git"],canonicalUrl:"https://dbdgs.cn/git-branch-principles.html",description:"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200906145443.jpg"},{name:"twitter:title",content:"Git分支-分支原理"},{name:"twitter:description",content:"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200906145443.jpg"},{name:"twitter:url",content:"https://dbdgs.cn/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/20.Git%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"Git分支-分支原理"},{property:"og:description",content:"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200906145443.jpg"},{property:"og:url",content:"https://dbdgs.cn/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/20.Git%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-11-18T17:43:57.000Z"},{property:"article:tag",content:"git"},{itemprop:"name",content:"Git分支-分支原理"},{itemprop:"description",content:"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200906145443.jpg"}]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/20.Git%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86.html",relativePath:"《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.md",key:"v-cda926b0",path:"/git-branch-principles.html",headers:[{level:3,title:"首次提交",slug:"首次提交",normalizedTitle:"首次提交",charIndex:130},{level:3,title:"再次提交",slug:"再次提交",normalizedTitle:"再次提交",charIndex:823},{level:3,title:"Git 的分支",slug:"git-的分支",normalizedTitle:"git 的分支",charIndex:896},{level:3,title:"创建分支",slug:"创建分支",normalizedTitle:"创建分支",charIndex:1088},{level:3,title:"当前分支的指针",slug:"当前分支的指针",normalizedTitle:"当前分支的指针",charIndex:1252},{level:3,title:"查看当前所在分支",slug:"查看当前所在分支",normalizedTitle:"查看当前所在分支",charIndex:1432},{level:3,title:"分支切换",slug:"分支切换",normalizedTitle:"分支切换",charIndex:1771},{level:3,title:"创建分支同时切换",slug:"创建分支同时切换",normalizedTitle:"创建分支同时切换",charIndex:3223}],headersStr:"首次提交 再次提交 Git 的分支 创建分支 当前分支的指针 查看当前所在分支 分支切换 创建分支同时切换",content:"# Git分支-分支原理\n\nGit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n\n\n# 首次提交\n\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\n\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n\n$ git add README test.rb LICENSE\n$ git commit -m 'The initial commit of my project'\n\n\n1\n2\n\n\n当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。\n\n现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\n\n\n\n图1. 首次提交对象及其树结构 ▲\n\n# 小结：\n\n 1. git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\n\n 2. git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\n\n\n# 再次提交\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n\n\n图2. 提交对象及其父对象 ▲\n\n\n# Git 的分支\n\nGit 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\n\n> Git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\n\n\n\n图3. 分支及其提交历史 ▲\n\n\n# 创建分支\n\nGit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\n\n$ git branch testing\n\n\n1\n\n\n这会在当前所在的提交对象上创建一个指针。\n\n\n\n图4. 两个指向相同提交历史的分支 ▲\n\n\n# 当前分支的指针\n\nGit 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n\n\n图5. HEAD 指向当前所在的分支 ▲\n\n\n# 查看当前所在分支\n\n你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\n\n$ git log --oneline --decorate\nf30ab (HEAD -> master, testing) add feature # f30ab提交对象 (HEAD当前所在分支 -> master分支，testing 分支)\n34ac2 Fixed bug # 34ac2 提交对象\n98ca9 The initial commit of my project # 98ca9 提交对象\n\n\n1\n2\n3\n4\n\n\n正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\n\n\n# 分支切换\n\n$ git checkout testing  # git checkout <分支名>\n\n\n1\n\n\n这样 HEAD 就指向 testing 分支了。\n\n\n\n图6. HEAD 指向当前所在的分支 ▲\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n\n$ vim test.rb\n$ git commit -a -m 'made a change'\n\n\n1\n2\n\n\n\n\n图7. HEAD 分支随着提交操作自动向前移动 ▲\n\n如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\n\n$ git checkout master\n\n\n1\n\n\n\n\n图8. 检出时 HEAD 随之移动 ▲\n\n这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\n\n我们不妨再稍微做些修改并提交：\n\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n\n\n1\n2\n\n\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\n\n\n\n图9. 项目分叉历史 ▲\n\n你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n\n$ git log --oneline --decorate --graph --all\n* c2b9e (HEAD, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature\n* 34ac2 fixed bug\n* 98ca9 initial commit of my project\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。\n\n\n# 创建分支同时切换\n\n通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\n\ngit checkout -b <newbranchname> \n\n\n1\n",normalizedContent:"# git分支-分支原理\n\ngit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n\n\n# 首次提交\n\n在进行提交操作时，git 会保存一个提交对象（commit object）。\n\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 sha-1 哈希算法），然后会把当前版本的文件快照保存到 git 仓库中 （git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n\n$ git add readme test.rb license\n$ git commit -m 'the initial commit of my project'\n\n\n1\n2\n\n\n当使用 git commit 进行提交操作时，git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 git 仓库中这些校验和保存为树对象。随后，git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，git 就可以在需要的时候重现此次保存的快照。\n\n现在，git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\n\n\n\n图1. 首次提交对象及其树结构 ▲\n\n# 小结：\n\n 1. git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\n\n 2. git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\n\n\n# 再次提交\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n\n\n图2. 提交对象及其父对象 ▲\n\n\n# git 的分支\n\ngit 的分支，其实本质上仅仅是指向提交对象的可变指针。 git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\n\n> git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\n\n\n\n图3. 分支及其提交历史 ▲\n\n\n# 创建分支\n\ngit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\n\n$ git branch testing\n\n\n1\n\n\n这会在当前所在的提交对象上创建一个指针。\n\n\n\n图4. 两个指向相同提交历史的分支 ▲\n\n\n# 当前分支的指针\n\ngit 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 head 的特殊指针，指向当前所在的本地分支（译注：将 head 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n\n\n图5. head 指向当前所在的分支 ▲\n\n\n# 查看当前所在分支\n\n你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\n\n$ git log --oneline --decorate\nf30ab (head -> master, testing) add feature # f30ab提交对象 (head当前所在分支 -> master分支，testing 分支)\n34ac2 fixed bug # 34ac2 提交对象\n98ca9 the initial commit of my project # 98ca9 提交对象\n\n\n1\n2\n3\n4\n\n\n正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\n\n\n# 分支切换\n\n$ git checkout testing  # git checkout <分支名>\n\n\n1\n\n\n这样 head 就指向 testing 分支了。\n\n\n\n图6. head 指向当前所在的分支 ▲\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n\n$ vim test.rb\n$ git commit -a -m 'made a change'\n\n\n1\n2\n\n\n\n\n图7. head 分支随着提交操作自动向前移动 ▲\n\n如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\n\n$ git checkout master\n\n\n1\n\n\n\n\n图8. 检出时 head 随之移动 ▲\n\n这条命令做了两件事。 一是使 head 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\n\n我们不妨再稍微做些修改并提交：\n\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n\n\n1\n2\n\n\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\n\n\n\n图9. 项目分叉历史 ▲\n\n你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n\n$ git log --oneline --decorate --graph --all\n* c2b9e (head, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature\n* 34ac2 fixed bug\n* 98ca9 initial commit of my project\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于 git 的分支实质上仅是包含所指对象校验和（长度为 40 的 sha-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 git 鼓励开发人员频繁地创建和使用分支。\n\n\n# 创建分支同时切换\n\n通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\n\ngit checkout -b <newbranchname> \n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"基础",frontmatter:{feed:{enable:!0},title:"基础",date:"2020-01-12T11:49:16.000Z",permalink:"/javascript-basics.html",categories:["《JavaScript教程》笔记"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源，教程版权归原作者所有。",meta:[{name:"twitter:title",content:"基础"},{name:"twitter:description",content:"说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源，教程版权归原作者所有。"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/%E3%80%8AJavaScript%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"基础"},{property:"og:description",content:"说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源，教程版权归原作者所有。"},{property:"og:url",content:"https://dbdgs.cn/%E3%80%8AJavaScript%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-01-12T11:49:16.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"基础"},{itemprop:"description",content:"说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源，教程版权归原作者所有。"}]},regularPath:"/%E3%80%8AJavaScript%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80.html",relativePath:"《JavaScript教程》笔记/01.基础.md",key:"v-b5a93fd2",path:"/javascript-basics.html",headers:[{level:2,title:"一、JS的一些名词概念",slug:"一、js的一些名词概念",normalizedTitle:"一、js的一些名词概念",charIndex:87},{level:2,title:"二、数据类型的转换",slug:"二、数据类型的转换",normalizedTitle:"二、数据类型的转换",charIndex:817},{level:3,title:"1、强制（手动）转换",slug:"_1、强制-手动-转换",normalizedTitle:"1、强制（手动）转换",charIndex:831},{level:3,title:"2、自动转换",slug:"_2、自动转换",normalizedTitle:"2、自动转换",charIndex:2082},{level:2,title:"三、错误处理机制",slug:"三、错误处理机制",normalizedTitle:"三、错误处理机制",charIndex:4185},{level:3,title:"1、Error实例对象",slug:"_1、error实例对象",normalizedTitle:"1、error实例对象",charIndex:4198},{level:3,title:"2、原生错误类型",slug:"_2、原生错误类型",normalizedTitle:"2、原生错误类型",charIndex:5511},{level:3,title:"3、自定义错误",slug:"_3、自定义错误",normalizedTitle:"3、自定义错误",charIndex:7694},{level:3,title:"4、throw 语句 （中断程序并抛出错误）",slug:"_4、throw-语句-中断程序并抛出错误",normalizedTitle:"4、throw 语句 （中断程序并抛出错误）",charIndex:8056},{level:3,title:"5、try...catch 结构（捕获错误，对错误进行处理，不中断）",slug:"_5、try-catch-结构-捕获错误-对错误进行处理-不中断",normalizedTitle:"5、try...catch 结构（捕获错误，对错误进行处理，不中断）",charIndex:8920},{level:3,title:"6、finally 代码块（在try..catch最后，必执行的）",slug:"_6、finally-代码块-在try-catch最后-必执行的",normalizedTitle:"6、finally 代码块（在try..catch最后，必执行的）",charIndex:10202},{level:2,title:"四、console对象",slug:"四、console对象",normalizedTitle:"四、console对象",charIndex:12965},{level:3,title:"console.time()，console.timeEnd() （用于计算程序的用时）",slug:"console-time-console-timeend-用于计算程序的用时",normalizedTitle:"console.time()，console.timeend() （用于计算程序的用时）",charIndex:12981},{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:13373}],headersStr:"一、JS的一些名词概念 二、数据类型的转换 1、强制（手动）转换 2、自动转换 三、错误处理机制 1、Error实例对象 2、原生错误类型 3、自定义错误 4、throw 语句 （中断程序并抛出错误） 5、try...catch 结构（捕获错误，对错误进行处理，不中断） 6、finally 代码块（在try..catch最后，必执行的） 四、console对象 console.time()，console.timeEnd() （用于计算程序的用时） 文档",content:"> 说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源https://wangdoc.com/javascript/，教程版权归原作者所有。\n\n\n# 基础篇\n\n\n# 一、JS的一些名词概念\n\n# 什么是作用域？\n\n变量存在的范围。\n\n可分为全局作用域和函数作用域，ES6新增块级作用域。\n\n# 什么是闭包？\n\n闭包就是能够读取其他函数内部变量的函数。\n\n * 闭包的形式：函数内部定义函数\n * 本质上闭包就是将函数内部和外部连接起来的一座桥梁\n\n闭包的作用：\n\n * 可以读取函数内部变量\n * 让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。\n * 封装对象的私有属性和私有方法\n\n# 什么是构造函数？\n\n用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。\n\n# 什么是实例对象？\n\n实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的一个对象。\n\n# 什么是this？\n\n就是属性或方法当前所在的对象，指向当前运行环境（对象）\n\n# 什么是原型？\n\n每个函数都有一个prototype属性，指向一个对象，该对象称为原型对象。\n\n# 什么是原型链？\n\n所有对象都有自己的原型对象，由于原型对象也是对象，因此它也有自己的原型，这就会形成一个原型链。\n\n最顶层的原型是Object.prototype。\n\n> 读取对象属性时，JS会先在对象自身上找，找到就直接返回，如果找不到，会到原型上找，如果还是找不到，就会去原型的原型上找，最终会到最顶层的Object.prototype上找，还是找不到就会返回undefined。\n\n# 什么是constructor？\n\nprototype原型对象都有一个constructor属性，默认指向prototype对象所在的构造函数。\n\n# 什么是包装对象？\n\n包装对象指的是将原始类型（数字、字符串、布尔值）进行实例化。\n\n\n# 二、数据类型的转换\n\n\n# 1、强制（手动）转换\n\n强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串、布尔值。\n\n# Number()\n\n// 数值：转换后还是原来的值\nNumber(324) // 324\n\n// 字符串：如果可以被解析为数值，则转换为相应的数值\nNumber('324') // 324\n\n// 字符串：如果不可以被解析为数值，返回 NaN\nNumber('324abc') // NaN\n\n// 空字符串转为0\nNumber('') // 0\n\n// 布尔值：true 转成 1，false 转成 0\nNumber(true) // 1\nNumber(false) // 0\n\n// undefined：转成 NaN\nNumber(undefined) // NaN\n\n// null：转成0\nNumber(null) // 0\n\nNumber({a: 1}) // NaN\nNumber([1, 2, 3]) // NaN\nNumber([5]) // 5\nNumber([]) // 0\n\n//使用parseInt()转数组\nparseInt([1, 2, 3]) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# String()\n\n// 原始类型的转换\nString(123) // \"123\"\nString('abc') // \"abc\"\nString(true) // \"true\"\nString(undefined) // \"undefined\"\nString(null) // \"null\"\n\n// 对象的转换\nString({a: 1}) // \"[object Object]\"\nString([1, 2, 3]) // \"1,2,3\"\nString([]) // \"\"  空字符串\nString(function(){}) // \"function(){}\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# Boolean()\n\n// 除了这五个为false，其他都为true\nBoolean(undefined) // false\nBoolean(null) // false\nBoolean(0) // false\nBoolean(NaN) // false\nBoolean('') // false\n\n//true\nBoolean({}) // true\nBoolean([]) // true\nBoolean(new Boolean(false)) // true\n\nBoolean(1) // true\nBoolean(' ') // true // 注意字符串内有个空格\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2、自动转换\n\n下面介绍自动转换，它是以强制转换为基础的。\n\n遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。\n\n第一种情况，不同类型的数据互相运算。\n\n123 + 'abc' // \"123abc\"\n\n\n1\n\n\n第二种情况，对非布尔值类型的数据求布尔值。\n\nif ('abc') {\n  console.log('hello')\n}  // \"hello\"\n\n\n1\n2\n3\n\n\n第三种情况，对非数值类型的值使用一元运算符（即+和-）。\n\n+ {foo: 'bar'} // NaN\n- [1, 2, 3] // NaN\n\n\n1\n2\n\n\n自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。\n\n由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。\n\n# 自动转换为布尔值（Boolean）\n\nJavaScript 遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用Boolean函数。\n\n因此除了以下五个值，其他都是自动转为true。\n\n * undefined\n * null\n * +0或-0\n * NaN\n * ''（空字符串）\n\n下面这个例子中，条件部分的每个值都相当于false，使用否定运算符后，就变成了true。\n\nif ( !undefined\n  && !null\n  && !0\n  && !NaN\n  && !''\n) {\n  console.log('true');\n} // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是Boolean函数。\n\n// 三元运算符\nexpression ? true : false\n\n// 取反运算符\n!! expression\n\n\n1\n2\n3\n4\n5\n\n\n# 自动转换为字符串（String）\n\nJavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。\n\n字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。\n\n# 所有类型的值与字符串相加都会变成字符串\n\n'5' + 1 // '51'\n 1  + '5' // '15'\n'5' + true // \"5true\"\n'5' + false // \"5false\"\n'5' + {} // \"5[object Object]\"\n 5 + {} // \"5[object Object]\"\n'5' + [] // \"5\"\n 5 + [] // \"5\"\n'5' + function (){} // \"5function (){}\"\n'5' + undefined // \"5undefined\"\n'5' + null // \"5null\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n#\n\n这种自动转换不注意的话很容易出错。\n\nvar obj = {\n  width: '100'\n};\n\nobj.width + 20 // \"10020\"\nparerInt(obj.width) + 20 // 120\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，开发者可能期望返回120，但是由于自动转换，实际上返回了一个字符10020。正确做法是先把字符串转成数字。\n\n# 自动转换为数值（Number）\n\nJavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用Number函数。\n\n# 除加号与字符串运行会转成字符串外，其他运行基本都会自动转成数值\n\n'5' - '2' // 3\n'5' * '2' // 10\ntrue - 1  // 0\nfalse - 1 // -1\n'1' - 1   // 0\n'5' * []    // 0\nfalse / '5' // 0\n'abc' - 1   // NaN\nnull + 1 // 1\nundefined + 1 // NaN\n\ntrue+true // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，运算符两侧的运算子，都被转成了数值。\n\n> 注意：null转为数值时为0，而undefined转为数值时为NaN。\n\n数值与布尔值、null也会转为数值\n\n5+true // 6\n5+false // 5\n5+null //5\n\n\n1\n2\n3\n\n\n一元运算符也会把运算子转成数值。\n\n+'abc' // NaN\n-'abc' // NaN\n+true // 1\n-false // 0\n\n\n1\n2\n3\n4\n\n\n\n# 三、错误处理机制\n\n\n# 1、Error实例对象\n\nJavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。\n\nvar err = new Error('出错了');\nerr.message // \"出错了\"\n\n\n1\n2\n\n\n上面代码中，我们调用Error构造函数，生成一个实例对象err。Error构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。抛出Error实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。\n\nJavaScript 语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。\n\n * message：错误提示信息\n * name：错误名称（非标准属性）\n * stack：错误的堆栈（非标准属性）\n\n使用name和message这两个属性，可以对发生什么错误有一个大概的了解。\n\nvar err = new Error('出错了');\nif (err.name) {\n  console.log(err.name + ': ' + err.message); // Error: 出错了\n}\n\n\n1\n2\n3\n4\n\n\nstack属性用来查看错误发生时的堆栈。\n\nfunction throwit() {\n  throw new Error('');\n}\n\nfunction catchit() {\n  try {\n    throwit();\n  } catch(e) {\n    console.log(e.stack); // print stack trace\n  }\n}\n\ncatchit()\n// Error\n//    at throwit (~/examples/throwcatch.js:9:11) // 堆栈的最内层throwit函数\n//    at catchit (~/examples/throwcatch.js:3:9) // 向外一层catchit函数\n//    at repl:1:5 // 函数的运行环境\n\n\n// 堆栈信息说明\n// Error 错误\n//    at throwit 在throwit方法 (~/examples/throwcatch.js:9:11) 文件名：第几行：第几个字符 \n//    at catchit 在catchit方法 (~/examples/throwcatch.js:3:9) 文件名：第几行：第几个字符\n//    at repl:1:5 // 函数的运行环境\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码中，错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。\n\n\n# 2、原生错误类型\n\nError实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。\n\n# SyntaxError 对象（语法错误）\n\nSyntaxError对象是解析代码时发生的语法错误。\n\n// 变量名错误\nvar 1a;\n// Uncaught SyntaxError: Invalid or unexpected token\n// 语法错误：无效或意外的标记符号\n\n// 缺少括号\nconsole.log 'hello');\n// Uncaught SyntaxError: Unexpected string\n// 语法错误：意外的字符串\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出SyntaxError。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。\n\n# ReferenceError 对象（引用错误）\n\nReferenceError对象是引用一个不存在的变量时发生的错误。\n\n// 使用一个不存在的变量\nunknownVariable\n// Uncaught ReferenceError: unknownVariable is not defined\n// 引用错误： unknownVariable 没有定义\n\n\n1\n2\n3\n4\n\n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。\n\n// 等号左侧不是变量\nconsole.log() = 1\n// Uncaught ReferenceError: Invalid left-hand side in assignment\n// 引用错误： 赋值中左边是无效的\n\n// this 对象不能手动赋值\nthis = 1\n// ReferenceError: Invalid left-hand side in assignment\n// 引用错误：  赋值中左边是无效的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码对函数console.log的运行结果和this赋值，结果都引发了ReferenceError错误。\n\n# RangeError 对象（范围错误）\n\nRangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n// 数组长度不得为负数\nnew Array(-1)\n// Uncaught RangeError: Invalid array length\n// 范围错误：无效的数组长度\n\n\n1\n2\n3\n4\n\n\n# TypeError 对象（类型错误）\n\nTypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。\n\nnew 123\n// Uncaught TypeError: number is not a function\n// 类型错误： 数字不是一个函数\n\nvar obj = {};\nobj.unknownMethod()\n// Uncaught TypeError: obj.unknownMethod is not a function\n// 类型错误：obj.unknownMethod 不是一个函数\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码的第二种情况，调用对象不存在的方法，也会抛出TypeError错误，因为obj.unknownMethod的值是undefined，而不是一个函数。\n\n# URIError 对象 （URI错误）\n\nURIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。\n\ndecodeURI('%2')\n// URIError: URI malformed\n\n\n1\n2\n\n\n# EvalError 对象 （eval错误）\n\neval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\n\n# 总结（开发者手动使用）\n\n以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。\n\nvar err1 = new Error('出错了！');\nvar err2 = new RangeError('出错了，变量超出有效范围！');\nvar err3 = new TypeError('出错了，变量类型无效！');\n\nerr1.message // \"出错了！\"\nerr2.message // \"出错了，变量超出有效范围！\"\nerr3.message // \"出错了，变量类型无效！\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3、自定义错误\n\n除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。\n\nfunction UserError(message) {\n  this.message = message || '默认信息';\n  this.name = 'UserError';\n}\n\nUserError.prototype = new Error(); // 原型继承 Error对象\nUserError.prototype.constructor = UserError;\n\n// 使用\nnew UserError('这是自定义的错误！');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。\n\n\n# 4、throw 语句 （中断程序并抛出错误）\n\nthrow语句的作用是手动中断程序执行，抛出一个错误。\n\nvar x = 0;\nif (x <= 0) {\n  throw new Error('x 必须为正数');\n}\n// Uncaught Error: x 必须为正数\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，如果变量x小于等于0，就手动抛出一个错误，告诉用户x的值不正确，整个程序就会在这里中断执行。可以看到，throw抛出的错误就是它的参数，这里是一个Error实例。\n\nfunction UserError(message) {\n  this.message = message || '默认信息';\n  this.name = 'UserError';\n}\n\nthrow new UserError('出错了！');\n// Uncaught UserError {message: \"出错了！\", name: \"UserError\"}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，throw抛出的是一个UserError实例。\n\n实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。\n\n// 抛出一个字符串\nthrow 'Error！';\n// Uncaught Error！\n\n// 抛出一个数值\nthrow 42;\n// Uncaught 42\n\n// 抛出一个布尔值\nthrow true;\n// Uncaught true\n\n// 抛出一个对象\nthrow {\n  toString: function () {\n    return 'Error!';\n  }\n};\n// Uncaught {toString: ƒ}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。\n\n\n# 5、try...catch 结构（捕获错误，对错误进行处理，不中断）\n\n一旦发生错误，程序就中止执行了。JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。\n\ntry {\n  throw new Error('出错了!');\n} catch (e) {\n  console.log(e.name + \": \" + e.message);\n  console.log(e.stack);\n}\n// Error: 出错了!\n//   at <anonymous>:3:9\n//   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，try代码块抛出错误（上例用的是throw语句），JavaScript 引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。\n\n如果你不确定某些代码是否会报错，就可以把它们放在try...catch代码块之中，便于进一步对错误进行处理。\n\ntry {\n  f();\n} catch(e) {\n  // 处理错误\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，如果函数f执行报错，就会进行catch代码块，接着对错误进行处理。\n\ncatch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。\n\ntry {\n  throw \"出错了\";\n} catch (e) {\n  console.log(111);\n}\nconsole.log(222);\n// 111\n// 222\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，try代码块抛出的错误，被catch代码块捕获后，程序会继续向下执行。\n\ncatch代码块之中，还可以再抛出错误，甚至使用嵌套的try...catch结构。\n\nvar n = 100;\n\ntry {\n  throw n;\n} catch (e) {\n  if (e <= 50) {\n    // ...\n  } else {\n    throw e;\n  }\n}\n// Uncaught 100\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，catch代码之中又抛出了一个错误。\n\n为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。\n\ntry {\n  foo.bar();\n} catch (e) {\n  if (e instanceof EvalError) {\n    console.log(e.name + \": \" + e.message);\n  } else if (e instanceof RangeError) {\n    console.log(e.name + \": \" + e.message);\n  }\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，catch捕获错误之后，会判断错误类型（EvalError还是RangeError），进行不同的处理。\n\n\n# 6、finally 代码块（在try..catch最后，必执行的）\n\ntry...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。\n\nfunction cleansUp() {\n  try {\n    throw new Error('出错了……');\n    console.log('此行不会执行');\n  } finally { // 不管有没有出错都会执行finally\n    console.log('完成清理工作');\n  }\n  console.log('此行不会执行');\n}\n\ncleansUp()\n// 完成清理工作\n// Uncaught Error: 出错了…… \n//    at cleansUp (<anonymous>:3:11)\n//    at <anonymous>:10:1\n\n// 由于没有catch语句，所以会打印出错误信息，并中断除finally以外的代码。\n// 如果有catch语句则会执行catch内的代码块，而不会打印错误信息。且不会中断代码。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，由于没有catch语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行finally代码块，然后再向用户提示报错信息。\n\nfunction idle(x) {\n  try {\n    console.log(x);\n    return 'result';\n  } finally {\n    console.log('FINALLY');\n  }\n}\n\nidle('hello')\n// hello\n// FINALLY\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，try代码块没有发生错误，而且里面还包括return语句，但是finally代码块依然会执行。而且，这个函数的返回值还是result。\n\n下面的例子说明，return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。\n\nvar count = 0;\nfunction countUp() {\n  try {\n    return count;\n  } finally {\n    count++;\n  }\n}\n\ncountUp()\n// 0\ncount\n// 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码说明，return语句里面的count的值，是在finally代码块运行之前就获取了。\n\n下面是finally代码块用法的典型场景。\n\nopenFile(); // 打开文件\n\ntry {\n  writeFile(Data); // 写入文件\n} catch(e) {\n  handleError(e); // 如果写入出错这处理错误\n} finally {\n  closeFile();// 不管是否出错都会执行关闭文件\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码首先打开一个文件，然后在try代码块中写入文件，如果没有发生错误，则运行finally代码块关闭文件；一旦发生错误，则先使用catch代码块处理错误，再使用finally代码块关闭文件。\n\n下面的例子充分反映了try...catch...finally这三者之间的执行顺序。\n\nfunction f() {\n  try {\n    console.log(0);\n    throw 'bug';\n  } catch(e) {\n    console.log(1);\n    return true; // 这句原本会延迟到 finally 代码块结束再执行\n    console.log(2); // 不会运行\n  } finally {\n    console.log(3);\n    return false; // 这句会覆盖掉前面那句 return\n    console.log(4); // 不会运行\n  }\n\n  console.log(5); // 不会运行\n}\n\nvar result = f();\n// 0\n// 1\n// 3\n\nresult\n// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码中，catch代码块结束执行之前，会先执行finally代码块。\n\ncatch代码块之中，触发转入finally代码块的标志，不仅有return语句，还有throw语句。\n\nfunction f() {\n  try {\n    throw '出错了！';\n  } catch(e) {\n    console.log('捕捉到内部错误');\n    throw e; // 这句原本会等到finally结束再执行\n  } finally {\n    return false; // 直接返回\n  }\n}\n\ntry {\n  f(); // 接收到返回值false，并没有接收到错误\n} catch(e) {\n  // 此处不会执行\n  console.log('caught outer \"bogus\"');\n}\n\n//  捕捉到内部错误\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。\n\ntry代码块内部，还可以再使用try代码块。\n\ntry {\n  try {\n    consle.log('Hello world!'); // 报错，console拼错\n  }\n  finally {\n    console.log('Finally');\n  }\n  console.log('Will I run?');\n} catch(error) {\n  console.error(error.message);\n}\n// Finally\n// consle is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，try里面还有一个try。内层的try报错（console拼错了），这时会执行内层的finally代码块，然后抛出错误，被外层的catch捕获。\n\n\n# 四、console对象\n\n\n# console.time()，console.timeEnd() （用于计算程序的用时）\n\n这两个方法用于计时，可以算出一个操作所花费的准确时间。\n\nconsole.time('Array initialize');\n\nvar array= new Array(1000000);\nfor (var i = array.length - 1; i >= 0; i--) {\n  array[i] = new Object();\n};\n\nconsole.timeEnd('Array initialize');\n// Array initialize: 1914.481ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ntime方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，控制台会显示“计时器名称: 所耗费的时间”。\n\n\n# 文档\n\n学习文档：https://wangdoc.com/javascript/",normalizedContent:"> 说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源https://wangdoc.com/javascript/，教程版权归原作者所有。\n\n\n# 基础篇\n\n\n# 一、js的一些名词概念\n\n# 什么是作用域？\n\n变量存在的范围。\n\n可分为全局作用域和函数作用域，es6新增块级作用域。\n\n# 什么是闭包？\n\n闭包就是能够读取其他函数内部变量的函数。\n\n * 闭包的形式：函数内部定义函数\n * 本质上闭包就是将函数内部和外部连接起来的一座桥梁\n\n闭包的作用：\n\n * 可以读取函数内部变量\n * 让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。\n * 封装对象的私有属性和私有方法\n\n# 什么是构造函数？\n\n用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。\n\n# 什么是实例对象？\n\n实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的一个对象。\n\n# 什么是this？\n\n就是属性或方法当前所在的对象，指向当前运行环境（对象）\n\n# 什么是原型？\n\n每个函数都有一个prototype属性，指向一个对象，该对象称为原型对象。\n\n# 什么是原型链？\n\n所有对象都有自己的原型对象，由于原型对象也是对象，因此它也有自己的原型，这就会形成一个原型链。\n\n最顶层的原型是object.prototype。\n\n> 读取对象属性时，js会先在对象自身上找，找到就直接返回，如果找不到，会到原型上找，如果还是找不到，就会去原型的原型上找，最终会到最顶层的object.prototype上找，还是找不到就会返回undefined。\n\n# 什么是constructor？\n\nprototype原型对象都有一个constructor属性，默认指向prototype对象所在的构造函数。\n\n# 什么是包装对象？\n\n包装对象指的是将原始类型（数字、字符串、布尔值）进行实例化。\n\n\n# 二、数据类型的转换\n\n\n# 1、强制（手动）转换\n\n强制转换主要指使用number()、string()和boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串、布尔值。\n\n# number()\n\n// 数值：转换后还是原来的值\nnumber(324) // 324\n\n// 字符串：如果可以被解析为数值，则转换为相应的数值\nnumber('324') // 324\n\n// 字符串：如果不可以被解析为数值，返回 nan\nnumber('324abc') // nan\n\n// 空字符串转为0\nnumber('') // 0\n\n// 布尔值：true 转成 1，false 转成 0\nnumber(true) // 1\nnumber(false) // 0\n\n// undefined：转成 nan\nnumber(undefined) // nan\n\n// null：转成0\nnumber(null) // 0\n\nnumber({a: 1}) // nan\nnumber([1, 2, 3]) // nan\nnumber([5]) // 5\nnumber([]) // 0\n\n//使用parseint()转数组\nparseint([1, 2, 3]) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# string()\n\n// 原始类型的转换\nstring(123) // \"123\"\nstring('abc') // \"abc\"\nstring(true) // \"true\"\nstring(undefined) // \"undefined\"\nstring(null) // \"null\"\n\n// 对象的转换\nstring({a: 1}) // \"[object object]\"\nstring([1, 2, 3]) // \"1,2,3\"\nstring([]) // \"\"  空字符串\nstring(function(){}) // \"function(){}\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# boolean()\n\n// 除了这五个为false，其他都为true\nboolean(undefined) // false\nboolean(null) // false\nboolean(0) // false\nboolean(nan) // false\nboolean('') // false\n\n//true\nboolean({}) // true\nboolean([]) // true\nboolean(new boolean(false)) // true\n\nboolean(1) // true\nboolean(' ') // true // 注意字符串内有个空格\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2、自动转换\n\n下面介绍自动转换，它是以强制转换为基础的。\n\n遇到以下三种情况时，javascript 会自动转换数据类型，即转换是自动完成的，用户不可见。\n\n第一种情况，不同类型的数据互相运算。\n\n123 + 'abc' // \"123abc\"\n\n\n1\n\n\n第二种情况，对非布尔值类型的数据求布尔值。\n\nif ('abc') {\n  console.log('hello')\n}  // \"hello\"\n\n\n1\n2\n3\n\n\n第三种情况，对非数值类型的值使用一元运算符（即+和-）。\n\n+ {foo: 'bar'} // nan\n- [1, 2, 3] // nan\n\n\n1\n2\n\n\n自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用string函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。\n\n由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用boolean、number和string函数进行显式转换。\n\n# 自动转换为布尔值（boolean）\n\njavascript 遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用boolean函数。\n\n因此除了以下五个值，其他都是自动转为true。\n\n * undefined\n * null\n * +0或-0\n * nan\n * ''（空字符串）\n\n下面这个例子中，条件部分的每个值都相当于false，使用否定运算符后，就变成了true。\n\nif ( !undefined\n  && !null\n  && !0\n  && !nan\n  && !''\n) {\n  console.log('true');\n} // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是boolean函数。\n\n// 三元运算符\nexpression ? true : false\n\n// 取反运算符\n!! expression\n\n\n1\n2\n3\n4\n5\n\n\n# 自动转换为字符串（string）\n\njavascript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。\n\n字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。\n\n# 所有类型的值与字符串相加都会变成字符串\n\n'5' + 1 // '51'\n 1  + '5' // '15'\n'5' + true // \"5true\"\n'5' + false // \"5false\"\n'5' + {} // \"5[object object]\"\n 5 + {} // \"5[object object]\"\n'5' + [] // \"5\"\n 5 + [] // \"5\"\n'5' + function (){} // \"5function (){}\"\n'5' + undefined // \"5undefined\"\n'5' + null // \"5null\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n#\n\n这种自动转换不注意的话很容易出错。\n\nvar obj = {\n  width: '100'\n};\n\nobj.width + 20 // \"10020\"\nparerint(obj.width) + 20 // 120\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，开发者可能期望返回120，但是由于自动转换，实际上返回了一个字符10020。正确做法是先把字符串转成数字。\n\n# 自动转换为数值（number）\n\njavascript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用number函数。\n\n# 除加号与字符串运行会转成字符串外，其他运行基本都会自动转成数值\n\n'5' - '2' // 3\n'5' * '2' // 10\ntrue - 1  // 0\nfalse - 1 // -1\n'1' - 1   // 0\n'5' * []    // 0\nfalse / '5' // 0\n'abc' - 1   // nan\nnull + 1 // 1\nundefined + 1 // nan\n\ntrue+true // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，运算符两侧的运算子，都被转成了数值。\n\n> 注意：null转为数值时为0，而undefined转为数值时为nan。\n\n数值与布尔值、null也会转为数值\n\n5+true // 6\n5+false // 5\n5+null //5\n\n\n1\n2\n3\n\n\n一元运算符也会把运算子转成数值。\n\n+'abc' // nan\n-'abc' // nan\n+true // 1\n-false // 0\n\n\n1\n2\n3\n4\n\n\n\n# 三、错误处理机制\n\n\n# 1、error实例对象\n\njavascript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。javascript 原生提供error构造函数，所有抛出的错误都是这个构造函数的实例。\n\nvar err = new error('出错了');\nerr.message // \"出错了\"\n\n\n1\n2\n\n\n上面代码中，我们调用error构造函数，生成一个实例对象err。error构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。抛出error实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。\n\njavascript 语言标准只提到，error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。大多数 javascript 引擎，对error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。\n\n * message：错误提示信息\n * name：错误名称（非标准属性）\n * stack：错误的堆栈（非标准属性）\n\n使用name和message这两个属性，可以对发生什么错误有一个大概的了解。\n\nvar err = new error('出错了');\nif (err.name) {\n  console.log(err.name + ': ' + err.message); // error: 出错了\n}\n\n\n1\n2\n3\n4\n\n\nstack属性用来查看错误发生时的堆栈。\n\nfunction throwit() {\n  throw new error('');\n}\n\nfunction catchit() {\n  try {\n    throwit();\n  } catch(e) {\n    console.log(e.stack); // print stack trace\n  }\n}\n\ncatchit()\n// error\n//    at throwit (~/examples/throwcatch.js:9:11) // 堆栈的最内层throwit函数\n//    at catchit (~/examples/throwcatch.js:3:9) // 向外一层catchit函数\n//    at repl:1:5 // 函数的运行环境\n\n\n// 堆栈信息说明\n// error 错误\n//    at throwit 在throwit方法 (~/examples/throwcatch.js:9:11) 文件名：第几行：第几个字符 \n//    at catchit 在catchit方法 (~/examples/throwcatch.js:3:9) 文件名：第几行：第几个字符\n//    at repl:1:5 // 函数的运行环境\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码中，错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。\n\n\n# 2、原生错误类型\n\nerror实例对象是最一般的错误类型，在它的基础上，javascript 还定义了其他6种错误对象。也就是说，存在error的6个派生对象。\n\n# syntaxerror 对象（语法错误）\n\nsyntaxerror对象是解析代码时发生的语法错误。\n\n// 变量名错误\nvar 1a;\n// uncaught syntaxerror: invalid or unexpected token\n// 语法错误：无效或意外的标记符号\n\n// 缺少括号\nconsole.log 'hello');\n// uncaught syntaxerror: unexpected string\n// 语法错误：意外的字符串\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出syntaxerror。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。\n\n# referenceerror 对象（引用错误）\n\nreferenceerror对象是引用一个不存在的变量时发生的错误。\n\n// 使用一个不存在的变量\nunknownvariable\n// uncaught referenceerror: unknownvariable is not defined\n// 引用错误： unknownvariable 没有定义\n\n\n1\n2\n3\n4\n\n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。\n\n// 等号左侧不是变量\nconsole.log() = 1\n// uncaught referenceerror: invalid left-hand side in assignment\n// 引用错误： 赋值中左边是无效的\n\n// this 对象不能手动赋值\nthis = 1\n// referenceerror: invalid left-hand side in assignment\n// 引用错误：  赋值中左边是无效的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码对函数console.log的运行结果和this赋值，结果都引发了referenceerror错误。\n\n# rangeerror 对象（范围错误）\n\nrangeerror对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是number对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n// 数组长度不得为负数\nnew array(-1)\n// uncaught rangeerror: invalid array length\n// 范围错误：无效的数组长度\n\n\n1\n2\n3\n4\n\n\n# typeerror 对象（类型错误）\n\ntypeerror对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。\n\nnew 123\n// uncaught typeerror: number is not a function\n// 类型错误： 数字不是一个函数\n\nvar obj = {};\nobj.unknownmethod()\n// uncaught typeerror: obj.unknownmethod is not a function\n// 类型错误：obj.unknownmethod 不是一个函数\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码的第二种情况，调用对象不存在的方法，也会抛出typeerror错误，因为obj.unknownmethod的值是undefined，而不是一个函数。\n\n# urierror 对象 （uri错误）\n\nurierror对象是 uri 相关函数的参数不正确时抛出的错误，主要涉及encodeuri()、decodeuri()、encodeuricomponent()、decodeuricomponent()、escape()和unescape()这六个函数。\n\ndecodeuri('%2')\n// urierror: uri malformed\n\n\n1\n2\n\n\n# evalerror 对象 （eval错误）\n\neval函数没有被正确执行时，会抛出evalerror错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\n\n# 总结（开发者手动使用）\n\n以上这6种派生错误，连同原始的error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。\n\nvar err1 = new error('出错了！');\nvar err2 = new rangeerror('出错了，变量超出有效范围！');\nvar err3 = new typeerror('出错了，变量类型无效！');\n\nerr1.message // \"出错了！\"\nerr2.message // \"出错了，变量超出有效范围！\"\nerr3.message // \"出错了，变量类型无效！\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3、自定义错误\n\n除了 javascript 原生提供的七种错误对象，还可以定义自己的错误对象。\n\nfunction usererror(message) {\n  this.message = message || '默认信息';\n  this.name = 'usererror';\n}\n\nusererror.prototype = new error(); // 原型继承 error对象\nusererror.prototype.constructor = usererror;\n\n// 使用\nnew usererror('这是自定义的错误！');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码自定义一个错误对象usererror，让它继承error对象。然后，就可以生成这种自定义类型的错误了。\n\n\n# 4、throw 语句 （中断程序并抛出错误）\n\nthrow语句的作用是手动中断程序执行，抛出一个错误。\n\nvar x = 0;\nif (x <= 0) {\n  throw new error('x 必须为正数');\n}\n// uncaught error: x 必须为正数\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，如果变量x小于等于0，就手动抛出一个错误，告诉用户x的值不正确，整个程序就会在这里中断执行。可以看到，throw抛出的错误就是它的参数，这里是一个error实例。\n\nfunction usererror(message) {\n  this.message = message || '默认信息';\n  this.name = 'usererror';\n}\n\nthrow new usererror('出错了！');\n// uncaught usererror {message: \"出错了！\", name: \"usererror\"}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，throw抛出的是一个usererror实例。\n\n实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。\n\n// 抛出一个字符串\nthrow 'error！';\n// uncaught error！\n\n// 抛出一个数值\nthrow 42;\n// uncaught 42\n\n// 抛出一个布尔值\nthrow true;\n// uncaught true\n\n// 抛出一个对象\nthrow {\n  tostring: function () {\n    return 'error!';\n  }\n};\n// uncaught {tostring: ƒ}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n对于 javascript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。\n\n\n# 5、try...catch 结构（捕获错误，对错误进行处理，不中断）\n\n一旦发生错误，程序就中止执行了。javascript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。\n\ntry {\n  throw new error('出错了!');\n} catch (e) {\n  console.log(e.name + \": \" + e.message);\n  console.log(e.stack);\n}\n// error: 出错了!\n//   at <anonymous>:3:9\n//   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，try代码块抛出错误（上例用的是throw语句），javascript 引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。\n\n如果你不确定某些代码是否会报错，就可以把它们放在try...catch代码块之中，便于进一步对错误进行处理。\n\ntry {\n  f();\n} catch(e) {\n  // 处理错误\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，如果函数f执行报错，就会进行catch代码块，接着对错误进行处理。\n\ncatch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。\n\ntry {\n  throw \"出错了\";\n} catch (e) {\n  console.log(111);\n}\nconsole.log(222);\n// 111\n// 222\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，try代码块抛出的错误，被catch代码块捕获后，程序会继续向下执行。\n\ncatch代码块之中，还可以再抛出错误，甚至使用嵌套的try...catch结构。\n\nvar n = 100;\n\ntry {\n  throw n;\n} catch (e) {\n  if (e <= 50) {\n    // ...\n  } else {\n    throw e;\n  }\n}\n// uncaught 100\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，catch代码之中又抛出了一个错误。\n\n为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。\n\ntry {\n  foo.bar();\n} catch (e) {\n  if (e instanceof evalerror) {\n    console.log(e.name + \": \" + e.message);\n  } else if (e instanceof rangeerror) {\n    console.log(e.name + \": \" + e.message);\n  }\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，catch捕获错误之后，会判断错误类型（evalerror还是rangeerror），进行不同的处理。\n\n\n# 6、finally 代码块（在try..catch最后，必执行的）\n\ntry...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。\n\nfunction cleansup() {\n  try {\n    throw new error('出错了……');\n    console.log('此行不会执行');\n  } finally { // 不管有没有出错都会执行finally\n    console.log('完成清理工作');\n  }\n  console.log('此行不会执行');\n}\n\ncleansup()\n// 完成清理工作\n// uncaught error: 出错了…… \n//    at cleansup (<anonymous>:3:11)\n//    at <anonymous>:10:1\n\n// 由于没有catch语句，所以会打印出错误信息，并中断除finally以外的代码。\n// 如果有catch语句则会执行catch内的代码块，而不会打印错误信息。且不会中断代码。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，由于没有catch语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行finally代码块，然后再向用户提示报错信息。\n\nfunction idle(x) {\n  try {\n    console.log(x);\n    return 'result';\n  } finally {\n    console.log('finally');\n  }\n}\n\nidle('hello')\n// hello\n// finally\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，try代码块没有发生错误，而且里面还包括return语句，但是finally代码块依然会执行。而且，这个函数的返回值还是result。\n\n下面的例子说明，return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。\n\nvar count = 0;\nfunction countup() {\n  try {\n    return count;\n  } finally {\n    count++;\n  }\n}\n\ncountup()\n// 0\ncount\n// 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码说明，return语句里面的count的值，是在finally代码块运行之前就获取了。\n\n下面是finally代码块用法的典型场景。\n\nopenfile(); // 打开文件\n\ntry {\n  writefile(data); // 写入文件\n} catch(e) {\n  handleerror(e); // 如果写入出错这处理错误\n} finally {\n  closefile();// 不管是否出错都会执行关闭文件\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码首先打开一个文件，然后在try代码块中写入文件，如果没有发生错误，则运行finally代码块关闭文件；一旦发生错误，则先使用catch代码块处理错误，再使用finally代码块关闭文件。\n\n下面的例子充分反映了try...catch...finally这三者之间的执行顺序。\n\nfunction f() {\n  try {\n    console.log(0);\n    throw 'bug';\n  } catch(e) {\n    console.log(1);\n    return true; // 这句原本会延迟到 finally 代码块结束再执行\n    console.log(2); // 不会运行\n  } finally {\n    console.log(3);\n    return false; // 这句会覆盖掉前面那句 return\n    console.log(4); // 不会运行\n  }\n\n  console.log(5); // 不会运行\n}\n\nvar result = f();\n// 0\n// 1\n// 3\n\nresult\n// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码中，catch代码块结束执行之前，会先执行finally代码块。\n\ncatch代码块之中，触发转入finally代码块的标志，不仅有return语句，还有throw语句。\n\nfunction f() {\n  try {\n    throw '出错了！';\n  } catch(e) {\n    console.log('捕捉到内部错误');\n    throw e; // 这句原本会等到finally结束再执行\n  } finally {\n    return false; // 直接返回\n  }\n}\n\ntry {\n  f(); // 接收到返回值false，并没有接收到错误\n} catch(e) {\n  // 此处不会执行\n  console.log('caught outer \"bogus\"');\n}\n\n//  捕捉到内部错误\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。\n\ntry代码块内部，还可以再使用try代码块。\n\ntry {\n  try {\n    consle.log('hello world!'); // 报错，console拼错\n  }\n  finally {\n    console.log('finally');\n  }\n  console.log('will i run?');\n} catch(error) {\n  console.error(error.message);\n}\n// finally\n// consle is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，try里面还有一个try。内层的try报错（console拼错了），这时会执行内层的finally代码块，然后抛出错误，被外层的catch捕获。\n\n\n# 四、console对象\n\n\n# console.time()，console.timeend() （用于计算程序的用时）\n\n这两个方法用于计时，可以算出一个操作所花费的准确时间。\n\nconsole.time('array initialize');\n\nvar array= new array(1000000);\nfor (var i = array.length - 1; i >= 0; i--) {\n  array[i] = new object();\n};\n\nconsole.timeend('array initialize');\n// array initialize: 1914.481ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ntime方法表示计时开始，timeend方法表示计时结束。它们的参数是计时器的名称。调用timeend方法之后，控制台会显示“计时器名称: 所耗费的时间”。\n\n\n# 文档\n\n学习文档：https://wangdoc.com/javascript/",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"安装 TypeScript",frontmatter:{feed:{enable:!0},title:"安装 TypeScript",date:"2020-01-05T10:15:07.000Z",permalink:"/install-typescript.html",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","初识 TypeScript"],tags:[null],description:"命令行运行如下命令，全局安装 TypeScript：",meta:[{name:"twitter:title",content:"安装 TypeScript"},{name:"twitter:description",content:"命令行运行如下命令，全局安装 TypeScript："},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/01.%E5%88%9D%E8%AF%86%20TypeScript/02.%E5%AE%89%E8%A3%85%20TypeScript.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"安装 TypeScript"},{property:"og:description",content:"命令行运行如下命令，全局安装 TypeScript："},{property:"og:url",content:"https://dbdgs.cn/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/01.%E5%88%9D%E8%AF%86%20TypeScript/02.%E5%AE%89%E8%A3%85%20TypeScript.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-01-05T10:15:07.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"安装 TypeScript"},{itemprop:"description",content:"命令行运行如下命令，全局安装 TypeScript："}]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/01.%E5%88%9D%E8%AF%86%20TypeScript/02.%E5%AE%89%E8%A3%85%20TypeScript.html",relativePath:"《TypeScript 从零实现 axios》/01.初识 TypeScript/02.安装 TypeScript.md",key:"v-44ea6316",path:"/install-typescript.html",headersStr:null,content:"# 安装 TypeScript\n\n命令行运行如下命令，全局安装 TypeScript：\n\nnpm install -g typescript\n\n\n1\n\n\n安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：\n\ntsc -V \n\n\n1\n",normalizedContent:"# 安装 typescript\n\n命令行运行如下命令，全局安装 typescript：\n\nnpm install -g typescript\n\n\n1\n\n\n安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：\n\ntsc -v \n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"MVVM模式",frontmatter:{feed:{enable:!0},title:"MVVM模式",date:"2020-02-04T12:19:00.000Z",permalink:"/mvvm-pattern.html",categories:["《Vue》笔记","基础"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"提示\n说明：本章内容是博主的Vue学习笔记，以官方文档为准。\n\nMVVM模式\nMVVM模式，M即 model，数据模型；V即 view，视图；VM即 view-model，视图模型。",meta:[{name:"image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200204123438.png"},{name:"twitter:title",content:"MVVM模式"},{name:"twitter:description",content:"提示\n说明：本章内容是博主的Vue学习笔记，以官方文档为准。\n\nMVVM模式\nMVVM模式，M即 model，数据模型；V即 view，视图；VM即 view-model，视图模型。"},{name:"twitter:card",content:"summary_large_image"},{name:"twitter:image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200204123438.png"},{name:"twitter:url",content:"https://dbdgs.cn/%E3%80%8AVue%E3%80%8B%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80/00.MVVM%E6%A8%A1%E5%BC%8F.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"MVVM模式"},{property:"og:description",content:"提示\n说明：本章内容是博主的Vue学习笔记，以官方文档为准。\n\nMVVM模式\nMVVM模式，M即 model，数据模型；V即 view，视图；VM即 view-model，视图模型。"},{property:"og:image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200204123438.png"},{property:"og:url",content:"https://dbdgs.cn/%E3%80%8AVue%E3%80%8B%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80/00.MVVM%E6%A8%A1%E5%BC%8F.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-02-04T12:19:00.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"MVVM模式"},{itemprop:"description",content:"提示\n说明：本章内容是博主的Vue学习笔记，以官方文档为准。\n\nMVVM模式\nMVVM模式，M即 model，数据模型；V即 view，视图；VM即 view-model，视图模型。"},{itemprop:"image",content:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200204123438.png"}]},regularPath:"/%E3%80%8AVue%E3%80%8B%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80/00.MVVM%E6%A8%A1%E5%BC%8F.html",relativePath:"《Vue》笔记/01.基础/00.MVVM模式.md",key:"v-78c8d138",path:"/mvvm-pattern.html",excerpt:'<div class="custom-block tip"><p class="custom-block-title">提示</p>\n<p>说明：本章内容是博主的Vue学习笔记，以<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="nofollow noopener noreferrer">官方文档<OutboundLink/></a>为准。</p>\n</div>\n<h1 id="mvvm模式"><a class="header-anchor" href="#mvvm模式">#</a> MVVM模式</h1>\n<p>MVVM模式，<code>M</code>即 model，数据模型；<code>V</code>即 view，视图；<code>VM</code>即 view-model，视图模型。</p>\n',headersStr:null,content:"提示\n\n说明：本章内容是博主的Vue学习笔记，以官方文档为准。\n\n\n# MVVM模式\n\nMVVM模式，M即 model，数据模型；V即 view，视图；VM即 view-model，视图模型。\n\n理解\n\n首先，数据Model通过Data Bindings把数据绑定在View视图上，\n\n当View视图有交互（有改变）的时候，Dom listeners会自动监听，然后更新数据Model。\n\nQ：什么是MVVM模式？\n\nA：MVVM模式，第一个M代表数据模型，V代表视图，VM代表视图模型； 它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候， 视图模型会自动监听到用户的操作，从而改变后台数据。",normalizedContent:"提示\n\n说明：本章内容是博主的vue学习笔记，以官方文档为准。\n\n\n# mvvm模式\n\nmvvm模式，m即 model，数据模型；v即 view，视图；vm即 view-model，视图模型。\n\n理解\n\n首先，数据model通过data bindings把数据绑定在view视图上，\n\n当view视图有交互（有改变）的时候，dom listeners会自动监听，然后更新数据model。\n\nq：什么是mvvm模式？\n\na：mvvm模式，第一个m代表数据模型，v代表视图，vm代表视图模型； 它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候， 视图模型会自动监听到用户的操作，从而改变后台数据。",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"自定义事件",frontmatter:{feed:{enable:!0},title:"自定义事件",date:"2020-02-15T11:27:45.000Z",permalink:"/custom-events.html",categories:["《Vue》笔记","组件"],tags:[null],author:{name:"geekzl.com",link:"https://github.com/wpfgeek"},description:"API",meta:[{name:"twitter:title",content:"自定义事件"},{name:"twitter:description",content:"API"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/%E3%80%8AVue%E3%80%8B%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/21.%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"自定义事件"},{property:"og:description",content:"API"},{property:"og:url",content:"https://dbdgs.cn/%E3%80%8AVue%E3%80%8B%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/21.%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2020-02-15T11:27:45.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"自定义事件"},{itemprop:"description",content:"API"}]},regularPath:"/%E3%80%8AVue%E3%80%8B%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/21.%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6.html",relativePath:"《Vue》笔记/02.组件/21.自定义事件.md",key:"v-46620dca",path:"/custom-events.html",headers:[{level:3,title:"在组件标签v-on绑定的事件是自定义事件",slug:"在组件标签v-on绑定的事件是自定义事件",normalizedTitle:"在组件标签v-on绑定的事件是自定义事件",charIndex:17},{level:3,title:"使自定义事件变为原生事件",slug:"使自定义事件变为原生事件",normalizedTitle:"使自定义事件变为原生事件",charIndex:1176},{level:3,title:"自定义事件名会自动变小写",slug:"自定义事件名会自动变小写",normalizedTitle:"自定义事件名会自动变小写",charIndex:1704}],headersStr:"在组件标签v-on绑定的事件是自定义事件 使自定义事件变为原生事件 自定义事件名会自动变小写",content:"# 自定义事件\n\nAPI\n\n\n# 在组件标签v-on绑定的事件是自定义事件\n\n<div id=\"root\">\n    <child @click=\"handleClick\"></child> \x3c!--这里click是自定义事件--\x3e\n</div>\n\n<script type=\"text/javascript\">\n    Vue.component('child', {\n        template: '<button>Child</button>',\n    })\n\n    var vm = new Vue({\n        el: '#root'\n        methods: {\n            handleClick() {\n                alert('click')\n            }\n        }\n    })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面这种情况，当点击子组件时并不会触发handleClick()事件，因为此时的click并非原生的点击事件，而是一个自定义事件。\n\n要想触发组件标签中的click事件需要通过子组件$emit来派发\n\n<div id=\"root\">\n    <child @click=\"handleClick\"></child>\n</div>\n\n<script type=\"text/javascript\">\n    Vue.component('child', {\n        template: '<button @click=\"handleChildClick\">Child</button>', // 这里的click是原生事件\n        methods: {\n            handleChildClick() {\n                this.$emit('click')\n            }\n        }\n    })\n\n    var vm = new Vue({\n        el: '#root'\n        methods: {\n            handleClick() {\n                alert('click')\n            }\n        }\n    })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上面代码中，子组件内的click是原生点击事件，通过$emit派发click自定义事件触发父组件的handleClick()\n\n\n# 使自定义事件变为原生事件\n\n使用.native修饰符把自定义事件变为原生事件\n\n<div id=\"root\">\n    <child @click.native=\"handleClick\"></child> \x3c!--自定义事件添加了native修饰符变原生事件--\x3e\n</div>\n\n<script type=\"text/javascript\">\n    Vue.component('child', {\n        template: '<button>Child</button>',\n    })\n\n    var vm = new Vue({\n        el: '#root'\n        methods: {\n            handleClick() {\n                alert('click')\n            }\n        }\n    })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，自定义事件click添加了.native修饰符，使其变为原生事件，从而触发handleClick()。\n\n\n# 自定义事件名会自动变小写\n\n当使用camelCase（驼峰）命名的自定义函数\n\nthis.$emit('myEvent')\n\n\n1\n\n\n则监听这个名字的 kebab-case（烤串） 版本是不会有任何效果的：\n\n\x3c!-- 没有效果 --\x3e\n<my-component v-on:my-event=\"doSomething\"></my-component>\n\n\n1\n2\n\n\nv-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。\n\n因此，我们推荐你始终使用 kebab-case（烤串） 的事件名。",normalizedContent:"# 自定义事件\n\napi\n\n\n# 在组件标签v-on绑定的事件是自定义事件\n\n<div id=\"root\">\n    <child @click=\"handleclick\"></child> \x3c!--这里click是自定义事件--\x3e\n</div>\n\n<script type=\"text/javascript\">\n    vue.component('child', {\n        template: '<button>child</button>',\n    })\n\n    var vm = new vue({\n        el: '#root'\n        methods: {\n            handleclick() {\n                alert('click')\n            }\n        }\n    })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面这种情况，当点击子组件时并不会触发handleclick()事件，因为此时的click并非原生的点击事件，而是一个自定义事件。\n\n要想触发组件标签中的click事件需要通过子组件$emit来派发\n\n<div id=\"root\">\n    <child @click=\"handleclick\"></child>\n</div>\n\n<script type=\"text/javascript\">\n    vue.component('child', {\n        template: '<button @click=\"handlechildclick\">child</button>', // 这里的click是原生事件\n        methods: {\n            handlechildclick() {\n                this.$emit('click')\n            }\n        }\n    })\n\n    var vm = new vue({\n        el: '#root'\n        methods: {\n            handleclick() {\n                alert('click')\n            }\n        }\n    })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上面代码中，子组件内的click是原生点击事件，通过$emit派发click自定义事件触发父组件的handleclick()\n\n\n# 使自定义事件变为原生事件\n\n使用.native修饰符把自定义事件变为原生事件\n\n<div id=\"root\">\n    <child @click.native=\"handleclick\"></child> \x3c!--自定义事件添加了native修饰符变原生事件--\x3e\n</div>\n\n<script type=\"text/javascript\">\n    vue.component('child', {\n        template: '<button>child</button>',\n    })\n\n    var vm = new vue({\n        el: '#root'\n        methods: {\n            handleclick() {\n                alert('click')\n            }\n        }\n    })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，自定义事件click添加了.native修饰符，使其变为原生事件，从而触发handleclick()。\n\n\n# 自定义事件名会自动变小写\n\n当使用camelcase（驼峰）命名的自定义函数\n\nthis.$emit('myevent')\n\n\n1\n\n\n则监听这个名字的 kebab-case（烤串） 版本是不会有任何效果的：\n\n\x3c!-- 没有效果 --\x3e\n<my-component v-on:my-event=\"dosomething\"></my-component>\n\n\n1\n2\n\n\nv-on 事件监听器在 dom 模板中会被自动转换为全小写 (因为 html 是大小写不敏感的)，所以 v-on:myevent 将会变成 v-on:myevent——导致 myevent 不可能被监听到。\n\n因此，我们推荐你始终使用 kebab-case（烤串） 的事件名。",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode103 Binary Tree Zigzag Level Order Traversal-zh",frontmatter:{title:"leetcode103 Binary Tree Zigzag Level Order Traversal-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/5f3c41/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode103 Binary Tree Zigzag Level Order Traversal-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10103.leetcode103%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode103 Binary Tree Zigzag Level Order Traversal-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10103.leetcode103%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode103 Binary Tree Zigzag Level Order Traversal-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10103.leetcode103%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal-zh.html",relativePath:"01.算法/24.leetcode/10103.leetcode103 Binary Tree Zigzag Level Order Traversal-zh.md",key:"v-d45a52be",path:"/p/5f3c41/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:40},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:237},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:244},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:1163},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2588},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:3741}],headersStr:"题目描述 解法 Python3 Java JavaScript ...",content:"# 103. 二叉树的锯齿形层序遍历\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n例如：\n给定二叉树 [3,9,20,null,null,15,7],\n\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回锯齿形层序遍历如下：\n\n\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n\n\n\n# 解法\n\n\n# Python3\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\n        if root is None:\n            return []\n        res = []\n        q = collections.deque([root])\n        left = False\n        while q:\n            size = len(q)\n            t = []\n            for _ in range(size):\n                node = q.popleft()\n                t.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if left:\n                t.reverse()\n            res.append(t)\n            left = not left\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# Java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        Deque<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        List<List<Integer>> res = new ArrayList<>();\n        boolean left = false;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            List<Integer> t = new ArrayList<>();\n            while (size-- > 0) {\n                TreeNode node = q.pollFirst();\n                t.add(node.val);\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n            if (left) {\n                Collections.reverse(t);\n            }\n            res.add(t);\n            left = !left;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# JavaScript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar zigzagLevelOrder = function (root) {\n    if (!root) {\n        return [];\n    }\n    let res = [], q = [];\n    q.push(root);\n    let leftToRight = true;\n    while (q.length) {\n        let levelSize = q.length, levelOutput = [];\n        for (let i = 0; i < levelSize; i++) {\n            let cur = q.shift();\n            if (cur.left) {\n                q.push(cur.left);\n            }\n            if (cur.right) {\n                q.push(cur.right);\n            }\n            if (leftToRight) {\n                levelOutput.push(cur.val);\n            } else {\n                levelOutput.unshift(cur.val);\n            }\n        }\n        res.push(levelOutput);\n        leftToRight = !leftToRight;\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 103. 二叉树的锯齿形层序遍历\n\nenglish version\n\n\n# 题目描述\n\n给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n例如：\n给定二叉树 [3,9,20,null,null,15,7],\n\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回锯齿形层序遍历如下：\n\n\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n\n\n\n# 解法\n\n\n# python3\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, val=0, left=none, right=none):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass solution:\n    def zigzaglevelorder(self, root: treenode) -> list[list[int]]:\n        if root is none:\n            return []\n        res = []\n        q = collections.deque([root])\n        left = false\n        while q:\n            size = len(q)\n            t = []\n            for _ in range(size):\n                node = q.popleft()\n                t.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if left:\n                t.reverse()\n            res.append(t)\n            left = not left\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# java\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public list<list<integer>> zigzaglevelorder(treenode root) {\n        if (root == null) {\n            return collections.emptylist();\n        }\n        deque<treenode> q = new arraydeque<>();\n        q.offer(root);\n        list<list<integer>> res = new arraylist<>();\n        boolean left = false;\n        while (!q.isempty()) {\n            int size = q.size();\n            list<integer> t = new arraylist<>();\n            while (size-- > 0) {\n                treenode node = q.pollfirst();\n                t.add(node.val);\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n            if (left) {\n                collections.reverse(t);\n            }\n            res.add(t);\n            left = !left;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# javascript\n\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number[][]}\n */\nvar zigzaglevelorder = function (root) {\n    if (!root) {\n        return [];\n    }\n    let res = [], q = [];\n    q.push(root);\n    let lefttoright = true;\n    while (q.length) {\n        let levelsize = q.length, leveloutput = [];\n        for (let i = 0; i < levelsize; i++) {\n            let cur = q.shift();\n            if (cur.left) {\n                q.push(cur.left);\n            }\n            if (cur.right) {\n                q.push(cur.right);\n            }\n            if (lefttoright) {\n                leveloutput.push(cur.val);\n            } else {\n                leveloutput.unshift(cur.val);\n            }\n        }\n        res.push(leveloutput);\n        lefttoright = !lefttoright;\n    }\n    return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"},{title:"leetcode233 Number of Digit One-zh",frontmatter:{title:"leetcode233 Number of Digit One-zh",date:"2021-07-20T04:24:14.000Z",permalink:"/p/6985d1/",categories:["算法","leetcode"],tags:[null],description:"English Version",meta:[{name:"twitter:title",content:"leetcode233 Number of Digit One-zh"},{name:"twitter:description",content:"English Version"},{name:"twitter:card",content:"summary"},{name:"twitter:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10233.leetcode233%20Number%20of%20Digit%20One-zh.html"},{name:"twitter:site",content:"@yanglr"},{property:"og:type",content:"article"},{property:"og:title",content:"leetcode233 Number of Digit One-zh"},{property:"og:description",content:"English Version"},{property:"og:url",content:"https://dbdgs.cn/01.%E7%AE%97%E6%B3%95/24.leetcode/10233.leetcode233%20Number%20of%20Digit%20One-zh.html"},{property:"og:site_name",content:"Bravo Yeung"},{property:"article:published_time",content:"2021-07-20T04:24:14.000Z"},{property:"article:tag",content:null},{itemprop:"name",content:"leetcode233 Number of Digit One-zh"},{itemprop:"description",content:"English Version"}]},regularPath:"/01.%E7%AE%97%E6%B3%95/24.leetcode/10233.leetcode233%20Number%20of%20Digit%20One-zh.html",relativePath:"01.算法/24.leetcode/10233.leetcode233 Number of Digit One-zh.md",key:"v-7ee238fd",path:"/p/6985d1/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:37},{level:2,title:"解法",slug:"解法",normalizedTitle:"解法",charIndex:167},{level:3,title:"Python3",slug:"python3",normalizedTitle:"python3",charIndex:174},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:193},{level:3,title:"...",slug:"",normalizedTitle:"...",charIndex:209}],headersStr:"题目描述 解法 Python3 Java ...",content:"# 233. 数字 1 的个数\n\nEnglish Version\n\n\n# 题目描述\n\n给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。\n\n \n\n示例 1：\n\n\n输入：n = 13\n输出：6\n\n\n示例 2：\n\n\n输入：n = 0\n输出：0\n\n\n \n\n提示：\n\n * 0 <= n <= 2 * 109\n\n\n# 解法\n\n\n# Python3\n\n\n\n\n1\n\n\n\n# Java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",normalizedContent:"# 233. 数字 1 的个数\n\nenglish version\n\n\n# 题目描述\n\n给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。\n\n \n\n示例 1：\n\n\n输入：n = 13\n输出：6\n\n\n示例 2：\n\n\n输入：n = 0\n输出：0\n\n\n \n\n提示：\n\n * 0 <= n <= 2 * 109\n\n\n# 解法\n\n\n# python3\n\n\n\n\n1\n\n\n\n# java\n\n\n\n\n1\n\n\n\n# ...\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/20, 04:23:41"}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"算法",link:"/algo/",items:[{text:"学习笔记",items:[{text:"LeetCode题解导航",link:"/leetcode/"}]}]},{text:"前端",link:"/web/",items:[{text:"学习笔记",items:[{text:"TypeScript笔记",link:"/typescript/"}]}]},{text:"页面",link:"/ui/"},{text:"技术",link:"/technology/"},{text:"更多",link:"/more/",items:[{text:"友情链接",link:"/friends/"}]},{text:"关于",link:"/about/"},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],sidebarDepth:3,logo:"/img/nav-logo.png",repo:"dbdgs/dbdgs.github.io",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",domain:"https://dbdgs.cn",sidebar:{"/00.目录页/":[["01.算法.md","算法","/algo"],["02.页面.md","页面","/ui"],["03.技术.md","技术","/technology"],["04.前端.md","前端","/web"],["05.更多.md","更多","/more"]],catalogue:{"算法":"/algo","页面":"/ui","技术":"/technology","前端":"/web","更多":"/more"},"/01.算法/":[{title:"leetcode",collapsable:!0,children:[["24.leetcode/27.LeetCode题解.md","LeetCode题解","/leetcode/"],["24.leetcode/10001.leetcode1 两数之和[简单难度].md","leetcode1 两数之和[简单难度]","/leetcode1/"],["24.leetcode/10002.leetcode2 Add Two Numbers.md","leetcode2 Add Two Numbers","/p/244378/"],["24.leetcode/10003.leetcode3 Longest Substring Without Repeating Characters.md","leetcode3 Longest Substring Without Repeating Characters","/p/a2420b/"],["24.leetcode/10004.leetcode4 寻找两个正序数组的中位数[困难难度].md","leetcode4 寻找两个正序数组的中位数[困难难度]","/leetcode4/"],["24.leetcode/10005.leetcode5 Longest Palindromic Substring.md","leetcode5 Longest Palindromic Substring","/p/804ab4/"],["24.leetcode/10006.leetcode6 ZigZag Conversion.md","leetcode6 ZigZag Conversion","/p/a57b35/"],["24.leetcode/10007.leetcode7 Reverse Integer.md","leetcode7 Reverse Integer","/p/786ee4/"],["24.leetcode/10008.leetcode8 String to Integer (atoi).md","leetcode8 String to Integer (atoi)","/p/d5e058/"],["24.leetcode/10009.leetcode9 Palindrome Number.md","leetcode9 Palindrome Number","/p/d52cd1/"],["24.leetcode/10010.leetcode10 Regular Expression Matching.md","leetcode10 Regular Expression Matching","/p/10dbda/"],["24.leetcode/10011.leetcode11-盛最多水的容器[中等难度].md","leetcode11-盛最多水的容器[中等难度]","/leetcode11/"],["24.leetcode/10012.leetcode12 Integer to Roman.md","leetcode12 Integer to Roman","/p/a5942d/"],["24.leetcode/10013.leetcode13 Roman to Integer.md","leetcode13 Roman to Integer","/p/07f2a8/"],["24.leetcode/10014.leetcode14 Longest Common Prefix.md","leetcode14 Longest Common Prefix","/p/bbae3d/"],["24.leetcode/10015.leetcode15 3Sum.md","leetcode15 3Sum","/p/42c6e3/"],["24.leetcode/10016.leetcode16 3Sum Closest.md","leetcode16 3Sum Closest","/p/5fe737/"],["24.leetcode/10017.leetcode17 Letter Combinations of a Phone Number.md","leetcode17 Letter Combinations of a Phone Number","/p/942fa8/"],["24.leetcode/10018.leetcode18 4Sum.md","leetcode18 4Sum","/p/1935e9/"],["24.leetcode/10019.leetcode19 Remove Nth Node From End of List.md","leetcode19 Remove Nth Node From End of List","/p/e99d7b/"],["24.leetcode/10020.leetcode20 Valid Parentheses.md","leetcode20 Valid Parentheses","/p/0afb6c/"],["24.leetcode/10021.leetcode21 Merge Two Sorted Lists.md","leetcode21 Merge Two Sorted Lists","/p/163bb4/"],["24.leetcode/10022.leetcode22 Generate Parentheses.md","leetcode22 Generate Parentheses","/p/cc1223/"],["24.leetcode/10023.leetcode23 Merge k Sorted Lists.md","leetcode23 Merge k Sorted Lists","/p/e16635/"],["24.leetcode/10024.leetcode24 Swap Nodes in Pairs.md","leetcode24 Swap Nodes in Pairs","/p/5421f4/"],["24.leetcode/10025.leetcode25 Reverse Nodes in k-Group.md","leetcode25 Reverse Nodes in k-Group","/p/222c60/"],["24.leetcode/10026.leetcode26 Remove Duplicates from Sorted Array.md","leetcode26 Remove Duplicates from Sorted Array","/p/dbd8bb/"],["24.leetcode/10027.leetcode27 Remove Element.md","leetcode27 Remove Element","/p/ac2720/"],["24.leetcode/10028.leetcode28 Implement strStr().md","leetcode28 Implement strStr()","/p/612dd5/"],["24.leetcode/10029.leetcode29 Divide Two Integers.md","leetcode29 Divide Two Integers","/p/35bd07/"],["24.leetcode/10030.leetcode30 Substring with Concatenation of All Words.md","leetcode30 Substring with Concatenation of All Words","/p/62136e/"],["24.leetcode/10031.leetcode31 Next Permutation.md","leetcode31 Next Permutation","/p/d4a741/"],["24.leetcode/10032.leetcode32 Longest Valid Parentheses.md","leetcode32 Longest Valid Parentheses","/p/d12644/"],["24.leetcode/10033.leetcode33 Search in Rotated Sorted Array.md","leetcode33 Search in Rotated Sorted Array","/p/584160/"],["24.leetcode/10034.leetcode34 Find First and Last Position of Element in Sorted Array.md","leetcode34 Find First and Last Position of Element in Sorted Array","/p/f47e3f/"],["24.leetcode/10035.leetcode35 Search Insert Position.md","leetcode35 Search Insert Position","/p/b5f6ea/"],["24.leetcode/10036.leetcode36 有效的数独[中等难度].md","leetcode36 有效的数独[中等难度]","/leetcode36/"],["24.leetcode/10037.leetcode37 Sudoku Solver.md","leetcode37 Sudoku Solver","/p/1a4005/"],["24.leetcode/10038.leetcode38 外观数列(报数)【中等难度】.md","leetcode38 外观数列(报数)【中等难度】","/leetcode38/"],["24.leetcode/10039.leetcode39 Combination Sum.md","leetcode39 Combination Sum","/p/ca29a3/"],["24.leetcode/10040.leetcode40 Combination Sum II.md","leetcode40 Combination Sum II","/p/3104b4/"],["24.leetcode/10041.leetcode41 First Missing Positive-zh.md","leetcode41 First Missing Positive-zh","/p/56c9c9/"],["24.leetcode/10042.leetcode42 Trapping Rain Water-zh.md","leetcode42 Trapping Rain Water-zh","/p/41be27/"],["24.leetcode/10043.leetcode43 Multiply Strings-zh.md","leetcode43 Multiply Strings-zh","/p/b5dd5b/"],["24.leetcode/10044.leetcode44 Wildcard Matching-zh.md","leetcode44 Wildcard Matching-zh","/p/6a9e78/"],["24.leetcode/10045.leetcode45 Jump Game II-zh.md","leetcode45 Jump Game II-zh","/p/fce74b/"],["24.leetcode/10046.leetcode46 Permutations-zh.md","leetcode46 Permutations-zh","/p/64e1ed/"],["24.leetcode/10047.leetcode47 Permutations II-zh.md","leetcode47 Permutations II-zh","/p/8e858c/"],["24.leetcode/10048.leetcode48 Rotate Image-zh.md","leetcode48 Rotate Image-zh","/p/deb8c7/"],["24.leetcode/10049.leetcode49 Group Anagrams-zh.md","leetcode49 Group Anagrams-zh","/p/15206f/"],["24.leetcode/10050.leetcode50 Pow(x, n)-zh.md","leetcode50 Pow(x, n)-zh","/p/f37caf/"],["24.leetcode/10051.leetcode51 N-Queens-zh.md","leetcode51 N-Queens-zh","/p/890db5/"],["24.leetcode/10052.leetcode52 N-Queens II-zh.md","leetcode52 N-Queens II-zh","/p/06718e/"],["24.leetcode/10053.leetcode53 Maximum Subarray-zh.md","leetcode53 Maximum Subarray-zh","/p/827961/"],["24.leetcode/10054.leetcode54 Spiral Matrix-zh.md","leetcode54 Spiral Matrix-zh","/p/b4f91b/"],["24.leetcode/10055.leetcode55 Jump Game-zh.md","leetcode55 Jump Game-zh","/p/30906e/"],["24.leetcode/10056.leetcode56 Merge Intervals-zh.md","leetcode56 Merge Intervals-zh","/p/f65cda/"],["24.leetcode/10057.leetcode57 Insert Interval-zh.md","leetcode57 Insert Interval-zh","/p/93b3a2/"],["24.leetcode/10058.leetcode58 Length of Last Word-zh.md","leetcode58 Length of Last Word-zh","/p/3d955e/"],["24.leetcode/10059.leetcode59 Spiral Matrix II-zh.md","leetcode59 Spiral Matrix II-zh","/p/1f8940/"],["24.leetcode/10060.leetcode60 Permutation Sequence-zh.md","leetcode60 Permutation Sequence-zh","/p/a46975/"],["24.leetcode/10061.leetcode61 Rotate List-zh.md","leetcode61 Rotate List-zh","/p/fe1724/"],["24.leetcode/10062.leetcode62 Unique Paths-zh.md","leetcode62 Unique Paths-zh","/p/665af6/"],["24.leetcode/10063.leetcode63 Unique Paths II-zh.md","leetcode63 Unique Paths II-zh","/p/641106/"],["24.leetcode/10064.leetcode64 Minimum Path Sum-zh.md","leetcode64 Minimum Path Sum-zh","/p/3cbab8/"],["24.leetcode/10065.leetcode65 Valid Number-zh.md","leetcode65 Valid Number-zh","/p/d84d4d/"],["24.leetcode/10066.leetcode66 Plus One-zh.md","leetcode66 Plus One-zh","/p/a9a5e7/"],["24.leetcode/10067.leetcode67 Add Binary-zh.md","leetcode67 Add Binary-zh","/p/7ca8bd/"],["24.leetcode/10068.leetcode68 Text Justification-zh.md","leetcode68 Text Justification-zh","/p/d7cf8a/"],["24.leetcode/10069.leetcode69 Sqrt(x)-zh.md","leetcode69 Sqrt(x)-zh","/p/565a77/"],["24.leetcode/10070.leetcode70 Climbing Stairs-zh.md","leetcode70 Climbing Stairs-zh","/p/fa8040/"],["24.leetcode/10071.leetcode71 Simplify Path-zh.md","leetcode71 Simplify Path-zh","/p/ba0add/"],["24.leetcode/10072.leetcode72 Edit Distance-zh.md","leetcode72 Edit Distance-zh","/p/143034/"],["24.leetcode/10073.leetcode73 Set Matrix Zeroes-zh.md","leetcode73 Set Matrix Zeroes-zh","/p/1a45c9/"],["24.leetcode/10074.leetcode74 Search a 2D Matrix-zh.md","leetcode74 Search a 2D Matrix-zh","/p/8b2390/"],["24.leetcode/10075.leetcode75 Sort Colors-zh.md","leetcode75 Sort Colors-zh","/p/d1d03e/"],["24.leetcode/10076.leetcode76 Minimum Window Substring-zh.md","leetcode76 Minimum Window Substring-zh","/p/8151b3/"],["24.leetcode/10077.leetcode77 Combinations-zh.md","leetcode77 Combinations-zh","/p/c30f65/"],["24.leetcode/10078.leetcode78 Subsets-zh.md","leetcode78 Subsets-zh","/p/be20e0/"],["24.leetcode/10079.leetcode79 Word Search-zh.md","leetcode79 Word Search-zh","/p/832da5/"],["24.leetcode/10080.leetcode80 Remove Duplicates from Sorted Array II-zh.md","leetcode80 Remove Duplicates from Sorted Array II-zh","/p/2f5116/"],["24.leetcode/10081.leetcode81 Search in Rotated Sorted Array II-zh.md","leetcode81 Search in Rotated Sorted Array II-zh","/p/d72c14/"],["24.leetcode/10082.leetcode82 Remove Duplicates from Sorted List II-zh.md","leetcode82 Remove Duplicates from Sorted List II-zh","/p/3f819f/"],["24.leetcode/10083.leetcode83 Remove Duplicates from Sorted List-zh.md","leetcode83 Remove Duplicates from Sorted List-zh","/p/54a9ff/"],["24.leetcode/10084.leetcode84 Largest Rectangle in Histogram-zh.md","leetcode84 Largest Rectangle in Histogram-zh","/p/61c799/"],["24.leetcode/10085.leetcode85 Maximal Rectangle-zh.md","leetcode85 Maximal Rectangle-zh","/p/54fa5d/"],["24.leetcode/10086.leetcode86 Partition List-zh.md","leetcode86 Partition List-zh","/p/4b39e8/"],["24.leetcode/10087.leetcode87 Scramble String-zh.md","leetcode87 Scramble String-zh","/p/9b9658/"],["24.leetcode/10088.leetcode88 Merge Sorted Array-zh.md","leetcode88 Merge Sorted Array-zh","/p/9ab86e/"],["24.leetcode/10089.leetcode89 Gray Code-zh.md","leetcode89 Gray Code-zh","/p/dc9180/"],["24.leetcode/10090.leetcode90 Subsets II-zh.md","leetcode90 Subsets II-zh","/p/8df0f5/"],["24.leetcode/10091.leetcode91 Decode Ways-zh.md","leetcode91 Decode Ways-zh","/p/04a12e/"],["24.leetcode/10092.leetcode92 Reverse Linked List II-zh.md","leetcode92 Reverse Linked List II-zh","/p/4999f0/"],["24.leetcode/10093.leetcode93 Restore IP Addresses-zh.md","leetcode93 Restore IP Addresses-zh","/p/81aad5/"],["24.leetcode/10094.leetcode94 Binary Tree Inorder Traversal-zh.md","leetcode94 Binary Tree Inorder Traversal-zh","/p/6844b9/"],["24.leetcode/10095.leetcode95 Unique Binary Search Trees II-zh.md","leetcode95 Unique Binary Search Trees II-zh","/p/65b61c/"],["24.leetcode/10096.leetcode96 Unique Binary Search Trees-zh.md","leetcode96 Unique Binary Search Trees-zh","/p/b6afec/"],["24.leetcode/10097.leetcode97 Interleaving String-zh.md","leetcode97 Interleaving String-zh","/p/53d753/"],["24.leetcode/10098.leetcode98 Validate Binary Search Tree-zh.md","leetcode98 Validate Binary Search Tree-zh","/p/64d24d/"],["24.leetcode/10099.leetcode99 Recover Binary Search Tree-zh.md","leetcode99 Recover Binary Search Tree-zh","/p/4c13f1/"],["24.leetcode/10100.leetcode100 Same Tree-zh.md","leetcode100 Same Tree-zh","/p/7662fd/"],["24.leetcode/10101.leetcode101 Symmetric Tree-zh.md","leetcode101 Symmetric Tree-zh","/p/f654ba/"],["24.leetcode/10102.leetcode102 Binary Tree Level Order Traversal-zh.md","leetcode102 Binary Tree Level Order Traversal-zh","/p/74e9b3/"],["24.leetcode/10103.leetcode103 Binary Tree Zigzag Level Order Traversal-zh.md","leetcode103 Binary Tree Zigzag Level Order Traversal-zh","/p/5f3c41/"],["24.leetcode/10104.leetcode104 Maximum Depth of Binary Tree-zh.md","leetcode104 Maximum Depth of Binary Tree-zh","/p/df42dd/"],["24.leetcode/10105.leetcode105 Construct Binary Tree from Preorder and Inorder Traversal-zh.md","leetcode105 Construct Binary Tree from Preorder and Inorder Traversal-zh","/p/5990ea/"],["24.leetcode/10106.leetcode106 Construct Binary Tree from Inorder and Postorder Traversal-zh.md","leetcode106 Construct Binary Tree from Inorder and Postorder Traversal-zh","/p/bb567d/"],["24.leetcode/10107.leetcode107 Binary Tree Level Order Traversal II-zh.md","leetcode107 Binary Tree Level Order Traversal II-zh","/p/cdb832/"],["24.leetcode/10108.leetcode108 Convert Sorted Array to Binary Search Tree-zh.md","leetcode108 Convert Sorted Array to Binary Search Tree-zh","/p/ea87fb/"],["24.leetcode/10109.leetcode109 Convert Sorted List to Binary Search Tree-zh.md","leetcode109 Convert Sorted List to Binary Search Tree-zh","/p/bc54a6/"],["24.leetcode/10110.leetcode110 Balanced Binary Tree-zh.md","leetcode110 Balanced Binary Tree-zh","/p/00d991/"],["24.leetcode/10111.leetcode111 Minimum Depth of Binary Tree-zh.md","leetcode111 Minimum Depth of Binary Tree-zh","/p/14281b/"],["24.leetcode/10112.leetcode112 Path Sum-zh.md","leetcode112 Path Sum-zh","/p/a45972/"],["24.leetcode/10113.leetcode113 Path Sum II-zh.md","leetcode113 Path Sum II-zh","/p/056cf0/"],["24.leetcode/10114.leetcode114 Flatten Binary Tree to Linked List-zh.md","leetcode114 Flatten Binary Tree to Linked List-zh","/p/22ae1f/"],["24.leetcode/10115.leetcode115 Distinct Subsequences-zh.md","leetcode115 Distinct Subsequences-zh","/p/32c581/"],["24.leetcode/10116.leetcode116 Populating Next Right Pointers in Each Node-zh.md","leetcode116 Populating Next Right Pointers in Each Node-zh","/p/f0fba3/"],["24.leetcode/10117.leetcode117 Populating Next Right Pointers in Each Node II-zh.md","leetcode117 Populating Next Right Pointers in Each Node II-zh","/p/cd0756/"],["24.leetcode/10118.leetcode118 Pascal's Triangle-zh.md","leetcode118 Pascal's Triangle-zh","/p/d24f32/"],["24.leetcode/10119.leetcode119 Pascal's Triangle II-zh.md","leetcode119 Pascal's Triangle II-zh","/p/5953ec/"],["24.leetcode/10120.leetcode120 Triangle-zh.md","leetcode120 Triangle-zh","/p/c386b4/"],["24.leetcode/10121.leetcode121 Best Time to Buy and Sell Stock-zh.md","leetcode121 Best Time to Buy and Sell Stock-zh","/p/3e318e/"],["24.leetcode/10122.leetcode122 Best Time to Buy and Sell Stock II-zh.md","leetcode122 Best Time to Buy and Sell Stock II-zh","/p/1c022a/"],["24.leetcode/10123.leetcode123 Best Time to Buy and Sell Stock III-zh.md","leetcode123 Best Time to Buy and Sell Stock III-zh","/p/b6d063/"],["24.leetcode/10124.leetcode124 Binary Tree Maximum Path Sum-zh.md","leetcode124 Binary Tree Maximum Path Sum-zh","/p/067c87/"],["24.leetcode/10125.leetcode125 Valid Palindrome-zh.md","leetcode125 Valid Palindrome-zh","/p/6d33d7/"],["24.leetcode/10126.leetcode126 Word Ladder II-zh.md","leetcode126 Word Ladder II-zh","/p/b0951d/"],["24.leetcode/10127.leetcode127 Word Ladder-zh.md","leetcode127 Word Ladder-zh","/p/3ec509/"],["24.leetcode/10128.leetcode128 Longest Consecutive Sequence-zh.md","leetcode128 Longest Consecutive Sequence-zh","/p/68f243/"],["24.leetcode/10129.leetcode129 Sum Root to Leaf Numbers-zh.md","leetcode129 Sum Root to Leaf Numbers-zh","/p/2dfa58/"],["24.leetcode/10130.leetcode130 Surrounded Regions-zh.md","leetcode130 Surrounded Regions-zh","/p/e68122/"],["24.leetcode/10131.leetcode131 Palindrome Partitioning-zh.md","leetcode131 Palindrome Partitioning-zh","/p/fbe3f4/"],["24.leetcode/10132.leetcode132 Palindrome Partitioning II-zh.md","leetcode132 Palindrome Partitioning II-zh","/p/cba4c5/"],["24.leetcode/10133.leetcode133 Clone Graph-zh.md","leetcode133 Clone Graph-zh","/p/7ede97/"],["24.leetcode/10134.leetcode134 Gas Station-zh.md","leetcode134 Gas Station-zh","/p/cc0ab7/"],["24.leetcode/10135.leetcode135 Candy-zh.md","leetcode135 Candy-zh","/p/3f7a76/"],["24.leetcode/10136.leetcode136 Single Number-zh.md","leetcode136 Single Number-zh","/p/e857cf/"],["24.leetcode/10137.leetcode137 Single Number II-zh.md","leetcode137 Single Number II-zh","/p/0e631d/"],["24.leetcode/10138.leetcode138 Copy List with Random Pointer-zh.md","leetcode138 Copy List with Random Pointer-zh","/p/529fc9/"],["24.leetcode/10139.leetcode139 Word Break-zh.md","leetcode139 Word Break-zh","/p/d40856/"],["24.leetcode/10140.leetcode140 Word Break II-zh.md","leetcode140 Word Break II-zh","/p/ccca7c/"],["24.leetcode/10141.leetcode141 Linked List Cycle-zh.md","leetcode141 Linked List Cycle-zh","/p/f2a66f/"],["24.leetcode/10142.leetcode142 Linked List Cycle II-zh.md","leetcode142 Linked List Cycle II-zh","/p/1394c2/"],["24.leetcode/10143.leetcode143 Reorder List-zh.md","leetcode143 Reorder List-zh","/p/820427/"],["24.leetcode/10144.leetcode144 Binary Tree Preorder Traversal-zh.md","leetcode144 Binary Tree Preorder Traversal-zh","/p/89277c/"],["24.leetcode/10145.leetcode145 Binary Tree Postorder Traversal-zh.md","leetcode145 Binary Tree Postorder Traversal-zh","/p/31fafb/"],["24.leetcode/10146.leetcode146 Lru Cache-zh.md","leetcode146 Lru Cache-zh","/p/2b0d9a/"],["24.leetcode/10147.leetcode147 Insertion Sort List-zh.md","leetcode147 Insertion Sort List-zh","/p/085977/"],["24.leetcode/10148.leetcode148 Sort List-zh.md","leetcode148 Sort List-zh","/p/fa1546/"],["24.leetcode/10149.leetcode149 Max Points on a Line-zh.md","leetcode149 Max Points on a Line-zh","/p/949028/"],["24.leetcode/10150.leetcode150 Evaluate Reverse Polish Notation-zh.md","leetcode150 Evaluate Reverse Polish Notation-zh","/p/76312a/"],["24.leetcode/10151.leetcode151 Reverse Words in a String-zh.md","leetcode151 Reverse Words in a String-zh","/p/780e72/"],["24.leetcode/10152.leetcode152 Maximum Product Subarray-zh.md","leetcode152 Maximum Product Subarray-zh","/p/769c10/"],["24.leetcode/10153.leetcode153 Find Minimum in Rotated Sorted Array-zh.md","leetcode153 Find Minimum in Rotated Sorted Array-zh","/p/67e5b5/"],["24.leetcode/10154.leetcode154 Find Minimum in Rotated Sorted Array II-zh.md","leetcode154 Find Minimum in Rotated Sorted Array II-zh","/p/9d0183/"],["24.leetcode/10155.leetcode155 Min Stack-zh.md","leetcode155 Min Stack-zh","/p/a7d71e/"],["24.leetcode/10156.leetcode156 Binary Tree Upside Down-zh.md","leetcode156 Binary Tree Upside Down-zh","/p/357d2e/"],["24.leetcode/10157.leetcode157 Read N Characters Given Read4-zh.md","leetcode157 Read N Characters Given Read4-zh","/p/11e2e0/"],["24.leetcode/10158.leetcode158 Read N Characters Given Read4 II - Call multiple times-zh.md","leetcode158 Read N Characters Given Read4 II - Call multiple times-zh","/p/638bc7/"],["24.leetcode/10159.leetcode159 Longest Substring with At Most Two Distinct Characters-zh.md","leetcode159 Longest Substring with At Most Two Distinct Characters-zh","/p/13bb7d/"],["24.leetcode/10160.leetcode160 Intersection of Two Linked Lists-zh.md","leetcode160 Intersection of Two Linked Lists-zh","/p/8e04cc/"],["24.leetcode/10161.leetcode161 One Edit Distance-zh.md","leetcode161 One Edit Distance-zh","/p/3ba9d1/"],["24.leetcode/10162.leetcode162 Find Peak Element-zh.md","leetcode162 Find Peak Element-zh","/p/7b7235/"],["24.leetcode/10163.leetcode163 Missing Ranges-zh.md","leetcode163 Missing Ranges-zh","/p/073c7e/"],["24.leetcode/10164.leetcode164 Maximum Gap-zh.md","leetcode164 Maximum Gap-zh","/p/881ab1/"],["24.leetcode/10165.leetcode165 Compare Version Numbers-zh.md","leetcode165 Compare Version Numbers-zh","/p/1808db/"],["24.leetcode/10166.leetcode166 Fraction to Recurring Decimal-zh.md","leetcode166 Fraction to Recurring Decimal-zh","/p/c52337/"],["24.leetcode/10167.leetcode167 Two Sum II - Input array is sorted-zh.md","leetcode167 Two Sum II - Input array is sorted-zh","/p/a20291/"],["24.leetcode/10168.leetcode168 Excel Sheet Column Title-zh.md","leetcode168 Excel Sheet Column Title-zh","/p/57b4e1/"],["24.leetcode/10169.leetcode169 Majority Element-zh.md","leetcode169 Majority Element-zh","/p/a36e82/"],["24.leetcode/10170.leetcode170 Two Sum III - Data structure design-zh.md","leetcode170 Two Sum III - Data structure design-zh","/p/6d9984/"],["24.leetcode/10171.leetcode171 Excel Sheet Column Number-zh.md","leetcode171 Excel Sheet Column Number-zh","/p/7d969b/"],["24.leetcode/10172.leetcode172 Factorial Trailing Zeroes-zh.md","leetcode172 Factorial Trailing Zeroes-zh","/p/4f95d4/"],["24.leetcode/10173.leetcode173 Binary Search Tree Iterator-zh.md","leetcode173 Binary Search Tree Iterator-zh","/p/64c315/"],["24.leetcode/10174.leetcode174 Dungeon Game-zh.md","leetcode174 Dungeon Game-zh","/p/43f342/"],["24.leetcode/10175.leetcode175 Combine Two Tables-zh.md","leetcode175 Combine Two Tables-zh","/p/2a7c04/"],["24.leetcode/10176.leetcode176 Second Highest Salary-zh.md","leetcode176 Second Highest Salary-zh","/p/076d61/"],["24.leetcode/10177.leetcode177 Nth Highest Salary-zh.md","leetcode177 Nth Highest Salary-zh","/p/1b72ec/"],["24.leetcode/10178.leetcode178 Rank Scores-zh.md","leetcode178 Rank Scores-zh","/p/a2620f/"],["24.leetcode/10179.leetcode179 Largest Number-zh.md","leetcode179 Largest Number-zh","/p/2aa7a2/"],["24.leetcode/10180.leetcode180 Consecutive Numbers-zh.md","leetcode180 Consecutive Numbers-zh","/p/647279/"],["24.leetcode/10181.leetcode181 Employees Earning More Than Their Managers-zh.md","leetcode181 Employees Earning More Than Their Managers-zh","/p/a2cad5/"],["24.leetcode/10182.leetcode182 Duplicate Emails-zh.md","leetcode182 Duplicate Emails-zh","/p/ea4745/"],["24.leetcode/10183.leetcode183 Customers Who Never Order-zh.md","leetcode183 Customers Who Never Order-zh","/p/2e1a79/"],["24.leetcode/10184.leetcode184 Department Highest Salary-zh.md","leetcode184 Department Highest Salary-zh","/p/df5343/"],["24.leetcode/10185.leetcode185 Department Top Three Salaries-zh.md","leetcode185 Department Top Three Salaries-zh","/p/d64ea2/"],["24.leetcode/10186.leetcode186 Reverse Words in a String II-zh.md","leetcode186 Reverse Words in a String II-zh","/p/036d01/"],["24.leetcode/10187.leetcode187 Repeated DNA Sequences-zh.md","leetcode187 Repeated DNA Sequences-zh","/p/99a96f/"],["24.leetcode/10188.leetcode188 Best Time to Buy and Sell Stock IV-zh.md","leetcode188 Best Time to Buy and Sell Stock IV-zh","/p/8e4d7f/"],["24.leetcode/10189.leetcode189 Rotate Array-zh.md","leetcode189 Rotate Array-zh","/p/035bd4/"],["24.leetcode/10190.leetcode190 Reverse Bits-zh.md","leetcode190 Reverse Bits-zh","/p/2f9de5/"],["24.leetcode/10191.leetcode191 Number of 1 Bits-zh.md","leetcode191 Number of 1 Bits-zh","/p/ca7d94/"],["24.leetcode/10192.leetcode192 Word Frequency-zh.md","leetcode192 Word Frequency-zh","/p/610d36/"],["24.leetcode/10193.leetcode193 Valid Phone Numbers-zh.md","leetcode193 Valid Phone Numbers-zh","/p/bc41dd/"],["24.leetcode/10194.leetcode194 Transpose File-zh.md","leetcode194 Transpose File-zh","/p/abe998/"],["24.leetcode/10195.leetcode195 Tenth Line-zh.md","leetcode195 Tenth Line-zh","/p/fb58c4/"],["24.leetcode/10196.leetcode196 Delete Duplicate Emails-zh.md","leetcode196 Delete Duplicate Emails-zh","/p/b142e0/"],["24.leetcode/10197.leetcode197 Rising Temperature-zh.md","leetcode197 Rising Temperature-zh","/p/81acc9/"],["24.leetcode/10198.leetcode198 House Robber-zh.md","leetcode198 House Robber-zh","/p/6f8e73/"],["24.leetcode/10199.leetcode199 Binary Tree Right Side View-zh.md","leetcode199 Binary Tree Right Side View-zh","/p/098207/"],["24.leetcode/10200.leetcode200 Number of Islands-zh.md","leetcode200 Number of Islands-zh","/p/394356/"],["24.leetcode/10201.leetcode201 Bitwise AND of Numbers Range-zh.md","leetcode201 Bitwise AND of Numbers Range-zh","/p/d93f2b/"],["24.leetcode/10202.leetcode202 Happy Number-zh.md","leetcode202 Happy Number-zh","/p/c9273c/"],["24.leetcode/10203.leetcode203 Remove Linked List Elements-zh.md","leetcode203 Remove Linked List Elements-zh","/p/fbd6a2/"],["24.leetcode/10204.leetcode204 Count Primes-zh.md","leetcode204 Count Primes-zh","/p/73017b/"],["24.leetcode/10205.leetcode205 Isomorphic Strings-zh.md","leetcode205 Isomorphic Strings-zh","/p/18ca2f/"],["24.leetcode/10206.leetcode206 Reverse Linked List-zh.md","leetcode206 Reverse Linked List-zh","/p/c4fbe9/"],["24.leetcode/10207.leetcode207 Course Schedule-zh.md","leetcode207 Course Schedule-zh","/p/96e670/"],["24.leetcode/10208.leetcode208 Implement Trie (Prefix Tree)-zh.md","leetcode208 Implement Trie (Prefix Tree)-zh","/p/a86416/"],["24.leetcode/10209.leetcode209 Minimum Size Subarray Sum-zh.md","leetcode209 Minimum Size Subarray Sum-zh","/p/2de570/"],["24.leetcode/10210.leetcode210 Course Schedule II-zh.md","leetcode210 Course Schedule II-zh","/p/198892/"],["24.leetcode/10211.leetcode211 Design Add and Search Words Data Structure-zh.md","leetcode211 Design Add and Search Words Data Structure-zh","/p/43f608/"],["24.leetcode/10212.leetcode212 Word Search II-zh.md","leetcode212 Word Search II-zh","/p/fd6811/"],["24.leetcode/10213.leetcode213 House Robber II-zh.md","leetcode213 House Robber II-zh","/p/b3cf16/"],["24.leetcode/10214.leetcode214 Shortest Palindrome-zh.md","leetcode214 Shortest Palindrome-zh","/p/d6bf9a/"],["24.leetcode/10215.leetcode215 Kth Largest Element in an Array-zh.md","leetcode215 Kth Largest Element in an Array-zh","/p/fd7454/"],["24.leetcode/10216.leetcode216 Combination Sum III-zh.md","leetcode216 Combination Sum III-zh","/p/bc08e4/"],["24.leetcode/10217.leetcode217 Contains Duplicate-zh.md","leetcode217 Contains Duplicate-zh","/p/0b5a60/"],["24.leetcode/10218.leetcode218 The Skyline Problem-zh.md","leetcode218 The Skyline Problem-zh","/p/8f61bf/"],["24.leetcode/10219.leetcode219 Contains Duplicate II-zh.md","leetcode219 Contains Duplicate II-zh","/p/1c26f8/"],["24.leetcode/10220.leetcode220 Contains Duplicate III-zh.md","leetcode220 Contains Duplicate III-zh","/p/7fc47c/"],["24.leetcode/10221.leetcode221 Maximal Square-zh.md","leetcode221 Maximal Square-zh","/p/838c9a/"],["24.leetcode/10222.leetcode222 Count Complete Tree Nodes-zh.md","leetcode222 Count Complete Tree Nodes-zh","/p/f1ccb7/"],["24.leetcode/10223.leetcode223 Rectangle Area-zh.md","leetcode223 Rectangle Area-zh","/p/e71170/"],["24.leetcode/10224.leetcode224 Basic Calculator-zh.md","leetcode224 Basic Calculator-zh","/p/5590ee/"],["24.leetcode/10225.leetcode225 Implement Stack using Queues-zh.md","leetcode225 Implement Stack using Queues-zh","/p/2cde3f/"],["24.leetcode/10226.leetcode226 Invert Binary Tree-zh.md","leetcode226 Invert Binary Tree-zh","/p/b0dddc/"],["24.leetcode/10227.leetcode227 Basic Calculator II-zh.md","leetcode227 Basic Calculator II-zh","/p/f546b9/"],["24.leetcode/10228.leetcode228 Summary Ranges-zh.md","leetcode228 Summary Ranges-zh","/p/a3f9ac/"],["24.leetcode/10229.leetcode229 Majority Element II-zh.md","leetcode229 Majority Element II-zh","/p/ff53b7/"],["24.leetcode/10230.leetcode230 Kth Smallest Element in a BST-zh.md","leetcode230 Kth Smallest Element in a BST-zh","/p/2a0744/"],["24.leetcode/10231.leetcode231 Power of Two-zh.md","leetcode231 Power of Two-zh","/p/1952f3/"],["24.leetcode/10232.leetcode232 Implement Queue using Stacks-zh.md","leetcode232 Implement Queue using Stacks-zh","/p/9f96da/"],["24.leetcode/10233.leetcode233 Number of Digit One-zh.md","leetcode233 Number of Digit One-zh","/p/6985d1/"],["24.leetcode/10234.leetcode234 Palindrome Linked List-zh.md","leetcode234 Palindrome Linked List-zh","/p/fe43a3/"],["24.leetcode/10235.leetcode235 Lowest Common Ancestor of a Binary Search Tree-zh.md","leetcode235 Lowest Common Ancestor of a Binary Search Tree-zh","/p/82740a/"],["24.leetcode/10236.leetcode236 Lowest Common Ancestor of a Binary Tree-zh.md","leetcode236 Lowest Common Ancestor of a Binary Tree-zh","/p/cd43df/"],["24.leetcode/10237.leetcode237 Delete Node in a Linked List-zh.md","leetcode237 Delete Node in a Linked List-zh","/p/be8ce1/"],["24.leetcode/10238.leetcode238 Product of Array Except Self-zh.md","leetcode238 Product of Array Except Self-zh","/p/7eb89b/"],["24.leetcode/10239.leetcode239 Sliding Window Maximum-zh.md","leetcode239 Sliding Window Maximum-zh","/p/624423/"],["24.leetcode/10240.leetcode240 Search a 2D Matrix II-zh.md","leetcode240 Search a 2D Matrix II-zh","/p/b02c03/"],["24.leetcode/10241.leetcode241 Different Ways to Add Parentheses-zh.md","leetcode241 Different Ways to Add Parentheses-zh","/p/f642d4/"],["24.leetcode/10242.leetcode242 Valid Anagram-zh.md","leetcode242 Valid Anagram-zh","/p/989be3/"],["24.leetcode/10243.leetcode243 Shortest Word Distance-zh.md","leetcode243 Shortest Word Distance-zh","/p/3e55e4/"],["24.leetcode/10244.leetcode244 Shortest Word Distance II-zh.md","leetcode244 Shortest Word Distance II-zh","/p/174423/"],["24.leetcode/10245.leetcode245 Shortest Word Distance III-zh.md","leetcode245 Shortest Word Distance III-zh","/p/940bbd/"],["24.leetcode/10246.leetcode246 Strobogrammatic Number-zh.md","leetcode246 Strobogrammatic Number-zh","/p/d1ea39/"],["24.leetcode/10247.leetcode247 Strobogrammatic Number II-zh.md","leetcode247 Strobogrammatic Number II-zh","/p/74a94a/"],["24.leetcode/10248.leetcode248 Strobogrammatic Number III-zh.md","leetcode248 Strobogrammatic Number III-zh","/p/858535/"],["24.leetcode/10249.leetcode249 Group Shifted Strings-zh.md","leetcode249 Group Shifted Strings-zh","/p/9740b7/"],["24.leetcode/10250.leetcode250 Count Univalue Subtrees-zh.md","leetcode250 Count Univalue Subtrees-zh","/p/fe02f7/"],["24.leetcode/10251.leetcode251 Flatten 2D Vector-zh.md","leetcode251 Flatten 2D Vector-zh","/p/91c29b/"],["24.leetcode/10252.leetcode252 Meeting Rooms-zh.md","leetcode252 Meeting Rooms-zh","/p/8386f0/"],["24.leetcode/10253.leetcode253 Meeting Rooms II-zh.md","leetcode253 Meeting Rooms II-zh","/p/d0435a/"],["24.leetcode/10254.leetcode254 Factor Combinations-zh.md","leetcode254 Factor Combinations-zh","/p/b4fea1/"],["24.leetcode/10255.leetcode255 Verify Preorder Sequence in Binary Search Tree-zh.md","leetcode255 Verify Preorder Sequence in Binary Search Tree-zh","/p/8ef0f4/"],["24.leetcode/10256.leetcode256 Paint House-zh.md","leetcode256 Paint House-zh","/p/de5fb9/"],["24.leetcode/10257.leetcode257 Binary Tree Paths-zh.md","leetcode257 Binary Tree Paths-zh","/p/050274/"],["24.leetcode/10258.leetcode258 Add Digits-zh.md","leetcode258 Add Digits-zh","/p/8e0d44/"],["24.leetcode/10259.leetcode259 3Sum Smaller-zh.md","leetcode259 3Sum Smaller-zh","/p/7a4e4a/"],["24.leetcode/10260.leetcode260 Single Number III-zh.md","leetcode260 Single Number III-zh","/p/cb9306/"]]}],"/02.页面/":[{title:"HTML",collapsable:!0,children:[["10.HTML/10.常用meta整理.md","常用meta整理","/common-used-meta.html"]]},{title:"CSS",collapsable:!0,children:[["20.CSS/00.CSS教程和技巧收藏.md","CSS教程和技巧收藏","/css-tips.html"]]},{title:"stylus",collapsable:!0,children:[["25.stylus/10.混入(Mixins).md","混入(Mixins)","/mixins.html"]]}],"/03.技术/":[{title:"技术文档",collapsable:!0,children:[["01.技术文档/03.npm常用命令.md","npm常用命令","/npm-common-commands.html"]]},{title:"GitHub技巧",collapsable:!0,children:[["02.GitHub技巧/01.GitHub高级搜索技巧.md","GitHub高级搜索技巧","/github-adv-search-tips.html"]]},{title:"Nodejs",collapsable:!0,children:[["03.Nodejs/01.nodejs递归读取所有文件.md","nodejs递归读取所有文件","/nodejs-recursive.html"]]},{title:"博客搭建",collapsable:!0,children:[["04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.md","解决百度无法收录搭建在GitHub上的个人博客的问题","/baidu-shoulu-github.html"]]}],"/04.前端/":[{title:"JavaScript文章",collapsable:!0,children:[["25.JavaScript文章/02.new命令原理.md","new命令原理","/p/new-commands-principles.html"]]},{title:"Vue文章",collapsable:!0,children:[["30.Vue文章/10.Vue项目开发前的一些准备工作.md","Vue项目开发前的一些准备工作","/vue-dev-prepare.html"]]},{title:"学习笔记",collapsable:!0,children:[["40.学习笔记/22.小程序笔记.md","小程序笔记","/note/wx-miniprogram"],["40.学习笔记/23.TypeScript笔记.md","TypeScript笔记","/typescript/"]]}],"/05.关于/":[["01.关于.md","关于","/about"]],"/05.更多/":[{title:"学习",collapsable:!0,children:[["01.学习/00.费曼学习法.md","费曼学习法","/feynman-method.html"],["01.学习/01.笔记方法.md","笔记方法","/note-methods.html"],["01.学习/02.提高学习效率的策略.md","提高学习效率的策略","/strategy-for-efficient-learn.html"],["01.学习/03.提高记忆的技巧.md","提高记忆的技巧","/memory-tips.html"],["01.学习/04.自律小建议.md","自律小建议","/autonomy-suggestions.html"],["01.学习/05.处理问题的思路.md","处理问题的思路","/solve-problems-mind.html"],["01.学习/10.搜索引擎使用技巧.md","搜索引擎使用技巧","/search-engine-tips.html"]]},{title:"面试",collapsable:!0,children:[["03.面试/01.面试问题集锦.md","面试问题集锦","/interviews-qa-list.html"]]},{title:"心情杂货",collapsable:!0,children:[["05.心情杂货/01.一个完美主义者的自我救赎.md","一个完美主义者的自我救赎","/perfectionist-comprehend.html"],["05.心情杂货/10.反向拆解让人上瘾的套路，找回自律.md","反向拆解让人上瘾的套路，找回自律","/why-being-addicted.html"]]},{title:"实用技巧",collapsable:!0,children:[["10.实用技巧/01.2分钟规则.md","2分钟规则","/two-minutes-rule.html"]]},["3000.友情链接.md","友情链接","/friends"]],"/06.收藏夹/":[["01.网站.md","网站","/sites.html"],["02.资源.md","资源","/resources.html"],["03.Vue资源.md","Vue资源","/vue-resources.html"]],"/《ES6 教程》笔记/":[["01.ECMAScript 6 简介.md","ECMAScript 6 简介","/ecma-script6.html"]],"/《Git》学习笔记/":[{title:"手册",collapsable:!0,children:[["10.手册/00.常用Git命令清单.md","常用Git命令清单","/common-git-commands.html"]]},{title:"文档笔记",collapsable:!0,children:[["20.文档笔记/20.Git分支-分支原理.md","Git分支-分支原理","/git-branch-principles.html"]]}],"/《JavaScript教程》笔记/":[["01.基础.md","基础","/javascript-basics.html"]],"/《TypeScript 从零实现 axios》/":[{title:"初识 TypeScript",collapsable:!0,children:[["01.初识 TypeScript/02.安装 TypeScript.md","安装 TypeScript","/install-typescript.html"]]}],"/《Vue》笔记/":[{title:"基础",collapsable:!0,children:[["01.基础/00.MVVM模式.md","MVVM模式","/mvvm-pattern.html"]]},{title:"组件",collapsable:!0,children:[["02.组件/21.自定义事件.md","自定义事件","/custom-events.html"]]}]},author:{name:"geekzl.com"},blogger:{avatar:"https://cdn.jsdelivr.net/gh/dbdgs/images@main/dabai.jpg",name:"大白的故事",slogan:"终身学习者"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:legege007@yeah.net"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/wpfgeek"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2020,copyrightInfo:'大白的故事 | <a href="https://github.com/dbdgs/dbdgs.github.io/blob/main/LICENSE" target="_blank">MIT License</a>'}},locales:{"/":{lang:"zh-CN",title:"大白的故事",description:"大白的技术故事，专注于分享IT前沿技术、干货知识、热点资讯等",path:"/"}}},as=(t(123),t(182),t(115),t(325),t(35));var ss={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,r=e.article,i=e.home;return!(t||!1===r||!0===i)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(as.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(as.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(as.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},r=function(r,i){var o=n[r].frontmatter,l=o.categories,a=o.tags;"array"===Object(as.n)(l)&&l.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))})),"array"===Object(as.n)(a)&&a.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))}))},i=0,o=n.length;i<o;i++)r(i);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var r in n.categories)e.push({key:r,length:n.categories[r].length});for(var i in n.tags)t.push({key:i,length:n.tags[i].length});return{categories:e,tags:t}}(this.$groupPosts)}}};function cs(n){return n.toString().padStart(2,"0")}t(330);Bi.component("Badge",(function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,875))}));t(331);var ds,us,ps={created:function(){void 0!==this.$ssrContext&&(this.$ssrContext.userHeadTags+="<link rel='canonical' href='".concat(this.computeURL(),"'/>"))},methods:{computeURL:function(){return"https://dbdgs.cn"+this.$page.path}}},ms=Object(rs.a)(ps,(function(){var n=this.$createElement;return(this._self._c||n)("div")}),[],!1,null,null,null).exports,hs=t(41),gs=(t(334),t(188)),fs=t.n(gs),vs=t(81);"valine"===(us="gitalk")?t.e(314).then(t.t.bind(null,564,7)).then((function(n){return n.default})):"gitalk"===us&&Promise.all([t.e(0),t.e(313)]).then(t.t.bind(null,565,7)).then((function(){return t.e(312).then(t.t.bind(null,566,7))})).then((function(n){return ds=n.default}));function ys(n,e){var t={};return Reflect.ownKeys(n).forEach((function(r){if("string"==typeof n[r])try{t[r]=fs.a.render(n[r],e)}catch(e){console.warn('Comment config option error at key named "'.concat(r,'"')),console.warn("More info: ".concat(e.message)),t[r]=n[r]}else t[r]=n[r]})),t}console.log('How to use "'.concat("gitalk",'" in ').concat(vs.name,"@v").concat(vs.version,":"),vs.homepage);var bs={render:function(n,e){var t=document.createElement("div");t.id=e,document.querySelector("main.page").appendChild(t),new ds(ys({clientID:"b6e73b8e0f841bc26b33",clientSecret:"55027aae57302a42d940a31232d2c696987359bc",repo:"dbdgs.cn",owner:"dbdgs",admin:["yanglr"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear:function(n){var e=document.querySelector("#".concat(n));return e&&e.remove(),!0}},xs=null;function ws(n){return bs.clear("vuepress-plugin-comment")}function Es(n){return!1!==n.comment&&!1!==n.comments}function js(n){if(clearTimeout(xs),document.querySelector("main.page"))return bs.render(n,"vuepress-plugin-comment");xs=setTimeout((function(){return js(n)}),200)}var zs={mounted:function(){var n=this;xs=setTimeout((function(){var e=Object(hs.a)({to:{},from:{}},n.$frontmatter);ws()&&Es(e)&&js(e)}),1e3),this.$router.afterEach((function(e,t){if(!e||!t||e.path!==t.path){var r=Object(hs.a)({to:e,from:t},n.$frontmatter);ws()&&Es(r)&&js(r)}}))}},Ts=Object(rs.a)(zs,(function(){var n=this.$createElement;return(this._self._c||n)("div")}),[],!1,null,null,null).exports,Ss=[function(n){n.Vue,n.options,n.router,n.siteData},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,r=e.date,i=e.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(cs(n.getUTCMonth()+1),"-").concat(cs(n.getUTCDate())," ").concat(cs(n.getUTCHours()),":").concat(cs(n.getUTCMinutes()),":").concat(cs(n.getUTCSeconds()))}(r)),i?n.author=i:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(ss)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(n){var e=n.Vue;n.options;e.component("Canonical",ms)},function(n){n.router;"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},function(n){var e=n.router;"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),e.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},function(n){n.Vue.component("Comment",Ts)}],ks=["Canonical","Comment"];t(183);function Is(n,e){return(Is=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(184);function As(n){return(As=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}var _s=t(189),Vs=t.n(_s);function Ns(n,e){return!e||"object"!==Vs()(e)&&"function"!=typeof e?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):e}function Ls(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=As(n);if(e){var i=As(this).constructor;t=Reflect.construct(r,arguments,i)}else t=r.apply(this,arguments);return Ns(this,t)}}var Bs=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&Is(n,e)}(t,n);var e=Ls(t);function t(){return sa(this,t),e.apply(this,arguments)}return t}(function(){function n(){sa(this,n),this.store=new Bi({data:{state:{}}})}return da(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Bi.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(Bs.prototype,{getPageAsyncComponent:Ol,getLayoutAsyncComponent:Ul,getAsyncComponent:Gl,getVueComponent:Fl});var Ps={install:function(n){var e=new Bs;n.$vuepress=e,n.prototype.$vuepress=e}};function Cs(n){n.beforeEach((function(e,t,r){if(Ds(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var i=e.path.replace(/\/$/,"")+".html";Ds(n,i)?r(i):r()}else r();else{var o=e.path+"/",l=e.path+".html";Ds(n,l)?r(l):Ds(n,o)?r(o):r()}}))}function Ds(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var qs={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return $l("pageKey",e),Bi.component(e)||Bi.component(e,Ol(e)),Bi.component(e)?n(e):n("")}},Ms={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},Rs={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Js=(t(339),t(340),Object(rs.a)(Rs,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function Os(){return(Os=i(regeneratorRuntime.mark((function n(e){var t,r,i,o;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ls.routerBase||ls.base,Cs(r=new Tl({base:t,mode:"history",fallback:!1,routes:os,scrollBehavior:function(n,e,t){return t||(n.hash?!Bi.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),i={},n.prev=4,n.next=7,Promise.all(Ss.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Bi,options:i,router:r,siteData:ls,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return o=new Bi(Object.assign(i,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},ks.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:o,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Bi.config.productionTip=!1,Bi.use(Tl),Bi.use(Ps),Bi.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Bi;Sl(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),i=new r,o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),l={};return Object.keys(o).reduce((function(n,e){return e.startsWith("$")&&(n[e]=o[e].get),n}),l),{computed:l}}((function(n){return function(){function e(){sa(this,e)}return da(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var i in r)"/"===i?e=r[i]:0===this.$page.path.indexOf(i)&&(n=r[i]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),ls)),Bi.component("Content",qs),Bi.component("ContentSlotsDistributor",Ms),Bi.component("OutboundLink",Js),Bi.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Bi.component("Layout",Ul("Layout")),Bi.component("NotFound",Ul("NotFound")),Bi.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.8.2",hash:"659b7e2"},function(n){return Os.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);